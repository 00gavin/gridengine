#!/vol2/TCL_TK/glinux/bin/expect
# global variables ... (defined in main check routine, but you can use it)
#
# global CHECK_CHECKTREE_ROOT              ;# path where checktree lies
# global CHECK_ACT_PATH          ;# actual checkpath
# gloabl CHECK_ACTUAL_TEST_PATH  ;# this directory
# global CHECK_PRODUCT_ROOT  ;# path to sge/sgeee system
# global CHECK_PRODUCT_TYPE       ;# "sgeee" or "sge"         
# global CHECK_COMMD_PORT        ;# commd port
# global CHECK_USER              ;# user who start test
# global CHECK_ARCH              ;# architecture of this system (e.g. irix6)
# global CHECK_HOST              ;# hostname of this system (e.g. DWAIN)
#___INFO__MARK_BEGIN__
##########################################################################
#
#  The Contents of this file are made available subject to the terms of
#  the Sun Industry Standards Source License Version 1.2
#
#  Sun Microsystems Inc., March, 2001
#
#
#  Sun Industry Standards Source License Version 1.2
#  =================================================
#  The contents of this file are subject to the Sun Industry Standards
#  Source License Version 1.2 (the "License"); You may not use this file
#  except in compliance with the License. You may obtain a copy of the
#  License at http://gridengine.sunsource.net/Gridengine_SISSL_license.html
#
#  Software provided under this License is provided on an "AS IS" basis,
#  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
#  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
#  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
#  See the License for the specific provisions governing your rights and
#  obligations concerning the Software.
#
#  The Initial Developer of the Original Code is: Sun Microsystems, Inc.
#
#  Copyright: 2001 by Sun Microsystems, Inc.
#
#  All Rights Reserved.
#
##########################################################################
#___INFO__MARK_END__

global check_name check_description check_needs check_functions check_errno check_errstr 
global check_root_access_needs check_category      
global check_use_installed_system

# This file shows some check spezific things
set check_root_access_needs  "yes"
set check_name          "init_core_system"
set check_category      "COMPATIBILITY SYSTEM"
set check_description(0)   "install a default system (master/execution daemon on local host and start them up)"
set check_needs         ""                        ;# dependencies of this check (name of other check)
set check_functions     ""                        ;# functions to call (in order)
lappend check_functions "kill_running_system"
lappend check_functions "install_qmaster"
lappend check_functions "make_user_cert"
lappend check_functions "install_execd"
# this procedure is not full implemented at this
# time so it is disabled for later use.
# lappend check_functions "setup_local_binary_path"
lappend check_functions "setup_queues"
lappend check_functions "setup_testcheckpointobject"
lappend check_functions "setup_conf" 
lappend check_functions "setup_mytestproject" 
lappend check_functions "setup_mytestpe" 
lappend check_functions "setup_deadlineuser" 
lappend check_functions "setup_schedconf" 
lappend check_functions "setup_default_calendars"
lappend check_functions "setup_check_user_permissions"
lappend check_functions "setup_check_messages_files"
lappend check_functions "setup_inhouse_cluster"


# ---------------------------------------------------------------------------------
# here the tests begin ....

global CORE_INSTALLED
global CORE_INSTALLED_TIME

global local_master_spool_set
global local_execd_spool_set


set local_master_spool_set 0
set local_execd_spool_set 0

set CORE_INSTALLED ""
set CORE_INSTALLED_TIME ""



# this is to setup the cluster
#                                                             max. column:     |
#****** install_core_system/write_install_list() ******
# 
#  NAME
#     write_install_list -- ??? 
#
#  SYNOPSIS
#     write_install_list { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc write_install_list {} {
  global CORE_INSTALLED CORE_INSTALLED_TIME CHECK_CORE_MASTER
  global CHECK_MAIN_RESULTS_DIR
 
  set myfile [open "$CHECK_MAIN_RESULTS_DIR/cluster.$CHECK_CORE_MASTER.inst" "w"]
  puts $myfile $CORE_INSTALLED
  close $myfile
}

#                                                             max. column:     |
#****** install_core_system/read_install_list() ******
# 
#  NAME
#     read_install_list -- ??? 
#
#  SYNOPSIS
#     read_install_list { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc read_install_list {} {
  global CORE_INSTALLED CORE_INSTALLED_TIME CHECK_CORE_MASTER
  global CHECK_MAIN_RESULTS_DIR 
  if { [file isfile "$CHECK_MAIN_RESULTS_DIR/cluster.$CHECK_CORE_MASTER.inst"] == 1 } {
     set myfile [open "$CHECK_MAIN_RESULTS_DIR/cluster.$CHECK_CORE_MASTER.inst" "r"]
     gets $myfile CORE_INSTALLED
     close $myfile
  }
}


# kill evtl. installed system
#                                                             max. column:     |
#****** install_core_system/kill_running_system() ******
# 
#  NAME
#     kill_running_system -- ??? 
#
#  SYNOPSIS
#     kill_running_system { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc kill_running_system {} {
   global CHECK_ARCH CHECK_PRODUCT_ROOT CHECK_PRODUCT_TYPE 
   global CHECK_OUTPUT CHECK_CORE_EXECD CHECK_CORE_MASTER CORE_INSTALLED
   global check_use_installed_system
 
   
   set CORE_INSTALLED ""
   write_install_list


   shutdown_core_system


   set_error "0" "kill_running_system - this is not a 'real' test (only try to shutdown $CHECK_PRODUCT_TYPE system)"

   if { $check_use_installed_system == 0 } { 
      # if this is master remove default dir (but not the licence file)
   
         set moved [timestamp]
   
         catch { exec "mv" "$CHECK_PRODUCT_ROOT/default" "$CHECK_PRODUCT_ROOT/default.$moved"  } result
         puts $result
   
         puts "current default directory ($CHECK_PRODUCT_ROOT/default) was moved to default.$moved"
   
         sleep 2
   
         catch { exec "mkdir" "$CHECK_PRODUCT_ROOT/default"  } result
         puts $result
         catch { exec "chmod" "755" "$CHECK_PRODUCT_ROOT/default"  } result
         puts $result

   
         sleep 2
   
         catch { exec "mkdir" "$CHECK_PRODUCT_ROOT/default/common"  } result
         puts $result

         catch { exec "chmod" "755" "$CHECK_PRODUCT_ROOT/default/common"  } result
         puts $result
   
         catch { exec "cp" "$CHECK_PRODUCT_ROOT/default.$moved/common/host_aliases" "$CHECK_PRODUCT_ROOT/default/common/host_aliases"  } result
         puts $result
   
         delete_directory "$CHECK_PRODUCT_ROOT/default.$moved"
   }
}



# install qmaster check 
#                                                             max. column:     |
#****** install_core_system/install_qmaster() ******
# 
#  NAME
#     install_qmaster -- ??? 
#
#  SYNOPSIS
#     install_qmaster { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc install_qmaster {} {
 global CHECK_PRODUCT_TYPE CHECK_PRODUCT_ROOT CHECK_USER check_errstr 
 global CHECK_CORE_EXECD CHECK_CORE_MASTER CORE_INSTALLED CORE_INSTALLED CHECK_OUTPUT 
 global open_spawn_buffer CHECK_TESTSUITE_ROOT env CHECK_COMMD_PORT local_master_spool_set
 global check_use_installed_system CHECK_ADMIN_USER_SYSTEM CHECK_DEFAULT_DOMAIN
 global CHECK_DEBUG_LEVEL CHECK_QMASTER_INSTALL_OPTIONS CHECK_PRODUCT_FEATURE CHECK_COMMD_PORT
 global CHECK_REPORT_EMAIL_TO CHECK_MAIN_RESULTS_DIR CHECK_FIRST_FOREIGN_SYSTEM_USER
 global CHECK_SECOND_FOREIGN_SYSTEM_USER CHECK_REPORT_EMAIL_TO
 global CHECK_PROTOCOL_DIR

 puts $CHECK_OUTPUT "install qmaster ($CHECK_PRODUCT_TYPE system) on host $CHECK_CORE_MASTER ..."

 if { $check_use_installed_system != 0 } {
    set_error "0" "install_qmaster - no need to install qmaster on host $CHECK_CORE_MASTER - noinst parameter is set"
    puts "no need to install qmaster on host $CHECK_CORE_MASTER, noinst parameter is set"
    set CORE_INSTALLED "" 
    if {[startup_qmaster] == 0} {
      lappend CORE_INSTALLED $CHECK_CORE_MASTER
      write_install_list
    }
    return
 }

 set CORE_INSTALLED ""
 write_install_list

 set_error "0" "install_qmaster - no errors"
 if {[file isfile "$CHECK_PRODUCT_ROOT/install_qmaster"] != 1} {
    set_error "-1" "install_qmaster - install_qmaster file not found"
    return
 }

 #dump hostlist to file
 set host_file_name "$CHECK_PROTOCOL_DIR/hostlist"
 set f [open $host_file_name w]
 foreach exechost $CHECK_CORE_EXECD {
    puts $f "${exechost}"
 }
 close $f

 cd "$CHECK_PRODUCT_ROOT"

 set prod_type_var "SGE_ROOT"

 set feature_install_options ""
 if { $CHECK_PRODUCT_FEATURE == "csp" } {
    append feature_install_options "-csp"
 }

 if { $CHECK_ADMIN_USER_SYSTEM == 0 } { 
    set id [open_remote_spawn_process "$CHECK_CORE_MASTER" "root"  "cd $$prod_type_var;./install_qmaster" "$CHECK_QMASTER_INSTALL_OPTIONS $feature_install_options" ]
 } else {
    puts $CHECK_OUTPUT "--> install as user $CHECK_USER <--" 
    set id [open_remote_spawn_process "$CHECK_CORE_MASTER" "$CHECK_USER"  "cd $$prod_type_var;./install_qmaster" "$CHECK_QMASTER_INSTALL_OPTIONS $feature_install_options" ]
 }
 set sp_id [ lindex $id 1 ] 
 

 log_user 1
 puts $CHECK_OUTPUT "cd $$prod_type_var;./install_qmaster $CHECK_QMASTER_INSTALL_OPTIONS $feature_install_options"
 set timeout 100 
 set hostcount 0

 set do_log_output 0 ;# _LOG
 if { $CHECK_DEBUG_LEVEL == 2 } {
   set do_log_output  1 ;# 1
 }

 while {1} {
 if {$do_log_output == 1} {
   flush stdout
   flush $CHECK_OUTPUT
   puts "press RETURN"
   gets stdin anykey
 }
    log_user 1
#    sleep 1
    puts "expecting now ..."
    expect {
       flush stdout
       flush $CHECK_OUTPUT 
       -i $sp_id full_buffer {
          set_error "-1" "install_qmaster - buffer overflow please increment CHECK_EXPECT_MATCH_MAX_BUFFER value"
          close_spawn_process $id; 
          return;
       }   

       -i $sp_id eof { 
          set_error "-1" "install_qmaster - unexpected eof"; 
          close_spawn_process $id;
          return;  
       }
       -i $sp_id "coredump" {
          set_error "-2" "install_qmaster - coredump";
          close_spawn_process $id
          return
       }

       -i $sp_id timeout { 
          set_error "-1" "install_qmaster - timeout while waiting for output"; 
          close_spawn_process $id;
          return;  
       }
       -i $sp_id "orry" { 
          set_error "-1" "install_qmaster - wrong root password"
          close_spawn_process $id;
          return;
       }

       -i $sp_id "issing" { 
          set_error "-1" "install_qmaster - missing binary error"
          close_spawn_process $id;
          return;
       }
       -i $sp_id "xit." {
          set_error "-1" "install_qmaster - installation failed"
          close_spawn_process $id; 
          return;
       }
       -i $sp_id "enter the file name with a valid license key" {
          set_error "-1" "install_qmaster - not a licensed system"
          close_spawn_process $id; 
          return;
       }

       -i $sp_id "admin user account =*\n" {
          set real_admin_user $expect_out(0,string)
          set real_help [ split $real_admin_user "=" ]
          set real_admin_user [ string trim [ lindex $real_help 1 ]]
          
          puts $CHECK_OUTPUT "\n -->testsuite: admin user is \"$real_admin_user\""
          if { [string compare $real_admin_user $CHECK_USER] != 0 } {
             set_error "-1" "install_qmaster - admin user \"$real_admin_user\" is different from CHECK_USER \"$CHECK_USER\"" 
             close_spawn_process $id;
             return;
          }
       }
       
       -i $sp_id "and contact * or your local distributor for getting a license" { 
          puts $CHECK_OUTPUT "\n -->testsuite: sending >return<"
          if {$do_log_output == 1} {
             puts "press RETURN"
             gets stdin anykey
          }
          send -i $sp_id "\n"
          continue;
       }

       -i $sp_id "o you want to recreate your SGE CA infrastructure" { 
          puts $CHECK_OUTPUT "\n -->testsuite: sending >y<(1)"
          if {$do_log_output == 1} {
             puts "press RETURN"
             gets stdin anykey
          }
          send -i $sp_id "y\n"
          continue;
       }


       -i $sp_id "enter your two letter country code" { 
          puts $CHECK_OUTPUT "\n -->testsuite: sending >DE<"
          if {$do_log_output == 1} {
             puts "press RETURN"
             gets stdin anykey
          }
          send -i $sp_id "DE\n"
          continue;
       }

       -i $sp_id "lease enter your state" { 
          puts $CHECK_OUTPUT "\n -->testsuite: sending >Bavaria<"
          if {$do_log_output == 1} {
             puts "press RETURN"
             gets stdin anykey
          }
          send -i $sp_id "Bavaria\n"
          continue;
       }
 
       -i $sp_id "lease enter your location" { 
          puts $CHECK_OUTPUT "\n -->testsuite: sending >Regensburg<"
          if {$do_log_output == 1} {
             puts "press RETURN"
             gets stdin anykey
          }
          send -i $sp_id "Regensburg\n"
          continue;
       }

       -i $sp_id "lease enter the name of your organization" { 
          puts $CHECK_OUTPUT "\n -->testsuite: sending >Sun Microsystems<"
          if {$do_log_output == 1} {
             puts "press RETURN"
             gets stdin anykey
          }
          send -i $sp_id "Sun Microsystems\n"
          continue;
       }

       -i $sp_id "lease enter your organizational unit" { 
          puts $CHECK_OUTPUT "\n -->testsuite: sending >Testsystem at port $CHECK_COMMD_PORT<"
          if {$do_log_output == 1} {
             puts "press RETURN"
             gets stdin anykey
          }
          send -i $sp_id "Testsystem at port $CHECK_COMMD_PORT\n"
          continue;
       }

       -i $sp_id "lease enter the email address of the CA administrator" { 
          if { $CHECK_REPORT_EMAIL_TO == "none" } {
             set CA_admin_mail "$CHECK_USER@sun.com"
          } else {
             set CA_admin_mail $CHECK_REPORT_EMAIL_TO
          }
          puts $CHECK_OUTPUT "\n -->testsuite: sending >$CA_admin_mail<"
          if {$do_log_output == 1} {
             puts "press RETURN"
             gets stdin anykey
          }
          send -i $sp_id "$CA_admin_mail\n"
          continue;
       }
       -i $sp_id "o you want to use these data" { 
          puts $CHECK_OUTPUT "\n -->testsuite: sending >y<(2)"
          if {$do_log_output == 1} {
             puts "press RETURN"
             gets stdin anykey
          }
          send -i $sp_id "y\n"
          continue;
       }


       -i $sp_id -gl "You requested -resport" {
         set_error "-1" "install_qmaster: Configuration error: System with reserved port security requested, but port is configured to $CHECK_COMMD_PORT"
         close_spawn_process $id
         return
       }

       -i $sp_id "Are all the hosts of your cluster in a single DNS domain" { 
          puts $CHECK_OUTPUT "\n -->testsuite: sending >y<(3)"
          if {$do_log_output == 1} {
             puts "press RETURN"
             gets stdin anykey
          }
          send -i $sp_id "y\n"
          continue;
       }
       -i $sp_id "Are all hosts of your cluster in a single DNS domain" { 
          puts $CHECK_OUTPUT "\n -->testsuite: sending >y<(4)"
          if {$do_log_output == 1} {
             puts "press RETURN"
             gets stdin anykey
          }
          send -i $sp_id "y\n"
          continue;
       }

 
       -i $sp_id "Do you want to install Grid Engine as admin user" { 
          puts $CHECK_OUTPUT "\n -->testsuite: sending >y<(5)"
          if {$do_log_output == 1} {
             puts "press RETURN"
             gets stdin anykey
          }
          send -i $sp_id "y\n"
          continue;
       }


       -i $sp_id "Do you want to * SGE as admin user" { 
          puts $CHECK_OUTPUT "\n -->testsuite: sending >y<(6)"
          if {$do_log_output == 1} {
             puts "press RETURN"
             gets stdin anykey
          }
          send -i $sp_id "y\n"
          continue;
       }

       -i $sp_id "Do you want to * SGEEE as admin user" { 
          puts $CHECK_OUTPUT "\n -->testsuite: sending >y<(7)"
          if {$do_log_output == 1} {
             puts "press RETURN"
             gets stdin anykey
          }
          send -i $sp_id "y\n"
          continue;
       }

       -i $sp_id "Do you want to use these configuration parameters" {
          puts $CHECK_OUTPUT "\n -->testsuite: sending >n<(1)"
          if {$do_log_output == 1} {
               puts "press RETURN"
               gets stdin anykey
          }
          send -i $sp_id "n\n"
          continue;
       }
       -i $sp_id "Do you want to set the file permissions" {
          puts $CHECK_OUTPUT "\n -->testsuite: sending >yes<"
          if {$do_log_output == 1} {
               puts "press RETURN"
               gets stdin anykey
          }
          send -i $sp_id "yes\n"
          continue;
       }

       -i $sp_id "Do you want to verify and set your file permissions" {
          puts $CHECK_OUTPUT "\n -->testsuite: sending >y<(8)"
          if {$do_log_output == 1} {
               puts "press RETURN"
               gets stdin anykey
          }
          send -i $sp_id "y\n"
          continue;
       }

       -i $sp_id "Please hit <RETURN> to continue once you set your file permissions" {
          puts $CHECK_OUTPUT "\n -->testsuite: sending >return<"
          if {$do_log_output == 1} {
               puts "press RETURN"
               gets stdin anykey
          }
          send -i $sp_id "\n"
          continue;
       }

       -i $sp_id "Do you want to use this configuration parameters" {
          puts $CHECK_OUTPUT "\n -->testsuite: sending >n<(2)"
          if {$do_log_output == 1} {
               puts "press RETURN"
               gets stdin anykey
          }
          send -i $sp_id "n\n"
          continue;
       }
       -i $sp_id "if this is ok or stop the installation with" {
          if { $CHECK_ADMIN_USER_SYSTEM != 0 } {
             puts $CHECK_OUTPUT "\n -->testsuite: sending >RETURN<"
             if {$do_log_output == 1} {
                  puts "press RETURN"
                  gets stdin anykey
             }
             send -i $sp_id "\n"
             continue;
          } else {
             set_error "-1" "install_qmaster - tried to install not as root"
             close_spawn_process $id; 
             return;
          }
       }

       -i $sp_id "Do you want to * the application as admin user" {
          puts $CHECK_OUTPUT "\n -->testsuite: sending >n<(3)"
          if {$do_log_output == 1} {
               puts "press RETURN"
               gets stdin anykey
          }
          send -i $sp_id "n\n"
          continue;
       }
       -i $sp_id "under an user id other than" {
          puts $CHECK_OUTPUT "\n -->testsuite: sending >n<(4)"
          if {$do_log_output == 1} {
               puts "press RETURN"
               gets stdin anykey
          }
          send -i $sp_id "n\n"
          continue;
       }
       -i $sp_id "you want to select another qmaster spool directory" {
          puts $CHECK_OUTPUT "\n -->testsuite: sending >n<(5)"
          if {$do_log_output == 1} {
               puts "press RETURN"
               gets stdin anykey
          }
          send -i $sp_id "n\n"
          continue;
       }
       -i $sp_id "<RETURN> to see where" {
          puts $CHECK_OUTPUT "\n -->testsuite: sending >RETURN<"
          if {$do_log_output == 1} {
               puts "press RETURN"
               gets stdin anykey
          }

          send -i $sp_id "\n"
          continue;
       }
       -i $sp_id "Did you install this version with >pkgadd<" {
          puts $CHECK_OUTPUT "\n -->testsuite: sending >n<(6)"
          if {$do_log_output == 1} {
               puts "press RETURN"
               gets stdin anykey
          }

          send -i $sp_id "n\n"
          continue;
       }
       -i $sp_id "Enter spool directory or hit" {
          puts $CHECK_OUTPUT "\n"
          set spooldir [get_spool_dir $CHECK_CORE_MASTER qmaster]
          if { $spooldir != "" } {
            # use local spool dir
            puts $CHECK_OUTPUT "\n -->testsuite: sending >$spooldir<"
            if {$do_log_output == 1} {
               puts "press RETURN"
               gets stdin anykey
            }
            send -i $sp_id "$spooldir\n"
            set local_master_spool_set 1
          } else {
            # use default spool dir
            puts $CHECK_OUTPUT "\n -->testsuite: sending >RETURN<"
            if {$do_log_output == 1} {
               puts "press RETURN"
               gets stdin anykey
            }
            send -i $sp_id "\n"
          }
          continue;
       }



       -i $sp_id "configure a default domain" {
          puts $CHECK_OUTPUT "\n -->testsuite: sending >n<(7)"
          if {$do_log_output == 1} {
               puts "(2)press RETURN"
               gets stdin anykey
          }
          send -i $sp_id "n\n"
          continue;
       }

       -i $sp_id "enter your default domain:" {
          puts $CHECK_OUTPUT "\n -->testsuite: sending >$CHECK_DEFAULT_DOMAIN<"
          if {$do_log_output == 1} {
               puts "press RETURN"
               gets stdin anykey
          }

          send -i $sp_id "$CHECK_DEFAULT_DOMAIN\n"

          continue;
       }


       -i $sp_id "at system boot time" {
          puts $CHECK_OUTPUT "\n -->testsuite: sending >n<(8)"
          if {$do_log_output == 1} {
               puts "press RETURN"
               gets stdin anykey
          }

          send -i $sp_id "n\n"
          continue;
       }
       
       -i $sp_id "is started at machine boot" {
          puts $CHECK_OUTPUT "\n -->testsuite: sending >n<(9)"
          if {$do_log_output == 1} {
               puts "press RETURN"
               gets stdin anykey
          }

          send -i $sp_id "n\n"
          continue;
       }

       -i $sp_id "Do you want to create a new configuration" {
          puts $CHECK_OUTPUT "\n -->testsuite: sending >y<(9)"
          if {$do_log_output == 1} {
               puts "(3)press RETURN"
               gets stdin anykey
          }

          send -i $sp_id "y\n"
          continue;
       }

       -i $sp_id "Please enter the file name which contains the host list" {
          puts $CHECK_OUTPUT "\n -->testsuite: sending >${host_file_name}<"
          if {$do_log_output == 1} {
               puts "press RETURN"
               gets stdin anykey
          }

          send -i $sp_id "${host_file_name}\n"
          continue;
       }
   
       -i $sp_id "Finished adding hosts" {
          puts $CHECK_OUTPUT "\n -->testsuite: sending >RETURN<"
          if {$do_log_output == 1} {
               puts "press RETURN"
               gets stdin anykey
          }

          send -i $sp_id "\n"
          continue;
       }
   
       -i $sp_id "already exists" {
          puts $CHECK_OUTPUT "\n --> testsuite: ignoring install script output"
          if {$do_log_output == 1} {
               puts "press RETURN"
               gets stdin anykey
          }

          continue;
       }
   
       -i $sp_id "added to * host list" {
          puts $CHECK_OUTPUT "\n --> testsuite: ignoring install script output"
          if {$do_log_output == 1} {
               puts "press RETURN"
               gets stdin anykey
          }

          continue;
       }
   
       -i $sp_id "Do you want to use a file which contains the list of hosts" {
          puts $CHECK_OUTPUT "\n -->testsuite: sending >y<(10)"
          if {$do_log_output == 1} {
               puts "press RETURN"
               gets stdin anykey
          }

          send -i $sp_id "y\n"
          continue;
       }
   
       -i $sp_id "Do you want to see previous screen about using" {
          flush stdout
          flush $CHECK_OUTPUT
          puts $CHECK_OUTPUT "\n -->testsuite: sending >n<(10)"
          if {$do_log_output == 1} {
               puts "press RETURN"
               gets stdin anykey
          }

          send -i $sp_id "n\n"
          continue;
       }
       -i $sp_id "enter a range" {
          set myrange [ get_gid_range $CHECK_USER $CHECK_COMMD_PORT]
          puts $CHECK_OUTPUT "\n -->testsuite: sending >${myrange}<"
          if {$do_log_output == 1} {
               puts "press RETURN"
               gets stdin anykey
          }

          send -i $sp_id "${myrange}\n"
          continue;
       }
       -i $sp_id "installation is now completed" {
          read_install_list
          lappend CORE_INSTALLED $CHECK_CORE_MASTER
          write_install_list
          set_error "0" "install_qmaster - no errors"
          close_spawn_process $id;
          return; 
       }
       -i $sp_id "Host(s):" {
          incr hostcount 1 
          if {$hostcount == 1} {
             foreach exechost $CHECK_CORE_EXECD {
               send -i $sp_id " $exechost"
               puts $CHECK_OUTPUT "\n -->testsuite: sending >${exechost}<"
             } 
             puts $CHECK_OUTPUT "\n -->testsuite: sending >RETURN<"
             send -i $sp_id "\n"
          } else {
             puts $CHECK_OUTPUT "\n -->testsuite: sending >RETURN<"
             send -i $sp_id "\n"
          }
          continue;
       }
   
       -i $sp_id "More" {
          puts $CHECK_OUTPUT "\n -->testsuite: sending >space<"
          if {$do_log_output == 1} {
               puts "press RETURN"
               gets stdin anykey
          }

          send -i $sp_id " "
          continue;
       }
       -i $sp_id "Error:" {
          set_error "-1" "install_qmaster - $expect_out(0,string)"
          close_spawn_process $id;
          return;
       }
       -i $sp_id "sge_qmaster binary is not compiled with" {
          set_error "-2" "install_qmaster - sge_qmaster binary is not compiled in secure mode"
          close_spawn_process $id;
          return;
       }
       -i $sp_id "ommand failed*\n" {
          set_error "-1" "install_qmaster - $expect_out(0,string)"
          close_spawn_process $id;
          return;
       }
       -i $sp_id "can't resolve hostname*\n" {
          set_error "-1" "install_qmaster - $expect_out(0,string)"
          close_spawn_process $id; 
          return;
       }     
   
       -i $sp_id "error:\n" {
          set_error "-1" "install_qmaster - $expect_out(0,string)"
          continue;
       }
   
       -i $sp_id "Hit <RETURN> to continue" {
          puts $CHECK_OUTPUT "\n -->testsuite: sending >RETURN<"
          if {$do_log_output == 1} {
               puts "press RETURN"
               gets stdin anykey
          }
          send -i $sp_id "\n"
          continue;
       }
       -i $sp_id default {
          set_error "-1" "install_qmaster - undefined behaviour: $expect_out(buffer)"
          close_spawn_process $id; 
          return;
       }
    }
 }
}

# generating all testsuite cluster user keys and certificates
proc make_user_cert {} {
  
  global CHECK_PRODUCT_FEATURE CHECK_OUTPUT CHECK_CORE_MASTER CHECK_MAIN_RESULTS_DIR
  global CHECK_FIRST_FOREIGN_SYSTEM_USER CHECK_SECOND_FOREIGN_SYSTEM_USER CHECK_REPORT_EMAIL_TO
  global CHECK_PRODUCT_ROOT CHECK_USER CHECK_DEBUG_LEVEL

  if { $CHECK_PRODUCT_FEATURE == "csp" } {
     puts $CHECK_OUTPUT "removing evtl. existing user_file.txt \"$CHECK_MAIN_RESULTS_DIR/user_file.txt\" ..."
     set result [ start_remote_prog "$CHECK_CORE_MASTER" "$CHECK_USER" "rm" "$CHECK_MAIN_RESULTS_DIR/user_file.txt" ]
     puts $CHECK_OUTPUT $result
 
     puts $CHECK_OUTPUT "creating file \"$CHECK_MAIN_RESULTS_DIR/user_file.txt\" ..."
     set script [ open "$CHECK_MAIN_RESULTS_DIR/user_file.txt" "w" ]
     puts $script "$CHECK_FIRST_FOREIGN_SYSTEM_USER:first_testsuite_user:$CHECK_REPORT_EMAIL_TO"
     puts $script "$CHECK_SECOND_FOREIGN_SYSTEM_USER:second_testsuite_user:$CHECK_REPORT_EMAIL_TO"
     flush $script
     close $script
     
     set result [ start_remote_prog "$CHECK_CORE_MASTER" "root" "cd" "$CHECK_PRODUCT_ROOT ; util/sgeCA/sge_ca -usercert $CHECK_MAIN_RESULTS_DIR/user_file.txt" ]
     puts $CHECK_OUTPUT $result
 
     puts $CHECK_OUTPUT "removing evtl. existing user_file.txt \"$CHECK_MAIN_RESULTS_DIR/user_file.txt\" ..."
     set result [ start_remote_prog "$CHECK_CORE_MASTER" "$CHECK_USER" "rm" "$CHECK_MAIN_RESULTS_DIR/user_file.txt" ]
     puts $CHECK_OUTPUT $result
  } else {
     puts $CHECK_OUTPUT "no csp feature enabled"
  }
  set_error 0 "ok"
}


#                                                             max. column:     |
#****** install_core_system/install_execd() ******
# 
#  NAME
#     install_execd -- ??? 
#
#  SYNOPSIS
#     install_execd { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc install_execd {} {
   global CHECK_OUTPUT CHECK_CORE_EXECD CHECK_PRODUCT_TYPE CORE_INSTALLED
   global check_use_installed_system CHECK_PRODUCT_ROOT CHECK_ARCH
   global CHECK_COMMD_PORT CHECK_ADMIN_USER_SYSTEM CHECK_USER
   global CHECK_DEBUG_LEVEL CHECK_EXECD_INSTALL_OPTIONS
   global CHECK_PRODUCT_FEATURE CHECK_COMMD_PORT CHECK_CORE_MASTER
   global CHECK_MAIN_RESULTS_DIR CHECK_SUBMIT_ONLY_HOSTS

   set CORE_INSTALLED "" 
   read_install_list

   set_error "0" "install_execd - no errors"

   set feature_install_options ""
   if { $CHECK_PRODUCT_FEATURE == "csp" } {
         set feature_install_options "-csp"
         set my_csp_host_list $CHECK_CORE_EXECD
         foreach elem $CHECK_SUBMIT_ONLY_HOSTS {
           lappend my_csp_host_list $elem
         }
         foreach exec_host $my_csp_host_list {
         if { $exec_host == $CHECK_CORE_MASTER } {
            continue;
         }
         set remote_arch [resolve_arch $exec_host]    
         puts $CHECK_OUTPUT "installing CA keys"
         puts $CHECK_OUTPUT "=================="
         puts $CHECK_OUTPUT "host:         $exec_host"
         puts $CHECK_OUTPUT "architecture: $remote_arch"
         puts $CHECK_OUTPUT "port:         $CHECK_COMMD_PORT"
         puts $CHECK_OUTPUT "source:       \"/var/sgeCA/port${CHECK_COMMD_PORT}/\" on host $CHECK_CORE_MASTER"
         puts $CHECK_OUTPUT "target:       \"/var/sgeCA/port${CHECK_COMMD_PORT}/\" on host $exec_host"

         if { $CHECK_ADMIN_USER_SYSTEM == 0 } { 
             puts $CHECK_OUTPUT "we have root access, fine !"
             set CA_ROOT_DIR "/var/sgeCA/"

             puts $CHECK_OUTPUT "removing evtl. existing tar file \"$CA_ROOT_DIR/port${CHECK_COMMD_PORT}.tar\" ..."
             set result [ start_remote_prog "$CHECK_CORE_MASTER" "root" "rm" "$CA_ROOT_DIR/port${CHECK_COMMD_PORT}.tar" ]
             puts $CHECK_OUTPUT $result

             puts $CHECK_OUTPUT "taring Certificate Authority (CA) directory into \"$CA_ROOT_DIR/port${CHECK_COMMD_PORT}.tar\""
             set tar_bin [get_binary_path $CHECK_CORE_MASTER "tar"]
             set remote_command_param "$CA_ROOT_DIR; ${tar_bin} -cvf port${CHECK_COMMD_PORT}.tar ./port${CHECK_COMMD_PORT}/*"
             set result [ start_remote_prog "$CHECK_CORE_MASTER" "root" "cd" "$remote_command_param" ]
             puts $CHECK_OUTPUT $result

             if { $prg_exit_state != 0 } {
                 add_proc_error "install_execd" -2 "could not tar Certificate Authority (CA) directory into \"$CA_ROOT_DIR/port${CHECK_COMMD_PORT}.tar\""
             } else {
                 puts $CHECK_OUTPUT "changing permissions for tar file \"$CA_ROOT_DIR/port${CHECK_COMMD_PORT}.tar\" ..."
                 set result [ start_remote_prog "$CHECK_CORE_MASTER" "root" "chmod" "700 $CA_ROOT_DIR/port${CHECK_COMMD_PORT}.tar" ]
                 puts $CHECK_OUTPUT $result
                 if { $prg_exit_state != 0 } {
                    add_proc_error "install_execd" -2 "could not change file permissions for \"$CA_ROOT_DIR/port${CHECK_COMMD_PORT}.tar\""
                 } else {
                    puts $CHECK_OUTPUT "copy tar file \"$CA_ROOT_DIR/port${CHECK_COMMD_PORT}.tar\"\nto \"$CHECK_MAIN_RESULTS_DIR/port${CHECK_COMMD_PORT}.tar\" ..."
                    set result [ start_remote_prog "$CHECK_CORE_MASTER" "root" "cp" "$CA_ROOT_DIR/port${CHECK_COMMD_PORT}.tar $CHECK_MAIN_RESULTS_DIR/port${CHECK_COMMD_PORT}.tar" ]
                    puts $CHECK_OUTPUT $result
                    
                    puts $CHECK_OUTPUT "copy tar file \"$CHECK_MAIN_RESULTS_DIR/port${CHECK_COMMD_PORT}.tar\"\nto \"$CA_ROOT_DIR/port${CHECK_COMMD_PORT}.tar\" on host $exec_host ..."
                    set result [ start_remote_prog "$exec_host" "root" "cp" "$CHECK_MAIN_RESULTS_DIR/port${CHECK_COMMD_PORT}.tar $CA_ROOT_DIR/port${CHECK_COMMD_PORT}.tar" ]
                    puts $CHECK_OUTPUT $result

                    set tar_bin [get_binary_path $exec_host "tar"]

                    puts $CHECK_OUTPUT "untaring Certificate Authority (CA) directory in \"$CA_ROOT_DIR\""
                    start_remote_prog "$exec_host" "root" "cd" "$CA_ROOT_DIR" 
                    if { $prg_exit_state != 0 } { 
                       set result [ start_remote_prog "$exec_host" "root" "mkdir" "$CA_ROOT_DIR" ]
                    }   
                    set result [ start_remote_prog "$exec_host" "root" "cd" "$CA_ROOT_DIR; ${tar_bin} -xvf port${CHECK_COMMD_PORT}.tar" ]
                    puts $CHECK_OUTPUT $result
                    if { $prg_exit_state != 0 } {
                       add_proc_error "install_execd" -2 "could not untar \"$CA_ROOT_DIR/port${CHECK_COMMD_PORT}.tar\" on host $exec_host;\ntar-bin:$tar_bin"
                    } 

                    puts $CHECK_OUTPUT "removing tar file \"$CA_ROOT_DIR/port${CHECK_COMMD_PORT}.tar\" on host $exec_host ..."
                    set result [ start_remote_prog "$exec_host" "root" "rm" "$CA_ROOT_DIR/port${CHECK_COMMD_PORT}.tar" ]
                    puts $CHECK_OUTPUT $result

                    puts $CHECK_OUTPUT "removing tar file \"$CHECK_MAIN_RESULTS_DIR/port${CHECK_COMMD_PORT}.tar\" ..."
                    set result [ start_remote_prog "$CHECK_CORE_MASTER" "root" "rm" "$CHECK_MAIN_RESULTS_DIR/port${CHECK_COMMD_PORT}.tar" ]
                    puts $CHECK_OUTPUT $result

                 }
                  
             }
             
             puts $CHECK_OUTPUT "removing existing tar file \"$CA_ROOT_DIR/port${CHECK_COMMD_PORT}.tar\" ..."
             set result [ start_remote_prog "$CHECK_CORE_MASTER" "root" "rm" "$CA_ROOT_DIR/port${CHECK_COMMD_PORT}.tar" ]
             puts $CHECK_OUTPUT $result
         } else {
            puts $CHECK_OUTPUT "can not copy this files as user $CHECK_USER"
            puts $CHECK_OUTPUT "installation error"
            add_proc_error "install_execd" -2 "exec host: $exec_host"
            continue
         }
      }
   }

 
   foreach exec_host $CHECK_CORE_EXECD {

      puts $CHECK_OUTPUT "installing execd on host $exec_host ($CHECK_PRODUCT_TYPE system) ..."
      if {[lsearch $CHECK_CORE_EXECD $exec_host] == -1 } {
         set_error "-1" "install_execd - host $exec_host is not in execd list"
         return 
      }
      if { $check_use_installed_system != 0 } {
         set_error "0" "install_execd - no need to install execd on hosts \"$CHECK_CORE_EXECD\" - noinst parameter is set"
         puts "no need to install execd on hosts \"$CHECK_CORE_EXECD\", noinst parameter is set"
         if {[startup_execd $exec_host] == 0 } {
            lappend CORE_INSTALLED $exec_host
            write_install_list
            continue
         } else {
            add_proc_error "install_execd" -2 "could not startup execd on host $exec_host"
            return
         }
      }

      if {[file isfile "$CHECK_PRODUCT_ROOT/install_execd"] != 1} {
         set_error "-1" "install_execd - install_execd file not found"
         return
      }

      set remote_arch [resolve_arch $exec_host]    
      set sensor_file [ get_loadsensor_path $remote_arch ]
      if { [string compare $sensor_file ""] != 0  } {
         puts $CHECK_OUTPUT "installing load sensor:"
         puts $CHECK_OUTPUT "======================="
         puts $CHECK_OUTPUT "architecture: $remote_arch"
         puts $CHECK_OUTPUT "sensor file:  $sensor_file"
         puts $CHECK_OUTPUT "target:       $CHECK_PRODUCT_ROOT/bin/$remote_arch/qloadsensor"
         if { $CHECK_ADMIN_USER_SYSTEM == 0 } { 
            set arguments "$sensor_file $CHECK_PRODUCT_ROOT/bin/$remote_arch/qloadsensor"
            set result [ start_remote_prog "$exec_host" "root" "cp" "$arguments" ] 
            puts $CHECK_OUTPUT "result: $result"
            puts $CHECK_OUTPUT "copy exit state: $prg_exit_state" 
         } else {
            puts $CHECK_OUTPUT "can not copy this file as user $CHECK_USER"
            puts $CHECK_OUTPUT "please copy this file manually!!"
            puts $CHECK_OUTPUT "if not, you will get no load values from this host (=$exec_host)"
            puts $CHECK_OUTPUT "installation will continue in 15 seconds!!"
            sleep 15
         }
      }

      cd "$CHECK_PRODUCT_ROOT"

      set prod_type_var "SGE_ROOT"
  
      if { $CHECK_ADMIN_USER_SYSTEM == 0 } { 
         set id [open_remote_spawn_process "$exec_host" "root"  "cd $$prod_type_var;./install_execd" "$CHECK_EXECD_INSTALL_OPTIONS $feature_install_options" ]
      } else {
         puts $CHECK_OUTPUT "--> install as user $CHECK_USER <--" 
         set id [open_remote_spawn_process "$exec_host" "$CHECK_USER"  "cd $$prod_type_var;./install_execd" "$CHECK_EXECD_INSTALL_OPTIONS $feature_install_options" ]
      }


      log_user 1
      puts $CHECK_OUTPUT "cd $$prod_type_var;./install_execd $CHECK_EXECD_INSTALL_OPTIONS $feature_install_options"

      set sp_id [ lindex $id 1 ] 


      set timeout 120
     
      set do_log_output 0 ;# 1 _LOG
      if { $CHECK_DEBUG_LEVEL == 2 } {
         set do_log_output 1
      }
     # set do_log_output 1
      set do_stop 0
      while {$do_stop == 0} {
         flush stdout
         flush $CHECK_OUTPUT
         if {$do_log_output == 1} {
             puts "press RETURN"
             gets stdin anykey
         }
     
         set timeout 60
         expect {
            -i $sp_id full_buffer {
               set_error "-1" "install_execd - buffer overflow please increment CHECK_EXPECT_MATCH_MAX_BUFFER value"
               close_spawn_process $id; 
               return;
            }
            -i $sp_id eof {
               set_error "-1" "install_execd - unexpeced eof";
               close_spawn_process $id
               set do_stop 1
            }
            -i $sp_id "coredump" {
               set_error "-2" "install_execd - coredump on host $exec_host";
               close_spawn_process $id
               set do_stop 1
            }

            -i $sp_id timeout { 
               set_error "-1" "install_execd - timeout while waiting for output"; 
               close_spawn_process $id;
               set do_stop 1
            }
            -i $sp_id "orry" { 
               set_error "-1" "install_execd - wrong root password"
               close_spawn_process $id; 
               return;
            }
            -i $sp_id "The installation of the execution daemon will abort now" {
               set_error "-1" "install_execd - installation error"
               close_spawn_process $id; 
               return;
            }

            -i $sp_id "Do you want to use these configuration parameters" { 
     
               puts $CHECK_OUTPUT "\n -->testsuite: sending >y<(11)"
               if {$do_log_output == 1} {
                    puts "press RETURN"
                    gets stdin anykey
               }
               send -i $sp_id "y\n"
               continue;
            }

            
            -i $sp_id "Do you want to use this configuration parameters" { 
     
               puts $CHECK_OUTPUT "\n -->testsuite: sending >y<(12)"
               if {$do_log_output == 1} {
                    puts "press RETURN"
                    gets stdin anykey
               }
               send -i $sp_id "y\n"
               continue;
            }
            -i $sp_id "lease enter cell name which you used for" {
               puts $CHECK_OUTPUT "\n -->testsuite: sending >RETURN<"
               if {$do_log_output == 1} {
                   puts "press RETURN"
                   gets stdin anykey
               }
               send -i $sp_id "\n"
               continue;
            }
            -i $sp_id "<RETURN> to see where" {
               puts $CHECK_OUTPUT "\n -->testsuite: sending >RETURN<"
               if {$do_log_output == 1} {
                   puts "press RETURN"
                   gets stdin anykey
               }
               send -i $sp_id "\n"
               continue;
            }

            -i $sp_id "Local configuration for host" {
               puts $CHECK_OUTPUT "\n -->testsuite: reconfigure configuration for spool dir\n"
               set spooldir [get_spool_dir $exec_host execd]
               puts $CHECK_OUTPUT "spooldir on host $exec_host is $spooldir"

               if { $spooldir != "" } {
                  set params(execd_spool_dir) $spooldir
                  set_config params $exec_host
                  set local_execd_spool_set 1 
               }
               continue; 
            }
            -i $sp_id "if this is ok or stop the installation with" {
               if { $CHECK_ADMIN_USER_SYSTEM != 0 } {
                  puts $CHECK_OUTPUT "\n -->testsuite: sending >RETURN<"
                  if {$do_log_output == 1} {
                       puts "press RETURN"
                       gets stdin anykey
                  }
                  send -i $sp_id "\n"
                  continue;
               } else {
                  set_error "-1" "install_execd - host $exec_host: tried to install not as root"
                  close_spawn_process $id; 
                  return;
               }
            }
 
     
            -i $sp_id "at system boot time" { 
               puts $CHECK_OUTPUT "\n -->testsuite: sending >n<(11)"
               if {$do_log_output == 1} {
                    puts "press RETURN"
                    gets stdin anykey
               }
     
               send -i $sp_id "n\n"
               continue;
            }

            -i $sp_id "is started at machine boot" { 
               puts $CHECK_OUTPUT "\n -->testsuite: sending >n<(12)"
               if {$do_log_output == 1} {
                    puts "press RETURN"
                    gets stdin anykey
               }
     
               send -i $sp_id "n\n"
               continue;
            }



            -i $sp_id "Do you want to add a default queue for this host" { 
               puts $CHECK_OUTPUT "\n -->testsuite: sending >y<(13)"
               if {$do_log_output == 1} {
                    puts "(5)press RETURN"
                    gets stdin anykey
               }
     
               send -i $sp_id "y\n"
               continue;
            }

            -i $sp_id "This host is unknown on the qmaster host" {
               puts $CHECK_OUTPUT "\nHostname resolving problem"
               puts $CHECK_OUTPUT "*********************************************************************"
               puts $CHECK_OUTPUT "Hostname resolving problem - use a host alias file for host $exec_host" 
               puts $CHECK_OUTPUT "**********************************************************************"
               puts $CHECK_OUTPUT "installation will continue in 15 seconds ..."
               sleep 15
            }

            -i $sp_id "There is still no service for" {
               set_error "-1" "install_execd - no TCP/IP service available";
               close_spawn_process $id
               set do_stop 1
            }

            -i $sp_id "Check again" { 
               puts $CHECK_OUTPUT "\n -->testsuite: sending >n<(13)"
               if {$do_log_output == 1} {
                    puts "press RETURN"
                    gets stdin anykey
               }
     
               send -i $sp_id "n\n"
               continue;
            }
            -i $sp_id "Do you want to see previous screen about using" { 
               puts $CHECK_OUTPUT "\n -->testsuite: sending >n<(14)"
               if {$do_log_output == 1} {
                    puts "press RETURN"
                    gets stdin anykey
               }
     
               send -i $sp_id "n\n"
               continue;
            }
            -i $sp_id "Error:" {
               set_error "-1" "install_execd - $expect_out(0,string)"
               close_spawn_process $id; 
               return;
            }
            -i $sp_id "can't resolve hostname*\n" {
               set_error "-1" "install_execd - $expect_out(0,string)"
               close_spawn_process $id; 
               return;
            }            
  
            -i $sp_id "error:\n" {
               set_error "-1" "install_execd - $expect_out(0,string)"
               close_spawn_process $id; 
               return;
            }
            -i $sp_id "execution daemon installation is now completed" {
               close_spawn_process $id
               read_install_list
               lappend CORE_INSTALLED $exec_host
               write_install_list
               set do_stop 1
            }

            -i $sp_id "Hit <RETURN> to continue" { 
               puts $CHECK_OUTPUT "\n -->testsuite: sending >RETURN<"
               if {$do_log_output == 1} {
                    puts "press RETURN"
                    gets stdin anykey
               }
     
               send -i $sp_id "\n"
               continue;
            }
            -i $sp_id default {
               set_error "-1" "install_execd - undefined behaiviour: $expect_out(buffer)"
               close_spawn_process $id; 
               return;
            }
         }
      }  ;# while 1
   }
}


#                                                             max. column:     |
#****** install_core_system/get_spool_dir() ******
# 
#  NAME
#     get_spool_dir -- ??? 
#
#  SYNOPSIS
#     get_spool_dir { host subdir } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#     host   - ??? 
#     subdir - ??? 
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc get_spool_dir {host subdir} {
   global CHECK_CONFIG_DIR CHECK_COMMD_PORT CHECK_OUTPUT CHECK_SPOOL_DIR_CONFIG_FILE
   global CHECK_USER CHECK_TESTSUITE_ROOT CHECK_DEFAULTS_FILE CHECK_TCL_SCRIPTFILE_DIR
   global CHECK_SCRIPT_FILE_DIR

   set spool_config $CHECK_CONFIG_DIR/$CHECK_SPOOL_DIR_CONFIG_FILE
   set spooldir ""

   puts "searching spooldir for host $host, type $subdir"
   if {[file exists $spool_config ]} {
      set f [open $spool_config r]
      while { [gets $f line] >= 0 } {
         if { [string first "#" $line ] == 0 } {
            continue 
         }  

         set string_tmp [lindex $line 0]
         puts $CHECK_OUTPUT "->$string_tmp"
         if {[string compare -nocase $host $string_tmp] == 0} {
            set spooldir "[lindex $line 1]"
            puts $CHECK_OUTPUT "->host $string_tmp has spool toplevel directory $spooldir"

            set result [ start_remote_tcl_prog $host $CHECK_USER "file_procedures.tcl" "cleanup_spool_dir" "$spooldir $subdir" ]
            set spooldir "$spooldir/$CHECK_COMMD_PORT/$subdir"
            puts $CHECK_OUTPUT $result
            puts $CHECK_OUTPUT $spooldir
#            gets stdin test
         }
      }
      close $f
   }
   return $spooldir
}

proc get_local_product_root_dir { host } {
   global CHECK_OUTPUT CHECK_CONFIG_DIR CHECK_LOCAL_BINARY_DIR_CONFIG_FILE
   
   set binary_config $CHECK_CONFIG_DIR/$CHECK_LOCAL_BINARY_DIR_CONFIG_FILE
   set binary_dir ""

   puts "searching binary directory for host $host ..."
   if {[file exists $binary_config ]} {
      set f [open $binary_config r]
      while { [gets $f line] >= 0 } {
         if { [string first "#" $line ] == 0 } {
            continue 
         }  
         set string_tmp [lindex $line 0]
         if {[string compare -nocase $host $string_tmp] == 0} {
            set binary_dir "[lindex $line 1]"
            puts $CHECK_OUTPUT "->host $string_tmp has binary directory $binary_dir"
         }
      }
      close $f
   }
   return $binary_dir
}

#                                                             max. column:     |
#****** install_core_system/setup_queues() ******
# 
#  NAME
#     setup_queues -- ??? 
#
#  SYNOPSIS
#     setup_queues { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc setup_queues {} {
  global CHECK_PRODUCT_ROOT CHECK_ARCH env check_errno CHECK_HOST
  global CHECK_CORE_EXECD CHECK_CORE_MASTER CHECK_CORE_PROCESSORS
  global check_use_installed_system CHECK_OUTPUT CHECK_PRODUCT_TYPE

  set catch_return [ catch { exec "$CHECK_PRODUCT_ROOT/bin/$CHECK_ARCH/qstat" } result ]
  if { $catch_return != 0 } {
     add_proc_error "setup_queues" -2 "error connecting qmaster: $result"
     set_error -2 "error connecting qmaster"
     return
  }

    
  puts $CHECK_OUTPUT "\ncleaning up system"
  catch { exec "$CHECK_PRODUCT_ROOT/bin/$CHECK_ARCH/qdel" "-uall" } result

  set my_time [ expr ( [timestamp] + 100 ) ]
  while { [timestamp]< $my_time } {
      set my_jobs [ get_standard_job_info 1 0 1 ]
      foreach job_elem $my_jobs {
         puts $CHECK_OUTPUT $job_elem
      }
      if { [llength $my_jobs] <= 2 } {
         break
      }
      sleep 1
  } 

  puts $CHECK_OUTPUT "\nremoving share tree"
  catch { exec "$CHECK_PRODUCT_ROOT/bin/$CHECK_ARCH/qconf" "-dstree" } result
  puts $CHECK_OUTPUT $result

  puts $CHECK_OUTPUT "\nremoving ckpt objects ..."
  catch { exec "$CHECK_PRODUCT_ROOT/bin/$CHECK_ARCH/qconf" "-sckptl" } result
  if { [string first "no ckpt interface definition defined" $result] >= 0 } {
     puts $CHECK_OUTPUT "no ckpt interface definition defined"
  } else {
     foreach elem $result {
        puts $CHECK_OUTPUT "removing ckpt interface $elem."
        del_checkpointobj $elem 
     }
  }

  puts $CHECK_OUTPUT "\nremoving PE objects ..."
  catch { exec "$CHECK_PRODUCT_ROOT/bin/$CHECK_ARCH/qconf" "-spl" } result
  if { [string first "no parallel environment defined" $result] >= 0 } {
     puts $CHECK_OUTPUT "no parallel environment defined"
  } else {
     foreach elem $result {
        puts $CHECK_OUTPUT "removing PE $elem."
        del_pe $elem 
     }
  }

  puts $CHECK_OUTPUT "\nremoving calendars ..."
  catch { exec "$CHECK_PRODUCT_ROOT/bin/$CHECK_ARCH/qconf" "-scall" } result
  if { [string first "no calendar defined" $result] >= 0 } {
     puts $CHECK_OUTPUT "no calendar defined"
  } else {
     foreach elem $result {
        puts $CHECK_OUTPUT "removing calendar $elem."
        del_calendar $elem 
     }
  }


  if { [ string compare $CHECK_PRODUCT_TYPE "sgeee" ] == 0 } {
     puts $CHECK_OUTPUT "\nremoving project objects ..."
     catch { exec "$CHECK_PRODUCT_ROOT/bin/$CHECK_ARCH/qconf" "-sprjl" } result
     if { [string first "no project list defined" $result] >= 0 } {
        puts $CHECK_OUTPUT "no project list defined"
     } else {
        foreach elem $result {
           puts $CHECK_OUTPUT "removing project $elem."
           del_prj $elem 
        }
     }
  }

  if { $check_use_installed_system != 0 } {
     puts $CHECK_OUTPUT "\nremoving queues ..."
     catch { exec "$CHECK_PRODUCT_ROOT/bin/$CHECK_ARCH/qconf" "-sql" } result
     if { [string first "no queue defined" $result] >= 0 } {
        puts $CHECK_OUTPUT "no queue defined"
     } else {
        foreach elem $result {
           puts $CHECK_OUTPUT "removing queue $elem."
           del_queue $elem 
        }
     }

     puts $CHECK_OUTPUT "\nadding testsuite queues ..."
     foreach hostname $CHECK_CORE_EXECD {
        set q_param(qname)       "$hostname.q" 
        set q_param(hostname)    "$hostname"
        add_queue "q_param" 
     }
  }
  # for each execd - standard - queue do:
  # set load_avg to 5.0
  # set slots * 10
  # --------------------------------------------------------------
  foreach hostname $CHECK_CORE_EXECD {

#     slots = 10 * cpu count (for qstat test)

    


     set index [lsearch $CHECK_CORE_EXECD $hostname] 
     set slots_tmp [lindex $CHECK_CORE_PROCESSORS $index]

     if { $slots_tmp <= 0 } {
        set_error -2 "no slots for execd $hostname"
        return
     }

     set slots [ expr ( $slots_tmp * 10) ]
     set new_values(load_thresholds)       "np_load_avg=11.00"
     set new_values(qtype)                 "BATCH INTERACTIVE CHECKPOINTING PARALLEL"
     set new_values(slots)                 "$slots"

     set result [ set_queue "${hostname}.q" new_values ]
     switch -- $result { 
       -1 {
         set_error -1 "setup_queues - modify queue ${hostname}.q - got timeout"
       }
       0 {
         set_error 0 "setup_queues - no errors"
       }
       -100 {
         set_error -1 "setup_queues - could not modify queue"
       } 
     }
     if {$check_errno != 0} {
        return;
     }
  }
  wait_for_load_from_all_queues 300 
}

#                                                             max. column:     |
#****** install_core_system/setup_testcheckpointobject() ******
# 
#  NAME
#     setup_testcheckpointobject -- ??? 
#
#  SYNOPSIS
#     setup_testcheckpointobject { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc setup_testcheckpointobject {} {
  global CHECK_PRODUCT_ROOT CHECK_ARCH check_errno  CHECK_CORE_EXECD CHECK_CORE_MASTER

  set q_list ""
  foreach elem $CHECK_CORE_EXECD {
    set q_list "$q_list,${elem}.q"
  }
  set change(queue_list) "$q_list"
  set change(ckpt_name)  "testcheckpointobject"
   
  add_checkpointobj change
  set_error 0 "ok"
}


#                                                             max. column:     |
#****** install_core_system/setup_conf() ******
# 
#  NAME
#     setup_conf -- ??? 
#
#  SYNOPSIS
#     setup_conf { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc setup_conf {} {
  global CHECK_PRODUCT_ROOT CHECK_ARCH CHECK_CORE_EXECD CHECK_CORE_MASTER
  global CHECK_DEFAULT_DOMAIN CHECK_PRODUCT_TYPE

  get_config old_config
  set params(reschedule_unknown) "00:00:00"
  set_config params
  get_config old_config

  # set finished_job in global config
  set params(finished_jobs) "0"  
  set params(load_report_time) "00:00:15"
  set params(default_domain) "$CHECK_DEFAULT_DOMAIN"
  set params(reschedule_unknown) "00:00:00"
  set params(loglevel) "log_info"
  set params(load_sensor) "none"
  set params(prolog) "none"
  set params(epilog) "none"
  set params(shell_start_mode) "posix_compliant"
  set params(login_shells) "sh,ksh,csh,tcsh"
  set params(min_uid) "0"
  set params(min_gid) "0"
  set params(user_lists) "none"
  set params(xuser_lists) "none"
  set params(max_unheard) "00:05:00"
  set params(administrator_mail) "none"
  set params(set_token_cmd) "none"
  set params(pag_cmd) "none"
  set params(token_extend_time) "none"
  set params(shepherd_cmd) "none"
  set params(qmaster_params) "none"
  set params(schedd_params) "none"
  set params(execd_params) "none"
  set params(qlogin_command) "telnet"
  set params(ignore_fqdn) "true"
  set params(max_aj_instances) "2000"
  set params(max_aj_tasks) "75000"

  if { $CHECK_PRODUCT_TYPE == "sgeee" } {
    set params(execd_params)    "PTF_MIN_PRIORITY=20,PTF_MAX_PRIORITY=0"
    set params(enforce_project) "false"
    set params(projects) "none"
    set params(xprojects) "none"
  }

  set result [ set_config params ] 

  # for sgeee systems on irix: set execd params to
  # PTF_MIN_PRIORITY=40,PTF_MAX_PRIORITY=20
  if { $CHECK_PRODUCT_TYPE == "sgeee" } {
  set ptf_param(execd_params) "PTF_MIN_PRIORITY=40,PTF_MAX_PRIORITY=20"
    foreach i $CHECK_CORE_EXECD {
      switch -exact [resolve_arch $i] {
        irix6 {
          set_config ptf_param $i
        }
      }
    }
  }

  get_config new_config
  
  set arrays_old [ array names old_config ]
  set arrays_new [ array names new_config ]
#  foreach elem $arrays_old { puts "old elem: \"$elem\"" }
#  foreach elem $arrays_new { puts "new elem: \"$elem\"" }

  if { [ llength $arrays_old] == [ llength $arrays_new ] } {
    foreach param $arrays_old {
       set old  $old_config($param)
       set new  $new_config($param)

       if { [ string compare $old $new ] != 0 } {
          if { [ string compare $param "load_report_time" ] == 0 } { continue }
          if { [ string compare $param "loglevel" ] == 0 } { continue }
          if { [ string compare $param "execd_params" ] == 0 } { continue }
          if { [ string compare $param "finished_jobs" ] == 0 } { continue }
#          if { [ string compare $param "" ] == 0 } { continue }
#          if { [ string compare $param "" ] == 0 } { continue }
#          if { [ string compare $param "" ] == 0 } { continue }
#          if { [ string compare $param "" ] == 0 } { continue }
#          if { [ string compare $param "" ] == 0 } { continue }
#          if { [ string compare $param "" ] == 0 } { continue }
#          if { [ string compare $param "" ] == 0 } { continue }



          add_proc_error "setup_conf" -3 "config parameter $param:\ndefault setup: $old, after testsuite reset: $new" 
       }
    }
  } else {
      foreach elem $arrays_old {
         if { [string first $elem $arrays_new] < 0 } {
            add_proc_error "setup_conf" -1 "paramter $elem not in new configuration"
         }
      }
      foreach elem $arrays_new { 
         if { [string first $elem $arrays_old] < 0 } {
           add_proc_error "setup_conf" -1 "paramter $elem not in old configuration"
         }
      }

     add_proc_error "setup_conf" -1 "config parameter count new/old configuration error"
  }

  set_error 0 "ok"
}



#                                                             max. column:     |
#****** install_core_system/setup_mytestproject() ******
# 
#  NAME
#     setup_mytestproject -- ??? 
#
#  SYNOPSIS
#     setup_mytestproject { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc setup_mytestproject {} {
  global CHECK_PRODUCT_ROOT CHECK_ARCH env check_errno  CHECK_CORE_EXECD 
  global open_spawn_buffer CHECK_CORE_MASTER CHECK_PRODUCT_TYPE
 

  if { [ string compare $CHECK_PRODUCT_TYPE "sge" ] == 0 } {
     set_error 0 "setup_mytestproject - not possible for sge systems"
     return
  }

  # setup project "mytestproject"
  set prj_setup(name) "mytestproject"
  set result [ add_prj prj_setup ] 

  set_error 0 "ok"  
}


#                                                             max. column:     |
#****** install_core_system/setup_mytestpe() ******
# 
#  NAME
#     setup_mytestpe -- ??? 
#
#  SYNOPSIS
#     setup_mytestpe { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc setup_mytestpe {} {
  global CHECK_PRODUCT_ROOT CHECK_ARCH env check_errno  CHECK_CORE_EXECD CHECK_CORE_MASTER


  set q_list ""
  foreach elem $CHECK_CORE_EXECD {
    set q_list "$q_list,${elem}.q"
  }
 

  set change(pe_name) "mytestpe"
  set change(queue_list) $q_list
  set change(slots) "5"

  add_pe change
  set_error 0 "ok"
}



#                                                             max. column:     |
#****** install_core_system/setup_deadlineuser() ******
# 
#  NAME
#     setup_deadlineuser -- ??? 
#
#  SYNOPSIS
#     setup_deadlineuser { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc setup_deadlineuser {} {
  global CHECK_PRODUCT_ROOT CHECK_ARCH CHECK_CORE_EXECD CHECK_USER CHECK_CORE_MASTER
  global CHECK_PRODUCT_TYPE


  if { [ string compare $CHECK_PRODUCT_TYPE "sge" ] == 0 } { 
     set_error 0 "setup_deadlineuser - no sgeee system"
     return
  }

  # add user to deadlineusers 
  set vi_commands "" 
  lappend vi_commands ":%s/entries.*$/entries  $CHECK_USER/\n"

  set result [ handle_vi_edit "$CHECK_PRODUCT_ROOT/bin/$CHECK_ARCH/qconf" "-mu deadlineusers" $vi_commands "modified*\"deadlineusers\"" ]
  if { $result == -1 } { add_proc_error "setup_deadlineuser" -1 "timeout error" }
  if { $result != 0 } { add_proc_error "setup_deadlineuser" -1 "could not add deadlineuser $CHECK_USER" }

  set_error 0 "ok"
}


#                                                             max. column:     |
#****** install_core_system/setup_schedconf() ******
# 
#  NAME
#     setup_schedconf -- ??? 
#
#  SYNOPSIS
#     setup_schedconf { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc setup_schedconf {} {
  global CHECK_PRODUCT_ROOT CHECK_ARCH env check_errno  CHECK_CORE_EXECD CHECK_USER CHECK_CORE_MASTER
  global CHECK_PRODUCT_TYPE 

  # reset_schedd_config has global error reporting
  get_schedd_config old_config
  reset_schedd_config 
  get_schedd_config new_config

  set arrays_old [ array names old_config ]
  set arrays_new [ array names new_config ]

  if { [ llength $arrays_old] == [ llength $arrays_new ] } {
    foreach param $arrays_old {
       set old  $old_config($param)
       set new  $new_config($param)

       if { [ string compare $old $new ] != 0 } {
          if { [ string compare $param "sgeee_schedule_interval" ] == 0 } { continue }
          if { [ string compare $param "weight_tickets_deadline" ] == 0 } { continue }
          if { [ string compare $param "job_load_adjustments" ] == 0 } { continue }
          if { [ string compare $param "schedule_interval" ] == 0 } { continue }
          add_proc_error "setup_schedconf" -3 "scheduler parameter $param:\ndefault setup: $old, after testsuite reset: $new" 
       }
    }
  } else {
     add_proc_error "setup_schedconf" -1 "parameter count new/old scheduler configuration error"
  }

  set_error 0 "ok"
}


#                                                             max. column:     |
#****** install_core_system/setup_default_calendars() ******
# 
#  NAME
#     setup_default_calendars -- ??? 
#
#  SYNOPSIS
#     setup_default_calendars { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc setup_default_calendars {} {
  global CHECK_PRODUCT_ROOT CHECK_ARCH env check_errno  CHECK_CORE_EXECD CHECK_USER CHECK_CORE_MASTER
  global CHECK_PRODUCT_TYPE 


  set calendar_param(calendar_name)          "always_suspend"              ;# always in calendar suspend
  set calendar_param(year)                   "NONE"
  set calendar_param(week)                   "mon-sun=0-24=suspended"

  set result [ add_calendar calendar_param ]
  if { $result != 0 } {
     set_error -1 "setup_default_calendards: result of add_default_calendars: $result"
     return
  }

  set calendar_param(calendar_name)          "always_disabled"              ;# always in calendar suspend
  set calendar_param(year)                   "NONE"
  set calendar_param(week)                   "mon-sun=0-24=off"

  set result [ add_calendar calendar_param ]
  if { $result != 0 } {
     set_error -1 "setup_default_calendards: result of add_default_calendars: $result"
     return
  }
 
  set_error 0 "setup_default_calendars - no errors" 
}

#                                                             max. column:     |
#****** install_core_system/setup_check_user_permissions() ******
# 
#  NAME
#     setup_check_user_permissions -- ??? 
#
#  SYNOPSIS
#     setup_check_user_permissions { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc setup_check_user_permissions {} {
  global CHECK_USER CHECK_FIRST_FOREIGN_SYSTEM_USER CHECK_SECOND_FOREIGN_SYSTEM_USER
  global CHECK_OUTPUT CHECK_CORE_EXECD CHECK_CORE_MASTER 
  global CHECK_TESTSUITE_ROOT CHECK_SCRIPT_FILE_DIR CHECK_ADMIN_USER_SYSTEM


  set time [timestamp]
  if { $CHECK_ADMIN_USER_SYSTEM == 0 } { 
     set user_list "root $CHECK_USER $CHECK_FIRST_FOREIGN_SYSTEM_USER $CHECK_SECOND_FOREIGN_SYSTEM_USER"
  } else {
     set user_list "$CHECK_USER"
  }
  foreach user $user_list {
     puts $CHECK_OUTPUT "\n----mask-check----\nuser: $user"
     set my_command ""
     foreach host $CHECK_CORE_EXECD {
        set execd_spooldir [get_execd_spool_dir $host]
        puts $CHECK_OUTPUT "checking execd spool directory on $host: \"$execd_spooldir\""
        set output [ start_remote_prog "$host" "$user" "cd" "$execd_spooldir ; cd $CHECK_TESTSUITE_ROOT/$CHECK_SCRIPT_FILE_DIR" ]
        if { $prg_exit_state != 0 } {
           set_error -1 "user $user has no read//exec permission to \"$execd_spooldir\" and \"$CHECK_TESTSUITE_ROOT/$CHECK_SCRIPT_FILE_DIR\" on host $host"
        }
     }
  }

  set master_spooldir [get_qmaster_spool_dir]
  puts $CHECK_OUTPUT "master spool directory on host $CHECK_CORE_MASTER: \"$master_spooldir\""
  foreach user $user_list {
      puts $CHECK_OUTPUT "checking master spool directory for user: \"$user\""
      set output [ start_remote_prog "$CHECK_CORE_MASTER" "$user" "cd" "$master_spooldir"  ]
      if { $prg_exit_state != 0 } {
         puts $CHECK_OUTPUT "--> E R R O R - user $user has no read//exec permission to $master_spooldir on host $CHECK_CORE_MASTER"
         set_error -1 "user $user has no read//exec permission to $master_spooldir on host $CHECK_CORE_MASTER"
      }
  }
  puts "runtime: [ expr ( [timestamp] - $time ) ]"
  get_version_info
  set_error 0 "ok"
}

proc setup_local_binary_path { } {
   global CHECK_OUTPUT CHECK_CONFIG_DIR CHECK_LOCAL_BINARY_DIR_CONFIG_FILE
   global CHECK_CORE_EXECD CHECK_ADMIN_USER_SYSTEM CHECK_PRODUCT_ROOT
   global CHECK_TESTSUITE_ROOT CHECK_CORE_MASTER CHECK_USER


   if { $CHECK_ADMIN_USER_SYSTEM == 0 } {
      set must_copy 0
      foreach host $CHECK_CORE_EXECD {
         set bin_dir [ get_local_product_root_dir $host ]
         if { $bin_dir != "" } {
            set must_copy 1
         }
      }
      if { $must_copy == 1 } {
         set tar_bin [get_binary_path $CHECK_CORE_MASTER "tar"]
         set tar_command "$tar_bin cvf tarfile.tar *"
         puts $CHECK_OUTPUT $tar_command
         set result [ start_remote_prog $CHECK_CORE_MASTER "root" "cd" "$CHECK_PRODUCT_ROOT; ${tar_command}" ]
         puts $CHECK_OUTPUT $result
         if { $prg_exit_state != 0 } {
            add_proc_error "setup_local_binary_path" -2 "$result"
         } 


         set gzip_bin [get_binary_path $CHECK_CORE_MASTER "gzip"]
         set gzip_command "$gzip_bin -1 tarfile.tar"
         puts $CHECK_OUTPUT $gzip_command
         set result [ start_remote_prog $CHECK_CORE_MASTER "root" "cd" "$CHECK_PRODUCT_ROOT; ${gzip_command}" prg_exit_state 1000 ]
         puts $CHECK_OUTPUT $result
         if { $prg_exit_state != 0 } {
            add_proc_error "setup_local_binary_path" -2 "$result"
         } 


         foreach host $CHECK_CORE_EXECD {
            set bin_dir [ get_local_product_root_dir $host ]
            if { $bin_dir != "" } {
               puts $CHECK_OUTPUT "copying binaries for host $host"
        
               set result [ start_remote_prog $host $CHECK_USER "cd" "$bin_dir" ]
               puts $CHECK_OUTPUT $result
               if { $prg_exit_state != 0 } {
                  set result [ start_remote_prog $host $CHECK_USER "mkdir" "-p $bin_dir" ]
                  puts $CHECK_OUTPUT $result
                  set result [ start_remote_prog $host $CHECK_USER "cd" "$bin_dir" ]
                  puts $CHECK_OUTPUT $result
                  if { $prg_exit_state != 0 } {
                     add_proc_error "setup_local_binary_path" -2 "$result"
                     return -2 "error"
                  }

               }

               set result [ start_remote_prog $host $CHECK_USER "cp" "$CHECK_PRODUCT_ROOT/tarfile.tar.gz $bin_dir/tarfile.tar.gz" ]
               puts $CHECK_OUTPUT $result
               if { $prg_exit_state != 0 } {
                   add_proc_error "setup_local_binary_path" -2 "$result"
               } 


               set gzip_bin [get_binary_path $host "gzip"]
               set gzip_command "$gzip_bin -d tarfile.tar"
               puts $CHECK_OUTPUT $gzip_command
               set result [ start_remote_prog $host $CHECK_USER "cd" "$bin_dir; ${gzip_command}" prg_exit_state 1000 ]
               puts $CHECK_OUTPUT $result
               if { $prg_exit_state != 0 } {
                   add_proc_error "setup_local_binary_path" -2 "$result"
               } 


               set tar_bin [get_binary_path $host "tar"]
               set tar_command "$tar_bin xvf tarfile.tar"
               puts $CHECK_OUTPUT $tar_command
               set result [ start_remote_prog $host "root" "cd" "$bin_dir; ${tar_command}" ]
               puts $CHECK_OUTPUT $result
               if { $prg_exit_state != 0 } {
                   add_proc_error "setup_local_binary_path" -2 "$result"
               } 

               puts $CHECK_OUTPUT "removing existing tar file ..."
               set result [ start_remote_prog $host $CHECK_USER "rm" "$bin_dir/tarfile.tar" ]
               puts $CHECK_OUTPUT $result
            }
         }
      }
      puts $CHECK_OUTPUT "removing existing tar file ..."
      set result [ start_remote_prog "$CHECK_CORE_MASTER" "root" "rm" "$CHECK_PRODUCT_ROOT/tarfile.tar.gz" ]
      puts $CHECK_OUTPUT $result
   } else {
     add_proc_error "setup_local_binary_path" -3 "not supported for non root cluster"
   }
   set_error 0 "ok"
}

proc setup_check_messages_files {} {
   global CHECK_CORE_EXECD CHECK_CORE_MASTER CHECK_OUTPUT
   global CHECK_USER

   puts $CHECK_OUTPUT "scheduler ..."
   set messages [get_schedd_messages_file]
   get_file_content $CHECK_CORE_MASTER $CHECK_USER $messages 
   if { $file_array(0) < 1 } {
      add_proc_error "setup_check_messages_files" -1 "no scheduler messages file:\n$messages"
   }
   for {set i 1 } { $i <= $file_array(0) } { incr i 1 } {
      puts $CHECK_OUTPUT $file_array($i)
   }

   puts $CHECK_OUTPUT "qmaster ..."
   set messages [get_qmaster_messages_file]
   get_file_content $CHECK_CORE_MASTER $CHECK_USER $messages 
   if { $file_array(0) < 1 } {
      add_proc_error "setup_check_messages_files" -1 "no qmaster messages file:\n$messages"
   }
   for {set i 1 } { $i <= $file_array(0) } { incr i 1 } {
      puts $CHECK_OUTPUT $file_array($i)
   }

   foreach execd $CHECK_CORE_EXECD {
      puts $CHECK_OUTPUT "execd $execd ..."
      set messages [ get_execd_messages_file $execd ]
      get_file_content $execd $CHECK_USER $messages 
      if { $file_array(0) < 1 } {
         add_proc_error "setup_check_messages_files" -1 "no execd(host=$execd) messages file:\n$messages"
      }
      for {set i 1 } { $i <= $file_array(0) } { incr i 1 } {
         puts $CHECK_OUTPUT $file_array($i)
      }
   }
   set_error 0 "ok"
}

#                                                             max. column:     |
#****** install_core_system/setup_inhouse_cluster() ******
# 
#  NAME
#     setup_inhouse_cluster -- ??? 
#
#  SYNOPSIS
#     setup_inhouse_cluster { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc setup_inhouse_cluster {} {
  global CHECK_PRODUCT_ROOT CHECK_ARCH env check_errno  CHECK_CORE_EXECD CHECK_USER CHECK_CORE_MASTER
  global CHECK_PRODUCT_TYPE
  global CHECK_OUTPUT

  # reset_schedd_config has global error reporting
  if {[lsearch -exact [info procs] "inhouse_cluster_post_install"] != -1} {
    puts $CHECK_OUTPUT "executing postinstall procedure for inhouse cluster"
    inhouse_cluster_post_install
  }

  set_error 0 "ok"
}



