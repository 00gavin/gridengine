#!/vol2/TCL_TK/glinux/bin/expect
# global variables ... (defined in main check routine, but you can use it)
#
# global CHECK_CHECKTREE_ROOT              ;# path where checktree lies
# global CHECK_ACT_PATH          ;# actual checkpath
# gloabl CHECK_ACTUAL_TEST_PATH  ;# this directory
# global CHECK_PRODUCT_ROOT  ;# path to sge/sgeee system
# global CHECK_PRODUCT_TYPE       ;# "sgeee" or "sge"         
# global CHECK_COMMD_PORT        ;# commd port
# global CHECK_USER              ;# user who start test
# global CHECK_ARCH              ;# architecture of this system (e.g. irix6)
# global CHECK_HOST              ;# hostname of this system (e.g. DWAIN)
#___INFO__MARK_BEGIN__
##########################################################################
#
#  The Contents of this file are made available subject to the terms of
#  the Sun Industry Standards Source License Version 1.2
#
#  Sun Microsystems Inc., March, 2001
#
#
#  Sun Industry Standards Source License Version 1.2
#  =================================================
#  The contents of this file are subject to the Sun Industry Standards
#  Source License Version 1.2 (the "License"); You may not use this file
#  except in compliance with the License. You may obtain a copy of the
#  License at http://gridengine.sunsource.net/Gridengine_SISSL_license.html
#
#  Software provided under this License is provided on an "AS IS" basis,
#  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
#  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
#  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
#  See the License for the specific provisions governing your rights and
#  obligations concerning the Software.
#
#  The Initial Developer of the Original Code is: Sun Microsystems, Inc.
#
#  Copyright: 2001 by Sun Microsystems, Inc.
#
#  All Rights Reserved.
#
##########################################################################
#___INFO__MARK_END__

global check_name check_description check_needs check_functions check_errno check_errstr 
global check_root_access_needs       
global check_use_installed_system

# This file shows some check spezific things
set check_root_access_needs  "yes"
set check_name          "init_core_system"
set check_description(0)   "install a default system (master/execution daemon on local host and start them up)"
set check_needs         ""                        ;# dependencies of this check (name of other check)
set check_functions     ""                        ;# functions to call (in order)
lappend check_functions "kill_running_system"
lappend check_functions "install_qmaster"
lappend check_functions "install_execd"
lappend check_functions "setup_queues"
lappend check_functions "setup_testcheckpointobject"
lappend check_functions "setup_conf" 
lappend check_functions "setup_mytestproject" 
lappend check_functions "setup_mytestpe" 
lappend check_functions "setup_deadlineuser" 
lappend check_functions "setup_schedconf" 
lappend check_functions "setup_default_calendars"
lappend check_functions "setup_check_user_permissions"
lappend check_functions "setup_inhouse_cluster"


# ---------------------------------------------------------------------------------
# here the tests begin ....

global CORE_INSTALLED
global CORE_INSTALLED_TIME

global local_master_spool_set
global local_execd_spool_set


set local_master_spool_set 0
set local_execd_spool_set 0

set CORE_INSTALLED ""
set CORE_INSTALLED_TIME ""



# this is to setup the cluster
#                                                             max. column:     |
#****** install_core_system/write_install_list() ******
# 
#  NAME
#     write_install_list -- ??? 
#
#  SYNOPSIS
#     write_install_list { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc write_install_list {} {
  global CORE_INSTALLED CORE_INSTALLED_TIME CHECK_CORE_MASTER
  global CHECK_MAIN_RESULTS_DIR
 
  set myfile [open "$CHECK_MAIN_RESULTS_DIR/cluster.$CHECK_CORE_MASTER.inst" "w"]
  puts $myfile $CORE_INSTALLED
  close $myfile
}

#                                                             max. column:     |
#****** install_core_system/read_install_list() ******
# 
#  NAME
#     read_install_list -- ??? 
#
#  SYNOPSIS
#     read_install_list { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc read_install_list {} {
  global CORE_INSTALLED CORE_INSTALLED_TIME CHECK_CORE_MASTER
  global CHECK_MAIN_RESULTS_DIR 
  if { [file isfile "$CHECK_MAIN_RESULTS_DIR/cluster.$CHECK_CORE_MASTER.inst"] == 1 } {
     set myfile [open "$CHECK_MAIN_RESULTS_DIR/cluster.$CHECK_CORE_MASTER.inst" "r"]
     gets $myfile CORE_INSTALLED
     close $myfile
  }
}


# kill evtl. installed system
#                                                             max. column:     |
#****** install_core_system/kill_running_system() ******
# 
#  NAME
#     kill_running_system -- ??? 
#
#  SYNOPSIS
#     kill_running_system { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc kill_running_system {} {
   global CHECK_ARCH CHECK_PRODUCT_ROOT CHECK_PRODUCT_TYPE 
   global CHECK_OUTPUT CHECK_CORE_EXECD CHECK_CORE_MASTER CORE_INSTALLED
   global check_use_installed_system
 
   
   set CORE_INSTALLED ""
   write_install_list


   shutdown_core_system


   set_error "0" "kill_running_system - this is not a 'real' test (only try to shutdown $CHECK_PRODUCT_TYPE system)"

   if { $check_use_installed_system == 0 } { 
      # if this is master remove default dir (but not the licence file)
   
         set moved [timestamp]
   
         catch { exec "mv" "$CHECK_PRODUCT_ROOT/default" "$CHECK_PRODUCT_ROOT/default.$moved"  } result
         puts $result
   
         puts "current default directory ($CHECK_PRODUCT_ROOT/default) was moved to default.$moved"
   
         sleep 2
   
         catch { exec "mkdir" "$CHECK_PRODUCT_ROOT/default"  } result
         puts $result
         catch { exec "chmod" "755" "$CHECK_PRODUCT_ROOT/default"  } result
         puts $result

   
         sleep 2
   
         catch { exec "mkdir" "$CHECK_PRODUCT_ROOT/default/common"  } result
         puts $result

         catch { exec "chmod" "755" "$CHECK_PRODUCT_ROOT/default/common"  } result
         puts $result
   
         catch { exec "cp" "$CHECK_PRODUCT_ROOT/default.$moved/common/host_aliases" "$CHECK_PRODUCT_ROOT/default/common/host_aliases"  } result
         puts $result
   
         delete_directory "$CHECK_PRODUCT_ROOT/default.$moved"
   }
}



# install qmaster check 
#                                                             max. column:     |
#****** install_core_system/install_qmaster() ******
# 
#  NAME
#     install_qmaster -- ??? 
#
#  SYNOPSIS
#     install_qmaster { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc install_qmaster {} {
 global CHECK_PRODUCT_TYPE CHECK_PRODUCT_ROOT CHECK_USER check_errstr 
 global CHECK_CORE_EXECD CHECK_CORE_MASTER CORE_INSTALLED CORE_INSTALLED CHECK_OUTPUT 
 global open_spawn_buffer CHECK_TESTSUITE_ROOT env CHECK_COMMD_PORT local_master_spool_set
 global check_use_installed_system CHECK_ADMIN_USER_SYSTEM CHECK_DEFAULT_DOMAIN
 global CHECK_DEBUG_LEVEL CHECK_QMASTER_INSTALL_OPTIONS


 puts $CHECK_OUTPUT "install qmaster ($CHECK_PRODUCT_TYPE system) on host $CHECK_CORE_MASTER ..."

 if { $check_use_installed_system != 0 } {
    set_error "0" "install_qmaster - no need to install qmaster on host $CHECK_CORE_MASTER - noinst parameter is set"
    puts "no need to install qmaster on host $CHECK_CORE_MASTER, noinst parameter is set"
    set CORE_INSTALLED "" 
    if {[startup_qmaster] == 0} {
      lappend CORE_INSTALLED $CHECK_CORE_MASTER
      write_install_list
    }
    return
 }

 set CORE_INSTALLED ""
 write_install_list

 set_error "0" "install_qmaster - no errors"
 if {[file isfile "$CHECK_PRODUCT_ROOT/install_qmaster"] != 1} {
    set_error "-1" "install_qmaster - install_qmaster file not found"
    return
 }

 cd "$CHECK_PRODUCT_ROOT"

 set prod_type_var "SGE_ROOT"

 if { $CHECK_ADMIN_USER_SYSTEM == 0 } { 
    set id [open_remote_spawn_process "$CHECK_CORE_MASTER" "root"  "cd $$prod_type_var;./install_qmaster" $CHECK_QMASTER_INSTALL_OPTIONS ]
 } else {
    puts $CHECK_OUTPUT "--> install as user $CHECK_USER <--" 
    set id [open_remote_spawn_process "$CHECK_CORE_MASTER" "$CHECK_USER"  "cd $$prod_type_var;./install_qmaster" $CHECK_QMASTER_INSTALL_OPTIONS ]
 }
 set sp_id [ lindex $id 1 ] 
 


 set timeout 100 
 set hostcount 0

  set do_log_output 0
 if { $CHECK_DEBUG_LEVEL == 2 } {
   set do_log_output  1 ;# 1
 }

 while {1} {
 if {$do_log_output == 1} {
   puts "press RETURN"
   gets stdin anykey
 }
#    sleep 1
    puts "expecting now ..."
    expect {
       -i $sp_id full_buffer {
          set_error "-1" "install_qmaster - buffer overflow please increment CHECK_EXPECT_MATCH_MAX_BUFFER value"
          close_spawn_process $id; 
          return;
       }   

       -i $sp_id eof { 
          set_error "-1" "install_qmaster - unexpected eof"; 
          close_spawn_process $id;
          return;  
       }

       -i $sp_id timeout { 
          set_error "-1" "install_qmaster - timeout while waiting for output"; 
          close_spawn_process $id;
          return;  
       }
       -i $sp_id "orry" { 
          set_error "-1" "install_qmaster - wrong root password"
          close_spawn_process $id;
          return;
       }

       -i $sp_id "issing" { 
          set_error "-1" "install_qmaster - missing binary error"
          close_spawn_process $id;
          return;
       }
       -i $sp_id "xit." {
          set_error "-1" "install_qmaster - installation failed"
          close_spawn_process $id; 
          return;
       }
       -i $sp_id "enter the file name with a valid license key" {
          set_error "-1" "install_qmaster - not a licensed system"
          close_spawn_process $id; 
          return;
       }

       -i $sp_id "admin user account =*\n" {
          set real_admin_user $expect_out(0,string)
          set real_help [ split $real_admin_user "=" ]
          set real_admin_user [ string trim [ lindex $real_help 1 ]]
          
          puts $CHECK_OUTPUT "\n -->testsuite: admin user is \"$real_admin_user\""
          if { [string compare $real_admin_user $CHECK_USER] != 0 } {
             set_error "-1" "install_qmaster - admin user \"$real_admin_user\" is different from CHECK_USER \"$CHECK_USER\"" 
             close_spawn_process $id;
             return;
          }
       }
       
       -i $sp_id "and contact * or your local distributor for getting a license" { 
          puts $CHECK_OUTPUT "\n -->testsuite: sending >return<"
          if {$do_log_output == 1} {
             puts "press RETURN"
             gets stdin anykey
          }
          send "\n"
          continue;
       }

       -i $sp_id -gl "You requested -resport" {
         set_error "-1" "install_qmaster: Configuration error: System with reserved port security requested, but port is configured to $CHECK_COMMD_PORT"
         close_spawn_process $id
         return
       }

       -i $sp_id "Are all the hosts of your cluster in a single DNS domain" { 
          puts $CHECK_OUTPUT "\n -->testsuite: sending >y<"
          if {$do_log_output == 1} {
             puts "press RETURN"
             gets stdin anykey
          }
          send "y\n"
          continue;
       }
 
       -i $sp_id "Do you want to run SGE as admin user" { 
          puts $CHECK_OUTPUT "\n -->testsuite: sending >y<"
          if {$do_log_output == 1} {
             puts "press RETURN"
             gets stdin anykey
          }
          send "y\n"
          continue;
       }

       -i $sp_id "Do you want to run SGEEE as admin user" { 
          puts $CHECK_OUTPUT "\n -->testsuite: sending >y<"
          if {$do_log_output == 1} {
             puts "press RETURN"
             gets stdin anykey
          }
          send "y\n"
          continue;
       }

       -i $sp_id "Do you want to use these configuration parameters" {
          puts $CHECK_OUTPUT "\n -->testsuite: sending >n<"
          if {$do_log_output == 1} {
               puts "press RETURN"
               gets stdin anykey
          }
          send "n\n"
          continue;
       }
       -i $sp_id "Do you want to set the file permissions" {
          puts $CHECK_OUTPUT "\n -->testsuite: sending >yes<"
          if {$do_log_output == 1} {
               puts "press RETURN"
               gets stdin anykey
          }
          send "yes\n"
          continue;
       }

       -i $sp_id "Do you want to verify and set your file permissions" {
          puts $CHECK_OUTPUT "\n -->testsuite: sending >y<"
          if {$do_log_output == 1} {
               puts "press RETURN"
               gets stdin anykey
          }
          send "y\n"
          continue;
       }

       -i $sp_id "Do you want to use this configuration parameters" {
          puts $CHECK_OUTPUT "\n -->testsuite: sending >n<"
          if {$do_log_output == 1} {
               puts "press RETURN"
               gets stdin anykey
          }
          send "n\n"
          continue;
       }
       -i $sp_id "if this is ok or stop the installation with" {
          if { $CHECK_ADMIN_USER_SYSTEM != 0 } {
             puts $CHECK_OUTPUT "\n -->testsuite: sending >RETURN<"
             if {$do_log_output == 1} {
                  puts "press RETURN"
                  gets stdin anykey
             }
             send "\n"
             continue;
          } else {
             set_error "-1" "install_qmaster - tried to install not as root"
             close_spawn_process $id; 
             return;
          }
       }

       -i $sp_id "Do you want to run the application as admin user" {
          puts $CHECK_OUTPUT "\n -->testsuite: sending >n<"
          if {$do_log_output == 1} {
               puts "press RETURN"
               gets stdin anykey
          }
          send "n\n"
          continue;
       }
       -i $sp_id "under an user id other than" {
          puts $CHECK_OUTPUT "\n -->testsuite: sending >n<"
          if {$do_log_output == 1} {
               puts "press RETURN"
               gets stdin anykey
          }
          send "n\n"
          continue;
       }
       -i $sp_id "you want to select another qmaster spool directory" {
          puts $CHECK_OUTPUT "\n -->testsuite: sending >n<"
          if {$do_log_output == 1} {
               puts "press RETURN"
               gets stdin anykey
          }
          send "n\n"
          continue;
       }
       -i $sp_id "<RETURN> to see where" {
          puts $CHECK_OUTPUT "\n -->testsuite: sending >RETURN<"
          if {$do_log_output == 1} {
               puts "press RETURN"
               gets stdin anykey
          }

          send "\n"
          continue;
       }
       -i $sp_id "Did you install this version with >pkgadd<" {
          puts $CHECK_OUTPUT "\n -->testsuite: sending >n<"
          if {$do_log_output == 1} {
               puts "press RETURN"
               gets stdin anykey
          }

          send "n\n"
          continue;
       }
       -i $sp_id "Enter spool directory or hit" {
          puts $CHECK_OUTPUT "\n"
          set spooldir [get_spool_dir $CHECK_CORE_MASTER qmaster]
          if { $spooldir != "" } {
            # use local spool dir
            puts $CHECK_OUTPUT "\n -->testsuite: sending >$spooldir<"
            if {$do_log_output == 1} {
               puts "press RETURN"
               gets stdin anykey
            }
            send "$spooldir\n"
            set local_master_spool_set 1
          } else {
            # use default spool dir
            puts $CHECK_OUTPUT "\n -->testsuite: sending >RETURN<"
            if {$do_log_output == 1} {
               puts "press RETURN"
               gets stdin anykey
            }
            send "\n"
          }
          continue;
       }



       -i $sp_id "configure a default domain" {
          puts $CHECK_OUTPUT "\n -->testsuite: sending >n<"
          if {$do_log_output == 1} {
               puts "(2)press RETURN"
               gets stdin anykey
          }
          send "n\n"
          continue;
       }

       -i $sp_id "enter your default domain:" {
          puts $CHECK_OUTPUT "\n -->testsuite: sending >$CHECK_DEFAULT_DOMAIN<"
          if {$do_log_output == 1} {
               puts "press RETURN"
               gets stdin anykey
          }

          send "$CHECK_DEFAULT_DOMAIN\n"

          continue;
       }


       -i $sp_id "at system boot time" {
          puts $CHECK_OUTPUT "\n -->testsuite: sending >n<"
          if {$do_log_output == 1} {
               puts "press RETURN"
               gets stdin anykey
          }

          send "n\n"
          continue;
       }
       -i $sp_id "Do you want to create a new configuration" {
          puts $CHECK_OUTPUT "\n -->testsuite: sending >y<"
          if {$do_log_output == 1} {
               puts "(3)press RETURN"
               gets stdin anykey
          }

          send "y\n"
          continue;
       }
       -i $sp_id "Do you want to use a file which contains the list of hosts" {
          puts $CHECK_OUTPUT "\n -->testsuite: sending >n<"
          if {$do_log_output == 1} {
               puts "press RETURN"
               gets stdin anykey
          }

          send "n\n"
          continue;
       }
   
       -i $sp_id "Do you want to see previous screen about using" {
          puts $CHECK_OUTPUT "\n -->testsuite: sending >n<"
          if {$do_log_output == 1} {
               puts "press RETURN"
               gets stdin anykey
          }

          send "n\n"
          continue;
       }
       -i $sp_id "enter a range" {
          set myrange [ get_gid_range $CHECK_USER $CHECK_COMMD_PORT]
          puts $CHECK_OUTPUT "\n -->testsuite: sending >${myrange}<"
          if {$do_log_output == 1} {
               puts "press RETURN"
               gets stdin anykey
          }

          send "${myrange}\n"
          continue;
       }
       -i $sp_id "installation is now completed" {
          read_install_list
          lappend CORE_INSTALLED $CHECK_CORE_MASTER
          write_install_list
          set_error "0" "install_qmaster - no errors"
          close_spawn_process $id;
          return; 
       }
       -i $sp_id "Host(s):" {
          incr hostcount 1 
          if {$hostcount == 1} {
             foreach exechost $CHECK_CORE_EXECD {
               send " $exechost"
               puts $CHECK_OUTPUT "\n -->testsuite: sending >${exechost}<"
             } 
             puts $CHECK_OUTPUT "\n -->testsuite: sending >RETURN<"
             send "\n"
          } else {
             puts $CHECK_OUTPUT "\n -->testsuite: sending >RETURN<"
             send "\n"
          }
          continue;
       }
   
       -i $sp_id "More" {
          puts $CHECK_OUTPUT "\n -->testsuite: sending >space<"
          if {$do_log_output == 1} {
               puts "press RETURN"
               gets stdin anykey
          }

          send " "
          continue;
       }
       -i $sp_id "Error:" {
          set_error "-1" "install_qmaster - $expect_out(0,string)"
          close_spawn_process $id;
          return;
       }
       -i $sp_id "ommand failed*\n" {
          set_error "-1" "install_qmaster - $expect_out(0,string)"
          close_spawn_process $id;
          return;
       }
       -i $sp_id "can't resolve hostname*\n" {
          set_error "-1" "install_execd - $expect_out(0,string)"
          close_spawn_process $id; 
          return;
       }     
   
       -i $sp_id "error:\n" {
          set_error "-1" "install_qmaster - $expect_out(0,string)"
          continue;
       }
   
       -i $sp_id "Hit <RETURN> to continue" {
          puts $CHECK_OUTPUT "\n -->testsuite: sending >RETURN<"
          if {$do_log_output == 1} {
               puts "press RETURN"
               gets stdin anykey
          }
          send "\n"
          continue;
       }
       -i $sp_id default {
          set_error "-1" "install_qmaster - undefined behaiviour: $expect_out(buffer)"
          close_spawn_process $id; 
          return;
       }
    }
 }
}


#                                                             max. column:     |
#****** install_core_system/install_execd() ******
# 
#  NAME
#     install_execd -- ??? 
#
#  SYNOPSIS
#     install_execd { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc install_execd {} {
   global CHECK_OUTPUT CHECK_CORE_EXECD CHECK_PRODUCT_TYPE CORE_INSTALLED
   global check_use_installed_system CHECK_PRODUCT_ROOT CHECK_ARCH
   global CHECK_COMMD_PORT CHECK_ADMIN_USER_SYSTEM CHECK_USER
   global CHECK_DEBUG_LEVEL CHECK_GROUP CHECK_EXECD_INSTALL_OPTIONS

   set CORE_INSTALLED "" 
   read_install_list

   set_error "0" "install_execd - no errors"
 
   foreach exec_host $CHECK_CORE_EXECD {

      puts $CHECK_OUTPUT "installing execd on host $exec_host ($CHECK_PRODUCT_TYPE system) ..."
      if {[lsearch $CHECK_CORE_EXECD $exec_host] == -1 } {
         set_error "-1" "install_execd - host $exec_host is not in execd list"
         return 
      }
      if { $check_use_installed_system != 0 } {
         set_error "0" "install_execd - no need to install execd on hosts \"$CHECK_CORE_EXECD\" - noinst parameter is set"
         puts "no need to install execd on hosts \"$CHECK_CORE_EXECD\", noinst parameter is set"
         if {[startup_execd $exec_host] == 0 } {
            lappend CORE_INSTALLED $exec_host
            write_install_list
            continue
         } else {
            add_proc_error "install_execd" -2 "could not startup execd on host $exec_host"
            return
         }
      }

      if {[file isfile "$CHECK_PRODUCT_ROOT/install_execd"] != 1} {
         set_error "-1" "install_execd - install_execd file not found"
         return
      }

      set remote_arch [resolve_arch $exec_host]    
      set sensor_file [ get_loadsensor_path $remote_arch ]
      if { [string compare $sensor_file ""] != 0  } {
         puts $CHECK_OUTPUT "installing load sensor:"
         puts $CHECK_OUTPUT "======================="
         puts $CHECK_OUTPUT "architecture: $remote_arch"
         puts $CHECK_OUTPUT "sensor file:  $sensor_file"
         puts $CHECK_OUTPUT "target:       $CHECK_PRODUCT_ROOT/bin/$remote_arch/qloadsensor"
         if { $CHECK_ADMIN_USER_SYSTEM == 0 } { 
            set arguments "$sensor_file $CHECK_PRODUCT_ROOT/bin/$remote_arch/qloadsensor"
            set result [ start_remote_prog "$exec_host" "root" "cp" "$arguments" ] 
            puts $CHECK_OUTPUT "result: $result"
            puts $CHECK_OUTPUT "copy exit state: $prg_exit_state" 
         } else {
            puts $CHECK_OUTPUT "can not copy this file as user $CHECK_USER"
            puts $CHECK_OUTPUT "please copy this file manually!!"
            puts $CHECK_OUTPUT "if not, you will get no load values from this host (=$exec_host)"
            puts $CHECK_OUTPUT "installation will continue in 15 seconds!!"
            sleep 15
         }
      }

      cd "$CHECK_PRODUCT_ROOT"

      set prod_type_var "SGE_ROOT"

      if { $CHECK_ADMIN_USER_SYSTEM == 0 } { 
         set id [open_remote_spawn_process "$exec_host" "root"  "cd $$prod_type_var;./install_execd" $CHECK_EXECD_INSTALL_OPTIONS ]
      } else {
         puts $CHECK_OUTPUT "--> install as user $CHECK_USER <--" 
         set id [open_remote_spawn_process "$exec_host" "$CHECK_USER"  "cd $$prod_type_var;./install_execd" $CHECK_EXECD_INSTALL_OPTIONS ]
      }



      set sp_id [ lindex $id 1 ] 


      set timeout 120
     
      set do_log_output 0 ;# 1
      if { $CHECK_DEBUG_LEVEL == 2 } {
         set do_log_output 1
      }
     # set do_log_output 1
      set do_stop 0
      while {$do_stop == 0} {
         if {$do_log_output == 1} {
             puts "press RETURN"
             gets stdin anykey
         }
     
         set timeout 60
         expect {
            -i $sp_id full_buffer {
               set_error "-1" "install_execd - buffer overflow please increment CHECK_EXPECT_MATCH_MAX_BUFFER value"
               close_spawn_process $id; 
               return;
            }
            -i $sp_id eof {
               set_error "-1" "install_execd - unexpeced eof";
               close_spawn_process $id
               set do_stop 1
            }

            -i $sp_id timeout { 
               set_error "-1" "install_execd - timeout while waiting for output"; 
               close_spawn_process $id;
               set do_stop 1
            }
            -i $sp_id "orry" { 
               set_error "-1" "install_execd - wrong root password"
               close_spawn_process $id; 
               return;
            }

            -i $sp_id "Do you want to use these configuration parameters" { 
     
               puts $CHECK_OUTPUT "\n -->testsuite: sending >y<"
               if {$do_log_output == 1} {
                    puts "press RETURN"
                    gets stdin anykey
               }
               send "y\n"
               continue;
            }

            
            -i $sp_id "Do you want to use this configuration parameters" { 
     
               puts $CHECK_OUTPUT "\n -->testsuite: sending >y<"
               if {$do_log_output == 1} {
                    puts "press RETURN"
                    gets stdin anykey
               }
               send "y\n"
               continue;
            }
            -i $sp_id "lease enter cell name which you used for" {
               puts $CHECK_OUTPUT "\n -->testsuite: sending >RETURN<"
               if {$do_log_output == 1} {
                   puts "press RETURN"
                   gets stdin anykey
               }
               send "\n"
               continue;
            }
            -i $sp_id "<RETURN> to see where" {
               puts $CHECK_OUTPUT "\n -->testsuite: sending >RETURN<"
               if {$do_log_output == 1} {
                   puts "press RETURN"
                   gets stdin anykey
               }
               send "\n"
               continue;
            }

            -i $sp_id "Local configuration for host" {
               puts $CHECK_OUTPUT "\n -->testsuite: reconfigure configuration for spool dir\n"
               set spooldir [get_spool_dir $exec_host execd]
               puts $CHECK_OUTPUT "spooldir on host $exec_host is $spooldir"

               if { $spooldir != "" } {
                  set params(execd_spool_dir) $spooldir
                  set_config params $exec_host
                  set local_execd_spool_set 1 
               }
               continue; 
            }
            -i $sp_id "if this is ok or stop the installation with" {
               if { $CHECK_ADMIN_USER_SYSTEM != 0 } {
                  puts $CHECK_OUTPUT "\n -->testsuite: sending >RETURN<"
                  if {$do_log_output == 1} {
                       puts "press RETURN"
                       gets stdin anykey
                  }
                  send "\n"
                  continue;
               } else {
                  set_error "-1" "install_execd - host $exec_host: tried to install not as root"
                  close_spawn_process $id; 
                  return;
               }
            }
 
     
            -i $sp_id "at system boot time" { 
               puts $CHECK_OUTPUT "\n -->testsuite: sending >n<"
               if {$do_log_output == 1} {
                    puts "press RETURN"
                    gets stdin anykey
               }
     
               send "n\n"
               continue;
            }
            -i $sp_id "Do you want to add a default queue for this host" { 
               puts $CHECK_OUTPUT "\n -->testsuite: sending >y<"
               if {$do_log_output == 1} {
                    puts "(5)press RETURN"
                    gets stdin anykey
               }
     
               send "y\n"
               continue;
            }

            -i $sp_id "This host is unknown on the qmaster host" {
               puts $CHECK_OUTPUT "\nHostname resolving problem"
               puts $CHECK_OUTPUT "*********************************************************************"
               puts $CHECK_OUTPUT "Hostname resolving problem - use a host alias file for host $exec_host" 
               puts $CHECK_OUTPUT "**********************************************************************"
               puts $CHECK_OUTPUT "installation will continue in 15 seconds ..."
               sleep 15
            }

            -i $sp_id "There is still no service for" {
               set_error "-1" "install_execd - no TCP/IP service available";
               close_spawn_process $id
               set do_stop 1
            }

            -i $sp_id "Check again" { 
               puts $CHECK_OUTPUT "\n -->testsuite: sending >n<"
               if {$do_log_output == 1} {
                    puts "press RETURN"
                    gets stdin anykey
               }
     
               send "n\n"
               continue;
            }
            -i $sp_id "Do you want to see previous screen about using" { 
               puts $CHECK_OUTPUT "\n -->testsuite: sending >n<"
               if {$do_log_output == 1} {
                    puts "press RETURN"
                    gets stdin anykey
               }
     
               send "n\n"
               continue;
            }
            -i $sp_id "Error:" {
               set_error "-1" "install_execd - $expect_out(0,string)"
               close_spawn_process $id; 
               return;
            }
            -i $sp_id "can't resolve hostname*\n" {
               set_error "-1" "install_execd - $expect_out(0,string)"
               close_spawn_process $id; 
               return;
            }            
  
            -i $sp_id "error:\n" {
               set_error "-1" "install_execd - $expect_out(0,string)"
               close_spawn_process $id; 
               return;
            }
            -i $sp_id "execution daemon installation is now completed" {
               close_spawn_process $id
               read_install_list
               lappend CORE_INSTALLED $exec_host
               write_install_list
               set do_stop 1
            }

            -i $sp_id "Hit <RETURN> to continue" { 
               puts $CHECK_OUTPUT "\n -->testsuite: sending >RETURN<"
               if {$do_log_output == 1} {
                    puts "press RETURN"
                    gets stdin anykey
               }
     
               send "\n"
               continue;
            }
            -i $sp_id default {
               set_error "-1" "install_execd - undefined behaiviour: $expect_out(buffer)"
               close_spawn_process $id; 
               return;
            }
         }
      }  ;# while 1
   }
}


#                                                             max. column:     |
#****** install_core_system/get_spool_dir() ******
# 
#  NAME
#     get_spool_dir -- ??? 
#
#  SYNOPSIS
#     get_spool_dir { host subdir } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#     host   - ??? 
#     subdir - ??? 
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc get_spool_dir {host subdir} {
   global CHECK_CONFIG_DIR CHECK_COMMD_PORT CHECK_OUTPUT CHECK_SPOOL_DIR_CONFIG_FILE
   global CHECK_USER CHECK_TESTSUITE_ROOT CHECK_DEFAULTS_FILE CHECK_TCL_SCRIPTFILE_DIR
   global CHECK_SCRIPT_FILE_DIR

   set spool_config $CHECK_CONFIG_DIR/$CHECK_SPOOL_DIR_CONFIG_FILE
   set spooldir ""

   puts "searching spooldir for host $host, type $subdir"
   if {[file exists $spool_config ]} {
      set f [open $spool_config r]
      while { [gets $f line] >= 0 } {
         if { [string first "#" $line ] == 0 } {
            continue 
         }  

         set string_tmp [lindex $line 0]
         puts $CHECK_OUTPUT "->$string_tmp"
         if {[string compare -nocase $host $string_tmp] == 0} {
            set spooldir "[lindex $line 1]"
            puts $CHECK_OUTPUT "->host $string_tmp has spool toplevel directory $spooldir"

            set result [ start_remote_tcl_prog $host $CHECK_USER "file_procedures.tcl" "cleanup_spool_dir" "$spooldir $subdir" ]
            set spooldir "$spooldir/$CHECK_COMMD_PORT/$subdir"
            puts $CHECK_OUTPUT $result
            puts $CHECK_OUTPUT $spooldir
#            gets stdin test
         }
      }
      close $f
   }
   return $spooldir
}



#                                                             max. column:     |
#****** install_core_system/setup_queues() ******
# 
#  NAME
#     setup_queues -- ??? 
#
#  SYNOPSIS
#     setup_queues { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc setup_queues {} {
  global CHECK_PRODUCT_ROOT CHECK_ARCH env check_errno
  global CHECK_CORE_EXECD CHECK_CORE_MASTER CHECK_CORE_PROCESSORS
  global check_use_installed_system CHECK_OUTPUT CHECK_PRODUCT_TYPE



    
  puts $CHECK_OUTPUT "\ncleaning up system"
  catch { exec "$CHECK_PRODUCT_ROOT/bin/$CHECK_ARCH/qdel" "-uall" } result

  set my_time [ expr ( [timestamp] + 100 ) ]
  while { [timestamp]< $my_time } {
      set my_jobs [ get_standard_job_info 1 0 1 ]
      foreach job_elem $my_jobs {
         puts $CHECK_OUTPUT $job_elem
      }
      if { [llength $my_jobs] <= 2 } {
         break
      }
      sleep 1
  } 


  puts $CHECK_OUTPUT "\nremoving ckpt objects ..."
  catch { exec "$CHECK_PRODUCT_ROOT/bin/$CHECK_ARCH/qconf" "-sckptl" } result
  if { [string first "no ckpt interface definition defined" $result] >= 0 } {
     puts $CHECK_OUTPUT "no ckpt interface definition defined"
  } else {
     foreach elem $result {
        puts $CHECK_OUTPUT "removing ckpt interface $elem."
        del_checkpointobj $elem 
     }
  }

  puts $CHECK_OUTPUT "\nremoving PE objects ..."
  catch { exec "$CHECK_PRODUCT_ROOT/bin/$CHECK_ARCH/qconf" "-spl" } result
  if { [string first "no parallel environment defined" $result] >= 0 } {
     puts $CHECK_OUTPUT "no parallel environment defined"
  } else {
     foreach elem $result {
        puts $CHECK_OUTPUT "removing PE $elem."
        del_pe $elem 
     }
  }

  puts $CHECK_OUTPUT "\nremoving calendars ..."
  catch { exec "$CHECK_PRODUCT_ROOT/bin/$CHECK_ARCH/qconf" "-scall" } result
  if { [string first "no calendar defined" $result] >= 0 } {
     puts $CHECK_OUTPUT "no calendar defined"
  } else {
     foreach elem $result {
        puts $CHECK_OUTPUT "removing calendar $elem."
        del_calendar $elem 
     }
  }


  if { [ string compare $CHECK_PRODUCT_TYPE "sgeee" ] == 0 } {
     puts $CHECK_OUTPUT "\nremoving project objects ..."
     catch { exec "$CHECK_PRODUCT_ROOT/bin/$CHECK_ARCH/qconf" "-sprjl" } result
     if { [string first "no project list defined" $result] >= 0 } {
        puts $CHECK_OUTPUT "no project list defined"
     } else {
        foreach elem $result {
           puts $CHECK_OUTPUT "removing project $elem."
           del_prj $elem 
        }
     }
  }

  if { $check_use_installed_system != 0 } {
     puts $CHECK_OUTPUT "\nremoving queues ..."
     catch { exec "$CHECK_PRODUCT_ROOT/bin/$CHECK_ARCH/qconf" "-sql" } result
     if { [string first "no queue defined" $result] >= 0 } {
        puts $CHECK_OUTPUT "no queue defined"
     } else {
        foreach elem $result {
           puts $CHECK_OUTPUT "removing queue $elem."
           del_queue $elem 
        }
     }

     puts $CHECK_OUTPUT "\nadding testsuite queues ..."

     foreach hostname $CHECK_CORE_EXECD {
        set q_param(qname)       "$hostname.q" 
        set q_param(hostname)    "$hostname"
        add_queue "q_param" 
     }
  }

  # for each execd - standard - queue do:
  # set load_avg to 5.0
  # set slots * 10
  # --------------------------------------------------------------
  foreach hostname $CHECK_CORE_EXECD {

#     slots = 10 * cpu count (for qstat test)

    


     set index [lsearch $CHECK_CORE_EXECD $hostname] 
     set slots_tmp [lindex $CHECK_CORE_PROCESSORS $index]

     if { $slots_tmp <= 0 } {
        set_error -2 "no slots for execd $hostname"
        return
     }

     set slots [ expr ( $slots_tmp * 10) ]
     set new_values(load_thresholds)       "np_load_avg=7.00"
     set new_values(migr_load_thresholds)  "np_load_avg=10.00"
     set new_values(qtype)                 "BATCH INTERACTIVE CHECKPOINTING PARALLEL"
     set new_values(slots)                 "$slots"

     set result [ set_queue "${hostname}.q" new_values ]
     switch -- $result { 
       -1 {
         set_error -1 "setup_queues - modify queue ${hostname}.q - got timeout"
       }
       0 {
         set_error 0 "setup_queues - no errors"
       }
       -100 {
         set_error -1 "setup_queues - could not modify queue"
       } 
     }
     if {$check_errno != 0} {
        return;
     }
  }
  wait_for_load_from_all_queues 300 
}

#                                                             max. column:     |
#****** install_core_system/setup_testcheckpointobject() ******
# 
#  NAME
#     setup_testcheckpointobject -- ??? 
#
#  SYNOPSIS
#     setup_testcheckpointobject { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc setup_testcheckpointobject {} {
  global CHECK_PRODUCT_ROOT CHECK_ARCH check_errno  CHECK_CORE_EXECD CHECK_CORE_MASTER

  set q_list ""
  foreach elem $CHECK_CORE_EXECD {
    set q_list "$q_list,${elem}.q"
  }
  set change(queue_list) "$q_list"
  set change(ckpt_name)  "testcheckpointobject"
   
  add_checkpointobj change
  set_error 0 "ok"
}


#                                                             max. column:     |
#****** install_core_system/setup_conf() ******
# 
#  NAME
#     setup_conf -- ??? 
#
#  SYNOPSIS
#     setup_conf { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc setup_conf {} {
  global CHECK_PRODUCT_ROOT CHECK_ARCH CHECK_CORE_EXECD CHECK_CORE_MASTER
  global CHECK_DEFAULT_DOMAIN CHECK_PRODUCT_TYPE


  # set finished_job in global config
  set params(finished_jobs) "0"  
  set params(load_report_time) "00:00:15"
  set params(default_domain) "$CHECK_DEFAULT_DOMAIN"
  set params(reschedule_unknown) "00:00:00"
  set params(loglevel) "log_info"

  if { $CHECK_PRODUCT_TYPE == "sgeee" } {
    set params(execd_params) "PTF_MIN_PRIORITY=20,PTF_MAX_PRIORITY=0"
  }

  set result [ set_config params ] 

  # for sgeee systems on irix: set execd params to
  # PTF_MIN_PRIORITY=40,PTF_MAX_PRIORITY=20
  if { $CHECK_PRODUCT_TYPE == "sgeee" } {
  set ptf_param(execd_params) "PTF_MIN_PRIORITY=40,PTF_MAX_PRIORITY=20"
    foreach i $CHECK_CORE_EXECD {
      switch -exact [resolve_arch $i] {
        irix6 {
          set_config ptf_param $i
        }
      }
    }
  }

  set_error 0 "ok"
}



#                                                             max. column:     |
#****** install_core_system/setup_mytestproject() ******
# 
#  NAME
#     setup_mytestproject -- ??? 
#
#  SYNOPSIS
#     setup_mytestproject { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc setup_mytestproject {} {
  global CHECK_PRODUCT_ROOT CHECK_ARCH env check_errno  CHECK_CORE_EXECD 
  global open_spawn_buffer CHECK_CORE_MASTER CHECK_PRODUCT_TYPE
 

  if { [ string compare $CHECK_PRODUCT_TYPE "sge" ] == 0 } {
     set_error 0 "setup_mytestproject - not possible for sge systems"
     return
  }

  # setup project "mytestproject"
  set prj_setup(name) "mytestproject"
  set result [ add_prj prj_setup ] 

  set_error 0 "ok"  
}


#                                                             max. column:     |
#****** install_core_system/setup_mytestpe() ******
# 
#  NAME
#     setup_mytestpe -- ??? 
#
#  SYNOPSIS
#     setup_mytestpe { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc setup_mytestpe {} {
  global CHECK_PRODUCT_ROOT CHECK_ARCH env check_errno  CHECK_CORE_EXECD CHECK_CORE_MASTER


  set q_list ""
  foreach elem $CHECK_CORE_EXECD {
    set q_list "$q_list,${elem}.q"
  }
 

  set change(pe_name) "mytestpe"
  set change(queue_list) $q_list
  set change(slots) "5"

  add_pe change
  set_error 0 "ok"
}



#                                                             max. column:     |
#****** install_core_system/setup_deadlineuser() ******
# 
#  NAME
#     setup_deadlineuser -- ??? 
#
#  SYNOPSIS
#     setup_deadlineuser { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc setup_deadlineuser {} {
  global CHECK_PRODUCT_ROOT CHECK_ARCH CHECK_CORE_EXECD CHECK_USER CHECK_CORE_MASTER
  global CHECK_PRODUCT_TYPE


  if { [ string compare $CHECK_PRODUCT_TYPE "sge" ] == 0 } { 
     set_error 0 "setup_deadlineuser - no sgeee system"
     return
  }

  # add user to deadlineusers 
  set vi_commands "" 
  lappend vi_commands ":%s/entries.*$/entries  $CHECK_USER/\n"

  set result [ handle_vi_edit "$CHECK_PRODUCT_ROOT/bin/$CHECK_ARCH/qconf" "-mu deadlineusers" $vi_commands "modified*\"deadlineusers\"*" ]
  if { $result == -1 } { add_proc_error "setup_deadlineuser" -1 "timeout error" }
  if { $result != 0 } { add_proc_error "setup_deadlineuser" -1 "could not add deadlineuser $CHECK_USER" }

  set_error 0 "ok"
}


#                                                             max. column:     |
#****** install_core_system/setup_schedconf() ******
# 
#  NAME
#     setup_schedconf -- ??? 
#
#  SYNOPSIS
#     setup_schedconf { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc setup_schedconf {} {
  global CHECK_PRODUCT_ROOT CHECK_ARCH env check_errno  CHECK_CORE_EXECD CHECK_USER CHECK_CORE_MASTER
  global CHECK_PRODUCT_TYPE 

  # reset_schedd_config has global error reporting
  reset_schedd_config 

  set_error 0 "ok"
}


#                                                             max. column:     |
#****** install_core_system/setup_default_calendars() ******
# 
#  NAME
#     setup_default_calendars -- ??? 
#
#  SYNOPSIS
#     setup_default_calendars { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc setup_default_calendars {} {
  global CHECK_PRODUCT_ROOT CHECK_ARCH env check_errno  CHECK_CORE_EXECD CHECK_USER CHECK_CORE_MASTER
  global CHECK_PRODUCT_TYPE 


  set calendar_param(calendar_name)          "always_suspend"              ;# always in calendar suspend
  set calendar_param(year)                   "NONE"
  set calendar_param(week)                   "mon-sun=0-24=suspended"

  set result [ add_calendar calendar_param ]
  if { $result != 0 } {
     set_error -1 "setup_default_calendards: result of add_default_calendars: $result"
     return
  }

  set calendar_param(calendar_name)          "always_disabled"              ;# always in calendar suspend
  set calendar_param(year)                   "NONE"
  set calendar_param(week)                   "mon-sun=0-24=off"

  set result [ add_calendar calendar_param ]
  if { $result != 0 } {
     set_error -1 "setup_default_calendards: result of add_default_calendars: $result"
     return
  }
 
  set_error 0 "setup_default_calendars - no errors" 
}

#                                                             max. column:     |
#****** install_core_system/setup_check_user_permissions() ******
# 
#  NAME
#     setup_check_user_permissions -- ??? 
#
#  SYNOPSIS
#     setup_check_user_permissions { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc setup_check_user_permissions {} {
  global CHECK_USER CHECK_FIRST_FOREIGN_SYSTEM_USER CHECK_SECOND_FOREIGN_SYSTEM_USER
  global CHECK_OUTPUT CHECK_CORE_EXECD CHECK_CORE_MASTER 
  global CHECK_TESTSUITE_ROOT CHECK_SCRIPT_FILE_DIR CHECK_ADMIN_USER_SYSTEM


  set time [timestamp]
  if { $CHECK_ADMIN_USER_SYSTEM == 0 } { 
     set user_list "root $CHECK_USER $CHECK_FIRST_FOREIGN_SYSTEM_USER $CHECK_SECOND_FOREIGN_SYSTEM_USER"
  } else {
     set user_list "$CHECK_USER"
  }
  foreach user $user_list {
     puts $CHECK_OUTPUT "\n----mask-check----\nuser: $user"
     set my_command ""
     foreach host $CHECK_CORE_EXECD {
        set execd_spooldir [get_execd_spool_dir $host]
        puts $CHECK_OUTPUT "checking execd spool directory on $host: \"$execd_spooldir\""
        set output [ start_remote_prog "$host" "$user" "cd" "$execd_spooldir ; cd $CHECK_TESTSUITE_ROOT/$CHECK_SCRIPT_FILE_DIR" ]
        if { $prg_exit_state != 0 } {
           set_error -1 "user $user has no read//exec permission to \"$execd_spooldir\" and \"$CHECK_TESTSUITE_ROOT/$CHECK_SCRIPT_FILE_DIR\" on host $host"
        }
     }
  }

  set master_spooldir [get_qmaster_spool_dir]
  puts $CHECK_OUTPUT "master spool directory on host $CHECK_CORE_MASTER: \"$master_spooldir\""
  foreach user $user_list {
      puts $CHECK_OUTPUT "checking master spool directory for user: \"$user\""
      set output [ start_remote_prog "$CHECK_CORE_MASTER" "$user" "cd" "$master_spooldir"  ]
      if { $prg_exit_state != 0 } {
         puts $CHECK_OUTPUT "--> E R R O R - user $user has no read//exec permission to $master_spooldir on host $CHECK_CORE_MASTER"
         set_error -1 "user $user has no read//exec permission to $master_spooldir on host $CHECK_CORE_MASTER"
      }
  }
  puts "runtime: [ expr ( [timestamp] - $time ) ]"
  get_version_info
  set_error 0 "ok"
}

#                                                             max. column:     |
#****** install_core_system/setup_inhouse_cluster() ******
# 
#  NAME
#     setup_inhouse_cluster -- ??? 
#
#  SYNOPSIS
#     setup_inhouse_cluster { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc setup_inhouse_cluster {} {
  global CHECK_PRODUCT_ROOT CHECK_ARCH env check_errno  CHECK_CORE_EXECD CHECK_USER CHECK_CORE_MASTER
  global CHECK_PRODUCT_TYPE
  global CHECK_OUTPUT

  # reset_schedd_config has global error reporting
  if {[lsearch -exact [info procs] "inhouse_cluster_post_install"] != -1} {
    puts $CHECK_OUTPUT "executing postinstall procedure for inhouse cluster"
    inhouse_cluster_post_install
  }

  set_error 0 "ok"
}



