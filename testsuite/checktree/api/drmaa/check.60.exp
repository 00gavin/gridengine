#!/vol2/TCL_TK/glinux/bin/expect
#___INFO__MARK_BEGIN__
##########################################################################
#
#  The Contents of this file are made available subject to the terms of
#  the Sun Industry Standards Source License Version 1.2
#
#  Sun Microsystems Inc., March, 2001
#
#
#  Sun Industry Standards Source License Version 1.2
#  =================================================
#  The contents of this file are subject to the Sun Industry Standards
#  Source License Version 1.2 (the "License"); You may not use this file
#  except in compliance with the License. You may obtain a copy of the
#  License at http://gridengine.sunsource.net/Gridengine_SISSL_license.html
#
#  Software provided under this License is provided on an "AS IS" basis,
#  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
#  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
#  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
#  See the License for the specific provisions governing your rights and
#  obligations concerning the Software.
#
#  The Initial Developer of the Original Code is: Sun Microsystems, Inc.
#
#  Copyright: 2001 by Sun Microsystems, Inc.
#
#  All Rights Reserved.
#
##########################################################################
#___INFO__MARK_END__

# define global variable in this namespace
global check_name 
global check_category
global check_description 
global check_needs
global check_functions 
global check_errno 
global check_errstr 
global check_highest_level
global check_init_level_procedure
global check_root_access_needs
global env

set check_root_access_needs "yes"


# define a level initialization procedure:
set check_init_level_procedure "drmaa_init_level"

# define test's name and run level descriptions
set check_name            "drmaa"
set check_category        "COMPATIBILITY SYSTEM VERIFIED"
set check_highest_level   202
set check_description(200)  "tests to verify DRMAA library: single threaded"
set check_description(201)  "tests to verify DRMAA library: multi threaded"
set check_description(202)  "tests to verify DRMAA library: additional interfaces"

# define test's dependencies
set check_needs           "init_core_system" 


# define test's procedure order
set check_functions ""
lappend check_functions "drmaa_setup"
lappend check_functions "drmaa_check"
lappend check_functions "drmaa_cleanup"

# this function is called each time before
# a new run level is started
proc drmaa_init_level {} {
  global CHECK_ACT_LEVEL


  # returning -1 causes disabling a certain runlevel
  # here per run level settings can be prepared
  switch -- $CHECK_ACT_LEVEL {
     "200" { 
           return 0
     } 
     "201" { 
           return 0
     } 
     "202" { 
           return -1
     } 
  } 
  return -1  ;# no other level else
}

# -------- local test procedures -----------------------------------------------

# change setup in a way allowing the next runlevel to start
proc drmaa_setup {} {
   global ts_config
  if { $ts_config(gridengine_version) == 53 } {
      set_error -3 "drmaa_setup - sge/ee version \"5.3\" doesn't support multi threading"
      return 1
   }


  set_error 0 "ok"
}

# here the actual test is done
proc drmaa_check {} {
   global ts_config
   global CHECK_OUTPUT CHECK_PRODUCT_ROOT CHECK_ARCH CHECK_ACTUAL_TEST_PATH
   global CHECK_HOST CHECK_CORE_EXECD CHECK_SOURCE_DIR CHECK_USER CHECK_CORE_MASTER
   global CHECK_ACT_LEVEL CHECK_SCRIPT_FILE_DIR CHECK_TESTSUITE_ROOT CHECK_DEBUG_LEVEL


   if { $ts_config(gridengine_version) == 53 } {
      set_error -3 "drmaa_check - sge/ee version \"5.3\" doesn't support multi threading"
      return 1
   }


   puts $CHECK_OUTPUT "product root is $CHECK_PRODUCT_ROOT"
   puts $CHECK_OUTPUT "arch is $CHECK_ARCH"
   puts $CHECK_OUTPUT "host is $CHECK_HOST"

   # must forbit reschedule on job exiting with 99 
   # must forbit job error upon job exiting with 100
   # otherwise drmaa_test ST_EXIT_STATUS never finishes
   set new_config(qmaster_params) "FORBID_RESCHEDULE FORBID_APPERROR"
   set_config new_config

   foreach host $CHECK_CORE_EXECD {

      set binary_arch "[resolve_arch $host]"

      switch -- $binary_arch {
         "sol-sparc" -
         "sol-sparc64" -
         "sol-x86" -
         "lx24-x86" -
         "lx26-x86" -
         "lx24-amd64" -
         "lx26-amd64" {
            puts $CHECK_OUTPUT "architecture $binary_arch is supported"
         }

         default {
            puts $CHECK_OUTPUT "DRMAA not supported for binary architecture $binary_arch"
            continue
         }
      }   

      set compile_arch_mt "[resolve_build_arch $host]"
      set binary_path "$CHECK_SOURCE_DIR/$compile_arch_mt"
      puts $CHECK_OUTPUT "host is $host has arch $compile_arch_mt mt bin path $binary_path"

      switch -- $CHECK_ACT_LEVEL {
         "200" { 
            # -- do all ST_DRMAA_CONTROL tests
            drmaa_test_failing_control_operations $host $binary_path

            # unset SGE_ROOT and try test_drmaa -h
            puts "starting single threaded test test_drmaa -h without SGE_ROOT"
            # set CHECK_DEBUG_LEVEL 2
            set test_output [ start_remote_prog $host $CHECK_USER "unset" "SGE_ROOT\n$binary_path/test_drmaa -h" \
                  prg_exit_state 500 0 "" 0 1]
            # set CHECK_DEBUG_LEVEL 0
            if { $prg_exit_state == 0 } {
               add_proc_error drmaa_check -1 "test_drmaa -h without SGE_ROOT must exit with unequal 0 at host $host"
               break
            }

            # the ST_INPUT_BECOMES_OUTPUT test
            drmaa_test_st_input_becomes_output $host $binary_path

            # -- tests without an argument
            foreach st_test "ST_MULT_INIT ST_MULT_EXIT ST_SUPPORTED_ATTR ST_SUPPORTED_VATTR ST_VERSION \
               ST_DRM_SYSTEM ST_CONTACT ST_EMPTY_SESSION_WAIT ST_EMPTY_SESSION_SYNCHRONIZE_DISPOSE \
               ST_EMPTY_SESSION_SYNCHRONIZE_NODISPOSE ST_DRMAA_IMPL" {
               
               puts "starting single threaded test $st_test"
               drmaa_test $host $binary_path $st_test ""
            }
           
            # -- tests to ensure control operations on session without jobs result in DRMAA_ERRNO_SUCCESS 
            foreach control_op "DRMAA_CONTROL_SUSPEND DRMAA_CONTROL_RESUME DRMAA_CONTROL_HOLD \
                  DRMAA_CONTROL_RELEASE DRMAA_CONTROL_TERMINATE" {
               puts "starting single threaded test ST_EMPTY_SESSION_CONTROL $control_op"
               drmaa_test $host $binary_path ST_EMPTY_SESSION_CONTROL "$control_op"
            }

            # -- tests with a <sleeper_job> argument
            foreach st_test "ST_SUBMIT_WAIT ST_BULK_SUBMIT_WAIT ST_BULK_SINGLESUBMIT_WAIT_INDIVIDUAL \
                ST_SUBMITMIXTURE_SYNC_ALL_DISPOSE ST_SUBMITMIXTURE_SYNC_ALL_NODISPOSE \
                ST_SUBMITMIXTURE_SYNC_ALLIDS_DISPOSE ST_SUBMITMIXTURE_SYNC_ALLIDS_NODISPOSE \
                ST_SUBMIT_PAUSE_SUBMIT_SYNC ST_INPUT_FILE_FAILURE ST_OUTPUT_FILE_FAILURE \
                ST_ERROR_FILE_FAILURE ST_SUBMIT_SUSPEND_RESUME_WAIT \
                ST_SUBMIT_POLLING_WAIT_TIMEOUT ST_SUBMIT_POLLING_WAIT_ZEROTIMEOUT \
                ST_SUBMIT_POLLING_SYNCHRONIZE_TIMEOUT ST_SUBMIT_POLLING_SYNCHRONIZE_ZEROTIMEOUT"  {
               puts "starting single threaded test $st_test"
               drmaa_test $host $binary_path $st_test $CHECK_PRODUCT_ROOT/examples/jobs/sleeper.sh
            }

            # -- tests with a <exit_arg_job> argument
            foreach ste_test "ST_EXIT_STATUS ST_USAGE_CHECK" {
               puts "starting single threaded test $ste_test"
               drmaa_test $host $binary_path $ste_test $CHECK_TESTSUITE_ROOT/$CHECK_SCRIPT_FILE_DIR/exit.sh
            }


            # -- tests with <exit_arg_job> and <email_addr> arguments
            # need to add the entry "test.cat -N ExitTest -h" to qtask file
            # need to add "-m a" to sge_request file 
            # test assumes job do run at submission host
            # puts "starting single threaded test ST_ATTRIBUTE_CHECK"
            # drmaa_test $host $binary_path ST_ATTRIBUTE_CHECK $CHECK_TESTSUITE_ROOT/$CHECK_SCRIPT_FILE_DIR/exit.sh "$CHECK_USER@localhost"
            # need to remove "-m a" from sge_request file 
            # need to remove entry "test.cat -N ExitTest -h" to users .qtask file
            # -- 
         } 
         "201" { 
            # all MT tests need a sleeper job as argument
            # 
            # test broken for MT_SUBMIT_BEFORE_INIT_WAIT due to #988
            foreach mt_test "MT_SUBMIT_WAIT MT_EXIT_DURING_SUBMIT \
                             MT_SUBMIT_MT_WAIT MT_EXIT_DURING_SUBMIT_OR_WAIT" {
               puts "starting multi threaded test $mt_test"
               drmaa_test $host $binary_path $mt_test $CHECK_PRODUCT_ROOT/examples/jobs/sleeper.sh
            }
         } 
         "202" { 
            # shutdown qmaster
            shutdown_master_and_scheduler $CHECK_CORE_MASTER [get_qmaster_spool_dir] 

            # this test must fail when qmaster is down
            set test_output [start_remote_prog $host $CHECK_USER $binary_path/test_drmaa ST_SUBMIT_WAIT ]

            puts $CHECK_OUTPUT "exit status was $prg_exit_state"
            puts $CHECK_OUTPUT "output was\n$test_output"

            if { $prg_exit_state == 0 } {
               add_proc_error drmaa_check -1 "test_drmaa ST_SUBMIT_WAIT failed at host $host"
            }
            # restart qmaster
            startup_qmaster 
         } 
      } 
   }

   # undo configuration changes that were made for this test
   set new_config(qmaster_params) "none"
   set_config new_config

   set_error 0 "ok"
}

# undo what we've done in drmaa_setup
proc drmaa_cleanup  {} {
   global ts_config
   if { $ts_config(gridengine_version) == 53 } {
      set_error -3 "drmaa_cleanup - sge/ee version \"5.3\" doesn't support multi threading"
      return 1
   }

   set_error 0 "ok"
}

#                                                             max. column:     |
#
#****** drmaa_test/drmaa_test() ******
#  NAME
#     drmaa_test() -- generic drmaa test
#
#  SYNOPSIS
#     drmaa_test { test_name host binary_path arguments }
#
#  FUNCTION
#     This procedure starts test_drmaa with the corresponding arguemnts.
#     Exit status of test_drmaa must always be 0 otherwise test has failed.
#
#  INPUTS
#     host                       - The host where 'test_drmaa' is run
#     binary_path                - The path where 'test_drmaa' can be found
#     test_name                  - The name of a test. To get a complete list
#                                  of all test cases run 'test_drmaa' without args
#     arguments                  - Additional arguments needed for the test case.
#     user                       - Optional argument if test shall be run as user 
#                                  other than CHECK_USER
#
#  EXAMPLE
#     drmaa_test ST_SUBMIT_WAIT ori <source-path>/SOLARIS86/ $SGE_ROOT/examples/jobs/sleeper.sh
#*******************************
#
proc drmaa_test { host binary_path test_name arguments {user ""} } {
   global CHECK_OUTPUT CHECK_USER

   if {$user == ""} { 
      set user $CHECK_USER
   }

   puts $CHECK_OUTPUT "$binary_path/test_drmaa $test_name $arguments"
   set test_output [ start_remote_prog $host $user $binary_path/test_drmaa "$test_name $arguments" prg_exit_state 500 ]

   puts $CHECK_OUTPUT "exit status was $prg_exit_state"
   puts $CHECK_OUTPUT "output was\n$test_output"

   if { $prg_exit_state != 0 } {
      add_proc_error drmaa_check -1 "$binary_path/test_drmaa $test_name $arguments failed at host $host"
   }
}

#                                                             max. column:     |
#
#****** drmaa_test/drmaa_test_st_input_becomes_output() ******
#  NAME
#     drmaa_test_st_input_becomes_output() -- Test to ensure 
#      input/output is treated correctly by DRMAA
#
#  SYNOPSIS
#     drmaa_test_st_input_becomes_output { host binary_path }
#
#  FUNCTION
#     This test creates unique file names for job input/output. These
#     file names are passed to the test_drmaa ST_INPUT_BECOMES_OUTPUT.
#     After test_drmaa ST_INPUT_BECOMES_OUTPUT was run the files are deleted.
#
#  INPUTS
#     host                       - The host where 'test_drmaa' is run
#     binary_path                - The path where 'test_drmaa' can be found
#*******************************
#
proc drmaa_test_st_input_becomes_output { host binary_path } {
   global CHECK_OUTPUT CHECK_USER

   # prepare input file
   set input_file [get_tmp_file_name]
  
   # prepare output file name
   set output_file [get_tmp_file_name]

   puts $CHECK_OUTPUT "$binary_path/test_drmaa ST_INPUT_BECOMES_OUTPUT $input_file $output_file"
   # wait_for_remote_file $host $CHECK_USER $input_file 500

   # run job
   set test_output [start_remote_prog $host $CHECK_USER $binary_path/test_drmaa "ST_INPUT_BECOMES_OUTPUT $input_file $output_file" prg_exit_state 500]

   puts $CHECK_OUTPUT "exit status was $prg_exit_state"
   puts $CHECK_OUTPUT "output was\n$test_output"

   # remove input and output file
   file delete "$input_file"
   file delete "$output_file"

   if { $prg_exit_state != 0 } {
      add_proc_error drmaa_check -1 "test_drmaa ST_INPUT_BECOMES_OUTPUT failed at host $host"
   }
}

#                                                             max. column:     |
#
#****** drmaa_test/drmaa_test_failing_control_operations() ******
#  NAME
#     drmaa_test_failing_control_operations() -- Test to ensure 
#      DRMAA operations behave correctly when they operate on other 
#      users jobs trying input/output is treated correctly by DRMAA
#
#  SYNOPSIS
#     drmaa_test_failing_control_operations { host binary_path }
#
#  FUNCTION
#     This test creates unique file names for job input/output. These
#     file names are passed to the test_drmaa ST_INPUT_BECOMES_OUTPUT.
#     After test_drmaa ST_INPUT_BECOMES_OUTPUT was run the files are deleted.
#
#  INPUTS
#     host                       - The host where 'test_drmaa' is run
#     binary_path                - The path where 'test_drmaa' can be found
#*******************************
#
proc drmaa_test_failing_control_operations { host binary_path } {
   global CHECK_OUTPUT CHECK_FIRST_FOREIGN_SYSTEM_USER CHECK_SECOND_FOREIGN_SYSTEM_USER 
   global CHECK_HOST CHECK_PRODUCT_ROOT

   #
   # submit sequential job in hold state as user1 
   #

   puts "going to submit a job as user $CHECK_FIRST_FOREIGN_SYSTEM_USER"
   set job_id [ submit_job "-o /dev/null -j y -h $CHECK_PRODUCT_ROOT/examples/jobs/sleeper.sh 15" 1 60 "" $CHECK_FIRST_FOREIGN_SYSTEM_USER ]
   puts "submitted job $job_id as user $CHECK_FIRST_FOREIGN_SYSTEM_USER"

   # ensure control operations forbidden for user2 result in a DRMAA_ERRNO_AUTH_FAILURE 
   # test broken for DRMAA_CONTROL_TERMINATE operation due to #979
   foreach control_op "DRMAA_CONTROL_SUSPEND DRMAA_CONTROL_RESUME DRMAA_CONTROL_HOLD DRMAA_CONTROL_RELEASE" {
      puts "starting single threaded test ST_DRMAA_CONTROL $control_op DRMAA_ERRNO_AUTH_FAILURE"
      drmaa_test $host $binary_path ST_DRMAA_CONTROL "$control_op DRMAA_ERRNO_AUTH_FAILURE $job_id" $CHECK_SECOND_FOREIGN_SYSTEM_USER
   }

   # ensure suspend/unsuspend as user1 on job in hold state returns intended errno value
   drmaa_test $host $binary_path ST_DRMAA_CONTROL "DRMAA_CONTROL_SUSPEND DRMAA_ERRNO_SUSPEND_INCONSISTENT_STATE $job_id" $CHECK_FIRST_FOREIGN_SYSTEM_USER
   drmaa_test $host $binary_path ST_DRMAA_CONTROL "DRMAA_CONTROL_RESUME  DRMAA_ERRNO_RESUME_INCONSISTENT_STATE $job_id" $CHECK_FIRST_FOREIGN_SYSTEM_USER

   # delete job as user1
   set result [ run_command_as_user "$CHECK_HOST" "$CHECK_FIRST_FOREIGN_SYSTEM_USER" "qdel" "$job_id" 1 ]
   puts $CHECK_OUTPUT "qdel_output = \n$result"
    
   # ensure control operation isused as user1 on no longer existing job results in a DRMAA_ERRNO_INVALID_JOB 
   foreach control_op "DRMAA_CONTROL_SUSPEND DRMAA_CONTROL_RESUME DRMAA_CONTROL_HOLD \
         DRMAA_CONTROL_RELEASE DRMAA_CONTROL_TERMINATE" {
      puts "starting single threaded test ST_DRMAA_CONTROL $control_op DRMAA_ERRNO_INVALID_JOB"
      drmaa_test $host $binary_path ST_DRMAA_CONTROL "$control_op DRMAA_ERRNO_INVALID_JOB $job_id" $CHECK_FIRST_FOREIGN_SYSTEM_USER
   }

   #
   # submit job array in hold state as user1 
   #

   puts "going to submit a job as user $CHECK_FIRST_FOREIGN_SYSTEM_USER"
   set job_id [ submit_job "-t 1-2 -o /dev/null -j y -h $CHECK_PRODUCT_ROOT/examples/jobs/sleeper.sh 15" 1 60 "" $CHECK_FIRST_FOREIGN_SYSTEM_USER ]
   puts "submitted job $job_id as user $CHECK_FIRST_FOREIGN_SYSTEM_USER"

   # ensure control operations forbidden for user2 result in a DRMAA_ERRNO_AUTH_FAILURE 
   # test broken for DRMAA_CONTROL_TERMINATE operation due to #979
   foreach control_op "DRMAA_CONTROL_SUSPEND DRMAA_CONTROL_RESUME DRMAA_CONTROL_HOLD \
         DRMAA_CONTROL_RELEASE" {
      puts "starting single threaded test ST_DRMAA_CONTROL $control_op DRMAA_ERRNO_AUTH_FAILURE"
      drmaa_test $host $binary_path ST_DRMAA_CONTROL "$control_op DRMAA_ERRNO_AUTH_FAILURE $job_id.1" $CHECK_SECOND_FOREIGN_SYSTEM_USER
      drmaa_test $host $binary_path ST_DRMAA_CONTROL "$control_op DRMAA_ERRNO_AUTH_FAILURE $job_id.2" $CHECK_SECOND_FOREIGN_SYSTEM_USER
   }

   # ensure suspend/unsuspend as user1 on job in hold state returns intended errno value
   drmaa_test $host $binary_path ST_DRMAA_CONTROL "DRMAA_CONTROL_SUSPEND DRMAA_ERRNO_SUSPEND_INCONSISTENT_STATE $job_id.1" $CHECK_FIRST_FOREIGN_SYSTEM_USER
   drmaa_test $host $binary_path ST_DRMAA_CONTROL "DRMAA_CONTROL_SUSPEND DRMAA_ERRNO_SUSPEND_INCONSISTENT_STATE $job_id.2" $CHECK_FIRST_FOREIGN_SYSTEM_USER
   drmaa_test $host $binary_path ST_DRMAA_CONTROL "DRMAA_CONTROL_RESUME  DRMAA_ERRNO_RESUME_INCONSISTENT_STATE $job_id.1" $CHECK_FIRST_FOREIGN_SYSTEM_USER
   drmaa_test $host $binary_path ST_DRMAA_CONTROL "DRMAA_CONTROL_RESUME  DRMAA_ERRNO_RESUME_INCONSISTENT_STATE $job_id.2" $CHECK_FIRST_FOREIGN_SYSTEM_USER

   # delete job as user1
   set result [ run_command_as_user "$CHECK_HOST" "$CHECK_FIRST_FOREIGN_SYSTEM_USER" "qdel" "$job_id" 1 ]
   puts $CHECK_OUTPUT "qdel_output = \n$result"
    
   # ensure control operation isused as user1 on no longer existing job results in a DRMAA_ERRNO_INVALID_JOB 
   foreach control_op "DRMAA_CONTROL_SUSPEND DRMAA_CONTROL_RESUME DRMAA_CONTROL_HOLD \
         DRMAA_CONTROL_RELEASE DRMAA_CONTROL_TERMINATE" {
      puts "starting single threaded test ST_DRMAA_CONTROL $control_op DRMAA_ERRNO_INVALID_JOB"
      drmaa_test $host $binary_path ST_DRMAA_CONTROL "$control_op DRMAA_ERRNO_INVALID_JOB $job_id.1" $CHECK_FIRST_FOREIGN_SYSTEM_USER
      drmaa_test $host $binary_path ST_DRMAA_CONTROL "$control_op DRMAA_ERRNO_INVALID_JOB $job_id.2" $CHECK_FIRST_FOREIGN_SYSTEM_USER
   }
}
