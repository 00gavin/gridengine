#!/vol2/TCL_TK/glinux/bin/expect
# global variables ... (defined in main check routine, but you can use it)
#
# Define the global veriables to give them back
#___INFO__MARK_BEGIN__
##########################################################################
#
#  The Contents of this file are made available subject to the terms of
#  the Sun Industry Standards Source License Version 1.2
#
#  Sun Microsystems Inc., March, 2001
#
#
#  Sun Industry Standards Source License Version 1.2
#  =================================================
#  The contents of this file are subject to the Sun Industry Standards
#  Source License Version 1.2 (the "License"); You may not use this file
#  except in compliance with the License. You may obtain a copy of the
#  License at http://gridengine.sunsource.net/Gridengine_SISSL_license.html
#
#  Software provided under this License is provided on an "AS IS" basis,
#  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
#  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
#  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
#  See the License for the specific provisions governing your rights and
#  obligations concerning the Software.
#
#  The Initial Developer of the Original Code is: Sun Microsystems, Inc.
#
#  Copyright: 2001 by Sun Microsystems, Inc.
#
#  All Rights Reserved.
#
##########################################################################
#___INFO__MARK_END__
global check_name check_description check_needs check_functions check_errno check_errstr 
global check_category
set check_name         "ckpt_migration_test"
set check_category     "COMPATIBILITY SYSTEM L10N"
set check_description(0)  "MPI based parallel application with checkpointing and event based migration"
set check_needs        "init_core_system"                   ;# dependencies of this check (name of other check)

set check_functions    ""           ;# functions to call (in order)
lappend check_functions "setup_queues"
lappend check_functions "setup_pe"
lappend check_functions "setup_checkpointing"
lappend check_functions "start_checkpoint_job"
lappend check_functions "check_slave_migration"
lappend check_functions "check_master_migration"
lappend check_functions "check_calendarsuspend_master_migration"
lappend check_functions "check_calendarsuspend_slave_migration"
lappend check_functions "check_calendardisable_migration_on_slavequeue_suspend"
lappend check_functions "check_calendardisable_migration_on_slavequeue_threshold_suspend"
lappend check_functions "clean_up_checkpoint_job"
lappend check_functions "clean_up_checkpointing"
lappend check_functions "clean_up_pe"
lappend check_functions "clean_up_queues"


#global test variables
global checkpoint_host1 checkpoint_host2 q1 q2 q3 q4 migration_pe_name migration_ckpt_name CHECK_CORE_EXECD
global checkpoint_job_id 

set checkpoint_host1 [lindex $CHECK_CORE_EXECD 0] 
set checkpoint_host2 [lindex $CHECK_CORE_EXECD 1]
set q1 "ckpt_mig-1"
set q2 "ckpt_mig-2"
set q3 "ckpt_mig-3"
set q4 "ckpt_mig-4"
set migration_pe_name "ckpt_mig_pe"
set migration_ckpt_name "ckpt_mig_ckptobj"
set checkpoint_job_id -1


proc calendardisable_queue { queue_list } {
   global CHECK_PRODUCT_ROOT CHECK_ARCH
   set return_value [mqattr "calendar" "always_disabled" "$queue_list"]
   return $return_value
}

proc calendarclear_queue { queue_list } {
   global CHECK_PRODUCT_ROOT CHECK_ARCH
   set return_value [mqattr "calendar" "NONE" "$queue_list"]
   return $return_value
}

proc calendarsuspend_queue { queue_list } {
   global CHECK_PRODUCT_ROOT CHECK_ARCH
   set return_value [mqattr "calendar" "always_suspend" "$queue_list"]
   return $return_value
}

proc threshold_suspend_queue { queue_list } {
   set return_value [mqattr "suspend_thresholds" "np_load_avg=-1" "$queue_list"]
   return $return_value
}

proc threshold_suspend_queue_clear { queue_list } {
   set return_value [mqattr "suspend_thresholds" "NONE" "$queue_list"]
   return $return_value
}


proc start_checkpoint_job {} {
   global CHECK_ACTUAL_TEST_PATH checkpoint_job_id CHECK_OUTPUT
   
   if { [check_test_dependencies] != 0 } {
     return
  }


   # delete migratewascalled - file
   file delete $CHECK_ACTUAL_TEST_PATH/migratewascalled

   set jobargs "-pe ckpt_mig_pe 2 -cwd -ckpt ckpt_mig_ckptobj checkpt_job.sh"
   set result [ submit_job $jobargs 1 30 "" "" $CHECK_ACTUAL_TEST_PATH ]
   set checkpoint_job_id $result 
   set result [ wait_for_jobstart $checkpoint_job_id "DEMO" 300]

   set_error 0 "ok"  
}

proc check_slave_migration {} {
   global checkpoint_job_id CHECK_OUTPUT CHECK_ACTUAL_TEST_PATH


   if { [check_test_dependencies] != 0 } {
     return
   }


   # wait for job to start running
   wait_for_end_of_transfer $checkpoint_job_id 100

   # find out where the slave task is running
   set slave_queue [slave_queue_of $checkpoint_job_id]

   # now suspend the slave queue
   suspend_queue $slave_queue

   # wait for migration command
   wait_for_file "$CHECK_ACTUAL_TEST_PATH/migratewascalled" 300

   # wait for job to get in pending state
   wait_for_jobpending $checkpoint_job_id "DEMO" 300

   # delete migratewascalled - file
   delete_file "$CHECK_ACTUAL_TEST_PATH/migratewascalled"

   # now unsuspend queue again
   unsuspend_queue $slave_queue

   # wait for restart  
   wait_for_jobstart $checkpoint_job_id "DEMO" 300

   set_error 0 "ok"  
}


#                                                             max. column:     |
#****** migration/check_calendardisable_migration_on_slavequeue_suspend() ******
# 
#  NAME
#     check_calendardisable_migration_on_slavequeue_suspend -- ??? 
#
#  SYNOPSIS
#     check_calendardisable_migration_on_slavequeue_suspend { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc check_calendardisable_migration_on_slavequeue_suspend {} {

   global checkpoint_job_id CHECK_OUTPUT CHECK_ACTUAL_TEST_PATH q1 q2

   if { [check_test_dependencies] != 0 } {
     return
   }


   # wait for job to start running
   wait_for_end_of_transfer $checkpoint_job_id 100

   

   # find out where the slave task is running
   set slave_queue [slave_queue_of $checkpoint_job_id]


   calendardisable_queue "$q1 $q2"  ;# pass list of queues to procedure
  
   # now suspend the slave queue
   suspend_queue $slave_queue

   wait_for_file "$CHECK_ACTUAL_TEST_PATH/migratewascalled" 300

   wait_for_jobpending $checkpoint_job_id "DEMO" 300

   # delete migratewascalled - file
   delete_file "$CHECK_ACTUAL_TEST_PATH/migratewascalled"

   # now unsuspend queue again
   unsuspend_queue $slave_queue

   set result [calendarclear_queue "$q1 $q2"]  ;# pass list of queues to procedure
  
   # wait for restart  
   wait_for_jobstart $checkpoint_job_id "DEMO" 300
 
   set_error 0 "check_calendardisable_migration_on_slavequeue_suspend  - no errors"  
}

#                                                             max. column:     |
#****** migration/check_calendardisable_migration_on_slavequeue_threshold_suspend() ******
# 
#  NAME
#     check_calendardisable_migration_on_slavequeue_threshold_suspend -- ??? 
#
#  SYNOPSIS
#     check_calendardisable_migration_on_slavequeue_threshold_suspend { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc check_calendardisable_migration_on_slavequeue_threshold_suspend {} {

   global checkpoint_job_id CHECK_OUTPUT CHECK_ACTUAL_TEST_PATH q1 q2

   if { [check_test_dependencies] != 0 } {
     return
   }


   # wait for job to start running
   wait_for_end_of_transfer $checkpoint_job_id 100


   # find out where the slave task is running
   set slave_queue [slave_queue_of $checkpoint_job_id]
  
   calendardisable_queue "$q1 $q2"  ;# pass list of queues to procedure
  
   # now threshold suspend the slave queue
   threshold_suspend_queue $slave_queue

   wait_for_file "$CHECK_ACTUAL_TEST_PATH/migratewascalled" 300

   wait_for_jobpending $checkpoint_job_id "DEMO" 300

   # delete migratewascalled - file
   delete_file "$CHECK_ACTUAL_TEST_PATH/migratewascalled"

   # now unsuspend queue again
   threshold_suspend_queue_clear $slave_queue

   calendarclear_queue "$q1 $q2"  ;# pass list of queues to procedure
  
   # wait for restart  
   wait_for_jobstart $checkpoint_job_id "DEMO" 300
 
   set_error 0 "check_calendardisable_migration_on_slavequeue_threshold_suspend  - no errors"  
}


#                                                             max. column:     |
#****** migration/check_master_migration() ******
# 
#  NAME
#     check_master_migration -- ??? 
#
#  SYNOPSIS
#     check_master_migration { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc check_master_migration {} {
   
   global checkpoint_job_id CHECK_OUTPUT CHECK_ACTUAL_TEST_PATH

   if { [check_test_dependencies] != 0 } {
     return
   }

    # wait for job to start running
   wait_for_end_of_transfer $checkpoint_job_id 100

   

   # find out where the master task is running
   set master_queue [master_queue_of $checkpoint_job_id]
   
   # now suspend the master queue
   suspend_queue $master_queue

   # wait for migration command

   wait_for_file "$CHECK_ACTUAL_TEST_PATH/migratewascalled" 300

   # check if job is now pending
   set wasok [wait_for_jobpending $checkpoint_job_id "DEMO" 300] 

   # delete migratewascalled - file
   delete_file "$CHECK_ACTUAL_TEST_PATH/migratewascalled"

   # now unsuspend queue again
   unsuspend_queue $master_queue

   # wait for restart  
   wait_for_jobstart $checkpoint_job_id "DEMO" 300


   set_error 0 "check_master_migration  - no errors"  
}


#                                                             max. column:     |
#****** migration/check_calendarsuspend_master_migration() ******
# 
#  NAME
#     check_calendarsuspend_master_migration -- ??? 
#
#  SYNOPSIS
#     check_calendarsuspend_master_migration { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc check_calendarsuspend_master_migration {} {
   global checkpoint_job_id CHECK_ACTUAL_TEST_PATH CHECK_OUTPUT

   if { [check_test_dependencies] != 0 } {
     return
   }
   # wait for job to start running
   wait_for_end_of_transfer $checkpoint_job_id 100


   # find out where the master task is running
   set master_queue [master_queue_of $checkpoint_job_id]

   # now calendarsuspend the master queue
   calendarsuspend_queue $master_queue
   
   # wait for migration command
   wait_for_file "$CHECK_ACTUAL_TEST_PATH/migratewascalled" 300

   # check if job is now pending
   wait_for_jobpending $checkpoint_job_id "DEMO" 300

   # delete migratewascalled - file
   delete_file "$CHECK_ACTUAL_TEST_PATH/migratewascalled"

   # now calendar un-suspend the master queue
   calendarclear_queue $master_queue
   
   # wait for restart  
   wait_for_jobstart $checkpoint_job_id "DEMO" 300

   set_error 0 "check_calendarsuspend_master_migration  - no errors"  
}


#                                                             max. column:     |
#****** migration/check_calendarsuspend_slave_migration() ******
# 
#  NAME
#     check_calendarsuspend_slave_migration -- ??? 
#
#  SYNOPSIS
#     check_calendarsuspend_slave_migration { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc check_calendarsuspend_slave_migration {} {
   global checkpoint_job_id CHECK_ACTUAL_TEST_PATH CHECK_OUTPUT


   if { [check_test_dependencies] != 0 } {
     return
   }

   # wait for job to start running
   wait_for_end_of_transfer $checkpoint_job_id 100


   # find out where the slave task is running
   set slave_queue [slave_queue_of $checkpoint_job_id]

   # now calendarsuspend the slave queue
   calendarsuspend_queue $slave_queue
   
   # wait for migration command
   wait_for_file "$CHECK_ACTUAL_TEST_PATH/migratewascalled" 300

   # check if job is now pending
   wait_for_jobpending $checkpoint_job_id "DEMO" 300

   # delete migratewascalled - file
   delete_file "$CHECK_ACTUAL_TEST_PATH/migratewascalled"

   # now calendar un-suspend the slave queue
   set queue_param(calendar)                  "NONE" 
   set_queue $slave_queue queue_param

   # wait for restart  
   wait_for_jobstart $checkpoint_job_id "DEMO" 300

   set_error 0 "check_calendarsuspend_slave_migration  - no errors"  
}



#                                                             max. column:     |
#****** migration/clean_up_checkpoint_job() ******
# 
#  NAME
#     clean_up_checkpoint_job -- ??? 
#
#  SYNOPSIS
#     clean_up_checkpoint_job { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc clean_up_checkpoint_job {} {
   global checkpoint_job_id CHECK_ACTUAL_TEST_PATH CHECK_OUTPUT

   if { [check_test_dependencies] != 0 } {
     return
   }


   if { $checkpoint_job_id < 0 } {
      set_error -1 "cleanup_checkpoint_job - no checkpoint job started" 
      return
   }

   # wait for job to start running
   wait_for_end_of_transfer $checkpoint_job_id 60
   sleep 2

   set result [ delete_job $checkpoint_job_id 1]
   
   if { $result != 0 } {
      set_error -1 "cleanup_checkpoint_job - could not delete job $checkpoint_job_id" 
      return
   }

   set files [ glob -nocomplain $CHECK_ACTUAL_TEST_PATH/DEMO.* ] 
  
   foreach elem $files { 
      delete_file $elem
   }

   set_error 0 "cleanup_checkpoint_job - no errors" 
}

#                                                             max. column:     |
#****** migration/setup_checkpointing() ******
# 
#  NAME
#     setup_checkpointing -- ??? 
#
#  SYNOPSIS
#     setup_checkpointing { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc setup_checkpointing {} {
  global checkpoint_host1 checkpoint_host2 q1 q2 q3 q4 migration_ckpt_name CHECK_ACTUAL_TEST_PATH

  if { [check_test_dependencies] != 0 } {
     return
  }


  set ckpt_param(ckpt_name)         "$migration_ckpt_name"
  set ckpt_param(interface)         "CPR"
  set ckpt_param(ckpt_command)      "none"
  set ckpt_param(migr_command)      "$CHECK_ACTUAL_TEST_PATH/migrate.sh"
  set ckpt_param(restart_command)   "none"
  set ckpt_param(clean_command)     "none"
  set ckpt_param(ckpt_dir)          "/tmp"
  set ckpt_param(queue_list)        "$q1 $q2"
  set ckpt_param(signal)            "none"
  set ckpt_param(when)              "sx"

  set result [ add_checkpointobj "ckpt_param" ]
  if { $result != 0 } {
     set_error -1 "setup_checkpointing - could not add checkpoint ENV $migration_ckpt_name (result of add_checkpointobj: $result)"
     return
  }
  set_error 0 "setup_checkpointing - no errors" 
}

#                                                             max. column:     |
#****** migration/clean_up_checkpointing() ******
# 
#  NAME
#     clean_up_checkpointing -- ??? 
#
#  SYNOPSIS
#     clean_up_checkpointing { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc clean_up_checkpointing {} {
  global checkpoint_host1 checkpoint_host2 q1 q2 q3 q4 migration_ckpt_name

   if { [check_test_dependencies] != 0 } {
     return
   }


  set not_deleted ""
  set error 0

  set result [ del_checkpointobj $migration_ckpt_name ] 
  if { $result != 0 } {
    set not_deleted "$not_deleted $result"
    incr error 1
  }

  if { $error != 0 } {
     set_error -1 "clean_up_checkpointing - could not delete pe(s) $not_deleted"
  }

  set_error 0 "clean_up_checkpointing - no errors"
}



#****** check/check_test_dependencies() ****************************************
#  NAME
#     check_test_dependencies() -- check dependencies for this test
#
#  SYNOPSIS
#     check_test_dependencies { } 
#
#  FUNCTION
#     check if test can run
#*******************************************************************************
proc check_test_dependencies { } {
   global CHECK_CORE_EXECD

   if { [ llength $CHECK_CORE_EXECD ] < 2 } {
     set_error -3 "setup_queues - need 2 execution daemons"
     return 1
   }
   return 0
}

#                                                             max. column:     |
#****** migration/setup_pe() ******
# 
#  NAME
#     setup_pe -- ??? 
#
#  SYNOPSIS
#     setup_pe { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc setup_pe {} {
  global checkpoint_host1 checkpoint_host2 q1 q2 q3 q4 migration_pe_name CHECK_CORE_EXECD
  
  if { [check_test_dependencies] != 0 } {
     return
  }

  

  set pe_param(pe_name)           "$migration_pe_name"
  set pe_param(queue_list)        "$q1 $q2"
  set pe_param(slots)             "2"
  set pe_param(user_lists)        "NONE"
  set pe_param(xuser_lists)       "NONE"
  set pe_param(start_proc_args)   "/bin/true"  
  set pe_param(stop_proc_args)    "/bin/true"
  set pe_param(allocation_rule)   "1" 
  set pe_param(control_slaves)    "FALSE"
  set pe_param(job_is_first_task) "TRUE"

  set result [ add_pe pe_param ]
  if { $result != 0 } {
     set_error -1 "setup_pe - could not add PE $migration_pe_name (result of add_pe: $result)"
     return
  }
  set_error 0 "setup_pe - no errors" 
}


#                                                             max. column:     |
#****** migration/clean_up_pe() ******
# 
#  NAME
#     clean_up_pe -- ??? 
#
#  SYNOPSIS
#     clean_up_pe { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc clean_up_pe {} {
  global checkpoint_host1 checkpoint_host2 q1 q2 q3 q4 migration_pe_name

   if { [check_test_dependencies] != 0 } {
     return
   }


  set not_deleted ""
  set error 0

  set result [ del_pe $migration_pe_name ] 
  if { $result != 0 } {
    set not_deleted "$not_deleted $result"
    incr error 1
  }

  if { $error != 0 } {
     set_error -1 "clean_up_pe - could not delete pe(s) $not_deleted"
  }

  set_error 0 "clean_up_pe - no errors"
}

#                                                             max. column:     |
#****** migration/setup_queues() ******
# 
#  NAME
#     setup_queues -- ??? 
#
#  SYNOPSIS
#     setup_queues { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc setup_queues {} {
# we need SOLARIS64 and AIX4.3 machines !

  global CHECK_CORE_EXECD checkpoint_host1 checkpoint_host2 q1 q2 q3 q4

  if { [check_test_dependencies] != 0 } {
     return
  }
  # queues on host 1
  set q_param(qname)                 "$q1"
  set q_param(hostname)              "$checkpoint_host1"
  set q_param(load_thresholds)       "np_load_avg=7.00"
  set q_param(qtype)                 "BATCH PARALLEL CHECKPOINTING"
  set q_param(suspend_thresholds)    "np_load_avg=7"            ;# migrate on suspend threshold
  set q_param(nsuspend)              "1"
  set q_param(suspend_interval)      "00:00:30"
  
  set result [ add_queue q_param ]

  if { ($result != 0)  } {
     set_error -1 "setup_queues - could not add queue $q1"
     return
  }

  set q_param(qname)                 "$q3"
  set result [ add_queue q_param ]
  if { $result != 0  } {
     set_error -1 "setup_queues - could not add queue $q3"
     return
  }

  # queues on host 2
  set q_param(qname)                 "$q2"
  set q_param(hostname)              "$checkpoint_host2"
  set result [ add_queue q_param ]
  if { $result != 0  } {
     set_error -1 "setup_queues - could not add queue $q3"
     return
  }
  
  set q_param(qname)                 "$q4"
  set result [ add_queue q_param ]
  if { $result != 0  } {
     set_error -1 "setup_queues - could not add queue $q4"
     return
  } 

  set_error 0 "setup_queues - no errors"
}

#                                                             max. column:     |
#****** migration/clean_up_queues() ******
# 
#  NAME
#     clean_up_queues -- ??? 
#
#  SYNOPSIS
#     clean_up_queues { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc clean_up_queues {} {
  global checkpoint_host1 checkpoint_host2 q1 q2 q3 q4

   if { [check_test_dependencies] != 0 } {
     return
   }


  set not_deleted ""
  set error 0

  set result [ del_queue $q1 ] 
  if { $result != 0 } {
    set not_deleted "$not_deleted $result"
    incr error 1
  }
  set result [ del_queue $q2 ] 
  if { $result != 0 } {
    set not_deleted "$not_deleted $result"
    incr error 1
  }
  set result [ del_queue $q3 ] 
  if { $result != 0 } {
    set not_deleted "$not_deleted $result"
    incr error 1
  }
  set result [ del_queue $q4 ] 
  if { $result != 0 } {
    set not_deleted "$not_deleted $result"
    incr error 1
  }

  if { $error != 0 } {
     set_error -1 "clean_up_queues - could not delete queue(s) $not_deleted"
  }

  set_error 0 "clean_up_queues - no errors"
}
