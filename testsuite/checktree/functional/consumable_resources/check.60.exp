#!/vol2/TCL_TK/glinux/bin/expect
#___INFO__MARK_BEGIN__
##########################################################################
#
#  The Contents of this file are made available subject to the terms of
#  the Sun Industry Standards Source License Version 1.2
#
#  Sun Microsystems Inc., March, 2001
#
#
#  Sun Industry Standards Source License Version 1.2
#  =================================================
#  The contents of this file are subject to the Sun Industry Standards
#  Source License Version 1.2 (the "License"); You may not use this file
#  except in compliance with the License. You may obtain a copy of the
#  License at http://gridengine.sunsource.net/Gridengine_SISSL_license.html
#
#  Software provided under this License is provided on an "AS IS" basis,
#  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
#  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
#  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
#  See the License for the specific provisions governing your rights and
#  obligations concerning the Software.
#
#  The Initial Developer of the Original Code is: Sun Microsystems, Inc.
#
#  Copyright: 2001 by Sun Microsystems, Inc.
#
#  All Rights Reserved.
#
##########################################################################
#___INFO__MARK_END__

# define global variable in this namespace
global check_name 
global check_category 
global check_description 
global check_needs
global check_functions 
global check_errno 
global check_errstr 
global check_highest_level
global check_init_level_procedure
global check_root_access_needs
global env

#set check_root_access_needs "yes"


# define a level initialization procedure:
set check_init_level_procedure "consumable_resources_init_level"

# define test's name and run level descriptions
set check_name            "consumable_resources"
set check_category        "COMPATIBILITY SYSTEM VERIFIED"
set check_highest_level   8
set check_description(0)  "Consumable resources on global level"
set check_description(1)  "Consumable resources on host level"
set check_description(2)  "Consumable resources on queue level"
set check_description(3)  "Consumable resources on global/host/queue level"
set check_description(4)  "Force request of consumable resource"
set check_description(5)  "Consumable resources as load_thresholds"
set check_description(6)  "Consumable resources and rescheduling"
set check_description(7)  "Consumable resources and load sensors"
set check_description(8)  "Consumable resources and 2 load sensor scripts"







# define test's dependencies
set check_needs           "init_core_system" 

# setup and cleanup functions
set check_setup_function consumable_resources_setup
set check_cleanup_function consumable_resources_cleanup



# define test's procedure order
set check_functions "consumable_resources_test"


global consumable_resources_test_hosts
global consumable_resources_saved_slot_count

proc consumable_resources_init_level {} {
   global CHECK_ACT_LEVEL

   switch -- $CHECK_ACT_LEVEL {
      "0" { 
         return 0
      } 
      "1" {
         return 0
      }
      "2" {
         return 0
      }
      "3" {
         return 0
      }
      "4" {
         return 0
      }
      "5" {
         return 0
      }
      "6" {
         return 0
      }
      "7" {
         return 0
      }
      "8" {
         return 0
      }
   } 

   return -1  ;# no other level 
}




# -------- local test procedures: initialization------------------------------


proc consumable_resources_setup  {} {
   global ts_config
   global consumable_resources_test_hosts
   global consumable_resources_saved_slot_count
   global CHECK_OUTPUT

   set consumable_resources_test_hosts {}
   set consumable_resources_saved_slot_count ""
   set execd_count 0
   foreach host $ts_config(execd_nodes) {
      if { $execd_count < 2 } {
         incr execd_count 1
         lappend consumable_resources_test_hosts "$host"
         puts $CHECK_OUTPUT "using host $host"
      } 
   }

   set queue_list {}
   foreach host $ts_config(execd_nodes) {
      lappend queue_list [get_queue_instance "all.q" $host]
   }

   disable_queue $queue_list
   puts $CHECK_OUTPUT "disabled $queue_list"
   

   set queue_settings(slots) 1000
   set queue_settings(load_thresholds) "np_load_avg=11.75"
   set qname "resource.q"
   add_queue $qname $consumable_resources_test_hosts queue_settings
   puts $CHECK_OUTPUT "added queue $qname for hosts $consumable_resources_test_hosts"

   set_error 0 "ok"
}

proc consumable_resources_cleanup  {} {
   global CHECK_OUTPUT ts_config
   global consumable_resources_test_hosts
   global consumable_resources_saved_slot_count

   delete_all_jobs
   wait_for_end_of_all_jobs 60

   set queue_list {}
   foreach host $ts_config(execd_nodes) {
      lappend queue_list [get_queue_instance "all.q" $host]
   }
   enable_queue $queue_list
   puts $CHECK_OUTPUT "disabled $queue_list"


   set qname "resource.q"
   del_queue $qname $consumable_resources_test_hosts  0 1

   set_error 0 "ok"
}

proc consumable_resources_submit_jobs_and_wait { job_arguments job_count run_job_count job_arguments2 { schedd_info "" } { queue_state "" } } {
   global ts_config CHECK_OUTPUT CHECK_ARCH
 
   if { $job_arguments2 == "" } {
      for { set i 0 } { $i < $job_count } { incr i 1 } {
         set job_id($i) [submit_job "$job_arguments $ts_config(product_root)/examples/jobs/sleeper.sh 100"]
      }
   } else {
      for { set i 0 } { $i < $job_count } { incr i 1 } {
         set job_id($i) [submit_job "$job_arguments $ts_config(product_root)/examples/jobs/sleeper.sh 100"]
         incr i 1
         set job_id($i) [submit_job "$job_arguments2 $ts_config(product_root)/examples/jobs/sleeper.sh 100"]
      }
   }

   while { 1 } {
      catch {  eval exec "$ts_config(product_root)/bin/$CHECK_ARCH/qconf" "-tsm" } catch_result
      set running_jobs 0
      set error 0
      for { set i 0 } { $i < $job_count } { incr i 1 } {
         set job_state [is_job_running $job_id($i) "leeper"]
         set job_id($i,running) $job_state
         if { $job_state == 1 } {
            incr running_jobs 1
         }
         if { $job_state == -1 } {
            add_proc_error "consumable_resources_submit_jobs_and_wait" -2 "job was not submitted - stop"
            set error 1
            break
         }
      }
      puts $CHECK_OUTPUT "running jobs count: $running_jobs"
      if { $running_jobs == $run_job_count || $error != 0 } {
         break
      }
   }

   if { $queue_state != "" } {
      wait_for_queue_state [lindex $queue_state 0] [lindex $queue_state 1] 60
   }


   if { $job_count != $run_job_count } {
      if { $schedd_info == "" } {
         add_proc_error "consumable_resources_submit_jobs_and_wait" -2 "got not running job, but no schedule info to search for"
      } else {
         set sched_info_tries 10
         set ok 0
         while { $sched_info_tries > 0 } {      
            catch {  eval exec "$ts_config(product_root)/bin/$CHECK_ARCH/qconf" "-tsm" } catch_result
            for { set i 0 } { $i < $job_count } { incr i 1 } {
               if { $job_id($i,running) == 0 } {
                  puts $CHECK_OUTPUT "job $job_id($i) is not running, checking schedd job info message ..."
                  puts $CHECK_OUTPUT "looking for \"$schedd_info\" of job $job_id($i)"
                  get_qstat_j_info $job_id($i)
                  if { [string match "*$schedd_info*" $qstat_j_info(scheduling info)] } {
                     puts $CHECK_OUTPUT "found matching scheduling info"
                     set ok 1
                  }
               }
            }
            if { $ok == 1 } {
               break
            }
            incr sched_info_tries -1
            after 1000
         }
         if { $ok != 1 } {
            add_proc_error "consumable_resources_submit_jobs_and_wait" -2 "can't find matching scheduler info:\nexpected: $schedd_info\ngot: $qstat_j_info(scheduling info)"
         }
      }
   }
 
   delete_all_jobs  
   wait_for_end_of_all_jobs 60

#   for { set i 0 } { $i < $job_count } { incr i 1 } { 
#      delete_job $job_id($i)
#   }

}

proc consumable_resources_test {} {
   global consumable_resources_test_hosts check_description CHECK_ARCH
   global CHECK_OUTPUT ts_config CHECK_CORE_MASTER CHECK_ACT_LEVEL CHECK_SCRIPT_FILE_DIR


   puts $CHECK_OUTPUT $check_description($CHECK_ACT_LEVEL)

   if { $CHECK_ACT_LEVEL == 0 } {

      set GLOBALLY [translate $CHECK_CORE_MASTER 1 0 0 [sge_macro MSG_SCHEDD_INFO_CANNOTRUNGLOBALLY_SS] "*" "*test1=0*"]
   
      # case a)
      #           all jobs will run
      puts $CHECK_OUTPUT "\ncase a)"

      # create test1 complex
      set test1_complex(test1) "t1 INT <= YES YES 0 1000"
      set_complex test1_complex
   
      # get original global host coniguration
      get_exechost orig_global_host global
   
      # modify complex_values of global host
      set global_host(complex_values) "test1=5"
      set_exechost global_host global
   
      set job_arguments "-o /dev/null -e /dev/null"
      set job_count 6
      set run_job_count 6
      consumable_resources_submit_jobs_and_wait $job_arguments $job_count $run_job_count ""
   
      # case b) 
      #           5 jobs run, 1 have to wait
      puts $CHECK_OUTPUT "\ncase b)"
      set job_arguments "-l test1=1 -o /dev/null -e /dev/null"
      set job_count 6
      set run_job_count 5
      consumable_resources_submit_jobs_and_wait $job_arguments $job_count $run_job_count "" $GLOBALLY
   
      # case c)
      #           5 jobs run, 1 have to wait
      puts $CHECK_OUTPUT "\ncase c)"
      set test1_complex(test1) "t1 INT <= YES YES 1 1000"
      set_complex test1_complex
      
      set job_arguments "-o /dev/null -e /dev/null"
      set job_count 6
      set run_job_count 5
      consumable_resources_submit_jobs_and_wait $job_arguments $job_count $run_job_count "" $GLOBALLY
   
      # case d)
      #           5 jobs run, 1 have to wait
      puts $CHECK_OUTPUT "\ncase d)"
      set job_arguments "-l test1=1 -o /dev/null -e /dev/null"
      set job_count 6
      set run_job_count 5
      consumable_resources_submit_jobs_and_wait $job_arguments $job_count $run_job_count "" $GLOBALLY
   
      set global_host(complex_values) $orig_global_host(complex_values)
      set_exechost global_host global
      
      set test1_complex(test1) ""
      set_complex test1_complex
      puts $CHECK_OUTPUT "done"
   }

   if { $CHECK_ACT_LEVEL == 1 } {
      set RUNATHOST  [translate $CHECK_CORE_MASTER 1 0 0 [sge_macro MSG_SCHEDD_INFO_CANNOTRUNATHOST_SSS]  "*" "*" "*test2=0*"]
#      set RUNINQUEUE [translate $CHECK_CORE_MASTER 1 0 0 [sge_macro MSG_SCHEDD_INFO_CANNOTRUNINQUEUE_SSS] "*" "*" "*test2=0*"]
   
      # case a)
      #           all jobs will run
      puts $CHECK_OUTPUT "\ncase a)"

      # create test2 complex
      set test2_complex(test2) "t2 INT <= YES YES 0 1000"
      set_complex test2_complex

      set host_a [lindex $consumable_resources_test_hosts 0]

      # get original host_a host coniguration
      get_exechost orig_host_a_host $host_a
   
      # modify complex_values of host_a host
      set host_a_host(complex_values) "test2=5"
      set_exechost host_a_host $host_a
   

      set job_arguments "-l h=$host_a -o /dev/null -e /dev/null"
      set job_count 6
      set run_job_count 6
      consumable_resources_submit_jobs_and_wait $job_arguments $job_count $run_job_count ""
   
      # case b) 
      #           5 jobs run, 1 have to wait
      puts $CHECK_OUTPUT "\ncase b)"
      
      set job_arguments "-l h=$host_a,test2=1 -o /dev/null -e /dev/null"
      set job_count 6
      set run_job_count 5
      consumable_resources_submit_jobs_and_wait $job_arguments $job_count $run_job_count "" $RUNATHOST
   
      # case c)
      #           5 jobs run, 1 have to wait
      puts $CHECK_OUTPUT "\ncase c)"
      set test2_complex(test2) "t2 INT <= YES YES 1 1000"
      set_complex test2_complex

      
      set job_arguments "-l h=$host_a -o /dev/null -e /dev/null"
      set job_count 6
      set run_job_count 5
      consumable_resources_submit_jobs_and_wait $job_arguments $job_count $run_job_count "" $RUNATHOST
   
      # case d)
      #           5 jobs run, 1 have to wait
      puts $CHECK_OUTPUT "\ncase d)"
      set job_arguments "-l h=$host_a,test2=1 -o /dev/null -e /dev/null"
      set job_count 6
      set run_job_count 5
      consumable_resources_submit_jobs_and_wait $job_arguments $job_count $run_job_count "" $RUNATHOST 
   
      set host_a_host(complex_values) $orig_host_a_host(complex_values)
      set_exechost host_a_host $host_a
      
      set test2_complex(test2) ""
      set_complex test2_complex
      puts $CHECK_OUTPUT "done"
   }

   if { $CHECK_ACT_LEVEL == 2 } {
      set RUNINQUEUE [translate $CHECK_CORE_MASTER 1 0 0 [sge_macro MSG_SCHEDD_INFO_CANNOTRUNINQUEUE_SSS] "*" "*" "*test3=0*"]
   
      # case a)
      #           all jobs will run
      puts $CHECK_OUTPUT "\ncase a)"

      # create complex
      set test3_complex(test3) "t3 INT <= YES YES 0 1000"
      set_complex test3_complex

      set queue_settings(complex_values) "test3=5"
      set_queue "resource.q" $consumable_resources_test_hosts queue_settings


      # case a
      puts $CHECK_OUTPUT "\ncase a)"
      set job_arguments "-o /dev/null -e /dev/null"
      set job_count 11
      set run_job_count 11
      consumable_resources_submit_jobs_and_wait $job_arguments $job_count $run_job_count ""

      # case b
      puts $CHECK_OUTPUT "\ncase b)"
      set job_arguments "-l test3=1 -o /dev/null -e /dev/null"
      set job_count 11
      set run_job_count 10
      consumable_resources_submit_jobs_and_wait $job_arguments $job_count $run_job_count "" $RUNINQUEUE

      # case c
      puts $CHECK_OUTPUT "\ncase c)"
      set test3_complex(test3) "t3 INT <= YES YES 1 1000"
      set_complex test3_complex

      set job_arguments "-o /dev/null -e /dev/null"
      set job_count 11
      set run_job_count 10
      consumable_resources_submit_jobs_and_wait $job_arguments $job_count $run_job_count "" $RUNINQUEUE

      #case d
      puts $CHECK_OUTPUT "\ncase d)"
      set job_arguments "-l test3=1 -o /dev/null -e /dev/null"
      set job_count 11
      set run_job_count 10
      consumable_resources_submit_jobs_and_wait $job_arguments $job_count $run_job_count "" $RUNINQUEUE

      set queue_settings(complex_values) "NONE"
      set_queue "resource.q" $consumable_resources_test_hosts queue_settings


      # remove test3 complex 
      set test3_complex(test3) ""
      set_complex test3_complex

      puts $CHECK_OUTPUT "done"
   }

   if { $CHECK_ACT_LEVEL == 3 } {
      set RUNINQUEUE [translate $CHECK_CORE_MASTER 1 0 0 [sge_macro MSG_SCHEDD_INFO_CANNOTRUNINQUEUE_SSS] "*" "*" "*test1=0*"]
      set RUNATHOST  [translate $CHECK_CORE_MASTER 1 0 0 [sge_macro MSG_SCHEDD_INFO_CANNOTRUNATHOST_SSS]  "*" "*" "*test1=0*"]
      set GLOBALLY [translate $CHECK_CORE_MASTER 1 0 0   [sge_macro MSG_SCHEDD_INFO_CANNOTRUNGLOBALLY_SS] "*" "*test1=0*"]

      # create complex
      set test1_complex(test1) "t2 INT <= YES YES 0 1000"
      set_complex test1_complex
  
      # get original global host coniguration
      get_exechost orig_global_host global
      # modify complex_values of global host
      set global_host(complex_values) "test1=5"
      set_exechost global_host global

      set host_a [lindex $consumable_resources_test_hosts 0]
      # get original host_a host coniguration
      get_exechost orig_host_a_host $host_a
       # modify complex_values of host_a host
      set host_a_host(complex_values) "test1=3"
      set_exechost host_a_host $host_a

      set queue_settings(complex_values) "test1=1"
      set_queue "resource.q" $consumable_resources_test_hosts queue_settings


      #case a
      puts $CHECK_OUTPUT "\ncase a)"
      set job_arguments "-l test1=1 -o /dev/null -e /dev/null"
      set job_count 3
      set run_job_count 2
      consumable_resources_submit_jobs_and_wait $job_arguments $job_count $run_job_count "" $RUNINQUEUE


      #case b
      puts $CHECK_OUTPUT "\ncase b)"
      set queue_settings(complex_values) "NONE"
      set_queue "resource.q" $consumable_resources_test_hosts queue_settings
      set job_arguments "-l test1=1,h=$host_a -o /dev/null -e /dev/null"
      set job_count 4
      set run_job_count 3
      consumable_resources_submit_jobs_and_wait $job_arguments $job_count $run_job_count "" $RUNATHOST

      #case c
      puts $CHECK_OUTPUT "\ncase c)"
      set job_arguments1 "-l test1=1,h=$host_a -o /dev/null -e /dev/null"
      set job_arguments2 "-l test1=1 -o /dev/null -e /dev/null"
      set job_count 6
      set run_job_count 5
      consumable_resources_submit_jobs_and_wait $job_arguments1 $job_count $run_job_count $job_arguments2 $GLOBALLY



      set queue_settings(complex_values) "NONE"
      set_queue "resource.q" $consumable_resources_test_hosts queue_settings
      
      set host_a_host(complex_values) $orig_host_a_host(complex_values)
      set_exechost host_a_host $host_a

      set global_host(complex_values) $orig_global_host(complex_values)
      set_exechost global_host global


      # remove test1 complex 
      set test1_complex(test1) ""
      set_complex test1_complex

      puts $CHECK_OUTPUT "done"
   }
   
   if { $CHECK_ACT_LEVEL == 4 } {
      set FORCED [translate $CHECK_CORE_MASTER 1 0 0 [sge_macro MSG_SCHEDD_INFO_NOTREQFORCEDRES_SS] "test1" "*"]

      # create complex
      set test1_complex(test1) "t1 INT <= FORCED YES 0 1000"
      set_complex test1_complex
  
      set queue_settings(complex_values) "test1=1"
      set_queue "resource.q" $consumable_resources_test_hosts queue_settings

      # case a
      puts $CHECK_OUTPUT "\ncase a)"
      set job_arguments1 "-o /dev/null -e /dev/null"
      set job_arguments2 ""
      set job_count 1
      set run_job_count 0
      consumable_resources_submit_jobs_and_wait $job_arguments1 $job_count $run_job_count $job_arguments2 $FORCED


      # case b
      puts $CHECK_OUTPUT "\ncase b)"
      set job_arguments1 "-l test1=1 -o /dev/null -e /dev/null"
      set job_arguments2 ""
      set job_count 1
      set run_job_count 1
      consumable_resources_submit_jobs_and_wait $job_arguments1 $job_count $run_job_count $job_arguments2


      set queue_settings(complex_values) "NONE"
      set_queue "resource.q" $consumable_resources_test_hosts queue_settings

      # remove test1 complex 
      set test1_complex(test1) ""
      set_complex test1_complex

      puts $CHECK_OUTPUT "done"
   }
    

   if { $CHECK_ACT_LEVEL == 5 } {

      # create complex
      set test1_complex(test1) "t1 INT <= YES YES 0 1000"
      set_complex test1_complex
  
      # get original global host coniguration
      get_exechost orig_global_host global
      # modify complex_values of global host
      set global_host(complex_values) "test1=5"
      set_exechost global_host global

      set host_a [lindex $consumable_resources_test_hosts 0]
      # get original host_a host coniguration
      get_exechost orig_host_a_host $host_a
       # modify complex_values of host_a host
      set host_a_host(complex_values) "test1=4"
      set_exechost host_a_host $host_a

      set queue_settings(complex_values) "test1=3"
      set queue_settings(load_thresholds) "np_load_avg=11.75,test1=2"
      set_queue "resource.q" $consumable_resources_test_hosts queue_settings


      # case a
      puts $CHECK_OUTPUT "\ncase a)"
      set job_arguments1 "-l test1=1,h=$host_a -o /dev/null -e /dev/null"
      set job_arguments2 ""
      set job_count 1
      set run_job_count 1
      set queue_check {}
      lappend queue_check "resource.q@$host_a"
      lappend queue_check "a"
      
      consumable_resources_submit_jobs_and_wait $job_arguments1 $job_count $run_job_count $job_arguments2 "" $queue_check



      set queue_settings(load_thresholds) "np_load_avg=11.75"
      set queue_settings(complex_values) "NONE"
      set_queue "resource.q" $consumable_resources_test_hosts queue_settings


      set host_a_host(complex_values) $orig_host_a_host(complex_values)
      set_exechost host_a_host $host_a
      
      set global_host(complex_values) $orig_global_host(complex_values)
      set_exechost global_host global


      # remove test1 complex 
      set test1_complex(test1) ""
      set_complex test1_complex

      puts $CHECK_OUTPUT "done"
   }

   if { $CHECK_ACT_LEVEL == 6 } {

      # create complex
      set test1_complex(test1) "t1 INT <= YES YES 0 1000"
      set_complex test1_complex
  
      # get original global host coniguration
      get_exechost orig_global_host global
      # modify complex_values of global host
      set global_host(complex_values) "test1=5"
      set_exechost global_host global

      set host_a [lindex $consumable_resources_test_hosts 0]
      # get original host_a host coniguration
      get_exechost orig_host_a_host $host_a
       # modify complex_values of host_a host
      set host_a_host(complex_values) "test1=4"
      set_exechost host_a_host $host_a

      set queue_settings(complex_values) "test1=3"
      set queue_settings(load_thresholds) "np_load_avg=11.75,test1=2"
      set_queue "resource.q" $consumable_resources_test_hosts queue_settings


      catch {  eval exec "$ts_config(product_root)/bin/$CHECK_ARCH/qstat" "-F | grep test" } qstat_F_1
      set job_id [submit_job "-l test1=1,h=$host_a -o /dev/null -e /dev/null $ts_config(product_root)/examples/jobs/sleeper.sh 1000"]
      wait_for_jobstart $job_id "leeper" 60

      catch {  eval exec "$ts_config(product_root)/bin/$CHECK_ARCH/qstat" "-F | grep test" } qstat_F_2


      puts $CHECK_OUTPUT "setting hold state of job $job_id"
      hold_job $job_id


      puts $CHECK_OUTPUT "reschedule job $job_id"
      catch {  eval exec "$ts_config(product_root)/bin/$CHECK_ARCH/qmod" "-f -r $job_id" } catch_result
      puts $CHECK_OUTPUT $catch_result

      wait_for_jobpending $job_id "leeper" 60
      set state [get_queue_state "resource.q@$host_a"]
      puts $CHECK_OUTPUT "queue state of queue \"resource.q@$host_a\": \"$state\""
      if { $state != "" } {
         add_proc_error "consumable_resources_test" -1 "queue did not free alarm state"
      }

      
      catch {  eval exec "$ts_config(product_root)/bin/$CHECK_ARCH/qstat" "-F | grep test" } qstat_F_3

      puts $CHECK_OUTPUT "qstat1 (before job was started)   :\n$qstat_F_1"
      puts $CHECK_OUTPUT "qstat2 (when job is running)      :\n$qstat_F_2"
      puts $CHECK_OUTPUT "qstat3 (after job was rescheduled):\n$qstat_F_3"

      if { [string compare $qstat_F_1 $qstat_F_3] != 0 } {
         puts $CHECK_OUTPUT "resource wasn't freed"
         add_proc_error "consumable_resources_test" -1 "resources of rescheduled job wasn't freed"
      }

      delete_all_jobs  
      wait_for_end_of_all_jobs 60

      set queue_settings(load_thresholds) "np_load_avg=11.75"
      set queue_settings(complex_values) "NONE"
      set_queue "resource.q" $consumable_resources_test_hosts queue_settings


      set host_a_host(complex_values) $orig_host_a_host(complex_values)
      set_exechost host_a_host $host_a
      
      set global_host(complex_values) $orig_global_host(complex_values)
      set_exechost global_host global


      # remove test1 complex 
      set test1_complex(test1) ""
      set_complex test1_complex

      puts $CHECK_OUTPUT "done"
   }
   
   if { $CHECK_ACT_LEVEL == 7 } {

      # create complex
      set test1_complex(test1) "t1 INT <= YES YES 0 1000"
      set_complex test1_complex
  
      # get original global host coniguration
      get_exechost orig_global_host global
      # modify complex_values of global host
      set global_host(complex_values) "test1=15"
      set_exechost global_host global

      set host_a [lindex $consumable_resources_test_hosts 0]
      # get original host_a host coniguration
      get_exechost orig_host_a_host $host_a
       # modify complex_values of host_a host
      set host_a_host(complex_values) "test1=10"
      set_exechost host_a_host $host_a

      set queue_settings(complex_values) "test1=5"
      set_queue "resource.q" $consumable_resources_test_hosts queue_settings

      # setup load script
      get_config execd_config_a_host $host_a

            
      catch {  eval exec "rm $ts_config(testsuite_root_dir)/$CHECK_SCRIPT_FILE_DIR/resource_loadsensor_link.sh" } output
      puts $CHECK_OUTPUT $output
      catch {  eval exec "ln -s $ts_config(testsuite_root_dir)/$CHECK_SCRIPT_FILE_DIR/resource_test1_6_loadsensor.sh $ts_config(testsuite_root_dir)/$CHECK_SCRIPT_FILE_DIR/resource_loadsensor_link.sh" } output
      puts $CHECK_OUTPUT $output


      set load_sensor_script_path "$ts_config(testsuite_root_dir)/$CHECK_SCRIPT_FILE_DIR/resource_loadsensor_link.sh"
      if { [info exists execd_config_a_host(load_sensor)] } {
         set new_config_a_host(load_sensor) "$execd_config_a_host(load_sensor),$load_sensor_script_path"
      } else {
         set new_config_a_host(load_sensor) "$load_sensor_script_path"
         set execd_config_a_host(load_sensor) ""
      }
      if { [info exists execd_config_a_host(load_report_time)] == 0 } {
         set execd_config_a_host(load_report_time) ""
      }

      set new_config_a_host(load_report_time) "00:00:05"
      set_config new_config_a_host $host_a


      # check for reported load value
      set retries 30
      set ok 0
      while { $retries > 0 } {
         catch {  eval exec "$ts_config(product_root)/bin/$CHECK_ARCH/qstat" "-l h=$host_a -F | grep test1" } test_grep
         puts $CHECK_OUTPUT "waiting for test1=6 load value (retry count: $retries) ..."
         puts $CHECK_OUTPUT $test_grep
         if { [string match "*hc:test1=6*" $test_grep] } {
            puts $CHECK_OUTPUT "resource test1 is set to value 6 - ok"
            set ok 1
            break
         }
         after 5000
         incr retries -1
      }

      if { $ok != 1 } {
         add_proc_error "consumable_resources_test" -1 "can't find load value hc:test1=6 by qstat -F on host $host_a"
      }

      catch {  eval exec "$ts_config(product_root)/bin/$CHECK_ARCH/qconf" "-se $host_a | grep test1" } test_grep
      if { [string match "*test1=6*" $test_grep] == 0 } {
         add_proc_error "consumable_resources_test" -1 "qconf -se doesn't show test1=6 load value"
      }

      catch {  eval exec "rm $ts_config(testsuite_root_dir)/$CHECK_SCRIPT_FILE_DIR/resource_loadsensor_link.sh" } output
      puts $CHECK_OUTPUT $output
      catch {  eval exec "ln -s $ts_config(testsuite_root_dir)/$CHECK_SCRIPT_FILE_DIR/resource_test1_3_loadsensor.sh $ts_config(testsuite_root_dir)/$CHECK_SCRIPT_FILE_DIR/resource_loadsensor_link.sh" } output
      puts $CHECK_OUTPUT $output

      
      # check for reported load value
      set retries 30
      set ok 0
      while { $retries > 0 } {
         catch {  eval exec "$ts_config(product_root)/bin/$CHECK_ARCH/qstat" "-l h=$host_a -F | grep test1" } test_grep
         puts $CHECK_OUTPUT "waiting for test1=3 load value (retry count: $retries) ..."
         puts $CHECK_OUTPUT $test_grep
         if { [string match "*hc:test1=3*" $test_grep] } {
            puts $CHECK_OUTPUT "resource test1 is set to value 3 - ok"
            set ok 1
            break
         }
         after 5000
         incr retries -1
      }

      if { $ok != 1 } {
         add_proc_error "consumable_resources_test" -1 "can't find load value hc:test1=3 by qstat -F on host $host_a"
      }

      catch {  eval exec "$ts_config(product_root)/bin/$CHECK_ARCH/qconf" "-se $host_a | grep test1" } test_grep
      if { [string match "*test1=3*" $test_grep] == 0 } {
         add_proc_error "consumable_resources_test" -1 "qconf -se doesn't show test1=3 load value"
      }

      

      # restore execd config
      set_config execd_config_a_host $host_a

      set queue_settings(complex_values) "NONE"
      set_queue "resource.q" $consumable_resources_test_hosts queue_settings

      set host_a_host(complex_values) $orig_host_a_host(complex_values)
      set_exechost host_a_host $host_a

      set global_host(complex_values) $orig_global_host(complex_values)
      set_exechost global_host global

      set test_grep "test1" 
      set retries 45
      while { [string match "*test1*" $test_grep] && $retries > 0 } {
         catch {  eval exec "$ts_config(product_root)/bin/$CHECK_ARCH/qconf" "-se $host_a | grep test1" } test_grep
         puts $CHECK_OUTPUT "\nwaiting for test resource report to disappear (retry count: $retries) ..."
         puts $CHECK_OUTPUT "$test_grep"
         incr retries -1
         sleep 5
      }

      if { [string match "*test1*" $test_grep] } {
         add_proc_error "consumable_resources_test" -1 "load sensor report test1 does not disappear"
      }
      
      # remove test1 complex 
      set test1_complex(test1) ""
      set_complex test1_complex

      catch {  eval exec "rm $ts_config(testsuite_root_dir)/$CHECK_SCRIPT_FILE_DIR/resource_loadsensor_link.sh" } output
      puts $CHECK_OUTPUT $output

      puts $CHECK_OUTPUT "done"
   }
   
   if { $CHECK_ACT_LEVEL == 8 } {

      # create complex
      set test1_complex(test1) "t1 INT <= YES YES 0 1000"
      set test1_complex(test2) "t2 INT <= YES YES 0 1000"
      set_complex test1_complex
  
      # get original global host coniguration
      get_exechost orig_global_host global
      # modify complex_values of global host
      set global_host(complex_values) "test1=15,test2=15"
      set_exechost global_host global

      set host_a [lindex $consumable_resources_test_hosts 0]
      # get original host_a host coniguration
      get_exechost orig_host_a_host $host_a
       # modify complex_values of host_a host
      set host_a_host(complex_values) "test1=10,test2=10"
      set_exechost host_a_host $host_a

      set queue_settings(complex_values) "test1=5,test2=5"
      set_queue "resource.q" $consumable_resources_test_hosts queue_settings

      # setup load script
      get_config execd_config_a_host $host_a

            
      catch { eval exec "rm $ts_config(testsuite_root_dir)/$CHECK_SCRIPT_FILE_DIR/resource_loadsensor_link6.sh" } output
      puts $CHECK_OUTPUT $output
      catch {  eval exec "ln -s $ts_config(testsuite_root_dir)/$CHECK_SCRIPT_FILE_DIR/resource_test1_6_loadsensor.sh $ts_config(testsuite_root_dir)/$CHECK_SCRIPT_FILE_DIR/resource_loadsensor_link6.sh" } output
      puts $CHECK_OUTPUT $output

      catch { eval exec "rm $ts_config(testsuite_root_dir)/$CHECK_SCRIPT_FILE_DIR/resource_loadsensor_link3.sh" } output
      puts $CHECK_OUTPUT $output
      catch {  eval exec "ln -s $ts_config(testsuite_root_dir)/$CHECK_SCRIPT_FILE_DIR/resource_test2_3_loadsensor.sh $ts_config(testsuite_root_dir)/$CHECK_SCRIPT_FILE_DIR/resource_loadsensor_link3.sh" } output
      puts $CHECK_OUTPUT $output



      set load_sensor_script_path "$ts_config(testsuite_root_dir)/$CHECK_SCRIPT_FILE_DIR/resource_loadsensor_link6.sh,$ts_config(testsuite_root_dir)/$CHECK_SCRIPT_FILE_DIR/resource_loadsensor_link3.sh"
      if { [info exists execd_config_a_host(load_sensor)] } {
         set new_config_a_host(load_sensor) "$execd_config_a_host(load_sensor),$load_sensor_script_path"
      } else {
         set new_config_a_host(load_sensor) "$load_sensor_script_path"
         set execd_config_a_host(load_sensor) ""
      }
      if { [info exists execd_config_a_host(load_report_time)] == 0 } {
         set execd_config_a_host(load_report_time) ""
      }

      set new_config_a_host(load_report_time) "00:00:05"
      set_config new_config_a_host $host_a


      # check for reported load value
      set retries 30
      set ok 0
      while { $retries > 0 } {
         catch {  eval exec "$ts_config(product_root)/bin/$CHECK_ARCH/qstat" "-l h=$host_a -F | grep test1" } test_grep
         puts $CHECK_OUTPUT "waiting for test1=6 load value (retry count: $retries) ..."
         puts $CHECK_OUTPUT $test_grep
         if { [string match "*hc:test1=6*" $test_grep] } {
            puts $CHECK_OUTPUT "resource test1 is set to value 6 - ok"
            set ok 1
            break
         }
         after 5000
         incr retries -1
      }
      if { $ok != 1 } {
         add_proc_error "consumable_resources_test" -1 "can't find load value hc:test1=6 by qstat -F on host $host_a"
      }

      catch {  eval exec "$ts_config(product_root)/bin/$CHECK_ARCH/qconf" "-se $host_a | grep test1" } test_grep
      if { [string match "*test1=6*" $test_grep] == 0 } {
         add_proc_error "consumable_resources_test" -1 "qconf -se doesn't show test1=6 load value"
      }

      # check for reported load value
      set retries 30
      set ok 0
      while { $retries > 0 } {
         catch {  eval exec "$ts_config(product_root)/bin/$CHECK_ARCH/qstat" "-l h=$host_a -F | grep test2" } test_grep
         puts $CHECK_OUTPUT "waiting for test2=3 load value (retry count: $retries) ..."
         puts $CHECK_OUTPUT $test_grep
         if { [string match "*hc:test2=3*" $test_grep] } {
            puts $CHECK_OUTPUT "resource test2 is set to value 3 - ok"
            set ok 1
            break
         }
         after 5000
         incr retries -1
      }
      if { $ok != 1 } {
         add_proc_error "consumable_resources_test" -1 "can't find load value hc:test2=3 by qstat -F on host $host_a"
      }

      catch {  eval exec "$ts_config(product_root)/bin/$CHECK_ARCH/qconf" "-se $host_a | grep test2" } test_grep
      if { [string match "*test2=3*" $test_grep] == 0 } {
         add_proc_error "consumable_resources_test" -1 "qconf -se doesn't show test2=3 load value"
      }


      catch { eval exec "rm $ts_config(testsuite_root_dir)/$CHECK_SCRIPT_FILE_DIR/resource_loadsensor_link6.sh" } output
      puts $CHECK_OUTPUT $output

      catch { eval exec "rm $ts_config(testsuite_root_dir)/$CHECK_SCRIPT_FILE_DIR/resource_loadsensor_link3.sh" } output
      puts $CHECK_OUTPUT $output


      # restore execd config
      set_config execd_config_a_host $host_a

      set queue_settings(complex_values) "NONE"
      set_queue "resource.q" $consumable_resources_test_hosts queue_settings

      set host_a_host(complex_values) $orig_host_a_host(complex_values)
      set_exechost host_a_host $host_a

      set global_host(complex_values) $orig_global_host(complex_values)
      set_exechost global_host global

      set test_grep "test1" 
      set retries 45
      while { [string match "*test1*" $test_grep] && $retries > 0 } {
         catch {  eval exec "$ts_config(product_root)/bin/$CHECK_ARCH/qconf" "-se $host_a | grep test1" } test_grep
         puts $CHECK_OUTPUT "\nwaiting for test resource report to disappear (retry count: $retries) ..."
         puts $CHECK_OUTPUT "$test_grep"
         incr retries -1
         sleep 5
      }

      if { [string match "*test1*" $test_grep] } {
         add_proc_error "consumable_resources_test" -1 "load sensor report test1 does not disappear"
      }

      set test_grep "test2" 
      set retries 45
      while { [string match "*test2*" $test_grep] && $retries > 0 } {
         catch {  eval exec "$ts_config(product_root)/bin/$CHECK_ARCH/qconf" "-se $host_a | grep test2" } test_grep
         puts $CHECK_OUTPUT "\nwaiting for test resource report to disappear (retry count: $retries) ..."
         puts $CHECK_OUTPUT "$test_grep"
         incr retries -1
         sleep 5
      }

      if { [string match "*test2*" $test_grep] } {
         add_proc_error "consumable_resources_test" -1 "load sensor report test2 does not disappear"
      }

      
      # remove test1 and test2 complex 
      set test1_complex(test1) ""
      set test1_complex(test2) ""
      set_complex test1_complex

      catch { eval exec "rm $ts_config(testsuite_root_dir)/$CHECK_SCRIPT_FILE_DIR/resource_loadsensor_link6.sh" } output
      puts $CHECK_OUTPUT $output

      catch { eval exec "rm $ts_config(testsuite_root_dir)/$CHECK_SCRIPT_FILE_DIR/resource_loadsensor_link3.sh" } output
      puts $CHECK_OUTPUT $output

      puts $CHECK_OUTPUT "done"
   }
   
   set_error 0 "ok"
}


