#!/vol2/TCL_TK/glinux/bin/expect
#___INFO__MARK_BEGIN__
##########################################################################
#
#  The Contents of this file are made available subject to the terms of
#  the Sun Industry Standards Source License Version 1.2
#
#  Sun Microsystems Inc., March, 2001
#
#
#  Sun Industry Standards Source License Version 1.2
#  =================================================
#  The contents of this file are subject to the Sun Industry Standards
#  Source License Version 1.2 (the "License"); You may not use this file
#  except in compliance with the License. You may obtain a copy of the
#  License at http://gridengine.sunsource.net/Gridengine_SISSL_license.html
#
#  Software provided under this License is provided on an "AS IS" basis,
#  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
#  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
#  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
#  See the License for the specific provisions governing your rights and
#  obligations concerning the Software.
#
#  The Initial Developer of the Original Code is: Sun Microsystems, Inc.
#
#  Copyright: 2001 by Sun Microsystems, Inc.
#
#  All Rights Reserved.
#
##########################################################################
#___INFO__MARK_END__

# define global variable in this namespace
global check_name 
global check_description 
global check_needs
global check_functions 
global check_errno 
global check_errstr 
global check_highest_level
global check_init_level_procedure
global check_root_access_needs
global env

set check_root_access_needs "yes"


# define a level initialization procedure:
set check_init_level_procedure "submit_del_init_level"

# define test's name and run level descriptions
set check_name            "submit_del"
set check_highest_level   0
set check_description(0)  "delete immediate submitted job (signaling test)"

# define test's dependencies
set check_needs           "init_core_system" 


# define test's procedure order
set check_functions ""
lappend check_functions "submit_del_setup"
lappend check_functions "submit_del_test"
lappend check_functions "submit_del_cleanup"

proc submit_del_init_level {} {
   global CHECK_ACT_LEVEL
   global CHECK_PRODUCT_TYPE
   global test_array_jobs 

  switch -- $CHECK_ACT_LEVEL {
     "0" { 
           return 0    
     } 
     "1" {
           return -1
     }
  } 
  return -1  ;# no other level else
}

# -------- local test procedures -----------------------------------------------

global submit_del_qconfig
global submit_del_check_queue
global tmp_shepherd_dir

proc submit_del_setup  {} {
   global CHECK_OUTPUT CHECK_SECOND_FOREIGN_SYSTEM_USER
   global CHECK_CORE_EXECD CHECK_MAIN_RESULTS_DIR CHECK_USER
   global submit_del_qconfig CHECK_PRODUCT_ROOT CHECK_HOST
   global submit_del_check_queue tmp_shepherd_dir


   get_config submit_del_qconfig
   set my_config(schedd_params) "FLUSH_SUBMIT_SEC=0,FLUSH_FINISH_SEC=0"
   set_config my_config
   
   wait_for_end_of_all_jobs 100

   if { [ file isdirectory $CHECK_MAIN_RESULTS_DIR ] != 1 } {
      set tmp_shepherd_dir "/tmp/"
   } else {
      set tmp_shepherd_dir  "$CHECK_MAIN_RESULTS_DIR/"
   }

   
   foreach hostname $CHECK_CORE_EXECD {
      set arch [resolve_arch $hostname]
      set script_path "$tmp_shepherd_dir/${hostname}_sge_shepherd_wrapper_script" 
      set sge_shepherd_file "$CHECK_PRODUCT_ROOT/bin/$arch/sge_shepherd"
      create_shell_script $script_path "sleep" "5\nexec ${sge_shepherd_file}.tmp $*" "" "/bin/csh" 1
      start_remote_prog $hostname $CHECK_USER "touch" $script_path
      start_remote_prog $hostname "root" "ls" "${sge_shepherd_file}.tmp"
      if { $prg_exit_state != 0 } {
         start_remote_prog $hostname "root" "mv" "$sge_shepherd_file ${sge_shepherd_file}.tmp"
         start_remote_prog $hostname "root" "ln" "-s $script_path $sge_shepherd_file"
      } else {
         puts $CHECK_OUTPUT "will not mv sge_shepherd_file, old sge_shepherd_file.tmp exists"
      }
   }

   puts $CHECK_OUTPUT "waiting 15 seconds to give qmaster time to update configurations on execds ..."
   sleep 15

   set_error 0 "ok"
}

proc submit_del_test { } {
   global CHECK_OUTPUT CHECK_PRODUCT_ROOT CHECK_ARCH
   global submit_del_qconfig submit_del_check_queue CHECK_USER
   global CHECK_CORE_EXECD CHECK_HOST CHECK_PRODUCT_ROOT CHECK_DEBUG_LEVEL

   set arch [resolve_arch $CHECK_HOST]
   set qsub_program "$CHECK_PRODUCT_ROOT/bin/$arch/qsub"
   set qdel_program "$CHECK_PRODUCT_ROOT/bin/$arch/qdel"
   set job_script "$CHECK_PRODUCT_ROOT/examples/jobs/sleeper.sh 30"

   set job_list ""
   foreach elem $CHECK_CORE_EXECD {
      set arguments "-o /dev/null -e /dev/null -q $elem.q $job_script"
      lappend job_list [submit_job $arguments ]
   }

   foreach elem $job_list {
      wait_for_jobstart $elem "Sleeper" 60 1 1
   }
   foreach elem $job_list {
      wait_for_jobend $elem "Sleeper" 60 0
   }

   wait_for_end_of_all_jobs 100

   set job_script "$CHECK_PRODUCT_ROOT/examples/jobs/sleeper.sh 1000"

   set runs [ expr ( [llength $$CHECK_CORE_EXECD ] * 5 ) ]
   while { $runs > 0 } { 
      foreach elem $CHECK_CORE_EXECD {
         set arguments "-o /dev/null -e /dev/null -q $elem.q"
         set catch_return [ catch { eval exec "$qsub_program $arguments $job_script" } result ]
         puts $CHECK_OUTPUT $result
         set job_id [lindex $result 2]    
         catch {  eval exec "$CHECK_PRODUCT_ROOT/bin/$arch/qconf" "-tsm" } result
         wait_for_jobstart $job_id "leeper" 60
         set catch_return [ catch { eval exec "$qdel_program $job_id" } result ]
         puts $CHECK_OUTPUT $result
         incr runs -1

      }
   }
   set runs [ expr ( [llength $$CHECK_CORE_EXECD ] * 5 ) ]

   while { $runs > 0 } { 
      foreach elem $CHECK_CORE_EXECD {
         set arguments "-o /dev/null -e /dev/null -q $elem.q"
         start_remote_prog $CHECK_HOST $CHECK_USER "qdel" "`qsub $arguments $job_script | cut -d\" \" -f3`"
         incr runs -1
      }
   }
   
   wait_for_end_of_all_jobs 100

   set_error 0 "ok"
}


proc submit_del_cleanup  {} {
   global CHECK_OUTPUT CHECK_PRODUCT_ROOT CHECK_ARCH CHECK_CORE_EXECD
   global submit_del_qconfig submit_del_check_queue tmp_shepherd_dir CHECK_HOST

   set_config submit_del_qconfig
   

   puts $CHECK_OUTPUT "do qdel -uall"
   catch {  eval exec "$CHECK_PRODUCT_ROOT/bin/$CHECK_ARCH/qdel" "-uall" } catch_result
   puts $CHECK_OUTPUT $catch_result
   wait_for_end_of_all_jobs 100

   foreach hostname $CHECK_CORE_EXECD {
      set arch [resolve_arch $hostname]
      set sge_shepherd_file "$CHECK_PRODUCT_ROOT/bin/$arch/sge_shepherd"
      start_remote_prog $hostname "root" "rm" "$sge_shepherd_file"
      start_remote_prog $hostname "root" "mv" "${sge_shepherd_file}.tmp $sge_shepherd_file"
      set script_path "$tmp_shepherd_dir/${hostname}_sge_shepherd_wrapper_script" 
      delete_file $script_path
   }
   puts $CHECK_OUTPUT "do qmod -c for all queues"
   foreach hostname $CHECK_CORE_EXECD {
      set result [ catch { eval exec "$CHECK_PRODUCT_ROOT/bin/$CHECK_ARCH/qmod -c ${hostname}.q" } output ]
      puts $CHECK_OUTPUT $output
   }
 

   set_error 0 "ok"
}



