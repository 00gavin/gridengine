#!/vol2/TCL_TK/glinux/bin/expect
#___INFO__MARK_BEGIN__
##########################################################################
#
#  The Contents of this file are made available subject to the terms of
#  the Sun Industry Standards Source License Version 1.2
#
#  Sun Microsystems Inc., March, 2001
#
#
#  Sun Industry Standards Source License Version 1.2
#  =================================================
#  The contents of this file are subject to the Sun Industry Standards
#  Source License Version 1.2 (the "License"); You may not use this file
#  except in compliance with the License. You may obtain a copy of the
#  License at http://gridengine.sunsource.net/Gridengine_SISSL_license.html
#
#  Software provided under this License is provided on an "AS IS" basis,
#  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
#  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
#  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
#  See the License for the specific provisions governing your rights and
#  obligations concerning the Software.
#
#  The Initial Developer of the Original Code is: Sun Microsystems, Inc.
#
#  Copyright: 2001 by Sun Microsystems, Inc.
#
#  All Rights Reserved.
#
##########################################################################
#___INFO__MARK_END__

# define global variable in this namespace
global check_name 
global check_description 
global check_needs
global check_functions 
global check_errno 
global check_errstr 
global check_highest_level
global check_init_level_procedure
global check_root_access_needs
global env

# set check_root_access_needs "yes"


# define a level initialization procedure:
set check_init_level_procedure "share_tree_init_level"

# define test's name and run level descriptions
set check_name            "share_tree"
set check_highest_level   100
set check_description(0)  "Testing grd share_tree (functional test)"
set check_description(100)  "Testing grd share_tree"

# define test's dependencies
set check_needs           "init_core_system" 


# define test's procedure order
set check_functions ""
lappend check_functions "share_tree_setup"
lappend check_functions "share_tree_test"
lappend check_functions "share_tree_cleanup"


global share_tree_job_counter 
global share_tree_percentage_variation

proc share_tree_init_level {} {
   global CHECK_ACT_LEVEL
   global CHECK_PRODUCT_TYPE
   global share_tree_job_counter
   global share_tree_percentage_variation

   if { [ string compare $CHECK_PRODUCT_TYPE "sgeee" ] != 0 } {
      return -1
   }


  switch -- $CHECK_ACT_LEVEL {
     "0" { 
           set share_tree_job_counter       5 
           set share_tree_percentage_variation  10
           return 0    
     } 
     "100" {
           set share_tree_job_counter       30
           set share_tree_percentage_variation  2
           return 0    
     }
  } 
  return -1  ;# no other level else
}

# -------- local test procedures -----------------------------------------------

proc wait_for_job_tickes { job_id } {

   global CHECK_OUTPUT

   set last_job_tickets 0
   while { $last_job_tickets == 0 } {
      get_extended_job_info $job_id job_info_var
      set last_job_tickets $job_info_var(tckts)
      puts $CHECK_OUTPUT "waiting for job $job_id to get his tickets ..."
      sleep 1
   }
}

proc get_job_tickets { job_list_prj1 job_list_prj2 job_list_prj3 array_name } {
   global CHECK_OUTPUT
 
   upvar $array_name my_tickets   
   
   set job_list ""
   foreach elem $job_list_prj1 {
      lappend job_list $elem
   }
   foreach elem $job_list_prj2 {
      lappend job_list $elem
   }
   foreach elem $job_list_prj3 {
      lappend job_list $elem
   }

   set nr_of_jobs [ llength $job_list ]

   set job_info_var ""
   foreach elem $job_list {
      unset job_info_var
      get_extended_job_info $elem job_info_var
      set my_tickets($elem) $job_info_var(tckts)
      puts -nonewline $CHECK_OUTPUT "\rjob to do: $nr_of_jobs ..."
      flush $CHECK_OUTPUT
      incr nr_of_jobs -1
   }
   puts $CHECK_OUTPUT "                        "

}

proc get_ticket_sum { job_list ticket_array_name } {
   global CHECK_OUTPUT

   upvar $ticket_array_name my_tickets

   set sum 0
   foreach elem $job_list {
      incr sum $my_tickets($elem)
   }
   return $sum
}

proc get_normalized_ticket_order { job_list_prj1 job_list_prj2 job_list_prj3 most_prior_project ticket_array_name return_array } {

   upvar  $ticket_array_name my_tickets  
   upvar  $return_array my_job_ticket_list

   set job_list ""
   foreach elem $job_list_prj1 {
      lappend job_list $elem
   }
   foreach elem $job_list_prj2 {
      lappend job_list $elem
   }
   foreach elem $job_list_prj3 {
      lappend job_list $elem
   }

   set ticket_list ""
   foreach job $job_list {
      lappend ticket_list $my_tickets($job)
   }

   set sorted_tickets [lsort -integer -decreasing $ticket_list]

   set normalized_list ""
   set last_elem ""
   foreach elem $sorted_tickets {
      if { $last_elem == $elem } {
         continue
      }
      lappend normalized_list $elem
      set last_elem $elem
   }
   set lf_nr 0
   set last_prj2_nr -1
   foreach elem $normalized_list {
      foreach job $job_list {
         if { $my_tickets($job) == $elem } {
            set project [get_project_member $job_list_prj1 $job_list_prj2 $job_list_prj3 $job]

            set my_job_ticket_list($lf_nr,project) $project
            set my_job_ticket_list($lf_nr,job_id)  $job
            set my_job_ticket_list($lf_nr,tickets) $elem
            if { $project == $most_prior_project } {
               set last_prj2_nr $lf_nr
            }
            incr lf_nr 1
         }
      } 
   }
   set my_job_ticket_list(job_count) $lf_nr 
   set my_job_ticket_list(last_prior_job_nr) $last_prj2_nr
  
   set jobs1_count 0
   set jobs2_count 0
   set jobs3_count 0
   for {set i 0} { $i <= $my_job_ticket_list(last_prior_job_nr) } {incr i 1} {   
      if { $my_job_ticket_list($i,project) == 1 } {
         incr jobs1_count 1
      }
      if { $my_job_ticket_list($i,project) == 2 } {
         incr jobs2_count 1
      }
      if { $my_job_ticket_list($i,project) == 3 } {
         incr jobs3_count 1
      }
   }
   set my_job_ticket_list(job_count_prj1) $jobs1_count
   set my_job_ticket_list(job_count_prj2) $jobs2_count
   set my_job_ticket_list(job_count_prj3) $jobs3_count


   set all_prj_count [ expr ( $jobs1_count + $jobs2_count + $jobs3_count ) ]
   set my_job_ticket_list(job_sum) $all_prj_count
   
   set all_prj_count_unit [ expr ( $all_prj_count / 100.0 ) ]
   set prj1_percentage [ expr ( $jobs1_count / $all_prj_count_unit ) ]
   set prj2_percentage [ expr ( $jobs2_count / $all_prj_count_unit ) ]
   set prj3_percentage [ expr ( $jobs3_count / $all_prj_count_unit ) ]

   set my_job_ticket_list(job_percent_prj1) $prj1_percentage     
   set my_job_ticket_list(job_percent_prj2) $prj2_percentage  
   set my_job_ticket_list(job_percent_prj3) $prj3_percentage  
 
   return $normalized_list
}



proc set_share_tree {} {
   set s_tree ""
   lappend s_tree "id=0"
   lappend s_tree "name=Root"
   lappend s_tree "type=0"
   lappend s_tree "shares=1"
   lappend s_tree "childnodes=1,4"
   lappend s_tree "id=1"
   lappend s_tree "name=node1"
   lappend s_tree "type=0"
   lappend s_tree "shares=8000"
   lappend s_tree "childnodes=2,3"
   lappend s_tree "id=2"
   lappend s_tree "name=project1"
   lappend s_tree "type=0"
   lappend s_tree "shares=4000"
   lappend s_tree "childnodes=NONE"
   lappend s_tree "id=3"
   lappend s_tree "name=project2"
   lappend s_tree "type=0"
   lappend s_tree "shares=6000"
   lappend s_tree "childnodes=NONE"
   lappend s_tree "id=4"
   lappend s_tree "name=node2"
   lappend s_tree "type=0"
   lappend s_tree "shares=2000"
   lappend s_tree "childnodes=5"
   lappend s_tree "id=5"
   lappend s_tree "name=project3"
   lappend s_tree "type=0"
   lappend s_tree "shares=10000"
   lappend s_tree "childnodes=NONE"
   return $s_tree
}


proc share_tree_setup  {} {
   global CHECK_OUTPUT
   global CHECK_PRODUCT_TYPE
   global CHECK_CORE_EXECD
   global CHECK_ARCH
   global CHECK_PRODUCT_ROOT

   if { [ string compare $CHECK_PRODUCT_TYPE "sgeee" ] != 0 } {
      set_error -3 "not available for sge system"
      return 
   }
    
   foreach elem $CHECK_CORE_EXECD {
      disable_queue "${elem}.q"
   }  
  
   set test_queue [lindex $CHECK_CORE_EXECD 0]
   set change_array(qname) "share_test"
   set change_array(hostname) $test_queue
   set change_array(slots) "1"
   set change_array(load_thresholds) "none"
   add_queue change_array fast

   set prj_setup(name) "project1"
   add_prj prj_setup

   set prj_setup(name) "project2"
   add_prj prj_setup

   set prj_setup(name) "project3"
   add_prj prj_setup

   
   set vi_commands "i" 
   set s_tree [set_share_tree]
   foreach elem $s_tree {
      lappend vi_commands "${elem}\n"
   } 
   lappend vi_commands [format "%c" 27]
   lappend  vi_commands "dddddddddddd"
   set result [ handle_vi_edit "$CHECK_PRODUCT_ROOT/bin/$CHECK_ARCH/qconf" "-astree" $vi_commands "changed sharetree" "error" ]  
   if { $result != 0 } {
      add_proc_error "share_tree_setup" -1 "could not add sharetree (error: $result)"
   }

   get_schedd_config my_config 
   set my_config(weight_tickets_share) "10000"
   set my_config(schedule_interval)    "2:0:0"
   set my_config(usage_weight_list)    "cpu=1,mem=0,io=0"
   set my_config(halftime)             "1"
   set_schedd_config my_config

   set_error 0 "ok"
}

proc get_project_member { prj1 prj2 prj3 job_id } {
   
   foreach elem $prj1 {
      if { $elem == $job_id } {
         return 1
      }
   }
   foreach elem $prj2 {
      if { $elem == $job_id } {
         return 2
      }
   }
   foreach elem $prj3 {
      if { $elem == $job_id } {
         return 3
      }
   }
   return 0
}


proc share_tree_test {} {
   global CHECK_PRODUCT_ROOT
   global CHECK_OUTPUT
   global CHECK_PRODUCT_TYPE 
   global CHECK_ARCH CHECK_TESTSUITE_ROOT
   global share_tree_job_counter CHECK_PROTOCOL_DIR
   global CHECK_SCRIPT_FILE_DIR
   global share_tree_percentage_variation

   if { [ string compare $CHECK_PRODUCT_TYPE "sgeee" ] != 0 } {
      set_error -3 "not available for sge system"
      return 
   }
   
   catch {  eval exec "$CHECK_PRODUCT_ROOT/bin/$CHECK_ARCH/qconf" "-tsm" } result

   disable_queue share_test

   set prj1_id_list ""
   set prj2_id_list ""
   set prj3_id_list ""
   set counter $share_tree_job_counter
   while { $counter > 0 } {
      lappend prj1_id_list [ submit_job "-e /dev/null -o /dev/null -P project1 $CHECK_TESTSUITE_ROOT/$CHECK_SCRIPT_FILE_DIR/worker.sh 2 $CHECK_PROTOCOL_DIR"]
      lappend prj2_id_list [ submit_job "-e /dev/null -o /dev/null -P project2 $CHECK_TESTSUITE_ROOT/$CHECK_SCRIPT_FILE_DIR/worker.sh 2 $CHECK_PROTOCOL_DIR"]
      set last_job [ submit_job "-e /dev/null -o /dev/null -P project3 $CHECK_TESTSUITE_ROOT/$CHECK_SCRIPT_FILE_DIR/worker.sh 2 $CHECK_PROTOCOL_DIR"]
      lappend prj3_id_list $last_job      
      incr counter -1
   }

   wait_for_jobpending $last_job "orker" 60

   catch {  eval exec "$CHECK_PRODUCT_ROOT/bin/$CHECK_ARCH/qconf" "-tsm" } result
   puts $CHECK_OUTPUT $result
   
   wait_for_job_tickes $last_job
   
   get_job_tickets $prj1_id_list $prj2_id_list $prj3_id_list tickets
   
   set sorted_tickets [get_normalized_ticket_order  $prj1_id_list $prj2_id_list $prj3_id_list 2 tickets answer ]
   

   if { $answer(job_count) != [ expr ( $share_tree_job_counter * 3 )]  } {
      add_proc_error "share_tree_test" "-1" "not all jobs in list"
   }

   set ticket_count 0
   for {set i 0} { $i < $answer(job_count) } {incr i 1} {
       puts $CHECK_OUTPUT "($i) tickets: $answer($i,tickets) job_id: $answer($i,job_id) project: $answer($i,project)"  
       incr ticket_count $answer($i,tickets) 
   }
   puts $CHECK_OUTPUT "SUM of tickets: $ticket_count"
   puts $CHECK_OUTPUT "last job of project 2: $answer(last_prior_job_nr)"
   puts $CHECK_OUTPUT "job counts:"
   puts $CHECK_OUTPUT "prj1: $answer(job_count_prj1)"
   puts $CHECK_OUTPUT "prj2: $answer(job_count_prj2)"
   puts $CHECK_OUTPUT "prj3: $answer(job_count_prj3)"
   puts $CHECK_OUTPUT "============"
   puts $CHECK_OUTPUT "sum : $answer(job_sum)"
   puts $CHECK_OUTPUT "percentage:"
   puts $CHECK_OUTPUT "prj1: $answer(job_percent_prj1)"
   puts $CHECK_OUTPUT "prj2: $answer(job_percent_prj2)"
   puts $CHECK_OUTPUT "prj3: $answer(job_percent_prj3)"

   set p1_abs [ expr ( int($answer(job_percent_prj1)) )  ]
   set p2_abs [ expr ( int($answer(job_percent_prj2)) )  ]
   set p3_abs [ expr ( int($answer(job_percent_prj3)) )  ]

   set x $share_tree_percentage_variation

   if { $p1_abs < [ expr ( 32 - $x ) ] || $p1_abs > [ expr ( 32 + $x ) ]  } {
      add_proc_error "share_tree_test" -1 "project1 percentage not 32 +/- $x % (value=$answer(job_percent_prj1),$p1_abs)"
   }
   if { $p2_abs < [ expr ( 48 - $x ) ] || $p2_abs > [ expr ( 48 + $x ) ] } {
      add_proc_error "share_tree_test" -1 "project2 percentage not 48 +/- $x % (value=$answer(job_percent_prj2),$p2_abs)"
   }
   if { $p3_abs < [ expr ( 20 - $x ) ] || $p3_abs > [ expr ( 20 + $x ) ] } {
      add_proc_error "share_tree_test" -1 "project3 percentage not 20 +/- $x % (value=$answer(job_percent_prj3),$p3_abs)"
   }


   foreach job $prj1_id_list {
      if { [file isfile $CHECK_PROTOCOL_DIR/$job] == 1 } {
         file delete $CHECK_PROTOCOL_DIR/$job
      }
   }
   foreach job $prj2_id_list {
      if { [file isfile $CHECK_PROTOCOL_DIR/$job] == 1 } {
         file delete $CHECK_PROTOCOL_DIR/$job
      }
   }
   foreach job $prj3_id_list {
      if { [file isfile $CHECK_PROTOCOL_DIR/$job] == 1 } {
         file delete $CHECK_PROTOCOL_DIR/$job
      }
   }

   enable_queue share_test

   set done 0
   while { $done == 0 } {
      set done 1
      set nr_of_jobs 0
      foreach job $prj2_id_list {
         set file_here [file isfile $CHECK_PROTOCOL_DIR/$job]
         if { $file_here == 0 } {
            set done 0
         } 
      }
      catch {  eval exec "$CHECK_PRODUCT_ROOT/bin/$CHECK_ARCH/qconf" "-tsm" } result
      puts -nonewline $CHECK_OUTPUT "."
      flush $CHECK_OUTPUT
      sleep 2
   }

     

 
   set prj3_count 0
   foreach job $prj3_id_list {
      if { [file isfile $CHECK_PROTOCOL_DIR/$job] == 1 } {   
         incr prj3_count 1
      }
   }

   set prj1_count 0
   foreach job $prj1_id_list {
      if { [file isfile $CHECK_PROTOCOL_DIR/$job] == 1 } {   
         incr prj1_count 1
      }
   }
   set prj2_count 0
   foreach job $prj2_id_list {
      if { [file isfile $CHECK_PROTOCOL_DIR/$job] == 1 } {   
         incr prj2_count 1
      }
   }
   puts $CHECK_OUTPUT ""
   puts $CHECK_OUTPUT "project1 count: $prj1_count"
   puts $CHECK_OUTPUT "project2 count: $prj2_count"
   puts $CHECK_OUTPUT "project3 count: $prj3_count"

   set all_prj_count [ expr ( $prj1_count + $prj2_count + $prj3_count ) ]
   puts $CHECK_OUTPUT "====================="
   puts $CHECK_OUTPUT "sum: $all_prj_count"  
 
   set all_prj_count_unit [ expr ( $all_prj_count / 100.0 ) ]

   set prj1_percentage [ expr ( $prj1_count / $all_prj_count_unit ) ]
   set prj2_percentage [ expr ( $prj2_count / $all_prj_count_unit ) ]
   set prj3_percentage [ expr ( $prj3_count / $all_prj_count_unit ) ]
  

   puts $CHECK_OUTPUT "project1 % $prj1_percentage"
   puts $CHECK_OUTPUT "project2 % $prj2_percentage"
   puts $CHECK_OUTPUT "project3 % $prj3_percentage"

   set x $share_tree_percentage_variation

   if { $prj1_percentage < [ expr ( 32 - $x ) ] || $prj1_percentage > [ expr ( 32 + $x ) ]  } {
      add_proc_error "share_tree_test" -1 "project1 running percentage not 32 +/- $x % (value=$prj1_percentage)"
   }
   if { $prj2_percentage < [ expr ( 48 - $x ) ] || $prj2_percentage > [ expr ( 48 + $x ) ] } {
      add_proc_error "share_tree_test" -1 "project2 running percentage not 48 +/- $x % (value=$prj2_percentage)"
   }
   if { $prj3_percentage < [ expr ( 20 - $x ) ] || $prj3_percentage > [ expr ( 20 + $x ) ] } {
      add_proc_error "share_tree_test" -1 "project3 running percentage not 20 +/- $x % (value=$prj3_percentage)"
   }


#   wait_for_jobstart $current_job_id "orker" 30 1
#   wait_for_jobstart $current_job_id2 "orker" 30 1
#   wait_for_jobstart $current_job_id3 "orker" 30 1

#   wait_for_jobend $current_job_id "orker" 120
#   wait_for_enter


   foreach job $prj1_id_list {
      if { [file isfile $CHECK_PROTOCOL_DIR/$job] == 1 } {
         file delete $CHECK_PROTOCOL_DIR/$job
      }
   }
   foreach job $prj2_id_list {
      if { [file isfile $CHECK_PROTOCOL_DIR/$job] == 1 } {
         file delete $CHECK_PROTOCOL_DIR/$job
      }
   }
   foreach job $prj3_id_list {
      if { [file isfile $CHECK_PROTOCOL_DIR/$job] == 1 } {
         file delete $CHECK_PROTOCOL_DIR/$job
      }
   }


   set_error 0 "ok" 

}


proc share_tree_cleanup  {} {
   global CHECK_OUTPUT
   global CHECK_PRODUCT_TYPE 
   global CHECK_CORE_EXECD 
   global CHECK_ARCH 
   global CHECK_PRODUCT_ROOT

   if { [ string compare $CHECK_PRODUCT_TYPE "sgeee" ] != 0 } {
      set_error -3 "not available for sge system"
      return 
   }

   reset_schedd_config

   catch {  eval exec "$CHECK_PRODUCT_ROOT/bin/$CHECK_ARCH/qdel" "-uall" } result
   catch {  eval exec "$CHECK_PRODUCT_ROOT/bin/$CHECK_ARCH/qconf" "-tsm" } result
   wait_for_end_of_all_jobs 60
   
   foreach elem $CHECK_CORE_EXECD {
      enable_queue "${elem}.q"
   }  

   del_queue "share_test"

   set catch_return [ catch {  
      eval exec "$CHECK_PRODUCT_ROOT/bin/$CHECK_ARCH/qconf -dstree" 
  } result ]

  puts "result: $result"
  puts "return: $catch_return "

  del_prj "project1"
  del_prj "project2"
  del_prj "project3"

  set job [ submit_job "-e /dev/null -o /dev/null $CHECK_PRODUCT_ROOT/examples/jobs/sleeper.sh 60"]
  wait_for_jobend $job "leeper" 120 0

  set_error 0 "ok"
}



