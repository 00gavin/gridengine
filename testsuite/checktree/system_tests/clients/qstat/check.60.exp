#!/vol2/TCL_TK/glinux/bin/expect
# global variables ... (defined in main check routine, but you can use it)
#___INFO__MARK_BEGIN__
##########################################################################
#
#  The Contents of this file are made available subject to the terms of
#  the Sun Industry Standards Source License Version 1.2
#
#  Sun Microsystems Inc., March, 2001
#
#
#  Sun Industry Standards Source License Version 1.2
#  =================================================
#  The contents of this file are subject to the Sun Industry Standards
#  Source License Version 1.2 (the "License"); You may not use this file
#  except in compliance with the License. You may obtain a copy of the
#  License at http://gridengine.sunsource.net/Gridengine_SISSL_license.html
#
#  Software provided under this License is provided on an "AS IS" basis,
#  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
#  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
#  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
#  See the License for the specific provisions governing your rights and
#  obligations concerning the Software.
#
#  The Initial Developer of the Original Code is: Sun Microsystems, Inc.
#
#  Copyright: 2001 by Sun Microsystems, Inc.
#
#  All Rights Reserved.
#
##########################################################################
#___INFO__MARK_END__

# Define the global veriables to give them back
global check_name check_description check_needs check_functions check_errno check_errstr 
global check_category check_root_access_needs

set check_root_access_needs  "yes"

set check_name           "qstat"
set check_category       "COMPATIBILITY SYSTEM L10N VERIFIED"
set check_description(0) "checking qstat functionality"
set check_needs          "init_core_system"      ;# dependencies of this check (name of other check)
# define a level initialization procedure:
set check_init_level_procedure "qstat_init_level"

# setup and cleanup functions
set check_setup_function "qstat_setup"
set check_cleanup_function "qstat_cleanup"

set check_functions      "";
lappend check_functions  "check_core_queues"     ;# functions to call (in order)
lappend check_functions  "qstat_option_l"
lappend check_functions  "qstat_option_q"
lappend check_functions  "qstat_option_pe"
lappend check_functions  "qstat_option_U"
lappend check_functions  "qstat_option_s"
lappend check_functions  "qstat_issue1800"
#lappend check_functions  "qstat_plain_xml_comparison"  ;# Compare the two qstat commands
#lappend check_functions  "qstat_ext_plain_xml_comparison"  ;# Compare the two qstat -ext commands
#lappend check_functions  "qstat_f_plain_xml_comparison"  ;# Compare the two qstat -f commands
#lappend check_functions  "qstat_F_plain_xml_comparison"  ;# Compare the two qstat -F commands
#lappend check_functions  "qstat_F_rerun_h_vmem_plain_xml_comparison"  ;# Compare the two qstat -F rerun,h_vmem commands
#lappend check_functions "qstat_g_c_plain_xml_comparison" ;# Compare the two qstat -g c commands
#lappend check_functions "qstat_g_d_plain_xml_comparison" ;# Compare the two qstat -g d commands
#lappend check_functions "qstat_g_t_plain_xml_comparison" ;# Compare the two qstat -g t commands

set check_errno          "-1"                    ;# 0 -> OK , != 0 means error
set check_errstr         "was never running"     ;# string for error description

# JG: TODO: we have to create an own queue for this test!

proc qstat_setup {} {
   global ts_config
   global CHECK_OUTPUT

   # First add queues "error" with one host (last).
   # Set prolog to non-existent path, and np_load_avg to 10

   if { [llength $ts_config(execd_nodes)] < 2 } {
      return -1
   }
   
   set first_host [lindex $ts_config(execd_nodes) 0]
   set last_host [lindex $ts_config(execd_nodes) 1]
                  
   puts $CHECK_OUTPUT "Adding queue wrong.q...\n"
   set wrong_queue "wrong.q"
   #set new_wrong_queue(hostlist)  "$last_host"
   add_queue $wrong_queue $last_host new_wrong_queue
   
   puts $CHECK_OUTPUT "Modifying information for wrong.q queue ...\n"
   set new_wrong_queue(prolog)  "/non/existent/path"
   set new_wrong_queue(load_thresholds)  "np_load_avg=10"
   set result1 [mod_queue $wrong_queue "" new_wrong_queue]
   
   # Add queue "empty with first host.
   # Set pe_list to NONE, and np_load_avg to 10

   puts $CHECK_OUTPUT "Adding queue empty...\n"
   #set new_empty_queue(hostlist)  "$first_host"
   set empty_queue "empty.q"
   add_queue $empty_queue $first_host new_empty_queue
   
   set new_empty_queue(pe_list)  "NONE"
   set new_empty_queue(load_thresholds)  "np_load_avg=10"
   puts $CHECK_OUTPUT "Modifying information for empty queue ...\n"
   set result2 [mod_queue $empty_queue "" new_empty_queue]

   # Check that both results are 0. If not, we return -1
   
   if { ($result1 == 0) && ($result2 == 0) } { 
      return 0
   } else {
      return -1
   }
   
}

proc qstat_cleanup {} {
   global CHECK_OUTPUT
   global ts_config

   set first_host [lindex $ts_config(execd_nodes) 0]
   set last_host [lindex $ts_config(execd_nodes) 1]

   puts $CHECK_OUTPUT "Deleting  wrong.q queue ...\n"
   del_queue "wrong.q" $last_host 1
   
   puts $CHECK_OUTPUT "Deleting  empty.q queue ...\n"
   del_queue "empty.q" $first_host 1

   return 0
}

proc qstat_init_level {} {
   global CHECK_ACT_LEVEL

   if {$CHECK_ACT_LEVEL == 0} {
      return 0
   }

   return -1
}

#                                                             max. column:     |
#****** qstat/get_numb_proc() ******
# 
#  NAME
#     get_numb_proc -- ??? 
#
#  SYNOPSIS
#     get_numb_proc { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc get_numb_proc {} {
  global CHECK_PRODUCT_ROOT ts_config CHECK_USER
  set result ""
  
  set check_host [lindex $ts_config(execd_nodes) 0]
  set check_arch [resolve_arch $check_host]
  set loadcheck_binary $ts_config(product_root)/utilbin/$check_arch/loadcheck
  set result [start_remote_prog $check_host $CHECK_USER $loadcheck_binary "" ]

#
#Original output of loadcheck looks like this:
#>loadcheck 
#arch            irix6
#num_proc        1
  
  # split each line as listelement
  set help [split $result "\n"]

  foreach elem $help {
     if {[string compare [lindex $elem 0] "num_proc"] == 0} {
        set numproc [lindex $elem 1]
     }
  }

  return $numproc    
}

#****** check/qstat_count_jobs() ***********************************************
#  NAME
#     qstat_count_jobs() -- count the jobs of the qstat output with the
#                           given options 
#
#  SYNOPSIS
#     qstat_count_jobs { func_name qstat_options expected_jobs } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#     func_name     - name of the calling function. needed for add_proc_error 
#     qstat_options - options for qstat 
#     expected_jobs - the nr of the expected job count
#
#*******************************************************************************
proc qstat_count_jobs { func_name qstat_options expected_jobs } {
   global ts_config CHECK_OUTPUT CHECK_USER
   set arch [ resolve_arch $ts_config(master_host) ]
   
   puts $CHECK_OUTPUT "\nrunning qstat $qstat_options"
   set result [ start_remote_prog $ts_config(master_host) $CHECK_USER "$ts_config(product_root)/bin/$arch/qstat" "$qstat_options" exit_code ]
   puts $CHECK_OUTPUT $result
   if { $exit_code == 0 } {
      if { [info exists jobinfo] } {
         unset jobinfo
      }  
      parse_qstat result jobinfo "" 0
      set shown_jobs [ split $jobinfo(index) "," ]
      set nr_jobs [llength $shown_jobs]
      # parse_qstat add always a "<jobid>,". Split then returns <jobnr>+1 so we need to adjust the nr of jobs. 
      if { $nr_jobs > 0 } {
         incr nr_jobs -1
      }
      puts $CHECK_OUTPUT "number of jobs: $nr_jobs"
      if { $nr_jobs != $expected_jobs } {
         add_proc_error "$func_name" -1 "qstat $qstat_options broken, got $nr_jobs but expected $expected_jobs"
      }
   } else {
      add_proc_error "$func_name" -1 "qstat $qstat_options exit status not 0"
   }
}

# here starts the test
#                                                             max. column:     |
#****** qstat/check_core_queues() ******
# 
#  NAME
#     check_core_queues -- ??? 
#
#  SYNOPSIS
#     check_core_queues { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc check_core_queues {} {
  global check_errno check_errstr CHECK_PRODUCT_ROOT CHECK_CORE_EXECD CHECK_OUTPUT
  global ts_config CHECK_USER

  set check_host [lindex $ts_config(execd_nodes) 0]

  wait_for_load_from_all_queues 300

  set result ""

  set check_arch [resolve_arch $check_host]
  set qstat_binary $ts_config(product_root)/bin/$check_arch/qstat

  set result [start_remote_prog $check_host $CHECK_USER $qstat_binary "-f" ]
#
#Original output of qstat -f looks like this:
#>qstat -f
#queuename            qtype used/tot. load_avg arch    states
#----------------------------------------------------------------------------
#all.q@balrog             BI    0/2       1.42     solaris64 
#----------------------------------------------------------------------------
#all.q@dwain              BI    1/1       2.00     irix6     a
#     2     0 Sleeper    crei         r     05/15/2000 13:09:48 MASTER           
#
############################################################################
# - PENDING JOBS - PENDING JOBS - PENDING JOBS - PENDING JOBS - PENDING JOBS
############################################################################
#     3     0 Sleeper    crei         qw    05/15/2000 13:09:49          

  # split each line as listelement
  set help [split $result "\n"]
 
  #remove first line
  set help [lreplace $help 0 0]
  set data ""

  #get every line after "----..." line 
  set len [llength $help]
  for {set ind 0} {$ind < $len } {incr ind 1} {
     if {[lsearch [lindex $help $ind] "------*"] >= 0 } {
        lappend data [lindex $help [expr ( $ind + 1 )]] 
     }
  }


  set qcount [ llength $data]
  set qnames ""
  set slots ""
  set load ""

  # get line data information for queuename used/tot and load_avg
  foreach elem $data {
     set linedata $elem
     lappend qnames [lindex $linedata 0]
     set used_tot [lindex $linedata 2]
     set pos1 [ expr ( [string first "/" $used_tot] + 1 ) ]
     set pos2 [ expr ( [string length $used_tot]          - 1 ) ]

     lappend slots [string range $used_tot $pos1 $pos2 ]
     lappend load [lindex $linedata 3]
  }
 
  

  # check if number of queues matches core system queue count
  if { [llength $CHECK_CORE_EXECD] != $qcount } {
     set_error -1 "check_core_queues - queue count doesn't match (number of queues should be [llength $CHECK_CORE_EXECD])"
     return
  }

  # check if slots for host $check_host are correct (needs successfully tested "loadcheck" check)
  set numofproc [get_numb_proc]
  set queue_name "all.q@[resolve_host $check_host 1]"
  puts $CHECK_OUTPUT "got $numofproc slots"
  if { [lindex $slots [lsearch $qnames $queue_name] ] != [expr ( $numofproc * 10 )] } {
     set_error -1 "check_core_queues - queue $queue_name shoud have [expr ( $numofproc * 10 )] slots) (cpu count * 10)"
     return
  } 

  # check if load of an host is set > 99 (no exed report)
  set ind 0
  foreach elem $load {
    if {$elem >= 99} {
       set_error -1 "check_core_queues - queue [lindex $qnames $ind] has load > 99"
       return
    }
    incr ind 1
  }

  puts $CHECK_OUTPUT "check_core_queues\n- number of queues: $qcount\n- qnames: $qnames\n- slots: $slots\n- load: $load"

  # ok - no errors, very very nice ;-) 
  set_error 0 "check_core_queues - no errors"
}

proc qstat_option_l {} {
  global CHECK_OUTPUT CHECK_CORE_EXECD CHECK_PRODUCT_ROOT

  puts $CHECK_OUTPUT "checking qstat -l option ..."

  set my_arch [resolve_arch [lindex $CHECK_CORE_EXECD 0]]

  puts $CHECK_OUTPUT "submitting job requesting arch=$my_arch ..."   
  
  set job_id_list ""
  set arguments "-o /dev/null -e /dev/null -h -l arch=$my_arch"
  set job_id [ submit_job "$arguments $CHECK_PRODUCT_ROOT/examples/jobs/sleeper.sh 1000" ]
  lappend job_id_list $job_id
  set job_id [ submit_job "$arguments $CHECK_PRODUCT_ROOT/examples/jobs/sleeper.sh 1000" ]
  lappend job_id_list $job_id
  set job_id [ submit_job "$arguments $CHECK_PRODUCT_ROOT/examples/jobs/sleeper.sh 1000" ]
  lappend job_id_list $job_id

  puts $CHECK_OUTPUT "submitting job requesting arch=undefined_arch ..."  
  set arguments "-o /dev/null -e /dev/null -h -l arch=undefined_arch"
  set job_id [ submit_job "$arguments $CHECK_PRODUCT_ROOT/examples/jobs/sleeper.sh 1000" ]
  lappend job_id_list $job_id
    
   qstat_count_jobs "qstat_option_l" "-l arch=$my_arch" 3 

   qstat_count_jobs "qstat_option_l" "-l arch=undefined_arch" 0 

  delete_all_jobs

  set_error 0 "ok"
}

proc qstat_option_q {} {
  global CHECK_OUTPUT CHECK_CORE_EXECD CHECK_PRODUCT_ROOT

  puts $CHECK_OUTPUT "checking qstat -q option ..."

  puts $CHECK_OUTPUT "submitting jobs requesting each queue ..."   
  set job_id_list ""
  set counter 0
  foreach host $CHECK_CORE_EXECD {
     set qname [get_queue_instance all.q ${host}]
     puts $CHECK_OUTPUT "\nsubmitting -q $qname ..."
     
     set arguments "-o /dev/null -e /dev/null -h -q $qname"
     set job_id [ submit_job "$arguments $CHECK_PRODUCT_ROOT/examples/jobs/sleeper.sh 1000" ]
     lappend job_id_list $job_id
     set queue_job_array($qname) $job_id
  }

  foreach host $CHECK_CORE_EXECD {
     set qname [get_queue_instance all.q ${host}]
     qstat_count_jobs "qstat_option_q" "-q $qname" 1 
  }

  delete_all_jobs
 
  wait_for_end_of_all_jobs 60

  set_error 0 "ok"
}


proc qstat_option_pe {} {
   global CHECK_OUTPUT CHECK_CORE_EXECD CHECK_PRODUCT_ROOT

   puts $CHECK_OUTPUT "checking qstat -pe option ..."

   set hostname [lindex $CHECK_CORE_EXECD 0]

   set testq(load_thresholds) "np_load_avg=7.00"
   set testq(slots) 10
   add_queue test1.q $hostname testq

   set mype1(pe_name) "mype1"
   set mype1(slots) 6 
   set mype1(allocation_rule) "\$pe_slots"
   add_pe mype1
   assign_queues_with_pe_object test1.q $hostname mype1

   add_queue test2.q $hostname testq

   set mype2(pe_name) "mype2"
   set mype2(slots) 2
   set mype2(allocation_rule) "\$pe_slots"
   add_pe mype2
   assign_queues_with_pe_object test2.q $hostname mype2

   puts $CHECK_OUTPUT "submitting job requesting pe mype1 ..."   
  
   set job_id_list ""
   set arguments "-o /dev/null -e /dev/null -pe mype1 2"
   set job_id [ submit_job "$arguments $CHECK_PRODUCT_ROOT/examples/jobs/sleeper.sh 1000" ]
   lappend job_id_list $job_id
   set job_id [ submit_job "$arguments $CHECK_PRODUCT_ROOT/examples/jobs/sleeper.sh 1000" ]
   lappend job_id_list $job_id
   set job_id [ submit_job "$arguments $CHECK_PRODUCT_ROOT/examples/jobs/sleeper.sh 1000" ]
   lappend job_id_list $job_id


   puts $CHECK_OUTPUT "submitting job requesting pe mype2 ..."  
   set arguments "-o /dev/null -e /dev/null -pe mype2 2"
   set job_id [ submit_job "$arguments $CHECK_PRODUCT_ROOT/examples/jobs/sleeper.sh 1000" ]
   lappend job_id_list $job_id
   wait_for_jobstart $job_id "Sleeper" 60
  
   qstat_count_jobs "qstat_option_pe" "-pe mype1" 3
   
   qstat_count_jobs "qstat_option_pe" "-pe mype2" 1 
   
   delete_all_jobs
   
   foreach jobid $job_id_list {
      wait_for_jobend $jobid "Sleeper" 60 0 1
   }
      
   del_pe mype1
   del_pe mype2

   del_queue test1.q $hostname 0 1
   del_queue test2.q $hostname 0 1

   set_error 0 "ok"
}


proc qstat_option_U {} {
  global CHECK_OUTPUT CHECK_CORE_EXECD CHECK_PRODUCT_ROOT
  global CHECK_USER CHECK_FIRST_FOREIGN_SYSTEM_USER

  puts $CHECK_OUTPUT "checking qstat -U option ..."

  set hostname [lindex $CHECK_CORE_EXECD 0]

  set testq(load_thresholds) "np_load_avg=7.00"
  set testq(slots) 10
  set testq(user_lists) deadlineusers 
  add_queue test.q $hostname testq
  set qname [get_queue_instance test.q $hostname]

  puts $CHECK_OUTPUT "submitting jobs as user $CHECK_USER ..."   
  
  set job_id_list ""
  set arguments "-o /dev/null -e /dev/null -h -q $qname"
  set job_id [ submit_job "$arguments $CHECK_PRODUCT_ROOT/examples/jobs/sleeper.sh 1000" 1 30 "" $CHECK_USER]
  lappend job_id_list $job_id
  set job_id [ submit_job "$arguments $CHECK_PRODUCT_ROOT/examples/jobs/sleeper.sh 1000" 1 30 "" $CHECK_USER]
  lappend job_id_list $job_id
  set job_id [ submit_job "$arguments $CHECK_PRODUCT_ROOT/examples/jobs/sleeper.sh 1000" 1 30 "" $CHECK_USER]
  lappend job_id_list $job_id


  puts $CHECK_OUTPUT "submitting job as user $CHECK_FIRST_FOREIGN_SYSTEM_USER ..."  
  set arguments "-o /dev/null -e /dev/null -h -q $qname"
  set job_id [ submit_job "$arguments $CHECK_PRODUCT_ROOT/examples/jobs/sleeper.sh 1000" 1 30 "" $CHECK_FIRST_FOREIGN_SYSTEM_USER]
  lappend job_id_list $job_id
  
  qstat_count_jobs "qstat_option_U" "-U $CHECK_USER" 4

  qstat_count_jobs "qstat_option_U" "-U $CHECK_FIRST_FOREIGN_SYSTEM_USER" 0

  delete_all_jobs

  wait_for_end_of_all_jobs 60

  del_queue test.q $hostname 0 1

  set_error 0 "ok"
  
  
  
}

proc qstat_option_s {} {
  global ts_config CHECK_OUTPUT CHECK_USER 

  set arch [ resolve_arch $ts_config(master_host) ]

  puts $CHECK_OUTPUT "submitting a long running batch job ..."   
  set job_id_list ""
  set arguments "-o /dev/null -e /dev/null"
  set job_id [ submit_job "$arguments $ts_config(product_root)/examples/jobs/sleeper.sh 100000" ]
  wait_for_jobstart $job_id "Sleeper" 60

  puts $CHECK_OUTPUT "submitting & suspending a batch job ..."   
  set job_id_list ""
  set arguments "-o /dev/null -e /dev/null"
  set job_id [ submit_job "$arguments $ts_config(product_root)/examples/jobs/sleeper.sh 100000" ]
  wait_for_jobstart $job_id "Sleeper" 60
  set result [ start_remote_prog $ts_config(master_host) $CHECK_USER "$ts_config(product_root)/bin/$arch/qmod" "-s $job_id" exit_code ]

  puts $CHECK_OUTPUT "submitting an user hold batch job ..."   
  set job_id_list ""
  set arguments "-h -o /dev/null -e /dev/null"
  set job_id [ submit_job "$arguments $ts_config(product_root)/examples/jobs/sleeper.sh 1000" ]

  puts $CHECK_OUTPUT "submitting an system hold batch job ..."   
  set job_id_list ""
  set arguments "-h -o /dev/null -e /dev/null"
  set job_id [ submit_job "$arguments $ts_config(product_root)/examples/jobs/sleeper.sh 1000" ]
  set result [ start_remote_prog $ts_config(master_host) $CHECK_USER "$ts_config(product_root)/bin/$arch/qalter" "-h s $job_id" exit_code ]
  set result [ start_remote_prog $ts_config(master_host) $CHECK_USER "$ts_config(product_root)/bin/$arch/qalter" "-h U $job_id" exit_code ]

  puts $CHECK_OUTPUT "submitting an operator hold batch job ..."   
  set job_id_list ""
  set arguments "-h -o /dev/null -e /dev/null"
  set job_id [ submit_job "$arguments $ts_config(product_root)/examples/jobs/sleeper.sh 1000" ]
  set result [ start_remote_prog $ts_config(master_host) $CHECK_USER "$ts_config(product_root)/bin/$arch/qalter" "-h o $job_id" exit_code ]
  set result [ start_remote_prog $ts_config(master_host) $CHECK_USER "$ts_config(product_root)/bin/$arch/qalter" "-h U $job_id" exit_code ]

  puts $CHECK_OUTPUT "submitting an dependency hold batch job ..."   
  set job_id_list ""
  set arguments "-hold_jid \"Sleeper\" -o /dev/null -e /dev/null"
  set job_id [ submit_job "$arguments $ts_config(product_root)/examples/jobs/sleeper.sh 1000" ]

  #-s a
  qstat_count_jobs "qstat_option_s" "-s a" 6

  #-s h
  qstat_count_jobs "qstat_option_s" "-s h" 4 

  #-s hu
  qstat_count_jobs "qstat_option_s" "-s hu" 1 

  #-s hs
  qstat_count_jobs "qstat_option_s" "-s hs" 1 

  #-s ho
  qstat_count_jobs "qstat_option_s" "-s ho" 1 

  #-s hj
  qstat_count_jobs "qstat_option_s" "-s hj" 1 

  #-s p
  qstat_count_jobs "qstat_option_s" "-s p" 4 

  #-s r
  qstat_count_jobs "qstat_option_s" "-s r" 1 

  #-s s 
  qstat_count_jobs "qstat_option_s" "-s s" 1 

  #-s ha
  puts $CHECK_OUTPUT "submitting an date hold batch job ..."   
  set job_id_list ""
  set arguments "-a 01011000 -o /dev/null -e /dev/null"
  set job_id [ submit_job "$arguments $ts_config(product_root)/examples/jobs/sleeper.sh 1000" ]
  qstat_count_jobs "qstat_option_s" "-s ha" 1 

  #TODO test critical states & combinations

  delete_all_jobs
  set_error 0 "ok"
}

proc qstat_issue1800 {} {
  global ts_config CHECK_OUTPUT CHECK_USER 

  set arch [ resolve_arch $ts_config(master_host) ]
  set first_host [ lindex $ts_config(execd_nodes) 0 ]
   
  puts $CHECK_OUTPUT "submitting an array job ..."   
  set job_id_list ""
  set arguments "-l h=$first_host -o /dev/null -e /dev/null -t 1-1000"
  set job_id [ submit_job "$arguments $ts_config(product_root)/examples/jobs/sleeper.sh 1000" ]

  wait_for_jobstart $job_id "Sleeper" 60
  qstat_count_jobs "qstat_issue1800" "-s p" 1 

  qstat_count_jobs "qstat_issue1800" "-s hu" 0 
  set result [ start_remote_prog $ts_config(master_host) $CHECK_USER "$ts_config(product_root)/bin/$arch/qalter" "-h u $job_id" exit_code ]
  qstat_count_jobs "qstat_issue1800" "-s hu" 1 

  qstat_count_jobs "qstat_issue1800" "-s hs" 0 
  set result [ start_remote_prog $ts_config(master_host) $CHECK_USER "$ts_config(product_root)/bin/$arch/qalter" "-h s $job_id" exit_code ]
  qstat_count_jobs "qstat_issue1800" "-s hs" 1 
   
  qstat_count_jobs "qstat_issue1800" "-s ho" 0 
  set result [ start_remote_prog $ts_config(master_host) $CHECK_USER "$ts_config(product_root)/bin/$arch/qalter" "-h o $job_id" exit_code ]
  qstat_count_jobs "qstat_issue1800" "-s ho" 1 

  delete_all_jobs
  set_error 0 "ok"
}


#****** qstat/qstat_plain_xml_comparison() ***********************************************
#  NAME
#     qstat_plain_xml_comparison() -- Compare plain and XML ouptout of qstat
#     command.
#
#  SYNOPSIS
#     qstat_plain_xml_comparison { }. The assoc. array has entries for jobid, prio, name, user, state,
#     submit_time, start_time and, if present, queue, slots, task_id. We also
#     accumuluate the jobids in output(jobid_list).
#
#  FUNCTION
#     Compare plain and XML ouptout of qstat command
#
#  INPUTS
#
#*******************************************************************************

proc qstat_plain_xml_comparison {} {
      global ts_config CHECK_OUTPUT CHECK_ACTUAL_TEST_PATH CHECK_USER output_result 

      set hostname [lindex $ts_config(execd_nodes) 0]
      
      # Run some jobs      
      set result_local_return [start_remote_prog $hostname $CHECK_USER "$CHECK_ACTUAL_TEST_PATH/qsub.sh" ""]
      
     
      # Wait a little for jobs to be scheduled.
      sleep 5

      # qstat_plain_output contains the plain qstat output in an assoc. array
      # qstat_plain_output(jobid) contains a list of jobids.
      set result1 [qstat_plain_parse qstat_plain_output]
      
      puts $CHECK_OUTPUT "plain qstat array .... \n"
      parray qstat_plain_output
      
      # qstat_xml_output contains the XML qstat output in an assoc. array
      set result2 [qstat_xml_parse qstat_xml_output]
      
      puts $CHECK_OUTPUT "xml qstat array .... \n"
      parray qstat_xml_output

      # Now let's compare them by jobid. For now we skip the last entry
      # due to bug in parse_qstat. See IZ 2024.
      #set jobid_list $qstat_plain_output(index)
      set jobid_list [lrange $qstat_plain_output(index) 0 end-1]
      
      # We skip the task_id comparison also due to a bug in parse_qstat,
      # See IZ 2052 for details.
      set column_vars "prior name user state time queue master"

      set error_flag 0
      
      foreach jobid $jobid_list {
   
         foreach column $column_vars {
            # Need to put $jobid$column since $jobid contains a "," already!
            # For columns state, queue and master, trim the trailing blanks
            
            # For queue or master values, need to trim XML output to match
            # the plain output.
            
         
            if { ($column == "state") || ($column == "queue") || ($column == "master") } {
               set qstat_xml_output($jobid$column) [string trim $qstat_xml_output($jobid$column)]
            }
            
            
            if { $qstat_plain_output($jobid$column) != $qstat_xml_output($jobid$column) } {
               puts $CHECK_OUTPUT "Plain output and XML output DO NOT agree for jobid $jobid ...\n"
               puts $CHECK_OUTPUT "and column $column... \n"
               puts $CHECK_OUTPUT "qstat_plain_output was $qstat_plain_output($jobid$column)... \n"
               puts $CHECK_OUTPUT "while qstat_xml_output was $qstat_xml_output($jobid$column)... \n"
               incr error_flag 1
            } 
         }
      }
   if { $error_flag == 0 } {  
      set_error 0 "ok"      
   } else {
      set_error -1 "error in plain, XML qstat"
   }
   
   delete_all_jobs
   
}

#****** qstat/qstat_ext_plain_xml_comparison() ***********************************************
#  NAME
#     qstat_ext_plain_xml_comparison() -- Compare plain and XML ouptout of
#     "qstat -ext" command.
#
#  SYNOPSIS
#     qstat_ext_plain_xml_comparison { }. The assoc. array has entries for jobid, prio, name, user, state,
#     submit_time, start_time and, if present, queue, slots, task_id. We also
#     accumuluate the jobids in output(jobid_list).
#
#  FUNCTION
#     Compare plain and XML ouptout of "qstat -ext" command
#
#  INPUTS
#
#*******************************************************************************

proc qstat_ext_plain_xml_comparison {} {
      global ts_config CHECK_OUTPUT CHECK_ACTUAL_TEST_PATH CHECK_USER output_result 

      set hostname [lindex $ts_config(execd_nodes) 0]
      
      # Run some jobs      
      set result_local_return [start_remote_prog $hostname $CHECK_USER "$CHECK_ACTUAL_TEST_PATH/qsub.sh" ""]
      
     
      # Wait a little for jobs to be scheduled.
      sleep 5

      # qstat_ext_plain_output contains the plain qstat output in an assoc. array
      # qstat_ext_plain_output(jobid) contains a list of jobids.
      set result1 [qstat_ext_plain_parse qstat_ext_plain_output]
      
      puts $CHECK_OUTPUT "plain qstat -ext array .... \n"
      parray qstat_ext_plain_output
      
      # qstat_ext_xml_output contains the XML qstat output in an assoc. array
      set result2 [qstat_ext_xml_parse qstat_ext_xml_output]
      
      puts $CHECK_OUTPUT "xml qstat -ext array .... \n"
      parray qstat_ext_xml_output

      # Now let's compare them by jobid. For now we skip the last entry
      # due to bug in parse_qstat. See IZ 2024.
      # For this case, let's skip the FIRST entry! New bug in parse_multiline_list
      set jobid_list [lrange $qstat_ext_plain_output(jobid_list) 1 end]
      
      #set column_vars "prior name user state time queue master"
      set column_vars "prior ntckts name user project department state cpu mem io  \
                       tckts ovrts otckt ftckt stckt share queue slots task_id"

      set error_flag 0
      
      foreach jobid $jobid_list {
   
         foreach column $column_vars {
            # For columns state, queue and slots, trim the trailing blanks
            # For queue or slots values, need to trim XML output to match
            # the plain output.
            if { ($column == "cpu") || ($column == "mem") || ($column == "io") || ($column == "state") || \
                 ($column == "queue") || ($column == "slots") || ($column == "task_id") } {
               append qstat_ext_xml_output($jobid,$column) " " 
               set qstat_ext_xml_output($jobid,$column) [string trim $qstat_ext_xml_output($jobid,$column)]
               set qstat_ext_plain_output($jobid,$column) [string trim $qstat_ext_plain_output($jobid,$column)]

            }
            # Add this to fix mismatch between plain, XML output for empty project name
            # See IZ 
            if { ($column == "project") && ($qstat_ext_xml_output($jobid,$column) == "") } {
               set qstat_ext_xml_output($jobid,$column) "NA"
            }   
            # Trim trailing blanks in plain output.
            set qstat_ext_plain_output($jobid,$column) [string trim $qstat_ext_plain_output($jobid,$column)]
            if { $qstat_ext_plain_output($jobid,$column) != $qstat_ext_xml_output($jobid,$column) } {
               if { ($column == "department") && ([string first $qstat_ext_plain_output($jobid,$column) \
                     $qstat_ext_xml_output($jobid,$column)] >=0) } {
                  continue ; # plain parsing is incomplete for column "department"
               }
               puts $CHECK_OUTPUT "Plain output and XML output DO NOT agree for jobid $jobid ...\n"
               puts $CHECK_OUTPUT "and column $column... \n"
               puts $CHECK_OUTPUT "qstat_ext_plain_output was $qstat_ext_plain_output($jobid,$column)... \n"
               puts $CHECK_OUTPUT "while qstat_ext_xml_output was $qstat_ext_xml_output($jobid,$column)... \n"
               incr error_flag 1
            } 
         }
      }
   if { $error_flag == 0 } {  
      set_error 0 "ok"      
   } else {
      set_error -1 "error in plain, XML qstat -ext"
   }
   
   delete_all_jobs
   
}


#****** qstat/qstat_f_plain_xml_comparison() ***********************************************
#  NAME
#     qstat_f_plain_xml_comparison() -- Compare plain and XML ouptout of qstat -f
#     command.
#
#  SYNOPSIS
#     qstat_f_plain_xml_comparison { }. The assoc. array has entries for queues
#     and jobs. For queues, we look at qname, qtype, total_slots, used_slots,
#     load_avg, arch, and  state. For jobs, we look at jobid, prio, name, user, state,
#     submit_time, start_time and, if present, slots, task_id. We also
#     accumuluate the queue names in output(queue_list) and  jobids in output(jobid_list).
#
#  FUNCTION
#     Compare plain and XML ouptout of qstat command
#
#  INPUTS
#
#*******************************************************************************

proc qstat_f_plain_xml_comparison {} {
      global ts_config CHECK_OUTPUT CHECK_ACTUAL_TEST_PATH CHECK_USER output_result

      set hostname [lindex $ts_config(execd_nodes) 0]

      # Run some jobs
      set result_local_return [start_remote_prog $hostname $CHECK_USER "$CHECK_ACTUAL_TEST_PATH/qsub.sh" ""]

      # Wait a little for jobs to be scheduled.
      sleep 10
      
      # Clear error states, if any
      set result1 [start_sge_bin "qmod" "-c all.q"]

      # qstat_f_plain_output contains the plain qstat -f output in an assoc. array
      # qstat_f_plain_output(jobid) contains a list of jobids.

      set result1 [qstat_f_plain_parse qstat_f_plain_output]

      puts $CHECK_OUTPUT "plain qstat -f array .... \n"
      parray qstat_f_plain_output

      # qstat_f_xml_output contains the XML qstat output in an assoc. array
      set result2 [qstat_f_xml_parse qstat_f_xml_output]

      puts $CHECK_OUTPUT "xml qstat -f array .... \n"
      parray qstat_f_xml_output

      #Now let's compare them by jobid

      set jobid_list [lrange $qstat_f_plain_output(jobid_list) 0 end]
      
      set plain_jobid_length [llength $qstat_f_plain_output(jobid_list) ]
      set xml_jobid_length [llength $qstat_f_xml_output(jobid_list) ]

      set column_vars "prior name user state time slots task_id" ;  # queue" ; # slots task_id"

      set error_flag 0
      
      # Check that we have same number of jobs in plain listing as in XML listing
      if { ($plain_jobid_length != $xml_jobid_length) } {
          incr error_flag 1
      }
      
      #delete_all_jobs
      
      foreach jobid $jobid_list {
   
         foreach column $column_vars {
            append qstat_f_xml_output($jobid,task_id) ""
            set qstat_f_xml_output($jobid,task_id) [string trim $qstat_f_xml_output($jobid,task_id)]
            set qstat_f_plain_output($jobid,task_id) [string trim $qstat_f_plain_output($jobid,task_id)]
 
            if { $qstat_f_plain_output($jobid,$column) != $qstat_f_xml_output($jobid,$column) } {
               puts $CHECK_OUTPUT "Plain output and XML output DO NOT agree for jobid $jobid ...\n"
               puts $CHECK_OUTPUT "and column $column... \n"
               puts $CHECK_OUTPUT "qstat_plain_output was $qstat_f_plain_output($jobid,$column)... \n"
               puts $CHECK_OUTPUT "while qstat_xml_output was $qstat_f_xml_output($jobid,$column)... \n"
               incr error_flag 1
            } 
         }   
      }
      
      
   # Now compare the queue information output   
   set queue_list [lrange $qstat_f_plain_output(queue_list) 0 end]
   
   set plain_queue_length [llength $qstat_f_plain_output(queue_list)]
   set xml_queue_length [llength $qstat_f_xml_output(queue_list)]
   
   # Check that we have same number of queues in plain listing as in XML listing
   if { ($plain_queue_length != $xml_queue_length) } {
      incr error_flag 1
   } 
   
   set column_vars "qname qtype total_slots used_slots load_avg arch state"

   foreach queue $queue_list {
   
      foreach column $column_vars {
         
         if { $qstat_f_plain_output($queue,$column) != $qstat_f_xml_output($queue,$column) } {
            puts $CHECK_OUTPUT "Plain output and XML output DO NOT agree for queue $queue ...\n"
            puts $CHECK_OUTPUT "and column $column... \n"
            puts $CHECK_OUTPUT "qstat_plain_output was $qstat_f_plain_output($queue,$column)... \n"
            puts $CHECK_OUTPUT "while qstat_xml_output was $qstat_f_xml_output($queue,$column)... \n"
            incr error_flag 1
         } 
      }   
   }
   
   if { $error_flag == 0 } {
      set_error 0 "ok"
   } else {
      set_error -1 "error in plain, XML qstat -f"
   }

   # Delete all jobs
   delete_all_jobs

}


#****** qstat/qstat_F_plain_xml_comparison() ***********************************************
#  NAME
#     qstat_F_plain_xml_comparison() -- Compare plain and XML ouptout of qstat -F
#     command.
#
#  SYNOPSIS
#     qstat_F_plain_xml_comparison { }. The assoc. array has entries for queues
#     and jobs. For queues, we look at qname, qtype, total_slots, used_slots,
#     load_avg, arch, and  state. For jobs, we look at jobid, prio, name, user, state,
#     submit_time, start_time and, if present, slots, task_id. We also
#     accumuluate the queue names in output(queue_list) and  jobids in output(jobid_list).
#     We also accumulate the compexes by queue and compare them.
#  FUNCTION
#     Compare plain and XML ouptout of qstat command
#
#  INPUTS
#
#*******************************************************************************

proc qstat_F_plain_xml_comparison {} {
      global ts_config CHECK_OUTPUT CHECK_ACTUAL_TEST_PATH CHECK_USER output_result

      set hostname [lindex $ts_config(execd_nodes) 0]

      # Run some jobs
      set result_local_return [start_remote_prog $hostname $CHECK_USER "$CHECK_ACTUAL_TEST_PATH/qsub.sh" ""]

      # Wait a little for jobs to be scheduled.
      sleep 15
      
      # Clear error states, if any
      set result1 [start_sge_bin "qmod" "-c all.q"]

      # qstat_F_plain_output contains the plain qstat -F output in an assoc. array
      # qstat_F_plain_output(jobid_list) contains a list of jobids.

      set result1 [qstat_F_plain_parse qstat_F_plain_output ""]

      puts $CHECK_OUTPUT "plain qstat -F array .... \n"
      parray qstat_F_plain_output

      # qstat_F_xml_output contains the XML qstat output in an assoc. array
      set result2 [qstat_F_xml_parse qstat_F_xml_output ""]

      puts $CHECK_OUTPUT "xml qstat -F array .... \n"
      parray qstat_F_xml_output

      #puts $CHECK_OUTPUT "plain jobid's are these: $qstat_F_plain_output(jobid_list) ...\n"
      #puts $CHECK_OUTPUT "xml jobid's are these: $qstat_F_xml_output(jobid_list) ...\n"

      #Now let's compare them by jobid

      set jobid_list [lrange $qstat_F_plain_output(jobid_list) 0 end]
      
      set plain_jobid_length [llength $qstat_F_plain_output(jobid_list)]
      set xml_jobid_length [llength $qstat_F_xml_output(jobid_list)]

      set column_vars "prior name user state time slots task_id" ; 

      set error_flag 0
      
      # Check that we have same number of jobs in plain listing as in XML listing
      if { ($plain_jobid_length != $xml_jobid_length) } {
          incr error_flag 1
      }
            
      foreach jobid $jobid_list {
   
         foreach column $column_vars {
            append qstat_F_xml_output($jobid,task_id) ""
            set qstat_F_xml_output($jobid,task_id) [string trim $qstat_F_xml_output($jobid,task_id)]
            set qstat_F_plain_output($jobid,task_id) [string trim $qstat_F_plain_output($jobid,task_id)]
 
            if { $qstat_F_plain_output($jobid,$column) != $qstat_F_xml_output($jobid,$column) } {
               puts $CHECK_OUTPUT "Plain output and XML output DO NOT agree for jobid $jobid ...\n"
               puts $CHECK_OUTPUT "and column $column... \n"
               puts $CHECK_OUTPUT "qstat_plain_output was $qstat_F_plain_output($jobid,$column)... \n"
               puts $CHECK_OUTPUT "while qstat_xml_output was $qstat_F_xml_output($jobid,$column)... \n"
               incr error_flag 1
            } 
         }   
      }
      
      
   # Now compare the queue information output   
   set queue_list [lrange $qstat_F_plain_output(queue_list) 0 end]
   
   set plain_queue_length [llength $qstat_F_plain_output(queue_list)]
   set xml_queue_length [llength $qstat_F_xml_output(queue_list)]
   
   # Check that we have same number of queues in plain listing as in XML listing
   if { ($plain_queue_length != $xml_queue_length) } {
      incr error_flag 1
   } 
   
   # Comment out state, which is not seen in XML output!
   #set column_vars "qname qtype total_slots used_slots load_avg arch state"
   set column_vars "qname qtype total_slots used_slots load_avg arch \
                    qf:qname qf:hostname qc:slots qf:tmpdir qf:seq_no qf:rerun qf:calendar \
                    qf:s_rt qf:h_rt qf:s_cpu qf:h_cpu qf:s_fsize qf:h_fsize qf:s_data \
                    qf:h_data qf:s_stack qf:h_stack qf:s_core qf:h_core qf:s_rss \
                    qf:h_rss qf:s_vmem qf:h_vmem qf:min_cpu_interval"
   
   foreach queue $queue_list {
   
      foreach column $column_vars {
         
         if { $qstat_F_plain_output($queue,$column) != $qstat_F_xml_output($queue,$column) } {
            puts $CHECK_OUTPUT "Plain output and XML output DO NOT agree for queue $queue ...\n"
            puts $CHECK_OUTPUT "and column $column... \n"
            puts $CHECK_OUTPUT "qstat_plain_output was $qstat_F_plain_output($queue,$column)... \n"
            puts $CHECK_OUTPUT "while qstat_xml_output was $qstat_F_xml_output($queue,$column)... \n"
            incr error_flag 1
         } 
      }   
   }
   
   if { $error_flag == 0 } {
      set_error 0 "ok"
   } else {
      set_error -1 "error in plain, XML qstat -F"
   }

   # Delete all jobs
   delete_all_jobs

}


#****** qstat/qstat_F_rerun_h_vmem_plain_xml_comparison() ***********************************************
#  NAME
#     qstat_F_rerun_h_vmem_plain_xml_comparison() -- Compare plain and XML ouptout of "qstat -F
#     rerun,h_vmem" command.
#
#  SYNOPSIS
#     qstat_F_rerun_h_vmem_plain_xml_comparison { }. The assoc. array has entries for queues
#     and jobs. For queues, we look at qname, qtype, total_slots, used_slots,
#     load_avg, arch, and  state. For jobs, we look at jobid, prio, name, user, state,
#     submit_time, start_time and, if present, slots, task_id. We also
#     accumuluate the queue names in output(queue_list) and  jobids in output(jobid_list).
#     We also accumulate the compexes by queue and compare them.
#  FUNCTION
#     Compare plain and XML ouptout of qstat command
#
#  INPUTS
#
#*******************************************************************************

proc qstat_F_rerun_h_vmem_plain_xml_comparison {} {
      global ts_config CHECK_OUTPUT CHECK_ACTUAL_TEST_PATH CHECK_USER output_result

      set hostname [lindex $ts_config(execd_nodes) 0]

      # Run some jobs
      set result_local_return [start_remote_prog $hostname $CHECK_USER "$CHECK_ACTUAL_TEST_PATH/qsub.sh" ""]

      # Wait a little for jobs to be scheduled.
      sleep 10
      
      # Clear error states, if any
      set result1 [start_sge_bin "qmod" "-c all.q"]

      # qstat_F_rerun_h_vmem_plain_output contains the plain "qstat -F rerun,h_vmem" output in an assoc. array
      # qstat_F_rerun_h_vmem_plain_output(jobid_list) contains a list of jobids.
 
      # Pass "rerun h_vmem" to qstat_F_plain_parse to get this output
      set result1 [qstat_F_plain_parse qstat_F_rerun_h_vmem_plain_output "rerun h_vmem"]

      puts $CHECK_OUTPUT "plain qstat -F rerun,h_vmem array .... \n"
      parray qstat_F_rerun_h_vmem_plain_output

      # qstat_F_rerun_h_vmem_xml_output contains the XML qstat output in an assoc. array
      #set result2 [qstat_F_rerun_h_vmem_xml_parse qstat_F_rerun_h_vmem_xml_output]
      set result2 [qstat_F_xml_parse qstat_F_rerun_h_vmem_xml_output "rerun h_vmem"]

      puts $CHECK_OUTPUT "xml qstat -F rerun,h_vmem array .... \n"
      parray qstat_F_rerun_h_vmem_xml_output

      #Now let's compare them by jobid

      set jobid_list [lrange $qstat_F_rerun_h_vmem_plain_output(jobid_list) 0 end]
      
      set plain_jobid_length [llength $qstat_F_rerun_h_vmem_plain_output(jobid_list)]
      set xml_jobid_length [llength $qstat_F_rerun_h_vmem_xml_output(jobid_list)]

      set column_vars "prior name user state time slots task_id "

      set error_flag 0
      
      # Check that we have same number of jobs in plain listing as in XML listing
      if { ($plain_jobid_length != $xml_jobid_length ) } {
          incr error_flag 1
      }
            
      foreach jobid $jobid_list {
   
         foreach column $column_vars {
            append qstat_F_rerun_h_vmem_xml_output($jobid,task_id) ""
            set qstat_F_rerun_h_vmem_xml_output($jobid,task_id) \
            [string trim $qstat_F_rerun_h_vmem_xml_output($jobid,task_id)]
            set qstat_F_rerun_h_vmem_plain_output($jobid,task_id) \
            [string trim $qstat_F_rerun_h_vmem_plain_output($jobid,task_id)]
 
            if { $qstat_F_rerun_h_vmem_plain_output($jobid,$column) != \
               $qstat_F_rerun_h_vmem_xml_output($jobid,$column) } {
               puts $CHECK_OUTPUT "Plain output and XML output DO NOT agree for jobid $jobid ...\n"
               puts $CHECK_OUTPUT "and column $column... \n"
               puts $CHECK_OUTPUT "qstat_F_rerun_h_vmem_plain_output was \
               $qstat_F_rerun_h_vmem_plain_output($jobid,$column)... \n"
               puts $CHECK_OUTPUT "while qstat_F_rerun_h_vmem_xml_output was \
               $qstat_F_rerun_h_vmem_xml_output($jobid,$column)... \n"
               incr error_flag 1
            } 
         }   
      }
      
      
   # Now compare the queue information output   
   set queue_list [lrange $qstat_F_rerun_h_vmem_plain_output(queue_list) 0 end]
   
   set plain_queue_length [llength $qstat_F_rerun_h_vmem_plain_output(queue_list)]
   set xml_queue_length [llength $qstat_F_rerun_h_vmem_xml_output(queue_list)]
   
   # Check that we have same number of queues in plain listing as in XML listing
   if { ($plain_queue_length != $xml_queue_length) } {
      incr error_flag 1
   } 
   
   # Comment out state, which is not seen in XML output!
   #set column_vars "qname qtype total_slots used_slots load_avg arch state"
   set column_vars "qname qtype total_slots used_slots load_avg arch \
                    qf:rerun qf:h_vmem"
                       
   foreach queue $queue_list {
   
      foreach column $column_vars {
         
         if { $qstat_F_rerun_h_vmem_plain_output($queue,$column) \
           != $qstat_F_rerun_h_vmem_xml_output($queue,$column) } {
            puts $CHECK_OUTPUT "Plain output and XML output DO NOT agree for queue $queue ...\n"
            puts $CHECK_OUTPUT "and column $column... \n"
            puts $CHECK_OUTPUT "qstat_F_rerun_h_vmem_plain_output was $qstat_F_rerun_h_vmem_plain_output($queue,$column)... \n"
            puts $CHECK_OUTPUT "while qstat_F_rerun_h_vmem_xml_output was $qstat_F_rerun_h_vmem_xml_output($queue,$column)... \n"
            incr error_flag 1
         } 
      }   
   }
   
   if { $error_flag == 0 } {
      set_error 0 "ok"
   } else {
      set_error -1 "error in plain, XML qstat -F rerun,h_vmem"
   }

   # Delete all jobs
   delete_all_jobs

}



#****** qstat/qstat_g_c_plain_xml_comparison() ***********************************************
#  NAME
#     qstat_plain_xml_comparison() -- Compare plain and XML ouptout of
#     "qstat -g c" command.
#
#  SYNOPSIS
#     qstat_g_c_plain_xml_comparison { }. The assoc. array has entries for
#     cluster, queue, cluster queue load, used, available, total,  aoACDS  cdsuE
#
#  FUNCTION
#     Compare plain and XML ouptout of "qstat -g c" command
#
#  INPUTS
#
#*******************************************************************************

proc qstat_g_c_plain_xml_comparison {} {
      global ts_config CHECK_OUTPUT CHECK_ACTUAL_TEST_PATH CHECK_USER output_result 

      set hostname [lindex $ts_config(execd_nodes) 0]
      
      # Run some jobs      
      set result_local_return [start_remote_prog $hostname $CHECK_USER "$CHECK_ACTUAL_TEST_PATH/qsub.sh" ""]
      
     
      # Wait a little for jobs to be scheduled.
      sleep 5

      # qstat_g_c_plain_output contains the plain qstat output in an assoc. array
      set result1 [qstat_g_c_plain_parse qstat_g_c_plain_output]
      
      puts $CHECK_OUTPUT "plain qstat -g c array .... \n"
      parray qstat_g_c_plain_output
      
      # qstat_g_c_xml_output contains the XML qstat output in an assoc. array
      set result2 [qstat_g_c_xml_parse qstat_g_c_xml_output]
      
      puts $CHECK_OUTPUT "xml qstat -g c array .... \n"
      parray qstat_g_c_xml_output

      # Now let's compare them by queues. For now we skip the last entry
      
      set queue_list [lrange $qstat_g_c_plain_output(queue_list) 0 end]
      
      set column_vars "clusterqueue cqload used avail total aoACDS cdsuE"

      set error_flag 0
      
      foreach queue $queue_list {
   
         foreach column $column_vars {
            
            # For queue or master values, need to trim XML output to match
            # the plain output.

            if { $qstat_g_c_plain_output($queue,$column) != $qstat_g_c_xml_output($queue,$column) } {
               puts $CHECK_OUTPUT "Plain output and XML output DO NOT agree for queue $queue...\n"
               puts $CHECK_OUTPUT "and column $column... \n"
               puts $CHECK_OUTPUT "qstat_g_c_plain_output was $qstat_g_c_plain_output($queue,$column)... \n"
               puts $CHECK_OUTPUT "while qstat_g_c_xml_output was $qstat_g_c_xml_output($queue,$column)... \n"
               incr error_flag 1
            }
            
         }
      }
   if { $error_flag == 0 } {  
      set_error 0 "ok"      
   } else {
      set_error -1 "error in plain, XML qstat -g c"
   }
   
   delete_all_jobs
   
}

#****** qstat/qstat_g_d_plain_xml_comparison() ***********************************************
#  NAME
#     qstat_g_d_plain_xml_comparison() -- Compare plain and XML ouptout of
#     "qstat -g d" command.
#
#  SYNOPSIS
#     qstat_g_d_plain_xml_comparison { }. The assoc. array has entries for jobid, prio, name, user, state,
#     submit_time, start_time and, if present, queue, slots, task_id. We also
#     accumuluate the jobids in output(jobid_list).
#
#  FUNCTION
#     Compare plain and XML ouptout of "qstat -g d" command
#
#  INPUTS
#
#*******************************************************************************

proc qstat_g_d_plain_xml_comparison {} {
      global ts_config CHECK_OUTPUT CHECK_ACTUAL_TEST_PATH CHECK_USER output_result 

      set hostname [lindex $ts_config(execd_nodes) 0]
      
      # Run some jobs      
      set result_local_return [start_remote_prog $hostname $CHECK_USER "$CHECK_ACTUAL_TEST_PATH/qsub.sh" ""]
      
     
      # Wait a little for jobs to be scheduled.
      sleep 5

      # qstat_g_d_plain_output contains the plain qstat output in an assoc. array
      # qstat_g_d_plain_output(jobid) contains a list of jobids.
      set result1 [qstat_g_d_plain_parse qstat_g_d_plain_output]
      
      puts $CHECK_OUTPUT "plain qstat -g d array .... \n"
      parray qstat_g_d_plain_output
      
      # qstat_g_d_xml_output contains the XML qstat output in an assoc. array
      set result2 [qstat_g_d_xml_parse qstat_g_d_xml_output]
      
      puts $CHECK_OUTPUT "xml qstat -g d array .... \n"
      parray qstat_g_d_xml_output

      # Now let's compare them by jobid.  For now we skip the last entry
      # due to bug in parse_qstat. See IZ 2024.
      set qstat_g_d_plain_output(jobid_list) $qstat_g_d_plain_output(index)
      set jobid_list [lrange $qstat_g_d_plain_output(jobid_list) 0 end-1]
      
      # We skip the task_id comparison also due to a bug in parse_qstat,
      # See IZ 2052 for details.
      set column_vars "prior name user state time queue master"
      
      set error_flag 0
      
      foreach jobid $jobid_list {
   
         foreach column $column_vars {
            
            
            # Need to put $jobid$column since $jobid contains a "," already!
            # For columns state, queue and master, trim the trailing blanks
            
            # For queue or master values, need to trim XML output to match
            # the plain output.
            if { ($column == "state") || ($column == "queue") || ($column == "master") } {
               set qstat_g_d_xml_output($jobid$column) [string trim $qstat_g_d_xml_output($jobid$column)]
               set qstat_g_d_plain_output($jobid$column) [string trim $qstat_g_d_plain_output($jobid$column)]
            }
            
            if { $qstat_g_d_plain_output($jobid$column) != $qstat_g_d_xml_output($jobid$column) } {
               puts $CHECK_OUTPUT "Plain output and XML output DO NOT agree for jobid $jobid ...\n"
               puts $CHECK_OUTPUT "and column $column... \n"
               puts $CHECK_OUTPUT "qstat_g_d_plain_output was $qstat_g_d_plain_output($jobid$column)... \n"
               puts $CHECK_OUTPUT "while qstat_g_d_xml_output was $qstat_g_d_xml_output($jobid$column)... \n"
               incr error_flag 1
            }
            
         }
      }
   if { $error_flag == 0 } {  
      set_error 0 "ok"      
   } else {
      set_error -1 "error in plain, XML qstat -g d"
   }
   
   delete_all_jobs
   
}

#****** qstat/qstat_g_t_plain_xml_comparison() ***********************************************
#  NAME
#     qstat_g_t_plain_xml_comparison() -- Compare plain and XML ouptout of
#     "qstat -g t" command.
#
#  SYNOPSIS
#     qstat_g_t_plain_xml_comparison { }. The assoc. array has entries for jobid, prio, name, user, state,
#     submit_time, start_time and, if present, queue, slots, task_id. We also
#     accumuluate the jobids in output(jobid_list).
#
#  FUNCTION
#     Compare plain and XML ouptout of "qstat -g d" command
#
#  INPUTS
#
#*******************************************************************************

proc qstat_g_t_plain_xml_comparison {} {
      global ts_config CHECK_OUTPUT CHECK_ACTUAL_TEST_PATH CHECK_USER output_result 

      set hostname [lindex $ts_config(execd_nodes) 0]
      
      # Run some jobs      
      set result_local_return [start_remote_prog $hostname $CHECK_USER "$CHECK_ACTUAL_TEST_PATH/qsub.sh" ""]
      
     
      # Wait a little for jobs to be scheduled.
      sleep 5

      # qstat_g_t_plain_output contains the plain qstat output in an assoc. array
      # qstat_g_t_plain_output(jobid) contains a list of jobids.
      set result1 [qstat_g_t_plain_parse qstat_g_t_plain_output]
      
      puts $CHECK_OUTPUT "plain qstat -g t array .... \n"
      parray qstat_g_t_plain_output
      
      # qstat_g_d_xml_output contains the XML qstat output in an assoc. array
      set result2 [qstat_g_t_xml_parse qstat_g_t_xml_output]
      
      puts $CHECK_OUTPUT "xml qstat -g t array .... \n"
      parray qstat_g_t_xml_output

      # Now let's compare them by jobid.  For now we skip the last entry
      # due to bug in parse_qstat. See IZ 2024.
      set qstat_g_t_plain_output(jobid_list) $qstat_g_t_plain_output(index)
      set jobid_list [lrange $qstat_g_t_plain_output(jobid_list) 0 end-1]
      
      # We skip the task_id comparison also due to a bug in parse_qstat,
      # See IZ 2052 for details.
      set column_vars "prior name user state time queue master"
      
      set error_flag 0
      
      foreach jobid $jobid_list {
   
         foreach column $column_vars {
            
            
            # Need to put $jobid$column since $jobid contains a "," already!
            # For columns state, queue and master, trim the trailing blanks
            
            # For queue or master values, need to trim XML output to match
            # the plain output.
            if { ($column == "state") || ($column == "queue") || ($column == "master") } {
               set qstat_g_t_xml_output($jobid$column) [string trim $qstat_g_t_xml_output($jobid$column)]
               set qstat_g_t_plain_output($jobid$column) [string trim $qstat_g_t_plain_output($jobid$column)]
            }
            
            if { $qstat_g_t_plain_output($jobid$column) != $qstat_g_t_xml_output($jobid$column) } {
               puts $CHECK_OUTPUT "Plain output and XML output DO NOT agree for jobid $jobid ...\n"
               puts $CHECK_OUTPUT "and column $column... \n"
               puts $CHECK_OUTPUT "qstat_g_t_plain_output was $qstat_g_t_plain_output($jobid$column)... \n"
               puts $CHECK_OUTPUT "while qstat_g_t_xml_output was $qstat_g_t_xml_output($jobid$column)... \n"
               incr error_flag 1
            }
            
         }
      }
   if { $error_flag == 0 } {  
      set_error 0 "ok"      
   } else {
      set_error -1 "error in plain, XML qstat -g t"
   }
   
   delete_all_jobs
   
}

