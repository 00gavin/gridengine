#!/vol2/TCL_TK/glinux/bin/expect
#___INFO__MARK_BEGIN__
##########################################################################
#
#  The Contents of this file are made available subject to the terms of
#  the Sun Industry Standards Source License Version 1.2
#
#  Sun Microsystems Inc., March, 2001
#
#
#  Sun Industry Standards Source License Version 1.2
#  =================================================
#  The contents of this file are subject to the Sun Industry Standards
#  Source License Version 1.2 (the "License"); You may not use this file
#  except in compliance with the License. You may obtain a copy of the
#  License at http://gridengine.sunsource.net/Gridengine_SISSL_license.html
#
#  Software provided under this License is provided on an "AS IS" basis,
#  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
#  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
#  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
#  See the License for the specific provisions governing your rights and
#  obligations concerning the Software.
#
#  The Initial Developer of the Original Code is: Sun Microsystems, Inc.
#
#  Copyright: 2001 by Sun Microsystems, Inc.
#
#  All Rights Reserved.
#
##########################################################################
#___INFO__MARK_END__

# define global variable in this namespace
global check_name 
global check_category
global check_description 
global check_needs
global check_functions 
global check_errno 
global check_errstr 
global check_highest_level
global check_init_level_procedure
global check_root_access_needs
global env

# define a level initialization procedure:
set check_init_level_procedure "init_level"

# define test's name and run level descriptions
set check_name            "qrsh"
set check_category        "COMPATIBILITY SYSTEM VERIFIED"
set check_highest_level   200
set check_description(0)    "checking qrsh to one exec host (master)"
set check_description(200)  "checking qrsh to all exec hosts"

# define test's dependencies
set check_needs           "init_core_system" 
set check_root_access_needs  "yes"

# define test's procedure order
set check_functions ""
lappend check_functions "qrsh_function"              ;# is a job executed?
lappend check_functions "qrsh_h"                     ;# test -h option
lappend check_functions "qrsh_hold_jid"              ;# test -hold_jid option
lappend check_functions "qrsh_alltoall"              ;# qrsh from all hosts to all hosts
lappend check_functions "qrsh_starter_method"        ;# does the starter method work for qrsh?
lappend check_functions "qrsh_accounting"            ;# accounting and online usage (sgeee)
lappend check_functions "qrsh_suspend"               ;# suspend
lappend check_functions "qrsh_delete"                ;# delete
lappend check_functions "qrsh_terminate"             ;# test terminate method
lappend check_functions "qrsh_qsub_gid"              ;# qsub gid set correctly?
lappend check_functions "qrsh_batch"                 ;# run qrsh in batch mode
lappend check_functions "qrsh_limits"                ;# limits (e.g. cpu) passed correctly
# lappend check_functions "qrsh_trap"                  ;# started command traps SIGINT


# test specific global variables
global qrsh_hostlist
global QSUB_GID_USER
global QSUB_GID_GROUPS
global CHECK_FIRST_FOREIGN_SYSTEM_USER CHECK_FIRST_FOREIGN_SYSTEM_GROUP CHECK_SECOND_FOREIGN_SYSTEM_GROUP
set QSUB_GID_USER   "$CHECK_FIRST_FOREIGN_SYSTEM_USER"
set QSUB_GID_GROUPS "$CHECK_FIRST_FOREIGN_SYSTEM_GROUP"

# run level initialization
#                                                             max. column:     |
#****** qrsh/init_level() ******
# 
#  NAME
#     init_level -- ??? 
#
#  SYNOPSIS
#     init_level { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc init_level {} {
   global CHECK_ACT_LEVEL CHECK_HOST CHECK_CORE_EXECD CHECK_OUTPUT
   global qrsh_hostlist

   switch -exact $CHECK_ACT_LEVEL {
      0 { 
         set qrsh_hostlist $CHECK_HOST
         return 0
      }
      200 {
         set qrsh_hostlist $CHECK_CORE_EXECD
         return 0
      }
   }

   return -1  ;# no other level else
}

# -------- local test procedures -----------------------------------------------

# -------- check functions -----------------------------------------------------

#                                                             max. column:     |
#****** qrsh/qrsh_function() ******
# 
#  NAME
#     qrsh_function -- ??? 
#
#  SYNOPSIS
#     qrsh_function { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc qrsh_function {} {
   global CHECK_OUTPUT CHECK_PRODUCT_ROOT CHECK_ARCH 
   global CHECK_HOST CHECK_USER
   global qrsh_hostlist open_spawn_buffer


   if { [have_root_passwd] == -1 } {
      set_error -3 "root access required"
      return
   } 


   puts $CHECK_OUTPUT "qrsh functional test"
   foreach host $qrsh_hostlist {
      set qrsh_id [open_remote_spawn_process $CHECK_HOST "ts_def_con" $CHECK_PRODUCT_ROOT/bin/$CHECK_ARCH/qrsh \
                                      "-l hostname=$host echo qrsh sucessfully started"]
      set sp_id [ lindex $qrsh_id 1 ] 
  
      set timeout 60
      expect {
         -i $sp_id full_buffer {
            close_spawn_process $qrsh_id
            set_error -1 "buffer overflow please increment CHECK_EXPECT_MATCH_MAX_BUFFER value"
            return
         }

         -i $sp_id default {
            close_spawn_process $qrsh_id
            set_error -1 "qrsh to host $host failed"
            return
         }
         -i $sp_id "qrsh sucessfully started" {
            close_spawn_process $qrsh_id
            puts $CHECK_OUTPUT "qrsh to host $host ok"
         }
      }
   }

   set_error 0 "ok"
}


proc qrsh_h {} {
   global CHECK_OUTPUT CHECK_PRODUCT_ROOT CHECK_ARCH 
   global CHECK_HOST CHECK_USER
   global open_spawn_buffer


   if { [have_root_passwd] == -1 } {
      set_error -3 "root access required"
      return
   } 


   puts $CHECK_OUTPUT "qrsh -h functional test"

   wait_for_end_of_all_jobs 30

   set my_outputs "-o /dev/null -e /dev/null"
   set arguments "$my_outputs $CHECK_PRODUCT_ROOT/examples/jobs/sleeper.sh 30"
   set job_id [submit_job $arguments]
   delete_job $job_id  ;# now we know the last job id

   incr job_id 1       ;# job id of next job !

   set qrsh_id [open_remote_spawn_process $CHECK_HOST "ts_def_con" $CHECK_PRODUCT_ROOT/bin/$CHECK_ARCH/qrsh \
                "-h echo qrsh sucessfully started"]
   set sp_id [ lindex $qrsh_id 1 ] 
  
   puts $CHECK_OUTPUT "Trigger scheduler monitoring"
   catch {  eval exec "$CHECK_PRODUCT_ROOT/bin/$CHECK_ARCH/qconf" "-tsm" } result
   puts $CHECK_OUTPUT $result

   wait_for_jobpending $job_id "echo" 60 

   puts $CHECK_OUTPUT "Trigger scheduler monitoring"
   catch {  eval exec "$CHECK_PRODUCT_ROOT/bin/$CHECK_ARCH/qconf" "-tsm" } result
   puts $CHECK_OUTPUT $result

   set run_result [get_standard_job_info $job_id ]
   foreach line $run_result {
      set tmp_job_id [lindex $line 0]
      set tmp_job_state [ lindex $line 4 ]
      puts $CHECK_OUTPUT "job id: $tmp_job_id, job state: $tmp_job_state"
   }

   if { $tmp_job_state != "hqw" } {
      add_proc_error "qrsh_h" -1 "qrsh -h job is not in pending state"
   }

   puts $CHECK_OUTPUT "Trigger scheduler monitoring"
   catch {  eval exec "$CHECK_PRODUCT_ROOT/bin/$CHECK_ARCH/qconf" "-tsm" } result
   puts $CHECK_OUTPUT $result

   set timeout 15
   expect {
         -i $sp_id full_buffer {
            close_spawn_process $qrsh_id
            set_error -1 "buffer overflow please increment CHECK_EXPECT_MATCH_MAX_BUFFER value"
            return
         }

         -i $sp_id default {
            puts $CHECK_OUTPUT "qrsh -h timeout for hold state ok, now releasing job $job_id"
         }
         -i $sp_id "qrsh sucessfully started" {
            add_proc_error "qrsh_h" -1 "qrsh -h failed" 
         }
   }

   release_job $job_id

   puts $CHECK_OUTPUT "Trigger scheduler monitoring"
   catch {  eval exec "$CHECK_PRODUCT_ROOT/bin/$CHECK_ARCH/qconf" "-tsm" } result
   puts $CHECK_OUTPUT $result

   set timeout 60
   expect {
         -i $sp_id full_buffer {
            close_spawn_process $qrsh_id
            set_error -1 "buffer overflow please increment CHECK_EXPECT_MATCH_MAX_BUFFER value"
            return
         }

         -i $sp_id default {
            add_proc_error "qrsh_h" -1 "qrsh -h failed for job $job_id"
            close_spawn_process $qrsh_id
         }
         -i $sp_id "qrsh sucessfully started" {
            puts $CHECK_OUTPUT "qrsh -h ok"
            close_spawn_process $qrsh_id
         }
   }
   set_error 0 "ok"
}


proc qrsh_hold_jid {} {
   global CHECK_OUTPUT CHECK_PRODUCT_ROOT CHECK_ARCH 
   global CHECK_HOST CHECK_USER
   global open_spawn_buffer


   if { [have_root_passwd] == -1 } {
      set_error -3 "root access required"
      return
   } 


   puts $CHECK_OUTPUT "qrsh -hold_jid functional test"

   wait_for_end_of_all_jobs 30

   set my_outputs "-o /dev/null -e /dev/null"
   set arguments "$my_outputs $CHECK_PRODUCT_ROOT/examples/jobs/sleeper.sh 6000"
   set hold_job_id [submit_job $arguments] 
   set job_id [ expr ( $hold_job_id + 1 )]

   set qrsh_id [open_remote_spawn_process $CHECK_HOST "ts_def_con" $CHECK_PRODUCT_ROOT/bin/$CHECK_ARCH/qrsh \
                "-hold_jid $hold_job_id echo qrsh sucessfully started"]
   set sp_id [ lindex $qrsh_id 1 ] 
  
   puts $CHECK_OUTPUT "Trigger scheduler monitoring"
   catch {  eval exec "$CHECK_PRODUCT_ROOT/bin/$CHECK_ARCH/qconf" "-tsm" } result
   puts $CHECK_OUTPUT $result

   wait_for_jobpending $job_id "echo" 60 

   puts $CHECK_OUTPUT "Trigger scheduler monitoring"
   catch {  eval exec "$CHECK_PRODUCT_ROOT/bin/$CHECK_ARCH/qconf" "-tsm" } result
   puts $CHECK_OUTPUT $result

   set run_result [get_standard_job_info $job_id ]
   foreach line $run_result {
      set tmp_job_id [lindex $line 0]
      set tmp_job_state [ lindex $line 4 ]
      puts $CHECK_OUTPUT "job id: $tmp_job_id, job state: $tmp_job_state"
   }

   if { $tmp_job_state != "hqw" } {
      add_proc_error "qrsh_h" -1 "qrsh -hold_jid job is not in pending state"
   }

   puts $CHECK_OUTPUT "Trigger scheduler monitoring"
   catch {  eval exec "$CHECK_PRODUCT_ROOT/bin/$CHECK_ARCH/qconf" "-tsm" } result
   puts $CHECK_OUTPUT $result

   set timeout 15
   expect {
         -i $sp_id full_buffer {
            close_spawn_process $qrsh_id
            set_error -1 "buffer overflow please increment CHECK_EXPECT_MATCH_MAX_BUFFER value"
            return
         }

         -i $sp_id default {
            puts $CHECK_OUTPUT "qrsh -hold_jid timeout for hold state ok, now deleting job $hold_job_id"
         }
         -i $sp_id "qrsh sucessfully started" {
            add_proc_error "qrsh_h" -1 "qrsh -hold_jid failed" 
         }
   }

   delete_job $hold_job_id

   puts $CHECK_OUTPUT "Trigger scheduler monitoring"
   catch {  eval exec "$CHECK_PRODUCT_ROOT/bin/$CHECK_ARCH/qconf" "-tsm" } result
   puts $CHECK_OUTPUT $result

   set timeout 60
   expect {
         -i $sp_id full_buffer {
            close_spawn_process $qrsh_id
            set_error -1 "buffer overflow please increment CHECK_EXPECT_MATCH_MAX_BUFFER value"
            return
         }

         -i $sp_id default {
            add_proc_error "qrsh_h" -1 "qrsh -hold_jid failed for job $job_id"
            close_spawn_process $qrsh_id
         }
         -i $sp_id "qrsh sucessfully started" {
            puts $CHECK_OUTPUT "qrsh -hold_jid ok"
            close_spawn_process $qrsh_id
         }
   }
   set_error 0 "ok"
}

#                                                             max. column:     |
#****** qrsh/qrsh_alltoall() ******
# 
#  NAME
#     qrsh_alltoall -- ??? 
#
#  SYNOPSIS
#     qrsh_alltoall { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc qrsh_alltoall {} {
   global CHECK_OUTPUT CHECK_PRODUCT_ROOT CHECK_ARCH CHECK_USER CHECK_ACTUAL_TEST_PATH
   global qrsh_hostlist open_spawn_buffer


   if { [have_root_passwd] == -1 } {
      set_error -3 "root access required"
      return
   } 


   puts $CHECK_OUTPUT "qrsh from each host to all hosts"


   foreach source $qrsh_hostlist {
      set source_arch [resolve_arch $source]
      foreach dest $qrsh_hostlist {
         set qrsh_id [open_remote_spawn_process "$source" "ts_def_con" "$CHECK_PRODUCT_ROOT/bin/$source_arch/qrsh" "-l hostname=$dest echo qrsh sucessfully started"]
         set sp_id [ lindex $qrsh_id 1 ]                              
         set timeout 60
         expect {
            -i $sp_id full_buffer {
               close_spawn_process $qrsh_id
               set_error -1 "buffer overflow please increment CHECK_EXPECT_MATCH_MAX_BUFFER value"
               return
            }
            -i $sp_id default {
               close_spawn_process $qrsh_id
               set_error -1 "qrsh from host $source to host $dest failed"
               continue
            }
            -i $sp_id "qrsh sucessfully started" {
               close_spawn_process $qrsh_id
               puts $CHECK_OUTPUT "qrsh from host $source to host $dest ok"
            }   
            -i $sp_id eof {
               close_spawn_process $qrsh_id
               add_proc_error "qrsh_alltoall"  -1 "open_remote_spawn_process closed connection (eof)"
            }
         }
      }
   }

   set_error 0 "ok"
}


proc qrsh_starter_method {} {
   global CHECK_OUTPUT CHECK_PRODUCT_ROOT CHECK_ARCH 
   global CHECK_HOST CHECK_USER CHECK_ACTUAL_TEST_PATH
   global qrsh_hostlist open_spawn_buffer

   puts $CHECK_OUTPUT "qrsh testing starter_method"

   # set starter method
   set change_array(starter_method) "$CHECK_ACTUAL_TEST_PATH/starter.sh"
   set_queue all.q "" change_array

   foreach host $qrsh_hostlist {
      set qrsh_id [open_remote_spawn_process $CHECK_HOST "ts_def_con" $CHECK_PRODUCT_ROOT/bin/$CHECK_ARCH/qrsh \
                                      "-l hostname=$host echo qrsh sucessfully started"]
      set sp_id [ lindex $qrsh_id 1 ] 
  
      set done 0
      set starter_method 0
 
      while {$done == 0} {
         set timeout 60
         expect {
            -i $sp_id full_buffer {
               close_spawn_process $qrsh_id
               add_proc_error "qrsh_starter_method" -1 "buffer overflow please increment CHECK_EXPECT_MATCH_MAX_BUFFER value"
               return
            }

            -i $sp_id "starter method started" {
               set starter_method 1
            }

            -i $sp_id "qrsh sucessfully started" {
               set done 1
               close_spawn_process $qrsh_id
               if {$starter_method == 0} {
                  add_proc_error "qrsh_starter_method" -1 "qrsh job stared without starter method on host $host"
               } else {
                  puts $CHECK_OUTPUT "qrsh to host $host ok"
               }
            }

            -i $sp_id default {
               set done 1
               close_spawn_process $qrsh_id
               set_error -1 "qrsh to host $host failed"
            }
         }
      }
   }

   # unset starter method
   set change_array(starter_method) "none"
   set_queue "all.q" "" change_array

   set_error 0 "ok"
}


#                                                             max. column:     |
#****** qrsh/qrsh_trap() ******
# 
#  NAME
#     qrsh_trap -- ??? 
#
#  SYNOPSIS
#     qrsh_trap { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc qrsh_trap {} {
   global CHECK_OUTPUT CHECK_PRODUCT_ROOT CHECK_USER CHECK_ACTUAL_TEST_PATH
   global qrsh_hostlist open_spawn_buffer

   if { [have_root_passwd] == -1 } {
      set_error -3 "root access required"
      return
   } 


   puts $CHECK_OUTPUT "qrsh of job that traps signals"

   add_proc_error "qrsh_trap" -3 "test not completely implemented"
   set_error 0 "test not completely implemented"
   return

   foreach source $qrsh_hostlist {
      foreach dest $qrsh_hostlist {
         set qrsh_id [open_remote_spawn_process $source "ts_def_con" $CHECK_ACTUAL_TEST_PATH/remote_submit.sh \
                                                "$CHECK_PRODUCT_ROOT $dest exec $CHECK_ACTUAL_TEST_PATH/trap.sh"]
 
         if [info exists job_id]  {unset job_id}
         if [info exists job_pid] {unset job_pid}
         # wait for start of testscript
         set timeout 60
         set sp_id [ lindex $qrsh_id 1 ] 

         while 1 {
         expect {
               -i $sp_id full_buffer {
                  close_spawn_process $qrsh_id
                  add_proc_error "qrsh_trap" -1 "buffer overflow please increment CHECK_EXPECT_MATCH_MAX_BUFFER value"
                  break
               }
               -i $sp_id default {
                  close_spawn_process $qrsh_id
                  add_proc_error "qrsh_trap" -1 "qrsh from host $source to host $dest failed"
                  break
               }
               -i $sp_id "my pid is *\n" {
                  set qrsh_pid [lindex $expect_out(0,string) 3]
               }
               -i $sp_id "qrsh trap test with JOB_ID *\n" {
                  set job_id [lindex $expect_out(0,string) 5]
                  puts $CHECK_OUTPUT "qrsh from host $source to host $dest with JOB_ID $job_id ok"
                  break
               }   
            }
         }

         # send signal and parse result
         foreach i "1 2 3" {
            # send SIGINT
            set output [ start_remote_prog $source $CHECK_USER "/bin/kill" "-2 $qrsh_pid" ] 
            set result $prg_exit_state
            if { $result != 0 } {
               set_error -1 "signaling qrsh on host $source failed: $output"
               break
            }
            # wait for output of testscript
            set timeout 10
            expect {
               -i $sp_id full_buffer {
                  add_proc_error "qrsh_trap" -1 "buffer overflow please increment CHECK_EXPECT_MATCH_MAX_BUFFER value"
               }
               -i $sp_id default {
                  add_proc_error "qrsh_trap" -1 "signaling qrsh on host $source for job on host $dest failed"
               }
               -i $sp_id "received SIGINT" {
                  puts $CHECK_OUTPUT "qrsh job received signal"
               }
            }
         }
         if [info exists job_id] {
            delete_job $job_id
         }   
         close_spawn_process $qrsh_id
      }
   }

   set_error 0 "ok"
}



#                                                             max. column:     |
#****** qrsh/qrsh_accounting() ******
# 
#  NAME
#     qrsh_accounting -- ??? 
#
#  SYNOPSIS
#     qrsh_accounting { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc qrsh_accounting {} {
   global ts_config
   global CHECK_OUTPUT CHECK_PRODUCT_ROOT CHECK_ARCH CHECK_PRODUCT_TYPE
   global CHECK_HOST CHECK_USER
   global qrsh_hostlist open_spawn_buffer


   if { [have_root_passwd] == -1 } {
      set_error -3 "root access required"
      return
   } 

   puts $CHECK_OUTPUT "qrsh accounting test"
   if { $ts_config(gridengine_version) != 53 } {
      set INTERACTIVE_JOB [translate $CHECK_HOST 1 0 0 [sge_macro MSG_QSH_INTERACTIVEJOBHASBEENSCHEDULED_S] "*"]
      set INTERACTIVE_JOB_DUMMY [translate $CHECK_HOST 1 0 0 [sge_macro MSG_QSH_INTERACTIVEJOBHASBEENSCHEDULED_S] "__JOBID__"]
   } else {
      set INTERACTIVE_JOB [translate $CHECK_HOST 1 0 0 [sge_macro MSG_QSH_INTERACTIVEJOBHASBEENSCHEDULED_D] "*"]
      set INTERACTIVE_JOB_DUMMY [translate $CHECK_HOST 1 0 0 [sge_macro MSG_QSH_INTERACTIVEJOBHASBEENSCHEDULED_D] "__JOBID__"]
   }
   set job_id_start [ string first "__JOBID__" $INTERACTIVE_JOB_DUMMY ]
   puts $CHECK_OUTPUT "parsing for \"$INTERACTIVE_JOB\""

   foreach host $qrsh_hostlist {
      set qrsh_id [open_remote_spawn_process $CHECK_HOST "ts_def_con" $CHECK_PRODUCT_ROOT/bin/$CHECK_ARCH/qrsh "-verbose -nostdin -l hostname=$host $CHECK_PRODUCT_ROOT/examples/jobs/worker.sh 120"]
      
      set state startup
      set job_id ""
      set sp_id [ lindex $qrsh_id 1 ] 
      

      while { [string compare $state exit] } {
         set timeout  80
         expect {
            -i $sp_id full_buffer {
               add_proc_error "qrsh_accounting" -1 "buffer overflow please increment CHECK_EXPECT_MATCH_MAX_BUFFER value"
               close_spawn_process $qrsh_id
               set state exit
            }
            -i $sp_id timeout {
               if { [string compare $state running] } {
                  close_spawn_process $qrsh_id
                  add_proc_error "qrsh_accounting"  -1 "qrsh to host $host failed"
                  set state exit
               } else {
                  if {$CHECK_PRODUCT_TYPE == "sgeee"} {
                     if { $job_id == "" } {
                        add_proc_error "qrsh_accounting"  -1 "unknown job_id for qrsh job on host $host"
                     } else {
                        if {[info exists job_info]} {
                           unset job_info
                        }
                        if {[get_extended_job_info $job_id] } {
                           if { $job_info(cpu) < 10 } {
                              add_proc_error "qrsh_accounting"  -1 "online usage probably does not work on $host"
                           }
                        } else {
                           add_proc_error "qrsh_accounting"  -1 "get_extended_jobinfo failed for job $job_id on host $host"
                        }
                     }
                  }
               }
            }
            -i $sp_id $INTERACTIVE_JOB {
               puts "jobstart: \"$expect_out(0,string)\""
               set job_id [ string range $expect_out(0,string) $job_id_start end]
               set space_start [ string first " " $job_id ]
               set job_id [ string range $job_id 0 $space_start ]
               set job_id [ string trim $job_id ]
               puts $CHECK_OUTPUT "job id is: \"$job_id\""
               set state scheduled
            }
            -i $sp_id "Your interactive job *\n" {
               set job_id [lindex $expect_out(0,string) 3]
               puts $CHECK_OUTPUT "job id is: \"$job_id\""
               set state scheduled
            }
            -i $sp_id "Forking" { ;# "Forking" printout is from worker job (utilbin/work.c)
               set state running
            }
            -i $sp_id "_exit_status_" {   ;# _exit_status_ is from open_remote_spawn_process - generated script
               if { [string compare $state running] } {
                  add_proc_error "qrsh_accounting"  -1 "qrsh to host $host failed"
               }
               close_spawn_process $qrsh_id
               set state exit
            }
            -i $sp_id eof {
               close_spawn_process $qrsh_id
               add_proc_error "qrsh_accounting"  -1 "open_remote_spawn_process closed connection (eof)"
               set state exit
            }
         }
      }

      # wait for accounting file to be flushed (esp. for 6.0) and NFS
      sleep 30

      if { $job_id != "" } {
         if {[info exists qacct_info]} {
            unset qacct_info
         }

         if { [get_qacct $job_id] == 0 } {
            add_proc_error "qrsh_accounting"  -1 "qacct for job $job_id on host $host failed"
         } else {
            set cpu [expr $qacct_info(ru_utime) + $qacct_info(ru_stime)]
            if { $cpu < 30 } {
               add_proc_error "qrsh_accounting"  -1 "cpu entry \"$cpu\" in accounting seems to be wrong for job $job_id on host $host"
            }

            if { $CHECK_PRODUCT_TYPE == "sgeee" } {
               # compute absolute diffence between cpu and ru_utime + ru_stime
               set difference [expr $cpu - $qacct_info(cpu)]
               set difference [expr $difference * $difference]
               if { $difference > 2 } {
                  add_proc_error "qrsh_accounting"  -1 "accounting: cpu($qacct_info(cpu)) is not the sum of ru_utime and ru_stime ($cpu) for job $job_id on host $host"
               }
            }
         }
      }
   }

   set_error 0 "ok"
}

#                                                             max. column:     |
#****** qrsh/qrsh_suspend() ******
# 
#  NAME
#     qrsh_suspend -- ??? 
#
#  SYNOPSIS
#     qrsh_suspend { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc qrsh_suspend {} {
   global CHECK_OUTPUT CHECK_PRODUCT_ROOT CHECK_ARCH CHECK_ACTUAL_TEST_PATH
   global CHECK_HOST CHECK_USER CHECK_FIRST_FOREIGN_SYSTEM_USER
   global qrsh_hostlist open_spawn_buffer

   if { [have_root_passwd] == -1 } {
      set_error -3 "root access required"
      return
   } 


   puts $CHECK_OUTPUT "check if a process started by qrsh can be (un)suspended using qmod"

   foreach host $qrsh_hostlist {
      switch -exact [resolve_arch $host] {
         aix42 -
         aix43 -
         aix51 {
            set running_state AWI
            set suspended_state T
         }
         default {
            set running_state OSR
            set suspended_state T
         }
      }
      # start qrsh job (shell script that outputs its pid)
      set qrsh_id [open_remote_spawn_process $CHECK_HOST "ts_def_con" $CHECK_PRODUCT_ROOT/bin/$CHECK_ARCH/qrsh "-l hostname=$host $CHECK_ACTUAL_TEST_PATH/sleep_pid.sh 60"]
      
      # evaluate pid and JOB_ID
      set done 0
      set sp_id [ lindex $qrsh_id 1 ] 

      while { $done == 0 } {
         set timeout 60
         expect {
            -i $sp_id full_buffer {
               close_spawn_process $qrsh_id
               add_proc_error "qrsh_suspend" -1 "buffer overflow please increment CHECK_EXPECT_MATCH_MAX_BUFFER value"
               set done 1
            }
            -i $sp_id "my pid is *\n" {
               set job_pid [lindex $expect_out(0,string) 3]
               set job_id [lindex $expect_out(0,string) 7]
               puts $CHECK_OUTPUT "job has pid $job_pid and job id $job_id"
               set done 1
            }
            -i $sp_id timeout {
               close_spawn_process $qrsh_id
               add_proc_error "qrsh_suspend" -1 "qrsh to host $host failed"
               set done 1
            }
            -i $sp_id "_exit_status_" {
               close_spawn_process $qrsh_id
               add_proc_error "qrsh_suspend" -1 "qrsh to host $host failed"
               set done 1
            }
            -i $sp_id eof {
               close_spawn_process $qrsh_id
               add_proc_error "qrsh_suspend" -1 "open_remote_spawn_process closed connection (eof)"
               set done 1
            }
         }
      }

      if { [info exists job_pid] && [info exists job_id] } {
         # check process status (should be sleeping or running)
         get_ps_info $job_pid $host 
         
         if { $ps_info($job_pid,error) != 0 } {
               close_spawn_process $qrsh_id
               set_error -1 "cannot get info about process $job_pid on host $host"
               continue
         }
         puts $CHECK_OUTPUT $ps_info($job_pid,index_names) 
         puts $CHECK_OUTPUT $ps_info($job_pid,string)
         if {[string first $ps_info($job_pid,state) $running_state] == -1} {
               close_spawn_process $qrsh_id
               set_error -1 "process $job_pid on host $host is in unexpected state $ps_info($job_pid,state)\nps output:\n$ps_info($job_pid,index_names)\n$ps_info($job_pid,string)\n"
               continue
         }
         # suspend job
         suspend_job $job_id
         sleep 10
         # process status should be suspended
         get_ps_info $job_pid $host
         # unsuspend job
         unsuspend_job $job_id
         if { $ps_info($job_pid,error) != 0 } {
               set_error -1 "cannot get info about process $job_pid on host $host"
               close_spawn_process $qrsh_id
               continue
         }
         if {$ps_info($job_pid,state) != $suspended_state} {
               set_error -1 "process $job_pid on host $host is in unexpected state $ps_info($job_pid,state)"
               close_spawn_process $qrsh_id
               continue
         }
         sleep 10
         # process status should be sleeping or running
         get_ps_info $job_pid $host
         if { $ps_info($job_pid,error) != 0 } {
               set_error -1 "cannot get info about process $job_pid on host $host"
               close_spawn_process $qrsh_id
               continue
         }
         if {[string first $ps_info($job_pid,state) $running_state] == -1} {
               set_error -1 "process $job_pid on host $host is in unexpected state $ps_info($job_pid,state)"
               close_spawn_process $qrsh_id
               continue
         }
      }

      set done 0
      while { $done == 0 } {
         set timeout 60
         expect {
            -i $sp_id full_buffer {
               close_spawn_process $qrsh_id
               add_proc_error "qrsh_suspend" -1 "buffer overflow please increment CHECK_EXPECT_MATCH_MAX_BUFFER value"
               set done 1
            }
            -i $sp_id timeout {
               close_spawn_process $qrsh_id
               add_proc_error "qrsh_suspend" -1 "timeout waiting for qrsh to host $host to finish"
               set done 1
            }
            -i $sp_id "_exit_status_" {
               close_spawn_process $qrsh_id
               set done 1
            }
            -i $sp_id eof {
               close_spawn_process $qrsh_id
               add_proc_error "qrsh_suspend" -1 "open_remote_spawn_process closed connection (eof)"
               set done 1
            }
         }
      }
   }

   set_error 0 "ok"
}

#                                                             max. column:     |
#****** qrsh/qrsh_delete() ******
# 
#  NAME
#     qrsh_delete -- ??? 
#
#  SYNOPSIS
#     qrsh_delete { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc qrsh_delete {} {
   global CHECK_OUTPUT CHECK_PRODUCT_ROOT CHECK_ARCH CHECK_ACTUAL_TEST_PATH
   global CHECK_HOST CHECK_USER CHECK_FIRST_FOREIGN_SYSTEM_USER
   global qrsh_hostlist open_spawn_buffer

   if { [have_root_passwd] == -1 } {
      set_error -3 "root access required"
      return
   } 


   puts $CHECK_OUTPUT "check if all processes of a qrsh job are finished after qdel"

   foreach host $qrsh_hostlist {
      # start qrsh job (shell script that outputs its pid)
      set qrsh_id [open_remote_spawn_process $CHECK_HOST "ts_def_con" $CHECK_PRODUCT_ROOT/bin/$CHECK_ARCH/qrsh "-l hostname=$host $CHECK_ACTUAL_TEST_PATH/sleep_pid.sh 120"]
      set sp_id [ lindex $qrsh_id 1 ] 
 
      # evaluate pid and JOB_ID
      set timeout 60
      set done 0
      set error 0
      while { $done == 0 } {
         expect {
            -i $sp_id full_buffer {
               close_spawn_process $qrsh_id
               add_proc_error "qrsh_delete" -1 "buffer overflow please increment CHECK_EXPECT_MATCH_MAX_BUFFER value"
               set done 1
               set error 1
            }
            -i $sp_id "my pid is*" {
               set job_pid [lindex $expect_out(0,string) 3]
               set job_id [lindex $expect_out(0,string) 7]
               set done 1
            }
            -i $sp_id timeout {
               close_spawn_process $qrsh_id
               add_proc_error "qrsh_delete" -1 "qrsh to host $host failed - timeout"
               set done 1
               set error 1
            }
            -i $sp_id eof {
               close_spawn_process $qrsh_id
               add_proc_error "qrsh_delete" -1 "qrsh to host $host failed - eof"
               set done 1
               set error 1
            }
            
         }
      }

      if { $error == 1 } {
         continue
      }

      if { [info exists job_pid] && [info exists job_id] } {
         # qdel 
         delete_job $job_id
         sleep 10
         # check if shell script is still running
         get_ps_info $job_pid $host
         if { $ps_info($job_pid,error) == 0 } {
            set_error -1 "process of deleted job $job_pid on host $host is still running"
         }
      }
      close_spawn_process $qrsh_id 1
   }

   set_error 0 "ok"
}

#                                                             max. column:     |
#****** qrsh/qrsh_terminate() ******
# 
#  NAME
#     qrsh_terminate -- ??? 
#
#  SYNOPSIS
#     qrsh_terminate { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc qrsh_terminate {} {
   global CHECK_OUTPUT CHECK_PRODUCT_ROOT CHECK_ARCH CHECK_ACTUAL_TEST_PATH
   global CHECK_HOST CHECK_USER CHECK_FIRST_FOREIGN_SYSTEM_USER CHECK_COMMD_PORT
   global qrsh_hostlist open_spawn_buffer

   if { [have_root_passwd] == -1 } {
      set_error -3 "root access required"
      return
   } 


   puts $CHECK_OUTPUT "check if terminate method for a qrsh job gets right job_pid"

   set terminate_out_file [get_tmp_file_name "" "qrsh" $CHECK_COMMD_PORT]

   # set terminate method
   set change_array(terminate_method) "$CHECK_ACTUAL_TEST_PATH/terminate.sh \$job_id \$job_pid $terminate_out_file"
   set_queue "all.q" "" change_array

   foreach host $qrsh_hostlist {
      # start qrsh job (shell script that outputs its pid)
      start_remote_prog $host $CHECK_USER ls $terminate_out_file exit_code
      set qrsh_id [open_remote_spawn_process $CHECK_HOST "ts_def_con" $CHECK_PRODUCT_ROOT/bin/$CHECK_ARCH/qrsh "-l hostname=$host $CHECK_ACTUAL_TEST_PATH/sleep_pid.sh 120"]
      
      # evaluate pid and JOB_ID
      set timeout 60
      set done 0
      set error 0
      set sp_id [ lindex $qrsh_id 1 ] 

      while { $done == 0 } {
         expect {
            -i $sp_id full_buffer {
               close_spawn_process $qrsh_id
               add_proc_error "qrsh_terminate" -1 "buffer overflow please increment CHECK_EXPECT_MATCH_MAX_BUFFER value"
               set done 1
               set error 1
            }
            -i $sp_id "my pid is*" {
               set job_pid [lindex $expect_out(0,string) 3]
               set job_id [lindex $expect_out(0,string) 7]
               set done 1
            }
            -i $sp_id timeout {
               close_spawn_process $qrsh_id
               add_proc_error "qrsh_terminate" -1 "qrsh to host $host failed - timeout"
               set done 1
               set error 1
            }
            -i $sp_id eof {
               close_spawn_process $qrsh_id
               add_proc_error "qrsh_terminate" -1 "qrsh to host $host failed - eof"
               set done 1
               set error 1
            }
            
         }
      }

      if { $error == 1 } {
         continue
      }

      if { [info exists job_pid] && [info exists job_id] } {
         get_ps_info $job_pid $host
         # qdel 
         delete_job $job_id

         for {set i 0} {$i < 60} {incr i} {
            after 1000
            start_remote_prog $host $CHECK_USER ls $terminate_out_file exit_code
            if {$exit_code == 0} {
               puts $CHECK_OUTPUT "terminate method has been started"
               break
            } else {
               puts $CHECK_OUTPUT "waiting for terminate method"
            }
         }   
        
         # wait for terminate method to finish
         sleep 2
         # check contents of terminate.out
         set line [start_remote_prog $host $CHECK_USER cat $terminate_out_file exit_code]
         if {$exit_code != 0} {
            add_proc_error "qrsh_terminate" -1 "error reading from terminate method output file on host $host"
         } else {
            if {[scan $line "job_id=%d job_pid=%d" t_job_id t_job_pid] != 2} {
               add_proc_error "qrsh_terminate" -1 "error reading from terminate method output file on host $host"
            } else {
               # t_job_pid should be ppid of job_pid
               if { ! [info exists ps_info($job_pid,ppid)] } {
                  add_proc_error "qrsh_terminate" -1 "info about ppid of pid $job_pid not available on host $host"
               } else {   
                  if { $ps_info($job_pid,ppid) != $t_job_pid} {
                     add_proc_error "qrsh_terminate" -1 "wrong job_pid passed to terminate method for job $job_id on host $host, should be $ps_info($job_pid,ppid) but is $t_job_pid"
                  }
               }
            }
         }
         # check if shell script is still running
         get_ps_info $job_pid $host
         if { $ps_info($job_pid,error) == 0 } {
            add_proc_error "qrsh_terminate" -1 "process of deleted job $job_pid on host $host is still running"
         }
      }
      
      set done 0
      while { $done == 0 } {
         set timeout 60
         expect {
            -i $sp_id full_buffer {
               close_spawn_process $qrsh_id
               add_proc_error "qrsh_terminate" -1 "buffer overflow please increment CHECK_EXPECT_MATCH_MAX_BUFFER value"
               set done 1
            }
            -i $sp_id timeout {
               close_spawn_process $qrsh_id
               add_proc_error "qrsh_terminate" -1 "timeout waiting for qrsh to host $host to finish"
               set done 1
            }
            -i $sp_id "_exit_status_" {
               close_spawn_process $qrsh_id
               set done 1
            }
            -i $sp_id eof {
               close_spawn_process $qrsh_id
               add_proc_error "qrsh_terminate" -1 "open_remote_spawn_process closed connection (eof)"
               set done 1
            }
         }
      }

      start_remote_prog $host $CHECK_USER ls $terminate_out_file exit_code
   }

   # reset terminate method
   set change_array(terminate_method) "NONE"
   set_queue "all.q" "" change_array

   set_error 0 "ok"
}

#                                                             max. column:     |
#****** qrsh/check_qsub_gid_output() ******
# 
#  NAME
#     check_qsub_gid_output -- ??? 
#
#  SYNOPSIS
#     check_qsub_gid_output { output check_group } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#     output      - ??? 
#     check_group - ??? 
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc check_qsub_gid_output {output check_group} {
   global CHECK_OUTPUT

   if { [have_root_passwd] == -1 } {
      set_error -3 "root access required"
      return
   } 

   set substring [string range $output [string first "gid=" $output] end]
   set group [string trim [string range $substring [string first "(" $substring] [string first ")" $substring]] "()"]

   puts $CHECK_OUTPUT "process was executed under user group $group"

   if {[string compare $group $check_group] == 0} {
      return 1
   } else {
      return 0
   }
}

#                                                             max. column:     |
#****** qrsh/qrsh_qsub_gid() ******
# 
#  NAME
#     qrsh_qsub_gid -- ??? 
#
#  SYNOPSIS
#     qrsh_qsub_gid { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc qrsh_qsub_gid {} {
   global ts_config
   global CHECK_OUTPUT CHECK_ACTUAL_TEST_PATH CHECK_PROTOCOL_DIR
   global CHECK_PRODUCT_ROOT CHECK_ARCH CHECK_HOST
   global QSUB_GID_USER QSUB_GID_GROUPS CHECK_SECOND_FOREIGN_SYSTEM_USER
   global qrsh_hostlist open_spawn_buffer CHECK_HOST

   if { [have_root_passwd] == -1 } {
      set_error -3 "root access required"
      return
   } 

   if { $ts_config(gridengine_version) == 53 } {
      set USING_FOR     [translate $CHECK_HOST 1 0 0 [sge_macro MSG_GDI_USING_SS] "*USE_QSUB_GID=true*" "*"]
      set FINISHED_JOBS [translate $CHECK_HOST 1 0 0 [sge_macro MSG_GDI_USING_SS] "*finished_jobs*" "*"]
   } else {
      set USING_FOR     [translate $CHECK_HOST 1 0 0 [sge_macro MSG_CONF_USING_SS] "*USE_QSUB_GID=true*" "*"]
      set FINISHED_JOBS [translate $CHECK_HOST 1 0 0 [sge_macro MSG_CONF_USING_SS] "*finished_jobs*" "*"]
   }

   puts $CHECK_OUTPUT "check if qsub gid is propagated to qrsh job"

   foreach host $qrsh_hostlist {
      # dump commandfile to file
      set f [open $CHECK_PROTOCOL_DIR/qrsh.sh w]
      switch -exact [resolve_arch $host] {
         aix42 -
         aix43 -
         osf4 -
         tru64 {
            puts $f "$CHECK_PRODUCT_ROOT/bin/$CHECK_ARCH/qrsh -l hostname=$host /usr/bin/id"
         }
         default {
            puts $f "$CHECK_PRODUCT_ROOT/bin/$CHECK_ARCH/qrsh -l hostname=$host /usr/bin/id -a"
         }   
      }   
      close $f

      file attributes "$CHECK_PROTOCOL_DIR/qrsh.sh" -permissions 00755
      wait_for_remote_file $host $QSUB_GID_USER $CHECK_PROTOCOL_DIR/qrsh.sh


      # call qsub_gid.sh, gid must be primary gid
      set output [start_remote_prog "$CHECK_HOST" $QSUB_GID_USER $CHECK_ACTUAL_TEST_PATH/qsub_gid.sh "[lindex $QSUB_GID_GROUPS 1] $CHECK_PROTOCOL_DIR/qrsh.sh"]
      set group [lindex $QSUB_GID_GROUPS 0]
      if {[check_qsub_gid_output $output $group] == 0} {
         set_error -1 "qrsh job on host $host was executed with wrong gid, should be $group, output of qrsh job was $output"
      }

      # get path of hosts messages file
      get_config config $host
      if {![info exists config(execd_spool_dir)]} {
         get_config config
      }
      set messages_name "$config(execd_spool_dir)/$host/messages"
      
      # spawn a tail -f to messages file and skip first (old) lines
      # we use the second configured test user to avoid having two open_remote_spawn
      # processes with same userid and same host
      set tail_id [open_remote_spawn_process $host "ts_def_con" /usr/bin/tail "-f $messages_name"]
      set skipping 1
      set sp_id [ lindex $tail_id 1 ] 

      while {$skipping == 1} {
         set timeout 5
         expect {
            -i $sp_id full_buffer {
               add_proc_error "qrsh_qsub_gid" -1 "buffer overflow please increment CHECK_EXPECT_MATCH_MAX_BUFFER value" 
            }
            -i $sp_id timeout {
               set skipping 0
            }
            -i $sp_id "*\n" {
            }
         }
      }

      # set parameter USE_QSUB_GID
      unset config
      get_config config $host
      if {[info exists config(execd_params)]} {
         set execd_params $config(execd_params)
      } else {
         set execd_params "NONE"
      }

      unset config
      if { [string compare -nocase $execd_params "NONE"] == 0 } {
         set config(execd_params) "USE_QSUB_GID=true"
      } else {
         set config(execd_params) "$execd_params,USE_QSUB_GID=true"
      }
      set_config config $host
      
      # wait until USE_QSUB_GID is changed on host
      puts $CHECK_OUTPUT "waiting for configuration change to take effect"
      set timeout 120
      expect {
         -i $sp_id full_buffer {
            close_spawn_process $tail_id
            add_proc_error "qrsh_qsub_gid" -1 "buffer overflow please increment CHECK_EXPECT_MATCH_MAX_BUFFER value"
            continue
         }
         -i $sp_id default {
            send -i $sp_id "\003"
            close_spawn_process $tail_id
            add_proc_error "qrsh_qsub_gid" -1 "setting execd_params to USE_QSUB_GID=true failed on host $host"
            continue
         }
         -i $sp_id $USING_FOR {
            send -i $sp_id "\003"
            close_spawn_process $tail_id
         }
         -i $sp_id "using*USE_QSUB_GID=true*\n" {
            send -i $sp_id "\003"
            close_spawn_process $tail_id
         }
      }

      # call qsub_gid.sh, gid must be secondary gid
      set output [start_remote_prog "$CHECK_HOST" $QSUB_GID_USER $CHECK_ACTUAL_TEST_PATH/qsub_gid.sh "[lindex $QSUB_GID_GROUPS 1] $CHECK_PROTOCOL_DIR/qrsh.sh"]
      set group [lindex $QSUB_GID_GROUPS 1]
      if {[check_qsub_gid_output $output $group] == 0} {
         set_error -1 "qrsh job on host $host was executed with wrong gid, should be $group, output of qrsh job was $output"
      }

      # spawn a tail -f to messages file and skip first (old) lines
      set tail_id [open_remote_spawn_process $host "ts_def_con" /usr/bin/tail "-f $messages_name"]
      set sp_id [ lindex $tail_id 1 ] 
      set skipping 1
      while {$skipping == 1} {
         set timeout 5
         expect {
            -i $sp_id full_buffer {
               add_proc_error "qrsh_qsub_gid" -1 "buffer overflow please increment CHECK_EXPECT_MATCH_MAX_BUFFER value"
            }
            -i $sp_id timeout {
               set skipping 0
            }
            -i $sp_id "*\n" {
            }
         }
      }

      # unset USE_QSUB_GID 
      unset config
      set config(execd_params) "$execd_params"
      set_config config $host

      # wait until USE_QSUB_GID is changed on host
      puts $CHECK_OUTPUT "waiting for configuration change to take effect"
      set timeout 120
      expect {
         -i $sp_id full_buffer {
            close_spawn_process $tail_id
            add_proc_error "qrsh_qsub_gid" -1 "buffer overflow please increment CHECK_EXPECT_MATCH_MAX_BUFFER value"
            continue
         }
         -i $sp_id timeout {
            send -i $sp_id "\003"
            close_spawn_process $tail_id
            add_proc_error "qrsh_qsub_gid" -1 "clearing execd_params from USE_QSUB_GID=true failed on host $host"
            continue
         }
         -i $sp_id $FINISHED_JOBS {
            send -i $sp_id "\003"
            close_spawn_process $tail_id
         }
         -i $sp_id "using*finished_jobs*" {
            send -i $sp_id "\003"
            close_spawn_process $tail_id
         }
      }
   }

   set_error 0 "ok"
}

#                                                             max. column:     |
#****** qrsh/qrsh_batch() ******
# 
#  NAME
#     qrsh_batch -- ??? 
#
#  SYNOPSIS
#     qrsh_batch { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc qrsh_batch {} {
   global ts_config
   global CHECK_OUTPUT CHECK_PRODUCT_ROOT CHECK_ARCH
   global CHECK_HOST CHECK_USER
   global qrsh_hostlist open_spawn_buffer

   if { [have_root_passwd] == -1 } {
      set_error -3 "root access required"
      return
   } 


   puts $CHECK_OUTPUT "check qrsh in immediate and batch mode (-now yes / no)"
   set COULD_NOT_BE_STARED [translate $CHECK_HOST 1 0 0 [sge_macro MSG_QSH_REQUESTCANTBESCHEDULEDTRYLATER_S] "*" ]
   if { $ts_config(gridengine_version) == 60 } {
      set HAS_BEEN_SUBMITTED  [translate $CHECK_HOST 1 0 0 [sge_macro MSG_QSUB_YOURJOBHASBEENSUBMITTED_SS] "*" "*"]
   } else {
      set HAS_BEEN_SUBMITTED  [translate $CHECK_HOST 1 0 0 [sge_macro MSG_JOB_SUBMITJOB_USS] "*" "*" "*" ]
   }


   foreach host $qrsh_hostlist {
      set queue [get_queue_instance "all.q" $host]
      # disable queue
      disable_queue $queue
      # start qrsh - must be rejected
      set qrsh_id [open_remote_spawn_process $CHECK_HOST "ts_def_con" $CHECK_PRODUCT_ROOT/bin/$CHECK_ARCH/qrsh "-q $queue echo blahblah"]
      set sp_id [ lindex $qrsh_id 1 ] 

      # evaluate pid and JOB_ID
      set timeout 60
      set error 1
      expect {
         -i $sp_id full_buffer {
            add_proc_error "qrsh_batch" -1 "buffer overflow please increment CHECK_EXPECT_MATCH_MAX_BUFFER value"
         }
         -i $sp_id "blahblah" {
            add_proc_error "qrsh_batch" -1 "qrsh -now yes ran dispite no resources free on host $host"
         }
         -i $sp_id $COULD_NOT_BE_STARED {
            puts $CHECK_OUTPUT "qrsh aborted correctly"
            set error 0
         } 
         -i $sp_id "could not be scheduled*\n" {
            puts $CHECK_OUTPUT "qrsh aborted correctly"
            set error 0
         }
         -i $sp_id timeout {
            add_proc_error "qrsh_batch" -1 "timeout waiting for qrsh -now yes on host $host to fail due to lack of resources"
         }
         -i $sp_id eof {
            add_proc_error "qrsh_batch" -1 "qrsh -now yes failed without error message on host $host"
         }
      }
      close_spawn_process $qrsh_id
 
      if { $error } {
         set_error -1 "skipping test on host $host"
         enable_queue [get_queue_instance "all.q" $host]
         continue
      }
 
      # start qrsh -now no
      set qrsh_id [open_remote_spawn_process $CHECK_HOST "ts_def_con" $CHECK_PRODUCT_ROOT/bin/$CHECK_ARCH/qrsh "-verbose -q $queue -now no echo blahblah"]
      # must be in pending jobs
      set sp_id [ lindex $qrsh_id 1 ] 

      set timeout 60
      expect {
         -i $sp_id full_buffer {
            add_proc_error "qrsh_batch" -1 "buffer overflow please increment CHECK_EXPECT_MATCH_MAX_BUFFER value"
            set error 1
         }
         -i $sp_id timeout {
            add_proc_error "qrsh_batch" -1 "timeout waiting for qrsh -now no to be submitted to host $host"
            set error 1
         }
         -i $sp_id $HAS_BEEN_SUBMITTED {
            set job_id [lindex $expect_out(0,string) 2]
            puts $CHECK_OUTPUT "qrsh job $job_id correctly submitted"
            set error 0
         }
         -i $sp_id "your job * has been submitted" {
            set job_id [lindex $expect_out(0,string) 2]
            puts $CHECK_OUTPUT "qrsh job $job_id correctly submitted"
            set error 0
         }
         -i $sp_id eof {
            add_proc_error "qrsh_batch" -1 "eof waiting for qrsh -now no to be submitted to host $host"
            set error 1
         }
      }
      if { $error } {
         add_proc_error "qrsh_batch" -1 "skipping test on host $host"
         close_spawn_process $qrsh_id
         enable_queue $host.q
         continue
      }

      if {[info exists job_info]} {
         unset job_info
      }

      if { [get_extended_job_info $job_id] == 0} {
         set_error -1 "no job info for job $job_id - skipping test on host $host"
         close_spawn_process $qrsh_id
         continue
      }

      if { $job_info(state) != "qw" } {
         set_error -1 "state of job is $job_info(state), should be qw, skipping test on host $host"
         close_spawn_process $qrsh_id
         continue
      }
      
      # enable queue, trigger scheduling
      enable_queue $queue
      catch "exec $CHECK_PRODUCT_ROOT/bin/$CHECK_ARCH/qconf -tsm" output
      
      # job must be scheduled
      set timeout 60
      expect {
         -i $sp_id full_buffer {
            add_proc_error "qrsh_batch" -1 "buffer overflow please increment CHECK_EXPECT_MATCH_MAX_BUFFER value"
         }
         -i $sp_id "blahblah" {
         }
         -i $sp_id $COULD_NOT_BE_STARED { 
            add_proc_error "qrsh_batch" -1 "message \"could not be scheduled\" should not occur with batch jobs"
         }
         -i $sp_id "*could not be scheduled*" {
            add_proc_error "qrsh_batch" -1 "message \"could not be scheduled\" should not occur with batch jobs"
         }
         -i $sp_id timeout {
            add_proc_error "qrsh_batch" -1 "timeout waiting for qrsh to be scheduled to host $host"
         }
         -i $sp_id eof {
            add_proc_error "qrsh_batch" -1 "qrsh exited without executing command on host $host"
         }
      }
      close_spawn_process $qrsh_id
   }

   set_error 0 "ok"
}

#                                                             max. column:     |
#****** qrsh/qrsh_limits() ******
# 
#  NAME
#     qrsh_limits -- ??? 
#
#  SYNOPSIS
#     qrsh_limits { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc qrsh_limits {} {
   global CHECK_OUTPUT CHECK_PRODUCT_ROOT CHECK_ARCH CHECK_ACTUAL_TEST_PATH
   global CHECK_HOST CHECK_USER
   global qrsh_hostlist open_spawn_buffer

   if { [have_root_passwd] == -1 } {
      set_error -3 "root access required"
      return
   } 


   puts $CHECK_OUTPUT "check if limits are propagated to qrsh jobs"
   set limit_in 10

   foreach host $qrsh_hostlist {
      set qrsh_id [open_remote_spawn_process $CHECK_HOST "ts_def_con" $CHECK_PRODUCT_ROOT/bin/$CHECK_ARCH/qrsh "-l hostname=$host -l h_cpu=$limit_in $CHECK_ACTUAL_TEST_PATH/ulimit.sh"]
      set sp_id [ lindex $qrsh_id 1 ] 

      set timeout 60
      expect {
         -i $sp_id full_buffer {
            add_proc_error "qrsh_limits" -1 "buffer overflow please increment CHECK_EXPECT_MATCH_MAX_BUFFER value"
            close_spawn_process $qrsh_id
            continue
         }
         -i $sp_id timeout {
            add_proc_error "qrsh_limits" -1 "qrsh to host $host failed"
            close_spawn_process $qrsh_id
            continue
         }
         -i $sp_id eof {
            add_proc_error "qrsh_limits" -1 "qrsh to host $host failed"
            close_spawn_process $qrsh_id
            continue
         }
         -i $sp_id "CPU limit is *\n" {
            set limit_out [lindex $expect_out(0,string) 3]
            puts $CHECK_OUTPUT "qrsh to host $host ok, CPU limit is $limit_out s"

            if { $limit_out != $limit_in } {
               add_proc_error "qrsh_limits" -1 "limit on host $host not correctly set"
            }
         }
      }

      close_spawn_process $qrsh_id
   }

   set_error 0 "ok"
}


