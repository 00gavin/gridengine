#!/vol2/TCL_TK/glinux/bin/expect
# global variables ... (defined in main check routine, but you can use it)
#___INFO__MARK_BEGIN__
##########################################################################
#
#  The Contents of this file are made available subject to the terms of
#  the Sun Industry Standards Source License Version 1.2
#
#  Sun Microsystems Inc., March, 2001
#
#
#  Sun Industry Standards Source License Version 1.2
#  =================================================
#  The contents of this file are subject to the Sun Industry Standards
#  Source License Version 1.2 (the "License"); You may not use this file
#  except in compliance with the License. You may obtain a copy of the
#  License at http://gridengine.sunsource.net/Gridengine_SISSL_license.html
#
#  Software provided under this License is provided on an "AS IS" basis,
#  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
#  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
#  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
#  See the License for the specific provisions governing your rights and
#  obligations concerning the Software.
#
#  The Initial Developer of the Original Code is: Sun Microsystems, Inc.
#
#  Copyright: 2001 by Sun Microsystems, Inc.
#
#  All Rights Reserved.
#
##########################################################################
#___INFO__MARK_END__

# Define the global veriables to give them back
global check_name 
global check_description 
global check_needs
global check_functions 
global check_errno 
global check_errstr 
global check_highest_level
global check_init_level_procedure
global check_root_access_needs
global env
global check_category

# define a level initialization procedure:
set check_init_level_procedure "qconf_init_level"

# define test's name and run level descriptions
set check_name            "qconf"
set check_category        "COMPATIBILITY SYSTEM VERIFIED"
set check_highest_level    0
set check_description(0)  "test all qconf options (test not complete)"

# define test's dependencies
#set check_needs        "init_core_system qstat qsub"       ;# dependencies of this check (name of other check)
set check_needs        "init_core_system"       ;# dependencies of this check (name of other check)


global qconf_original_host_groups qconf_original_usersets
# setup and cleanup functions
set check_setup_function "qconf_setup"
set check_cleanup_function "qconf_cleanup"

# define test's procedure order
set check_functions     ""
lappend check_functions "qconf_addqueues"             ;# functions to call (in order)
lappend check_functions "qconf_removequeues"
lappend check_functions "qconf_auser"
lappend check_functions "qconf_duser"
lappend check_functions "qconf_Auser"
lappend check_functions "qconf_muser"
lappend check_functions "qconf_Muser"
lappend check_functions "qconf_de_check"
lappend check_functions "qconf_segfault"
lappend check_functions "qconf_se"
lappend check_functions "qconf_sel"

# TODO: check all options
#lappend check_functions "qconf_aattr_check"
#lappend check_functions "qconf_rattr_check"
#lappend check_functions "qconf_Aattr_check"
#lappend check_functions "qconf_Rattr_check"
#lappend check_functions "qconf_dattr_check"
#lappend check_functions "qconf_Dattr_check"
#lappend check_functions "qconf_mattr_check"
#lappend check_functions "qconf_Mattr_check"

# Show options DONE
lappend check_functions "qconf_scal_check"   	;# List calendars
lappend check_functions "qconf_scall_check"	;# List all calalendars
lappend check_functions "qconf_sconfl_check"	;# List all hosts with configurations
lappend check_functions "qconf_sds_check"	;# List detached settings in the cluster  config
lappend check_functions "qconf_secl_check"	;# List event client list
lappend check_functions "qconf_sep_check"	;# List processors
lappend check_functions "qconf_shgrp_tree_check"	;# List tree like structure of hosts
lappend check_functions "qconf_shgrp_resolved_check"	;# List  hosts in a group
lappend check_functions "qconf_sm_check"	;# List  managers
lappend check_functions "qconf_so_check"	;# List operators 
lappend check_functions "qconf_ss_check"	;# List submit hosts
lappend check_functions "qconf_sss_check"	;# Show scheduler status
lappend check_functions "qconf_sul_check"	;# Show user list
lappend check_functions "qconf_sprjl_check"	;# Show project list

# New options, non-show

lappend check_functions "qconf_add_delete_manager"	;# Add and delete manager users
lappend check_functions "qconf_add_show_delete_queue"	;# Add, show and delete queue "qconf_queue.q"
#lappend check_functions "qconf_add_show_delete_host"	;# Add, show and delete host exec_host [1], the first execd host
#lappend check_functions "qconf_add_show_delete_stnode"	;# Add, show and delete share tree nodes
#lappend check_functions "qconf_event_client"	;# Create, show and delete event clients



global queue_names

global submitjob_jobid

proc qconf_init_level {} {
   global ts_config
   global CHECK_ACT_LEVEL hold_state pending_state queue_names

  set queue_names     ""
  for { set i 0 } { $i < 1000 }  {incr i 1} {
     lappend queue_names "q.$i"
  }

  switch -- $CHECK_ACT_LEVEL {
     "0" {
        if { [llength $ts_config(execd_nodes)] <= 1 } {
           set_error -1 "need more than one host for this test"
           return -1
        } else {
           return 0
        }
     } 
  }

  return -1  ;# no other level else
}

proc qconf_setup {} {
   global CHECK_OUTPUT qconf_original_host_groups qconf_original_usersets
   puts $CHECK_OUTPUT "setup ..."
   set output [start_sge_bin qconf -shgrpl]
   set output [string trim $output]
   set qconf_original_host_groups {}
   foreach hg $output {
      lappend qconf_original_host_groups $hg
      puts $CHECK_OUTPUT "saving known hostgroup \"$output\" for cleanup procedure"
   }

   set output [start_sge_bin qconf -sul]
   set output [string trim $output]
   set qconf_original_usersets {}
   foreach user $output {
      lappend qconf_original_usersets $user
      puts $CHECK_OUTPUT "saving known userset \"$output\" for cleanup procedure"
   }


   set_error 0 ""
}


proc qconf_cleanup {} {
   global CHECK_OUTPUT qconf_original_host_groups qconf_original_usersets

   puts $CHECK_OUTPUT "cleanup ..."
   set output [start_sge_bin qconf -shgrpl]
   set output [string trim $output]
   foreach hg $output {
      puts $CHECK_OUTPUT "testing hostgroup \"$hg\" ..."
      if { [lsearch -exact $qconf_original_host_groups $hg] < 0 } {
         puts $CHECK_OUTPUT "deleting unexpected hostgroup \"$hg\" ..."
         set res [start_sge_bin qconf "-dhgrp $hg"]
         puts $CHECK_OUTPUT $res
      }
   }

   set output [start_sge_bin qconf -sul]
   set output [string trim $output]
   foreach userg $output {
      puts $CHECK_OUTPUT "testing usergroup \"$userg\" ..."
      if { [lsearch -exact $qconf_original_usersets $userg] < 0 } {
         puts $CHECK_OUTPUT "deleting unexpected usergroup \"$userg\" ..."
         set res [start_sge_bin qconf "-dusergrp $userg"]
         puts $CHECK_OUTPUT $res
      }
   }


   delete_all_jobs
   wait_for_end_of_all_jobs 60
   set_error 0 ""
}

proc qconf_auser {} {
   global CHECK_OUTPUT CHECK_PRODUCT_TYPE CHECK_HOST CHECK_USER

   puts $CHECK_OUTPUT "testing qconf -auser ..."

   if { [ string compare $CHECK_PRODUCT_TYPE "sgeee" ] == 0 } {
      set new_user(name) "qconf_test_user"
      set new_user(default_project) "mytestproject"
      add_user new_user
      set output [start_remote_prog $CHECK_HOST $CHECK_USER "qconf" "-suser qconf_test_user" ]
      if { [string first "mytestproject" $output] < 0  } {
         add_proc_error "qconf_auser" -1 "error showing user qconf_test_user"
      }
      set_error 0 "ok"
   } else {
      set_error 0 "not tested for sge system"
   }
}

proc qconf_duser {} {
   global CHECK_OUTPUT CHECK_PRODUCT_TYPE CHECK_HOST CHECK_USER
   puts $CHECK_OUTPUT "testing qconf -duser ..."

   if { [ string compare $CHECK_PRODUCT_TYPE "sgeee" ] == 0 } {
      del_user "qconf_test_user"

      set output [start_remote_prog $CHECK_HOST $CHECK_USER "qconf" "-suser qconf_test_user" ]
      if { [string first "mytestproject" $output] >= 0  } {
         add_proc_error "qconf_auser" -1 "error user qconf_test_user should have been deleted"
      }
      set_error 0 "ok"
   } else {
      set_error 0 "not tested for sge system"
   }
}


proc qconf_Auser {} {
   global CHECK_OUTPUT CHECK_PRODUCT_TYPE CHECK_HOST CHECK_USER

   puts $CHECK_OUTPUT "testing qconf -Auser ..."

   if { [ string compare $CHECK_PRODUCT_TYPE "sgeee" ] == 0 } {
      set new_user(name) "qconf_test_user"
      set new_user(default_project) "mytestproject"
      add_user new_user 1
      set output [start_remote_prog $CHECK_HOST $CHECK_USER "qconf" "-suser qconf_test_user" ]
      if { [string first "mytestproject" $output] < 0  } {
         add_proc_error "qconf_auser" -1 "error showing user qconf_test_user"
      }
      del_user "qconf_test_user"
      set_error 0 "ok"
   } else {
      set_error 0 "not tested for sge system"
   }
}


proc qconf_muser {} {
   global CHECK_OUTPUT CHECK_PRODUCT_TYPE CHECK_HOST CHECK_USER

   puts $CHECK_OUTPUT "testing qconf -muser ..."

   if { [ string compare $CHECK_PRODUCT_TYPE "sgeee" ] == 0 } {
      set new_user(name) "qconf_test_user"
      set new_user(default_project) "mytestproject"
      add_user new_user
      set output [start_remote_prog $CHECK_HOST $CHECK_USER "qconf" "-suser qconf_test_user" ]
      if { [string first "mytestproject" $output] < 0  } {
         add_proc_error "qconf_muser" -1 "error showing user qconf_test_user"
      }
      # now modifiy user
      set new_conf(name)  "qconf_test_user"
      set new_conf(default_project) "NONE"
      mod_user new_conf 
      set output [start_remote_prog $CHECK_HOST $CHECK_USER "qconf" "-suser qconf_test_user" ]
      puts $CHECK_OUTPUT $output
      if { [string first "mytestproject" $output] >= 0  } {
         add_proc_error "qconf_muser" -1 "error modify user qconf_test_user"
      }

      # now delete user
      del_user "qconf_test_user"


      set_error 0 "ok"
   } else {
      set_error 0 "not tested for sge system"
   }
}

proc qconf_Muser {} {
   global CHECK_OUTPUT CHECK_PRODUCT_TYPE CHECK_HOST CHECK_USER

   puts $CHECK_OUTPUT "testing qconf -Muser ..."

   if { [ string compare $CHECK_PRODUCT_TYPE "sgeee" ] == 0 } {
      set new_user(name) "qconf_test_user"
      set new_user(default_project) "mytestproject"
      add_user new_user
      set output [start_remote_prog $CHECK_HOST $CHECK_USER "qconf" "-suser qconf_test_user" ]
      if { [string first "mytestproject" $output] < 0  } {
         add_proc_error "qconf_Muser" -1 "error showing user qconf_test_user"
      }
      # now modifiy user
      set new_conf(name)  "qconf_test_user"
      set new_conf(default_project) "NONE"
      mod_user new_conf 1
      set output [start_remote_prog $CHECK_HOST $CHECK_USER "qconf" "-suser qconf_test_user" ]
      puts $CHECK_OUTPUT $output
      if { [string first "mytestproject" $output] >= 0  } {
         add_proc_error "qconf_Muser" -1 "error modify user qconf_test_user"
      }

      # now delete user
      del_user "qconf_test_user"


      set_error 0 "ok"
   } else {
      set_error 0 "not tested for sge system"
   }
}



# run qconf -aq
#                                                             max. column:     |
#****** qconf/qconf_addqueues() ******
# 
#  NAME
#     qconf_addqueues -- ??? 
#
#  SYNOPSIS
#     qconf_addqueues { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc qconf_addqueues {} {
   global ts_config
   global CHECK_PRODUCT_ROOT CHECK_ARCH queue_names CHECK_OUTPUT

   set q_param(load_thresholds)       "np_load_avg=7.00"

   set test_host [lindex $ts_config(execd_nodes) 0]

   set count 0
   foreach queue $queue_names {
      if { $count > 50 } {
         puts $CHECK_OUTPUT "adding queue \"$queue\" with vi"
         add_queue $queue $test_host q_param 0
         set count 0
      } else {
         puts $CHECK_OUTPUT "adding queue \"$queue\" with file"
         add_queue $queue $test_host q_param
      }
      incr count 1
   }

   set_error 0 "ok"
}



#                                                             max. column:     |
#****** qconf/qconf_removequeues() ******
# 
#  NAME
#     qconf_removequeues -- ??? 
#
#  SYNOPSIS
#     qconf_removequeues { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc qconf_removequeues {} {
   global ts_config
   global queue_names CHECK_OUTPUT

   set test_host [lindex $ts_config(execd_nodes) 0]

   foreach queue $queue_names {
     puts $CHECK_OUTPUT "deleting queue \"$queue\""
     del_queue $queue $test_host 0 1
   }

   set_error 0 "ok"
}

#                                                             max. column:     |
#****** qconf/check_exec_conf() ******
# 
#  NAME
#     check_exec_conf -- ??? 
#
#  SYNOPSIS
#     check_exec_conf { host_list attr_name check_value } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#     host_list   - ??? 
#     attr_name   - ??? 
#     check_value - ??? 
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc check_exec_conf { host_list attr_name check_value } {
  global CHECK_OUTPUT

  foreach host $host_list {
     get_exechost host_config $host
     set host_attr_value $host_config($attr_name)

     puts $CHECK_OUTPUT "host \"$host\": $attr_name is set to \"$host_attr_value\"" 

     if { [ string compare $check_value $host_attr_value ] != 0 } {
        puts $CHECK_OUTPUT "\"$check_value\" is not \"$host_attr_value\""
        add_proc_error "check_exec_conf" -1 "\"$check_value\" is not \"$host_attr_value\"" 
     }
  } 
}

# check all queues in queue_list for attr_name and compare it with check_value
#                                                             max. column:     |
#****** qconf/check_queue_conf() ******
# 
#  NAME
#     check_queue_conf -- ??? 
#
#  SYNOPSIS
#     check_queue_conf { queue_list attr_name check_value } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#     queue_list  - ??? 
#     attr_name   - ??? 
#     check_value - ??? 
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc check_queue_conf { queue_list attr_name check_value } {

  global CHECK_OUTPUT

  foreach queue $queue_list {
     get_queue $queue q_config
     set q_attr_value $q_config($attr_name)

     puts $CHECK_OUTPUT "queue \"$queue\": $attr_name is set to \"$q_attr_value\"" 

     if { [ string compare $check_value $q_attr_value ] != 0 } {
        puts $CHECK_OUTPUT "\"$check_value\" is not \"$q_attr_value\""
        add_proc_error "check_queue_conf" -1 "\"$check_value\" is not \"$q_attr_value\"" 
     }
  } 
}



# obj_nm is "queue" or "exechost" 
# attr_nm is "object"
# val is value
# obj_id_lst is a list with names of the queues or hostnames to be modified
#                                                             max. column:     |
#****** qconf/qconf_aattr_check() ******
# 
#  NAME
#     qconf_aattr_check -- ??? 
#
#  SYNOPSIS
#     qconf_aattr_check { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc qconf_aattr_check {} {
   global ts_config
   global CHECK_OUTPUT CHECK_PRODUCT_ROOT CHECK_ARCH queue_names


   # check queue add normal attribute
   check_queue_conf $queue_names qtype "BATCH INTERACTIVE"
   puts $CHECK_OUTPUT "adding qtype PARALLEL to queues $queue_names"
   set result [ catch { 
       eval exec "$CHECK_PRODUCT_ROOT/bin/$CHECK_ARCH/qconf -aattr queue qtype PARALLEL $queue_names" 
   } output ]
   if {$result != 0} {
     set_error -1 "exit state is not 0"
   }          
   puts $CHECK_OUTPUT $output
   check_queue_conf $queue_names qtype "BATCH INTERACTIVE PARALLEL"

    
   # check queue add parameter list
   check_queue_conf $queue_names load_thresholds "np_load_avg=7.00"
   puts $CHECK_OUTPUT "adding qtype PARALLEL to queues $queue_names"
   set result [ catch { 
       eval exec "$CHECK_PRODUCT_ROOT/bin/$CHECK_ARCH/qconf -aattr queue load_thresholds \"mem_free=1M\" $queue_names" 
   } output ]
   if {$result != 0} {
     set_error -1 "exit state is not 0"
   }          
   puts $CHECK_OUTPUT $output
   check_queue_conf $queue_names load_thresholds "np_load_avg=7.00,mem_free=1M"

   # check global host add user_lists list
   check_exec_conf $ts_config(execd_nodes) user_lists "NONE"

   puts $CHECK_OUTPUT "adding deadlineusers to user_lists of all execd hosts"
   set result [ catch { 
       eval exec "$CHECK_PRODUCT_ROOT/bin/$CHECK_ARCH/qconf -aattr exechost user_lists \"deadlineusers\" $ts_config(execd_nodes)" 
   } output ]
   if {$result != 0} {
     set_error -1 "exit state is not 0"
   }          
   puts $CHECK_OUTPUT $output
   check_exec_conf $ts_config(execd_nodes) user_lists "deadlineusers"

   puts $CHECK_OUTPUT "adding defaultdepartment to user_lists of all execd hosts"
   set result [ catch { 
       eval exec "$CHECK_PRODUCT_ROOT/bin/$CHECK_ARCH/qconf -aattr exechost user_lists \"defaultdepartment\" $ts_config(execd_nodes)" 
   } output ]
   if {$result != 0} {
     set_error -1 "exit state is not 0"
   }          
   puts $CHECK_OUTPUT $output
   check_exec_conf $ts_config(execd_nodes) user_lists "deadlineusers defaultdepartment"

   set_error 0 "ok"
}

#                                                             max. column:     |
#****** qconf/qconf_Aattr_check() ******
# 
#  NAME
#     qconf_Aattr_check -- ??? 
#
#  SYNOPSIS
#     qconf_Aattr_check { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc qconf_Aattr_check {} {
   global CHECK_OUTPUT CHECK_PRODUCT_ROOT CHECK_ARCH queue_names 
   global CHECK_ACTUAL_TEST_PATH

   # check queue add normal attribute
   check_queue_conf $queue_names qtype "BATCH INTERACTIVE"
   check_queue_conf $queue_names load_thresholds "np_load_avg=7.00"

   puts $CHECK_OUTPUT "adding qtype PARALLEL and load_thresholds mem_free=1M to queues $queue_names"
   set result [ catch { 
       eval exec "$CHECK_PRODUCT_ROOT/bin/$CHECK_ARCH/qconf -Aattr queue $CHECK_ACTUAL_TEST_PATH/Aattr_file_queue_wrong_syntax  $queue_names" 
   } output ]
   if {$result != 1} {
      set_error -1 "exit state is not 1 (used wrong file syntax format)"
   }
   
   set result [ catch { 
       eval exec "$CHECK_PRODUCT_ROOT/bin/$CHECK_ARCH/qconf -Aattr queue $CHECK_ACTUAL_TEST_PATH/Aattr_file_queue $queue_names" 
   } output ]

   if {$result != 0} {
     set_error -1 "exit state is not 0"
   }          
   puts $CHECK_OUTPUT $output
   check_queue_conf $queue_names qtype "BATCH INTERACTIVE PARALLEL"
   check_queue_conf $queue_names load_thresholds "np_load_avg=7.00,mem_free=1M"

   set_error 0 "ok"
}

#                                                             max. column:     |
#****** qconf/qconf_dattr_check() ******
# 
#  NAME
#     qconf_dattr_check -- ??? 
#
#  SYNOPSIS
#     qconf_dattr_check { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc qconf_dattr_check {} {
}

#                                                             max. column:     |
#****** qconf/qconf_Dattr_check() ******
# 
#  NAME
#     qconf_Dattr_check -- ??? 
#
#  SYNOPSIS
#     qconf_Dattr_check { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc qconf_Dattr_check {} {
}

#                                                             max. column:     |
#****** qconf/qconf_mattr_check() ******
# 
#  NAME
#     qconf_mattr_check -- ??? 
#
#  SYNOPSIS
#     qconf_mattr_check { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc qconf_mattr_check {} {
}

#                                                             max. column:     |
#****** qconf/qconf_Mattr_check() ******
# 
#  NAME
#     qconf_Mattr_check -- ??? 
#
#  SYNOPSIS
#     qconf_Mattr_check { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc qconf_Mattr_check {} {
}

#                                                             max. column:     |
#****** qconf/qconf_rattr_check() ******
# 
#  NAME
#     qconf_rattr_check -- ??? 
#
#  SYNOPSIS
#     qconf_rattr_check { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc qconf_rattr_check {} {
   global ts_config
   global CHECK_OUTPUT CHECK_PRODUCT_ROOT CHECK_ARCH queue_names

   puts $CHECK_OUTPUT "replaceing exechost user_lists with NONE"
   set result [ catch { 
       eval exec "$CHECK_PRODUCT_ROOT/bin/$CHECK_ARCH/qconf -rattr exechost user_lists \"NONE\" $ts_config(execd_nodes)" 
   } output ]
   if {$result != 0} {
     set_error -1 "exit state is not 0"
   }          
   puts $CHECK_OUTPUT $output

   check_exec_conf $ts_config(execd_nodes) user_lists "NONE"

   puts $CHECK_OUTPUT "replaceing queues qtype with BATCH INTERACTIVE"
   set result [ catch { 
       eval exec "$CHECK_PRODUCT_ROOT/bin/$CHECK_ARCH/qconf -rattr queue qtype \"BATCH INTERACTIVE\" $queue_names" 
   } output ]
   if {$result != 0} {
     set_error -1 "exit state is not 0"
   }          
   puts $CHECK_OUTPUT $output
   check_queue_conf $queue_names qtype "BATCH INTERACTIVE"

   puts $CHECK_OUTPUT "replaceing queues load_thresholds with np_load_avg=7.00"
   set result [ catch { 
       eval exec "$CHECK_PRODUCT_ROOT/bin/$CHECK_ARCH/qconf -rattr queue load_thresholds \"np_load_avg=7.00\" $queue_names" 
   } output ]
   if {$result != 0} {
     set_error -1 "exit state is not 0"
   }          
   puts $CHECK_OUTPUT $output
   check_queue_conf $queue_names load_thresholds "np_load_avg=7.00"



   set_error 0 "ok"
}

#                                                             max. column:     |
#****** qconf/qconf_Rattr_check() ******
# 
#  NAME
#     qconf_Rattr_check -- ??? 
#
#  SYNOPSIS
#     qconf_Rattr_check { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc qconf_Rattr_check {} {
}

#                                                             max. column:     |
#****** qconf/qconf_Rattr_check() ******
# 
#  NAME
#     qconf_Rattr_check -- ??? 
#
#  SYNOPSIS
#     qconf_Rattr_check { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc qconf_de_check {} {
   global ts_config
   global CHECK_OUTPUT CHECK_PRODUCT_TYPE CHECK_USER CHECK env
   puts $CHECK_OUTPUT "testing qconf -de ..."

   if { $ts_config(gridengine_version) == 53 } {
      set_error 0 "test doesn't apply for SGE 5.3"
      return
   }

   # Setup
   set execd [lindex $ts_config(execd_nodes) 0]
   set arch [resolve_arch $ts_config(master_host)]

   puts $CHECK_OUTPUT "using execd host $execd"

   # the tmp_file is automatically removed from testsuite
   set tmp_file [get_tmp_file_name]
   set catch_result [ catch {  eval exec "$ts_config(product_root)/bin/$arch/qconf -se $execd | grep -v load_values | grep -v processors > $tmp_file" } result ]
   if { $catch_result != 0 } {
      add_proc_error "qconf_de_check" "-1" "could not store execd config: $result"
   }
   puts $CHECK_OUTPUT "tmp file is: $tmp_file"
   puts $CHECK_OUTPUT "doing qconf -dattr hostgroup hostlist $execd @allhosts:"
   set catch_result [ catch {  eval exec "$ts_config(product_root)/bin/$arch/qconf -dattr hostgroup hostlist $execd @allhosts" } result ]
   puts $CHECK_OUTPUT $result
 
   if { $catch_result != 0 } {
      add_proc_error "qconf_de_check" "-1" "could not remove host from hostgroup @allhosts: $result"
   }

 
   # Test
   puts $CHECK_OUTPUT "doing qconf -de $execd"
   set catch_result [ catch {  eval exec "$ts_config(product_root)/bin/$arch/qconf" "-de" "$execd" } result ]
   puts $CHECK_OUTPUT $result
   
   set EXEC_HOST_REMOVED [translate $ts_config(master_host) 1 0 0 [sge_macro MSG_SGETEXT_REMOVEDFROMLIST_SSSS] $CHECK_USER [resolve_host $ts_config(master_host) 1] [resolve_host $execd 1] "execution host"]

   puts $CHECK_OUTPUT "looking for : \"$EXEC_HOST_REMOVED\""
   puts $CHECK_OUTPUT "answer was  : \"$result\""

   if { [ string match "*$EXEC_HOST_REMOVED*" $result ] == 0 } {
      add_proc_error "qconf_de_check" "-1" "could not delete live execd: $result\nBug 1269: qconf -de still crashes qmaster"
   }
   puts $CHECK_OUTPUT "removed execd $execd from cluster"

   puts $CHECK_OUTPUT "doing qconf -Ae $tmp_file"
   catch { eval exec "$ts_config(product_root)/bin/$arch/qconf -Ae $tmp_file" } result 
   puts $CHECK_OUTPUT $result

   puts $CHECK_OUTPUT "doing qconf -aattr hostgroup hostlist $execd @allhosts"
   catch { eval exec "$ts_config(product_root)/bin/$arch/qconf -aattr hostgroup hostlist $execd @allhosts" } result
   puts $CHECK_OUTPUT $result

   puts $CHECK_OUTPUT "added execd $execd to cluster"

   set_error 0 "ok"
}

proc qconf_segfault {} {
   global ts_config CHECK_OUTPUT CHECK_ARCH CHECK_HOST CHECK_USER

   set output [start_remote_prog $CHECK_HOST $CHECK_USER "$ts_config(product_root)/bin/$CHECK_ARCH/qconf" "-as \"\""]
   if { [string match "*egmentation ?ault*" $output] == 1 } {
      puts $CHECK_OUTPUT $output
      add_proc_error "qconf_segfault" -1 "qconf -as \"\" failed - see Issue: 1732"
   }
   set output [start_remote_prog $CHECK_HOST $CHECK_USER "$ts_config(product_root)/bin/$CHECK_ARCH/qconf" "-ah \"\""]
   if { [string match "*egmentation ?ault*" $output] == 1 } {
      puts $CHECK_OUTPUT $output
      add_proc_error "qconf_segfault" -1 "qconf -ah \"\" failed - see Issue: 1732"
   }

   set output [start_remote_prog $CHECK_HOST $CHECK_USER "$ts_config(product_root)/bin/$CHECK_ARCH/qconf" "-ae localhost"]
   if { [string match "*egmentation ?ault*" $output] == 1 } {
      puts $CHECK_OUTPUT $output
      add_proc_error "qconf_segfault" -1 "qconf -ah \"\" failed - see Issue: 1884"
   } else {
      set output [start_remote_prog $CHECK_HOST $CHECK_USER "$ts_config(product_root)/bin/$CHECK_ARCH/qconf" "-de localhost"]
   }


   set_error 0 "ok"
}

proc qconf_se {} {
   global ts_config
  
   # test hosts
   set cluster_host [lindex $ts_config(execd_nodes) 0]
   set non_cluster_host [host_conf_get_unused_host]

   # fields delivered by qconf -se
   if {$ts_config(gridengine_version) == 53} {
      set qconf_se_fields "hostname load_scaling complex_list complex_values load_values processors user_lists xuser_lists projects xprojects usage_scaling resource_capability_factor"
   } else {
      set qconf_se_fields "hostname load_scaling complex_values load_values processors user_lists xuser_lists projects xprojects usage_scaling report_variables"
   }

   # positive check
   # check qconf -se <an exec host>, check completeness of result
   if {[get_exechost exec_host $cluster_host] == 0} {
      foreach elem $qconf_se_fields {
         if {![info exists exec_host($elem)]} {
            add_proc_error "qconf_se" -1 "$elem is missing in result of qconf -se"
         }
      }
   }

   # negative checks
   # check qconf -se <a non exec host>
   if {$non_cluster_host != ""} {
      if {[get_exechost exec_host $non_cluster_host "" "" 0] == 0} {
         add_proc_error "qconf_se" -1 "qconf -se $non_cluster_host (non cluster host) should have failed"
      }
   }

   # check qconf -se from a non admin/submit host
   if {$non_cluster_host != ""} {
      if {[get_exechost exec_host $cluster_host $non_cluster_host "" 0] == 0} {
         add_proc_error "qconf_se" -3 "qconf -se called on $non_cluster_host (non submit/admin host) should have failed\nknown issue 1889"
      }
   }

   set_error 0 "ok"
}

proc qconf_sel {} {
   global ts_config
  
   # test hosts
   set non_cluster_host [host_conf_get_unused_host]

   # positive check
   # qconf -sel, has to match testsuite's execd_nodes list
   if {[get_exechost_list exechost_list] == 0} {
      set qconf_list [lsort $exechost_list]
      set testsuite_list [lsort $ts_config(execd_nodes)]
      if {[string compare $qconf_list $testsuite_list] != 0} {
         add_proc_error "qconf_sel" -1 "exec host list delivered by qconf does not match testsuite exec host list:\n$qconf_list\n$testsuite_list"
      }
   }

   # negative check
   # call qconf -sel on a non admin/submit host
   if {$non_cluster_host != ""} {
      if {[get_exechost_list exechost_list $non_cluster_host "" 0] == 0} {
         add_proc_error "qconf_sel" -3 "qconf -sel called on $non_cluster_host (non submit/admin host) should have failed\nknown issue 1889"
      }
   }

   set_error 0 "ok"
}


#                                                             max. column:     |
#****** qconf/qconf_scal_check() ******
#
#  NAME
#     qconf_scal_check - Check known calendar "always_suspend"
#
#  SYNOPSIS
#     qconf_scal_check { } - Call get_calendar with calendar "always_suspend"
#                            Then call get_calendar with a wrong calendar name,
#                            like "wrong_calendar". 
#
#  FUNCTION
#     Check basic functionality of qconf
#
#  SEE ALSO
# sge_calendar/get_calendar()
# sge_calendar/get_calender_error()
#
#*******************************
proc qconf_scal_check {} {
   global ts_config env
   global CHECK_OUTPUT CHECK_USER CHECK_HOST CHECK_ARCH


   # First do a positive test, give a valid calendar name, "always_suspend"
   puts $CHECK_OUTPUT "Positive test for qconf -scal always_suspend...\n"
   set result0 [get_calendar "always_suspend" ]

   if { ( $result0 == 0 ) } {
      puts $CHECK_OUTPUT "qconf -scal always_suspend succeded"
   } else {
      puts $CHECK_OUTPUT "result is $result0"
   }

   # Next do a negative test, give a invalid calendar name, "wrong_calendar"
   puts $CHECK_OUTPUT "Negative test for qconf -scal wrong_calendar...\n"
   set result1 [get_calendar "wrong_calendar" result $CHECK_HOST $CHECK_USER 0 ]

   if { ( $result1 == -1 ) } {
      puts $CHECK_OUTPUT "qconf -scal wrong_calendar succeded"
   } else {
      puts $CHECK_OUTPUT "result is $result1"

   }

   set_error 0 "ok"
}

#                                                             max. column:     |
#****** qconf/qconf_scall_check() ******
#
#  NAME
#     qconf_scall_check - Check all known calendars 
#
#  SYNOPSIS
#     qconf_scall_check { } - Call get_calender_list
#
#  FUNCTION
#     Check basic functionality of qconf
#
#  SEE ALSO
# sge_calendar/get_calender_list()
#*******************************
proc qconf_scall_check {} {

   global ts_config env
   global CHECK_OUTPUT CHECK_USER CHECK_HOST CHECK_ARCH

   # Do a positive test
   puts $CHECK_OUTPUT "Positive test for qconf -scall ...\n"
   set result0 [get_calender_list ]

   if { ( $result0 == 0 ) } {
      puts $CHECK_OUTPUT "qconf -scall succeded"
   } else {
      puts $CHECK_OUTPUT "result is $result0"

   }

   set_error 0 "ok"
}

#                                                             max. column:     |
#****** qconf/qconf_sconfl_check() ******
#
#  NAME
#     qconf_sconfl_check - Display a list of hosts  for  which  configurations
#                          are  available.  
#
#  SYNOPSIS
#     qconf_sconfl_check { } - Call get_config_list
#
#  FUNCTION
#     Check basic functionality of qconf
#
#  SEE ALSO
# sge_host/get_config_list()
#*******************************

proc qconf_sconfl_check {} {

   global ts_config env
   global CHECK_OUTPUT CHECK_USER CHECK_HOST CHECK_ARCH

   # Do a positive test
    puts $CHECK_OUTPUT "Positive test for qconf -sconfl ...\n"

   set result0 [get_queue_config_list ]

   if { ( $result0 == 0 ) } {
      puts $CHECK_OUTPUT "qconf -sconfl succeded"
   } else {
      puts $CHECK_OUTPUT "result is $result0"
   }

   set_error 0 "ok"
}

#                                                             max. column:     |
#****** qconf/qconf_sds_check() ******
#
#  NAME
#     qconf_sds_check - Display detached settings in the cluster  config
#
#  SYNOPSIS
#     qconf_sds_check { } - Call get_detached_settings
#
#  FUNCTION
#     Check basic functionality of qconf
#
#  SEE ALSO
# sge_procedures/get_detached_settings()
#*******************************

proc qconf_sds_check {} {

   global ts_config env
   global CHECK_OUTPUT CHECK_USER CHECK_HOST CHECK_ARCH
  
   # First do a positive test
   set result0 [get_detached_settings]


   if { ( $result0 == 0 ) } {
      puts $CHECK_OUTPUT "qconf -sds succeded"
   } else {
      puts $CHECK_OUTPUT "result is $result0"
   }

   set_error 0 "ok"
}

#                                                      max. column:     |
#****** qconf/qconf_secl_check() ******
#
#  NAME
#     qconf_secl_check - Display the event client list
#
#  SYNOPSIS
#     qconf_secl_check { } - Call get_event_client_list
#
#  FUNCTION
#     Check basic functionality of qconf
#
#  SEE ALSO
# sge_procedures/get_event_client_list()
#*******************************

proc qconf_secl_check {} {
   global ts_config env
   global CHECK_OUTPUT CHECK_USER CHECK_HOST CHECK_ARCH

   # DO A Positive test
   puts $CHECK_OUTPUT "Positive test for qconf -secl ...\n"

   set result0 [get_event_client_list]

   if { ( $result0 == 0 ) } {
      puts $CHECK_OUTPUT "qconf -secl succeded"
   } else {
      puts $CHECK_OUTPUT "result is $result0"
   }

   set_error 0 "ok"
}

#                                               max. column:     | #
#****** qconf/qconf_sep_check() ******  
#  NAME
#     qconf_sep_check - Display the processor list
#
#  SYNOPSIS
#     qconf_sep_check { } - Call get_processor_list
#
#  FUNCTION
#     Check basic functionality of qconf
#
#  SEE ALSO
# sge_host/get_processor_list()
#*******************************
proc qconf_sep_check {} {
   global ts_config env
   global CHECK_OUTPUT CHECK_USER CHECK_HOST CHECK_ARCH

   # DO A Positive test
   puts $CHECK_OUTPUT "Positive test for qconf -sep ...\n"
   set result0 [get_processor_list]

  if { ( $result0 == 0 ) } {
      puts $CHECK_OUTPUT "qconf -sep succeded\n"
   } else {
      puts $CHECK_OUTPUT "result is $result0"
   }

   set_error 0 "ok"
}
#                                                             max. column:     |
#****** qconf/qconf_shgrp_tree_check() ******
#
#  NAME
#     qconf_shgrp_tree_check - Display tree like structure of host group 
#
#  SYNOPSIS
#     qconf_shgrp_tree_check { } - Call get_shgrp_tree_error for group "@allhosts"
#
#  FUNCTION
#     Check basic functionality of qconf
#
#  SEE ALSO
# sge_host.60/get_hostgroup_tree()
# sge_host.60/get_hostgroup_tree_error()
#*******************************
proc qconf_shgrp_tree_check {} {
   global ts_config env
   global CHECK_OUTPUT CHECK_USER CHECK_HOST CHECK_ARCH

   # First do a positive test
   puts $CHECK_OUTPUT "Positive test for qconf -shgrp_tree ...\n"
   set result0 [get_hostgroup_tree "@allhosts" ]

   if { ( $result0 == 0 ) } {
      puts $CHECK_OUTPUT "qconf -shgrp_tree @allhosts succeded"
   } else {
      puts $CHECK_OUTPUT "result is $result0"
   }

   # next do a negative test
   puts $CHECK_OUTPUT "Negative test for qconf -shgrp_tree ...\n"
   set result1 [get_hostgroup_tree "wrong_hostgroup" result $CHECK_HOST $CHECK_USER 0]

   if { ( $result1 == -1 ) } {
      puts $CHECK_OUTPUT "qconf -shgrp_tree wrong_hostgroup succeded"
   } else {
      puts $CHECK_OUTPUT "result is $result1"
   }

   set_error 0 "ok"
}
#                                                             max. column:     |
#****** qconf/qconf_shgrp_resolved_check() ******
#
#  NAME
#     qconf_shgrp_resolved_check - Display list of host group 
#
#  SYNOPSIS
#     qconf_shgrp_resolved_check { } - Call "qconf -shgrp_resolved @allhosts"
#                            Check that the output contains   "$CHECK_HOST"
#
#  FUNCTION
#     Check basic functionality of qconf
#
#  SEE ALSO
# sge_host.60/get_hostgroup_resolved()
# sge_host.60/get_hostgroup_resolved_error()
#*******************************
proc qconf_shgrp_resolved_check {} {
   global ts_config env
   global CHECK_OUTPUT CHECK_USER CHECK_HOST CHECK_ARCH

   # First do a positive test
   puts $CHECK_OUTPUT "Positive test for qconf -shgrp_resolved ...\n"
   set result0 [get_hostgroup_resolved "@allhosts" ]
   if { ( $result0 == 0 ) } {
      puts $CHECK_OUTPUT "qconf -shgrp_resolved @allhosts  succeded"
   } else {
      puts $CHECK_OUTPUT "result is $result0"
   }

   # next do a negative test
   puts $CHECK_OUTPUT "Negative test for qconf -shgrp_resolved ...\n"
   set result1 [get_hostgroup_resolved "wrong_hostgroup" result $CHECK_HOST $CHECK_USER 0]

   if { ( $result1 == -1 ) } {
      puts $CHECK_OUTPUT "qconf -shgrp_resolved wrong_hostgroup succeded"
   } else {
      puts $CHECK_OUTPUT "result is $result1"
   }

   set_error 0 "ok"
}
#                                                             max. column:     |
#****** qconf/qconf_sm_check() ******
#
#  NAME
#     qconf_sm_check - Display list of managers
#
#  SYNOPSIS
#     qconf_sm_check { } - Call get_manager_list
#
#  FUNCTION
#     Check basic functionality of qconf
#
#  SEE ALSO
# sge_host/get_manager_list()
#*******************************
proc qconf_sm_check {} {
   global ts_config env
   global CHECK_OUTPUT CHECK_USER CHECK_HOST CHECK_ARCH

   # First do a positive test
   puts $CHECK_OUTPUT "Positive test for qconf -sm ...\n"

   set result0 [get_manager_list]

  if { ( $result0 == 0 ) } {
      puts $CHECK_OUTPUT "qconf -sm succeded"
   } else {
      puts $CHECK_OUTPUT "result is $result0"
   }

   set_error 0 "ok"
}
#                                                             max. column:     |
#****** qconf/qconf_so_check() ******
#
#  NAME
#     qconf_so_check - Display list of operators
#
#  SYNOPSIS
#     qconf_so_check { } - Call get_operator_list
#
#  FUNCTION
#     Check basic functionality of qconf
#
#  SEE ALSO
# sge_host/get_operator_list()
#*******************************
proc qconf_so_check {} {
   global ts_config env
   global CHECK_OUTPUT CHECK_USER CHECK_HOST CHECK_ARCH

   # Do a positive test
   puts $CHECK_OUTPUT "Positive test for qconf -so ...\n"
   set result0 [get_operator_list]

   if { ( $result0 == 0 ) } {
      puts $CHECK_OUTPUT "qconf -so succeded"
   } else {
      puts $CHECK_OUTPUT "result is $result0"
   }

   set_error 0 "ok"
}

#                                                             max. column:     |
#****** qconf/qconf_ss_check() ******
#
#  NAME
#     qconf_ss_check - Display list of submit hosts
#
#  SYNOPSIS
#     qconf_ss_check { } - Call get_submithost_list
#
#  FUNCTION
#     Check basic functionality of qconf
#
#  SEE ALSO
# sge_host/get_submithost_list()
#*******************************
proc qconf_ss_check {} {
   global ts_config env
   global CHECK_OUTPUT CHECK_USER CHECK_HOST CHECK_ARCH

   # Do a positive test
   puts $CHECK_OUTPUT "Positive test for qconf -ss ...\n"
   set result0 [get_submithost_list ]

   if { ( $result0 == 0 ) } {
      puts $CHECK_OUTPUT "qconf -ss succeded"
   } else {
      puts $CHECK_OUTPUT "result is $result0"
   }

   set_error 0 "ok"
}
#                                                             max. column:     |
#****** qconf/qconf_sss_check() ******
#
#  NAME
#     qconf_sss_check - Display scheduler status
#
#  SYNOPSIS
#     qconf_sss_check { } - Call "qconf -sss "
#                            Check that the output contains   "$CHECK_HOST"
#
#  FUNCTION
#     Check basic functionality of qconf
#
#  SEE ALSO
# sge_procedures/get_scheduler_status()
#*******************************
proc qconf_sss_check {} {
   global ts_config env
   global CHECK_OUTPUT CHECK_USER CHECK_HOST CHECK_ARCH

   # Do a positive tests
   puts $CHECK_OUTPUT "Positive test for qconf -sss ...\n"
   set result0 [get_scheduler_status]

   if { ( $result0 == 0 ) } {
      puts $CHECK_OUTPUT "qconf -sss succeded"
   } else {
      puts $CHECK_OUTPUT "result is $result0"
   }

   set_error 0 "ok"
}
#                                                             max. column:     |
#****** qconf/qconf_sul_check() ******
#
#  NAME
#     qconf_sul_check - Display user list
#
#  SYNOPSIS
#     qconf_sul_check { } - Call get_user_list
#
#  FUNCTION
#     Check basic functionality of qconf
#
#  SEE ALSO
# sge_users/get_user_list()
#*******************************
proc qconf_sul_check {} {
   global ts_config env
   global CHECK_OUTPUT CHECK_USER CHECK_HOST CHECK_ARCH

   # Do q positive test
   puts $CHECK_OUTPUT "Positive test for qconf -sul ...\n"
   set result0 [get_user_list ]

   if { ( $result0 == 0 ) } {
      puts $CHECK_OUTPUT "qconf -sul succeded"
   } else {
      add_proc_error "qconf_sul_check" -1 "qconf -sul failed"
      puts $CHECK_OUTPUT "result is $result0"
   }

   set_error 0 "ok"
}
#                                                             max. column:     |
#****** qconf/qconf_sprjl_check() ******
#
#  NAME
#     qconf_sprjl_check - Display project list
#
#  SYNOPSIS
#     qconf_sprjl_check { } - Call "qconf -sprjl "
#                            Check that the output contains   "mytestproject"
#
#  FUNCTION
#     Check basic functionality of qconf
#
#  SEE ALSO
# sge_project/get_project_list()
#*******************************
proc qconf_sprjl_check {} {
   global ts_config env
   global CHECK_OUTPUT CHECK_USER CHECK_HOST CHECK_ARCH

    # Do a positive test
    puts $CHECK_OUTPUT "Positive test for qconf -sprjl ...\n"
    set result0 [get_project_list]

   if { ( $result0 == 0 ) } {
      puts $CHECK_OUTPUT "qconf -sprjl succeded"
   } else {
      puts $CHECK_OUTPUT "result is $result0"
   }

   set_error 0 "ok"
}
#                                                             max. column:     |
#****** qconf/qconf_add_delete_manager() ******
#
#  NAME
#     qconf_add_delete_manager - Add and delete manager user
#
#  SYNOPSIS
#     qconf_add_delete_manager { } - Call add_manager, get_manager_list,
#	                             del_manager
#
#  FUNCTION
#     Check basic functionality of qconf
#
#  SEE ALSO
# sge_users/add_manager()
# sge_users/get_manager_list()
# sge_users/del_manager()
#*******************************
proc qconf_add_delete_manager {} {
   global ts_config env
   global CHECK_OUTPUT CHECK_USER CHECK_HOST CHECK_ARCH

   # First add manager "qconf_user"
   puts $CHECK_OUTPUT "Positive test for qconf -am ...\n"
   set result0 [add_manager "qconf_user"]

   if { ( $result0 == 0 ) } {
      puts $CHECK_OUTPUT "qconf -am qconf_user succeded"
   } else {
      puts $CHECK_OUTPUT "result is $result0"
   }

   # Now show manager list, check that  "qconf_user" is there
   puts $CHECK_OUTPUT "Positive test for qconf -sm ...\n"
   set result22 [get_manager_list ]

   if { ( $result22 == 0 ) } {
      puts $CHECK_OUTPUT "qconf -sm succeded"
   } else {
      puts $CHECK_OUTPUT "result is $result22"
   }

   # Now delete manager "qconf_user"
   puts $CHECK_OUTPUT "Positive test for qconf -dm ...\n"
   set result2 [del_manager "qconf_user"]

   if { ( $result2 == 0 ) } {
      puts $CHECK_OUTPUT "qconf -dm qconf_user succeded"
   } else {
      puts $CHECK_OUTPUT "result is $result2"
   }

   # Now delete manager "qconf_user" again
   puts $CHECK_OUTPUT "Negative test for qconf -dm ...\n"
   set result3 [del_manager "qconf_user"] 

   if { ( $result3 == 0 ) } {
      puts $CHECK_OUTPUT "qconf -dm qconf_user again succeded"
   } else {
      puts $CHECK_OUTPUT "result is $result3"
   }

   set_error 0 "ok"
}


#                                                             max. column:     |
#****** qconf/qconf_add_show_delete_queue() ******
#
#  NAME
#     qconf_add_show_delete_queue - Add, show and delete queue "qconf_queue.q"
#
#  SYNOPSIS
#     qconf_add_show_delete_queue { } - Call add_queue qconf_queue.q $CHECK_HOST new_queue
#                                then   "qconf -sq qconf_queue.q" to show new queue
#                                Also use "qconf -purge queue qname qconf_queue.q"
#                                Then clean up with "qconf -dq qconf_queue.q"
#
#  FUNCTION
#     Check basic functionality of qconf
#
#  SEE ALSO
#
# sge_queue/add_queue()
# sge_procedures/get_qconf_show_list()
# sge_procedures/get_qconf_show_list_error()
#*******************************
proc qconf_add_show_delete_queue {} {
   global ts_config env CHECK_ACTUAL_TEST_PATH CHECK_PRODUCT_ROOT
   global CHECK_OUTPUT CHECK_USER CHECK_HOST CHECK_ARCH

   # First add queue "qconf_queue.q". Set the new name to "qconf_queue.q, 
   # host to $CHECK_HOST

   puts $CHECK_OUTPUT "Adding queue qconf_queue.q ...\n"
   add_queue qconf_queue.q $CHECK_HOST new_queue 

   # Now show queue list, check that  "qconf_queue.q" is there
   puts $CHECK_OUTPUT "Getting information for qconf_queue.q ...\n"
   set result1 [get_queue "qconf_queue.q" change_array ]

   if { ( $result1 == 0 ) } {
      puts $CHECK_OUTPUT "qconf -sq succeded"
   } else {
      puts $CHECK_OUTPUT "result is $result1"
   }

   # Now do positive test on qconf -sql
   puts $CHECK_OUTPUT "Positive test of qconf -sql ...\n"
   set result2 [get_queue_list ]

   if { ( $result2 == 0 ) } {
      puts $CHECK_OUTPUT "qconf -sql succeded"
   } else {
      puts $CHECK_OUTPUT "result is $result2"
   }

   # Now clear queue "qconf_queue.q"
   puts $CHECK_OUTPUT "Clearing queue qconf_queue.q ...\n"
   set result3 [clear_queue "qconf_queue.q"]

   if { ( $result3 == 0 ) } {
      puts $CHECK_OUTPUT "qconf -cq qconf_queue.q succeded"
   } else {
      puts $CHECK_OUTPUT "result is $result3"
   }
   
   # Now try to clear it again!
   puts $CHECK_OUTPUT "Clearing queue qconf_queue.q again...\n"
   set result4 [clear_queue "qconf_queue.q"]

   if { ( $result4 == 0 ) } {
      puts $CHECK_OUTPUT "qconf -cq qconf_queue.q again succeded"
   } else {
      puts $CHECK_OUTPUT "result is $result4"
   }

   #  Now try to clear a non-existing queue, "wrong_queue.q"
   puts $CHECK_OUTPUT "Negative test of qconf -cq wrong_queue.q ...\n"
   set result5 [clear_queue "wrong_queue.q" result $CHECK_HOST $CHECK_USER 0]

   if { ( $result5 == -1 ) } {
      puts $CHECK_OUTPUT "qconf -cq wrong_queue.q succeded"
   } else {
      puts $CHECK_OUTPUT "result is $result5"
   }

   # Now purge queue "qconf_queue.q"
   puts $CHECK_OUTPUT "Positive test of qconf -purge hostlist ...\n"
   set result33 [purge_queue "qconf_queue.q" $CHECK_HOST "hostlist"]

   if { ( $result33 == 0 ) } {
      puts $CHECK_OUTPUT "qconf -purge queue hostlist qconf_queue.q succeded"
   } else {
      puts $CHECK_OUTPUT "result is $result33"
   }
 
   # Now purge queue "wrong_queue.q"
   puts $CHECK_OUTPUT "Negative test of qconf -purge hostlist...\n"
   set result34 [purge_queue "wrong_queue.q" $CHECK_HOST "hostlist" result $CHECK_HOST $CHECK_USER 0]

   if { ( $result34 == -1 ) } {
      puts $CHECK_OUTPUT "qconf -purge queue hostlist wrong_queue.q succeded
"
   } else {
      puts $CHECK_OUTPUT "result is $result34"
   }

 
   # Now try load_thresholds for purge
   puts $CHECK_OUTPUT "Positive test of qconf -purge load_thresholds ...\n"
   set result35 [purge_queue "qconf_queue.q" $CHECK_HOST "load_thresholds"]

   if { ( $result35 == 0 ) } {
      puts $CHECK_OUTPUT "qconf -purge queue load_thresholds qconf_queue.q succeded"
   } else {
      puts $CHECK_OUTPUT "result is $result35"
   }

   # Now purge queue "wrong_queue.q"
   puts $CHECK_OUTPUT "Negative test of qconf -purge load_thresholds...\n"
   set result36 [purge_queue "wrong_queue.q" $CHECK_HOST "load_thresholds" result $CHECK_HOST $CHECK_USER 0]

   if { ( $result36 == -1 ) } {
      puts $CHECK_OUTPUT "qconf -purge queue load_thresholds wrong_queue.q succeded "
   } else {
      puts $CHECK_OUTPUT "result is $result36"
   }


   # Now delete queue "qconf_queue.q"
   puts $CHECK_OUTPUT "Positive test of qconf -dq qconf_queue.q...\n"
   set result4 [del_queue  "qconf_queue.q" $CHECK_HOST 1]

   if { ( $result4  == 0 )} {
      puts $CHECK_OUTPUT "qconf -dq qconf_queue.q succeded"
   } else {
      puts $CHECK_OUTPUT "result is $result4"
   }

   # Now delete queue "qconf_queue.q" again
   #puts $CHECK_OUTPUT "Negative test of qconf -dq qconf_queue.q...\n"
   #set result44 [del_queue  "qconf_queue.q" $CHECK_HOST 1]

   #if { ( $result44 == 0 ) } {
   #   puts $CHECK_OUTPUT "qconf -dq qconf_queue.q again succeded"
   #} else {
   #   puts $CHECK_OUTPUT "result is $result44"
   #}

   # Now try to clear a non-existant queue
   puts $CHECK_OUTPUT "Negative test of qconf -cq qconf_queue.q...\n"
   set result5 [clear_queue "qconf_queue.q"]

   if { ( $result5 == 0 ) } {
      puts $CHECK_OUTPUT "qconf -cq qconf_queue.q again succeded"
   } else {
      puts $CHECK_OUTPUT "result is $result5"
   }

   set_error 0 "ok"

}
#                                                             max. column:     |
#****** qconf/qconf_add_show_delete_host() ******
#
#  NAME
#     qconf_add_show_delete_host - Add, show and delete host execd_nodes 1
#
#  SYNOPSIS
#     qconf_add_show_delete_host { } - Call "qconf -dh execd_host "
#	                         Show it with "qconf -sh"
#                                Then add it ack with "qconf -ah execd_host"
#                                Try to add it again
#                                Show it with "qconf -sh"
#
#  FUNCTION
#     Check basic functionality of qconf
#
#  SEE ALSO
#
# sge_procedures/get_qconf_show_list()
# sge_procedures/get_qconf_show_list_error()
#*******************************
proc qconf_add_show_delete_host {} {
   global ts_config env CHECK_ACTUAL_TEST_PATH CHECK_PRODUCT_ROOT
   global CHECK_OUTPUT CHECK_USER CHECK_HOST CHECK_ARCH

   set other_host [lindex $ts_config(execd_nodes) 1]

   set string1 [translate $CHECK_HOST 0 1 0 "added"]
   set string2 [translate $CHECK_HOST 0 1 0 "removed"]
   set string3 [translate $CHECK_HOST 0 1 0 "administrative host list"]
   set string4 [translate $CHECK_HOST 0 1 0 "already exists"]

   # First delete host $other_host. 
   get_qconf_show_list result1 $CHECK_HOST $CHECK_USER "-dh $other_host"

   if { ( [string first "$other_host"   $result1] >= 0 ) &&
        ( [string first "$string2"   $result1] >= 0 ) &&
        ( [string first "$string3"   $result1] >= 0 ) } {
      puts $CHECK_OUTPUT "qconf -dh $other_host succeded"
   } else {
      add_proc_error "qconf_add_show_delete_host" -1 "qconf -dh $other_host failed"
      puts $CHECK_OUTPUT "result is $result1"
   }

   # Now show hosts list, check that  "$other_host" is NOT there
   get_qconf_show_list result2 $CHECK_HOST $CHECK_USER "-sh "

   if { ( [string first "$other_host"   $result2] < 0 ) } {
      puts $CHECK_OUTPUT "qconf -sh succeded"
   } else {
      add_proc_error "qconf_add_show_delete_host" -1 "qconf -sh failed"
      puts $CHECK_OUTPUT "result is $result2"
   }

   # Try deleting it again
   set result3 [get_qconf_list_error result $CHECK_HOST $CHECK_USER "-dh" "$other_host" ]

   if { ( $result3 == 0 ) } {
      puts $CHECK_OUTPUT "qconf -dh $other_host again succeded"
   } else {
      add_proc_error "qconf_add_show_delete_host" -1 "qconf -dh $other_host  again failed"
      puts $CHECK_OUTPUT "result is $result3"
   }

  
 # Now add back $other_host
   get_qconf_show_list result4 $CHECK_HOST $CHECK_USER "-ah $other_host"

   if { ( [string first "$other_host"   $result4] >= 0 ) &&
        ( [string first "$string1"   $result4] >= 0 ) &&
        ( [string first "$string3"   $result4] >= 0 ) } {
      puts $CHECK_OUTPUT "qconf -ah $other_host succeded"
   } else {
      add_proc_error "qconf_add_show_delete_host" -1 "qconf -ah $other_host failed"
      puts $CHECK_OUTPUT "result is $result4"
   }

   # Now try adding it again
   get_qconf_show_list result5 $CHECK_HOST $CHECK_USER "-ah $other_host"

   if { ( [string first "$other_host"   $result5] >= 0 ) &&
        ( [string first "$string4"   $result5] >= 0 ) } {
      puts $CHECK_OUTPUT "qconf -ah $other_host again succeded"
   } else {
      add_proc_error "qconf_add_show_delete_host" -1 "qconf -ah $other_host again failed"
      puts $CHECK_OUTPUT "result is $result5"
   }

   set_error 0 "ok"

}

#                                                             max. column:     |
#****** qconf/qconf_add_show_delete_stnode() ******
#
#  NAME
#     qconf_add_show_delete_stnode - Add, show and delete sharetree
#
#  SYNOPSIS
#     qconf_add_show_delete_stnode { } - Call "qconf -astnode ..."
#                                Show it with "qconf -sstnode qconf_proj"
#                                Then delete it with "qconf -dstnode qconf_proj"
#
#  FUNCTION
#     Check basic functionality of qconf
#
#  SEE ALSO
#
# performance/large_cluster/check.exp/large_cluster_setup_sharetree()
# sge_procedures/get_qconf_show_list()
# sge_procedures/get_qconf_show_list_error()
#*******************************
proc qconf_add_show_delete_stnode {} {
   global ts_config env 
   global CHECK_OUTPUT CHECK_USER CHECK_HOST CHECK_FIRST_FOREIGN_SYSTEM_USER

   set other_host [lindex $ts_config(execd_nodes) 1]

   set string1 [translate $CHECK_HOST 0 1 0 "added"]
   set string2 [translate $CHECK_HOST 0 1 0 "removing"]
   set string3 [translate $CHECK_HOST 0 1 0 "removed"]
   set string4 [translate $CHECK_HOST 0 1 0 "sharetree list"]

   set project "qconf_project"

   # Add project "qconf_project"
   set new_project(name) $project
   add_prj new_project

   # Add users
   set new_user(name) $CHECK_USER
   set new_user(default_project) $project
   add_user new_user

   set new_user(name) $CHECK_FIRST_FOREIGN_SYSTEM_USER
   add_user new_user

   # Check that the new project has been added

   # Now add policies to the project $project
   get_qconf_show_list result1 $CHECK_HOST $CHECK_USER "-astnode /$project=100,/$project/$CHECK_USER=30,/$project/$CHECK_FIRST_FOREIGN_SYSTEM_USER=70"

   # Now show the sharetree list
   get_qconf_show_list result2 $CHECK_HOST $CHECK_USER "-sstnode /$project"

   if { ( [string first "$project"   $result2] >= 0 ) } {
      puts $CHECK_OUTPUT "qconf -sstnode /$project succeded"
   } else {
      add_proc_error "qconf_add_show_delete_stnode" -1 "qconf -sstnode /$project failed"
      puts $CHECK_OUTPUT "result is $result2"
   }

   # Modify shares in project $project

   get_qconf_show_list result22 $CHECK_HOST $CHECK_USER "-mstnode /$project=100,/$project/$CHECK_USER=50,/$project/$CHECK_FIRST_FOREIGN_SYSTEM_USER=50"

   # Now show the sharetree list again
   get_qconf_show_list result23 $CHECK_HOST $CHECK_USER "-sstnode /$project"

   if { ( [string first "$project"   $result23] >= 0 ) } {
      puts $CHECK_OUTPUT "qconf -sstnode /$project again succeded"
   } else {
      add_proc_error "qconf_add_show_delete_stnode" -1 "qconf -sstnode /$project  again failed"
      puts $CHECK_OUTPUT "result is $result23"
   }

   
   # Delete $project/$CHECK_USER
   get_qconf_show_list result3 $CHECK_HOST $CHECK_USER "-dstnode /$project/$CHECK_USER"
  
   if { ( [string first "$project/$CHECK_USER"   $result3] >= 0 ) &&
        ( [string first "$string2"   $result3] >= 0 ) } {
      puts $CHECK_OUTPUT "qconf -dstnode /$project/$CHECK_USER succeded"
   } else {
      add_proc_error "qconf_add_show_delete_stnode" -1 "qconf -dstnode /$project/$CHECK_USER failed"
      puts $CHECK_OUTPUT "result is $result3"
   }

   # Delete $project/$CHECK_FIRST_FOREIGN_SYSTEM_USER

   get_qconf_show_list result4 $CHECK_HOST $CHECK_USER "-dstnode /$project/$CHECK_FIRST_FOREIGN_SYSTEM_USER"

   if { ( [string first "$project/$CHECK_FIRST_FOREIGN_SYSTEM_USER"   $result4] >= 0 ) &&
        ( [string first "$string2"   $result4] >= 0 ) } {
      puts $CHECK_OUTPUT "qconf -dstnode /$project/$CHECK_FIRST_FOREIGN_SYSTEM_USER succeded"
   } else {
      add_proc_error "qconf_add_show_delete_stnode" -1 "qconf -dstnode /$project/$CHECK_FIRST_FOREIGN_SYSTEM_USER failed"
      puts $CHECK_OUTPUT "result is $result4"
   }
   
   # Now delete all sharetree
   get_qconf_show_list result5 $CHECK_HOST $CHECK_USER "-dstree " 

   if { ( [string first "$string3"   $result5] >= 0 ) &&
        ( [string first "$string4"   $result5] >= 0 ) } {
      puts $CHECK_OUTPUT "qconf -dstree succeded"
   } else {
      add_proc_error "qconf_add_show_delete_stnode" -1 "qconf -dstree failed"
      puts $CHECK_OUTPUT "result is $result5"
   }

   # Delete users CHECK_USER, CHECK_FIRST_FOREIGN_SYSTEM_USER from userlist
   del_user $CHECK_USER
   del_user $CHECK_FIRST_FOREIGN_SYSTEM_USER

   # Delete $project
   del_prj $project

   set_error 0 "ok"

}


#                                                             max. column:     |
#****** qconf/qconf_event_client() ******
#
#  NAME
#     qconf_event_client - Create and then destroy an event client
#
#  SYNOPSIS
#     qconf_event_client { } - First create an INTERACTIVE only queue
#                             Then start qevent -ts as special user 
#                            ts_def_con2
#                            Check event client list with qconf -secl
#			     Then kill event client with qconf -kec
#
#  FUNCTION
#     Check basic functionality of qconf
#
#  SEE ALSO
# performance/throughput/run_throughput_test()
# sge_procedures/get_qconf_show_list()
# sge_procedures/get_qconf_show_list_error()
#*******************************
proc qconf_event_client {} {
   global ts_config env CHECK_SOURCE_DIR
   global CHECK_OUTPUT CHECK_USER CHECK_HOST CHECK_ARCH

   set string1 [translate $CHECK_HOST 0 1 0 "shutdown notification to event client qevent"]
   set up_arch [resolve_build_arch $ts_config(master_host)]
   set event_client_bin $CHECK_SOURCE_DIR/$up_arch/qevent

   if { [file isfile $event_client_bin] != 1 } {
      set_error -3 "could not open event client binary: $event_client_bin"
      return -3
   }
   puts $CHECK_OUTPUT "using event client: $event_client_bin"

   # start event client on master host, using special user ts_def_con2
   puts $CHECK_OUTPUT "starting event client with -ts option ..."
   set event_client_sid [ open_remote_spawn_process $ts_config(master_host) "ts_def_con2" $event_client_bin "-ts"]
   set event_client_id [lindex $event_client_sid 1]

   set event_client_id [lindex $event_client_sid 1]

   # First do a list of event clients
   get_qconf_show_list result0 $CHECK_HOST $CHECK_USER "-secl"

   if { ( [string first "scheduler"   $result0] >= 0 ) } {
      puts $CHECK_OUTPUT "qconf -secl succeded"
   } else {
      add_proc_error "qconf_event_client" -1 "qconf -secl failed"
      puts $CHECK_OUTPUT "result is $result0"
   }

   # Do now a negative test
   set result1 [get_qconf_list_error result $CHECK_HOST $CHECK_USER "-secl always_depend"]

   if { ( $result1 == 0 ) } {
      puts $CHECK_OUTPUT "qconf -secl always_depend succeded"
   } else {
      add_proc_error "qconf_event_client" -1 "qconf -secl always_depend failed"
      puts $CHECK_OUTPUT "result is $result1"
   }

   # Kill now event clients

   #get_qconf_show_list result2 $CHECK_HOST $CHECK_USER "-kec all"
   get_qconf_show_list result2 $CHECK_HOST $CHECK_USER "-kec $event_client_id"

   if { ( [string first "$string1"   $result2] >= 0 ) &&
        ( [string first "$CHECK_HOST"   $result2] >= 0 ) } {
      #puts $CHECK_OUTPUT "qconf -kec all succeded"
      puts $CHECK_OUTPUT "qconf -kec $event_client_id succeded"
   } else {
      #add_proc_error "qconf_event_client" -1 "qconf -kec all failed"
      add_proc_error "qconf_event_client" -1 "qconf -kec $event_client_id failed"
      puts $CHECK_OUTPUT "result is $result2"
   }

   close_spawn_process $event_client_sid
   
   # Restart event client to do a -kec all

   # start event client on master host, using special user ts_def_con2
   puts $CHECK_OUTPUT "Re-starting event client with -ts option ..."
   set event_client_sid1 [ open_remote_spawn_process $ts_config(master_host) "ts_def_con2" $event_client_bin "-ts"]
   set event_client_id1 [lindex $event_client_sid1 1]

   get_qconf_show_list result2 $CHECK_HOST $CHECK_USER "-kec all"

   if { ( [string first "$string1"   $result2] >= 0 ) &&
        ( [string first "$CHECK_HOST"   $result2] >= 0 ) } {
      puts $CHECK_OUTPUT "qconf -kec all succeded"
   } else {
      add_proc_error "qconf_event_client" -1 "qconf -kec all failed"
      puts $CHECK_OUTPUT "result is $result2"
   }

   close_spawn_process $event_client_sid1
   
   set_error 0 "ok"
}

