#!/vol2/TCL_TK/glinux/bin/expect
# global variables ... (defined in main check routine, but you can use it)
#___INFO__MARK_BEGIN__
##########################################################################
#
#  The Contents of this file are made available subject to the terms of
#  the Sun Industry Standards Source License Version 1.2
#
#  Sun Microsystems Inc., March, 2001
#
#
#  Sun Industry Standards Source License Version 1.2
#  =================================================
#  The contents of this file are subject to the Sun Industry Standards
#  Source License Version 1.2 (the "License"); You may not use this file
#  except in compliance with the License. You may obtain a copy of the
#  License at http://gridengine.sunsource.net/Gridengine_SISSL_license.html
#
#  Software provided under this License is provided on an "AS IS" basis,
#  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
#  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
#  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
#  See the License for the specific provisions governing your rights and
#  obligations concerning the Software.
#
#  The Initial Developer of the Original Code is: Sun Microsystems, Inc.
#
#  Copyright: 2001 by Sun Microsystems, Inc.
#
#  All Rights Reserved.
#
##########################################################################
#___INFO__MARK_END__

# Define the global veriables to give them back
global check_name 
global check_description 
global check_needs
global check_functions 
global check_errno 
global check_errstr 
global check_highest_level
global check_init_level_procedure
global check_root_access_needs
global env
global check_category

# define a level initialization procedure:
set check_init_level_procedure "init_level"

# define test's name and run level descriptions
set check_name            "qconf"
set check_category        "COMPATIBILITY SYSTEM L10N VERIFIED"
set check_highest_level    0
set check_description(0)  "test all qconf options (test not complete)"

# define test's dependencies
#set check_needs        "init_core_system qstat qsub"       ;# dependencies of this check (name of other check)
set check_needs        "init_core_system"       ;# dependencies of this check (name of other check)

# setup and cleanup functions
set check_cleanup_function "qconf_cleanup"

# define test's procedure order
set check_functions     ""
lappend check_functions "qconf_addqueues"             ;# functions to call (in order)
lappend check_functions "qconf_removequeues"
lappend check_functions "qconf_auser"
lappend check_functions "qconf_duser"
lappend check_functions "qconf_Auser"
lappend check_functions "qconf_muser"
lappend check_functions "qconf_Muser"
lappend check_functions "qconf_de_check"

# TODO: check all options
#lappend check_functions "qconf_aattr_check"
#lappend check_functions "qconf_rattr_check"
#lappend check_functions "qconf_Aattr_check"
#lappend check_functions "qconf_Rattr_check"
#lappend check_functions "qconf_dattr_check"
#lappend check_functions "qconf_Dattr_check"
#lappend check_functions "qconf_mattr_check"
#lappend check_functions "qconf_Mattr_check"


global queue_names

global submitjob_jobid

# run level initialization
#                                                             max. column:     |
#****** qconf/init_level() ******
# 
#  NAME
#     init_level -- ??? 
#
#  SYNOPSIS
#     init_level { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc init_level {} {
   global ts_config
   global CHECK_ACT_LEVEL hold_state pending_state queue_names

  set queue_names     ""
  for { set i 0 } { $i < 1000 }  {incr i 1} {
     lappend queue_names "qconf.$i"
  }

  switch -- $CHECK_ACT_LEVEL {
     "0" {
        if { [llength $ts_config(execd_nodes)] <= 1 } {
           set_error -1 "need more than one host for this test"
           return -1
        } else {
           return 0
        }
     } 
  }

  return -1  ;# no other level else
}

proc qconf_cleanup {} {
   delete_all_jobs
   wait_for_end_of_all_jobs 60
}

proc qconf_auser {} {
   global CHECK_OUTPUT CHECK_PRODUCT_TYPE CHECK_HOST CHECK_USER

   puts $CHECK_OUTPUT "testing qconf -auser ..."

   if { [ string compare $CHECK_PRODUCT_TYPE "sgeee" ] == 0 } {
      set new_user(name) "qconf_test_user"
      set new_user(default_project) "mytestproject"
      add_user new_user
      set output [start_remote_prog $CHECK_HOST $CHECK_USER "qconf" "-suser qconf_test_user" ]
      if { [string first "mytestproject" $output] < 0  } {
         add_proc_error "qconf_auser" -1 "error showing user qconf_test_user"
      }
      set_error 0 "ok"
   } else {
      set_error 0 "not tested for sge system"
   }
}

proc qconf_duser {} {
   global CHECK_OUTPUT CHECK_PRODUCT_TYPE CHECK_HOST CHECK_USER
   puts $CHECK_OUTPUT "testing qconf -duser ..."

   if { [ string compare $CHECK_PRODUCT_TYPE "sgeee" ] == 0 } {
      del_user "qconf_test_user"

      set output [start_remote_prog $CHECK_HOST $CHECK_USER "qconf" "-suser qconf_test_user" ]
      if { [string first "mytestproject" $output] >= 0  } {
         add_proc_error "qconf_auser" -1 "error user qconf_test_user should have been deleted"
      }
      set_error 0 "ok"
   } else {
      set_error 0 "not tested for sge system"
   }
}


proc qconf_Auser {} {
   global CHECK_OUTPUT CHECK_PRODUCT_TYPE CHECK_HOST CHECK_USER

   puts $CHECK_OUTPUT "testing qconf -Auser ..."

   if { [ string compare $CHECK_PRODUCT_TYPE "sgeee" ] == 0 } {
      set new_user(name) "qconf_test_user"
      set new_user(default_project) "mytestproject"
      add_user new_user 1
      set output [start_remote_prog $CHECK_HOST $CHECK_USER "qconf" "-suser qconf_test_user" ]
      if { [string first "mytestproject" $output] < 0  } {
         add_proc_error "qconf_auser" -1 "error showing user qconf_test_user"
      }
      del_user "qconf_test_user"
      set_error 0 "ok"
   } else {
      set_error 0 "not tested for sge system"
   }
}


proc qconf_muser {} {
   global CHECK_OUTPUT CHECK_PRODUCT_TYPE CHECK_HOST CHECK_USER

   puts $CHECK_OUTPUT "testing qconf -muser ..."

   if { [ string compare $CHECK_PRODUCT_TYPE "sgeee" ] == 0 } {
      set new_user(name) "qconf_test_user"
      set new_user(default_project) "mytestproject"
      add_user new_user
      set output [start_remote_prog $CHECK_HOST $CHECK_USER "qconf" "-suser qconf_test_user" ]
      if { [string first "mytestproject" $output] < 0  } {
         add_proc_error "qconf_muser" -1 "error showing user qconf_test_user"
      }
      # now modifiy user
      set new_conf(name)  "qconf_test_user"
      set new_conf(default_project) "NONE"
      mod_user new_conf 
      set output [start_remote_prog $CHECK_HOST $CHECK_USER "qconf" "-suser qconf_test_user" ]
      puts $CHECK_OUTPUT $output
      if { [string first "mytestproject" $output] >= 0  } {
         add_proc_error "qconf_muser" -1 "error modify user qconf_test_user"
      }

      # now delete user
      del_user "qconf_test_user"


      set_error 0 "ok"
   } else {
      set_error 0 "not tested for sge system"
   }
}

proc qconf_Muser {} {
   global CHECK_OUTPUT CHECK_PRODUCT_TYPE CHECK_HOST CHECK_USER

   puts $CHECK_OUTPUT "testing qconf -Muser ..."

   if { [ string compare $CHECK_PRODUCT_TYPE "sgeee" ] == 0 } {
      set new_user(name) "qconf_test_user"
      set new_user(default_project) "mytestproject"
      add_user new_user
      set output [start_remote_prog $CHECK_HOST $CHECK_USER "qconf" "-suser qconf_test_user" ]
      if { [string first "mytestproject" $output] < 0  } {
         add_proc_error "qconf_Muser" -1 "error showing user qconf_test_user"
      }
      # now modifiy user
      set new_conf(name)  "qconf_test_user"
      set new_conf(default_project) "NONE"
      mod_user new_conf 1
      set output [start_remote_prog $CHECK_HOST $CHECK_USER "qconf" "-suser qconf_test_user" ]
      puts $CHECK_OUTPUT $output
      if { [string first "mytestproject" $output] >= 0  } {
         add_proc_error "qconf_Muser" -1 "error modify user qconf_test_user"
      }

      # now delete user
      del_user "qconf_test_user"


      set_error 0 "ok"
   } else {
      set_error 0 "not tested for sge system"
   }
}



# run qconf -aq
#                                                             max. column:     |
#****** qconf/qconf_addqueues() ******
# 
#  NAME
#     qconf_addqueues -- ??? 
#
#  SYNOPSIS
#     qconf_addqueues { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc qconf_addqueues {} {
   global ts_config
   global CHECK_PRODUCT_ROOT CHECK_ARCH queue_names CHECK_OUTPUT

   set q_param(load_thresholds)       "np_load_avg=7.00"

   set test_host [lindex $ts_config(execd_nodes) 0]

   set count 0
   foreach queue $queue_names {
      if { $count > 50 } {
         puts $CHECK_OUTPUT "adding queue \"$queue\" with vi"
         add_queue $queue $test_host q_param
         set count 0
      } else {
         puts $CHECK_OUTPUT "adding queue \"$queue\" with file"
         add_queue $queue $test_host q_param 1
      }
      incr count 1
   }

   set_error 0 "ok"
}



#                                                             max. column:     |
#****** qconf/qconf_removequeues() ******
# 
#  NAME
#     qconf_removequeues -- ??? 
#
#  SYNOPSIS
#     qconf_removequeues { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc qconf_removequeues {} {
   global ts_config
   global queue_names CHECK_OUTPUT

   set test_host [lindex $ts_config(execd_nodes) 0]

   foreach queue $queue_names {
     puts $CHECK_OUTPUT "deleting queue \"$queue\""
     del_queue $queue $test_host 0 1
   }

   set_error 0 "ok"
}

#                                                             max. column:     |
#****** qconf/check_exec_conf() ******
# 
#  NAME
#     check_exec_conf -- ??? 
#
#  SYNOPSIS
#     check_exec_conf { host_list attr_name check_value } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#     host_list   - ??? 
#     attr_name   - ??? 
#     check_value - ??? 
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc check_exec_conf { host_list attr_name check_value } {
  global CHECK_OUTPUT

  foreach host $host_list {
     get_exechost host_config $host
     set host_attr_value $host_config($attr_name)

     puts $CHECK_OUTPUT "host \"$host\": $attr_name is set to \"$host_attr_value\"" 

     if { [ string compare $check_value $host_attr_value ] != 0 } {
        puts $CHECK_OUTPUT "\"$check_value\" is not \"$host_attr_value\""
        add_proc_error "check_exec_conf" -1 "\"$check_value\" is not \"$host_attr_value\"" 
     }
  } 
}

# check all queues in queue_list for attr_name and compare it with check_value
#                                                             max. column:     |
#****** qconf/check_queue_conf() ******
# 
#  NAME
#     check_queue_conf -- ??? 
#
#  SYNOPSIS
#     check_queue_conf { queue_list attr_name check_value } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#     queue_list  - ??? 
#     attr_name   - ??? 
#     check_value - ??? 
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc check_queue_conf { queue_list attr_name check_value } {

  global CHECK_OUTPUT

  foreach queue $queue_list {
     get_queue $queue q_config
     set q_attr_value $q_config($attr_name)

     puts $CHECK_OUTPUT "queue \"$queue\": $attr_name is set to \"$q_attr_value\"" 

     if { [ string compare $check_value $q_attr_value ] != 0 } {
        puts $CHECK_OUTPUT "\"$check_value\" is not \"$q_attr_value\""
        add_proc_error "check_queue_conf" -1 "\"$check_value\" is not \"$q_attr_value\"" 
     }
  } 
}



# obj_nm is "queue" or "exechost" 
# attr_nm is "object"
# val is value
# obj_id_lst is a list with names of the queues or hostnames to be modified
#                                                             max. column:     |
#****** qconf/qconf_aattr_check() ******
# 
#  NAME
#     qconf_aattr_check -- ??? 
#
#  SYNOPSIS
#     qconf_aattr_check { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc qconf_aattr_check {} {
   global ts_config
   global CHECK_OUTPUT CHECK_PRODUCT_ROOT CHECK_ARCH queue_names


   # check queue add normal attribute
   check_queue_conf $queue_names qtype "BATCH INTERACTIVE"
   puts $CHECK_OUTPUT "adding qtype PARALLEL to queues $queue_names"
   set result [ catch { 
       eval exec "$CHECK_PRODUCT_ROOT/bin/$CHECK_ARCH/qconf -aattr queue qtype PARALLEL $queue_names" 
   } output ]
   if {$result != 0} {
     set_error -1 "exit state is not 0"
   }          
   puts $CHECK_OUTPUT $output
   check_queue_conf $queue_names qtype "BATCH INTERACTIVE PARALLEL"

    
   # check queue add parameter list
   check_queue_conf $queue_names load_thresholds "np_load_avg=7.00"
   puts $CHECK_OUTPUT "adding qtype PARALLEL to queues $queue_names"
   set result [ catch { 
       eval exec "$CHECK_PRODUCT_ROOT/bin/$CHECK_ARCH/qconf -aattr queue load_thresholds \"mem_free=1M\" $queue_names" 
   } output ]
   if {$result != 0} {
     set_error -1 "exit state is not 0"
   }          
   puts $CHECK_OUTPUT $output
   check_queue_conf $queue_names load_thresholds "np_load_avg=7.00,mem_free=1M"

   # check global host add user_lists list
   check_exec_conf $ts_config(execd_nodes) user_lists "NONE"

   puts $CHECK_OUTPUT "adding deadlineusers to user_lists of all execd hosts"
   set result [ catch { 
       eval exec "$CHECK_PRODUCT_ROOT/bin/$CHECK_ARCH/qconf -aattr exechost user_lists \"deadlineusers\" $ts_config(execd_nodes)" 
   } output ]
   if {$result != 0} {
     set_error -1 "exit state is not 0"
   }          
   puts $CHECK_OUTPUT $output
   check_exec_conf $ts_config(execd_nodes) user_lists "deadlineusers"

   puts $CHECK_OUTPUT "adding defaultdepartment to user_lists of all execd hosts"
   set result [ catch { 
       eval exec "$CHECK_PRODUCT_ROOT/bin/$CHECK_ARCH/qconf -aattr exechost user_lists \"defaultdepartment\" $ts_config(execd_nodes)" 
   } output ]
   if {$result != 0} {
     set_error -1 "exit state is not 0"
   }          
   puts $CHECK_OUTPUT $output
   check_exec_conf $ts_config(execd_nodes) user_lists "deadlineusers defaultdepartment"

   set_error 0 "ok"
}

#                                                             max. column:     |
#****** qconf/qconf_Aattr_check() ******
# 
#  NAME
#     qconf_Aattr_check -- ??? 
#
#  SYNOPSIS
#     qconf_Aattr_check { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc qconf_Aattr_check {} {
   global CHECK_OUTPUT CHECK_PRODUCT_ROOT CHECK_ARCH queue_names 
   global CHECK_ACTUAL_TEST_PATH

   # check queue add normal attribute
   check_queue_conf $queue_names qtype "BATCH INTERACTIVE"
   check_queue_conf $queue_names load_thresholds "np_load_avg=7.00"

   puts $CHECK_OUTPUT "adding qtype PARALLEL and load_thresholds mem_free=1M to queues $queue_names"
   set result [ catch { 
       eval exec "$CHECK_PRODUCT_ROOT/bin/$CHECK_ARCH/qconf -Aattr queue $CHECK_ACTUAL_TEST_PATH/Aattr_file_queue_wrong_syntax  $queue_names" 
   } output ]
   if {$result != 1} {
      set_error -1 "exit state is not 1 (used wrong file syntax format)"
   }
   
   set result [ catch { 
       eval exec "$CHECK_PRODUCT_ROOT/bin/$CHECK_ARCH/qconf -Aattr queue $CHECK_ACTUAL_TEST_PATH/Aattr_file_queue $queue_names" 
   } output ]

   if {$result != 0} {
     set_error -1 "exit state is not 0"
   }          
   puts $CHECK_OUTPUT $output
   check_queue_conf $queue_names qtype "BATCH INTERACTIVE PARALLEL"
   check_queue_conf $queue_names load_thresholds "np_load_avg=7.00,mem_free=1M"

   set_error 0 "ok"
}

#                                                             max. column:     |
#****** qconf/qconf_dattr_check() ******
# 
#  NAME
#     qconf_dattr_check -- ??? 
#
#  SYNOPSIS
#     qconf_dattr_check { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc qconf_dattr_check {} {
}

#                                                             max. column:     |
#****** qconf/qconf_Dattr_check() ******
# 
#  NAME
#     qconf_Dattr_check -- ??? 
#
#  SYNOPSIS
#     qconf_Dattr_check { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc qconf_Dattr_check {} {
}

#                                                             max. column:     |
#****** qconf/qconf_mattr_check() ******
# 
#  NAME
#     qconf_mattr_check -- ??? 
#
#  SYNOPSIS
#     qconf_mattr_check { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc qconf_mattr_check {} {
}

#                                                             max. column:     |
#****** qconf/qconf_Mattr_check() ******
# 
#  NAME
#     qconf_Mattr_check -- ??? 
#
#  SYNOPSIS
#     qconf_Mattr_check { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc qconf_Mattr_check {} {
}

#                                                             max. column:     |
#****** qconf/qconf_rattr_check() ******
# 
#  NAME
#     qconf_rattr_check -- ??? 
#
#  SYNOPSIS
#     qconf_rattr_check { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc qconf_rattr_check {} {
   global ts_config
   global CHECK_OUTPUT CHECK_PRODUCT_ROOT CHECK_ARCH queue_names

   puts $CHECK_OUTPUT "replaceing exechost user_lists with NONE"
   set result [ catch { 
       eval exec "$CHECK_PRODUCT_ROOT/bin/$CHECK_ARCH/qconf -rattr exechost user_lists \"NONE\" $ts_config(execd_nodes)" 
   } output ]
   if {$result != 0} {
     set_error -1 "exit state is not 0"
   }          
   puts $CHECK_OUTPUT $output

   check_exec_conf $ts_config(execd_nodes) user_lists "NONE"

   puts $CHECK_OUTPUT "replaceing queues qtype with BATCH INTERACTIVE"
   set result [ catch { 
       eval exec "$CHECK_PRODUCT_ROOT/bin/$CHECK_ARCH/qconf -rattr queue qtype \"BATCH INTERACTIVE\" $queue_names" 
   } output ]
   if {$result != 0} {
     set_error -1 "exit state is not 0"
   }          
   puts $CHECK_OUTPUT $output
   check_queue_conf $queue_names qtype "BATCH INTERACTIVE"

   puts $CHECK_OUTPUT "replaceing queues load_thresholds with np_load_avg=7.00"
   set result [ catch { 
       eval exec "$CHECK_PRODUCT_ROOT/bin/$CHECK_ARCH/qconf -rattr queue load_thresholds \"np_load_avg=7.00\" $queue_names" 
   } output ]
   if {$result != 0} {
     set_error -1 "exit state is not 0"
   }          
   puts $CHECK_OUTPUT $output
   check_queue_conf $queue_names load_thresholds "np_load_avg=7.00"



   set_error 0 "ok"
}

#                                                             max. column:     |
#****** qconf/qconf_Rattr_check() ******
# 
#  NAME
#     qconf_Rattr_check -- ??? 
#
#  SYNOPSIS
#     qconf_Rattr_check { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc qconf_Rattr_check {} {
}

#                                                             max. column:     |
#****** qconf/qconf_Rattr_check() ******
# 
#  NAME
#     qconf_Rattr_check -- ??? 
#
#  SYNOPSIS
#     qconf_Rattr_check { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc qconf_de_check {} {
   global ts_config
   global CHECK_OUTPUT CHECK_PRODUCT_TYPE CHECK_USER CHECK env
   puts $CHECK_OUTPUT "testing qconf -de ..."

   if { $ts_config(gridengine_version) == 53 } {
      set_error 0 "test doesn't apply for SGE 5.3"
      return
   }

   # Setup
   set execd [lindex $ts_config(execd_nodes) 0]
   set arch [resolve_arch $ts_config(master_host)]

   puts $CHECK_OUTPUT "using execd host $execd"

   # the tmp_file is automatically removed from testsuite
   set tmp_file [get_tmp_file_name]
   set catch_result [ catch {  eval exec "$ts_config(product_root)/bin/$arch/qconf -se $execd | grep -v load_values | grep -v processors > $tmp_file" } result ]
   if { $catch_result != 0 } {
      add_proc_error "qconf_de_check" "-1" "could not store execd config: $result"
   }
   puts $CHECK_OUTPUT "tmp file is: $tmp_file"
   puts $CHECK_OUTPUT "doing qconf -dattr hostgroup hostlist $execd @allhosts:"
   set catch_result [ catch {  eval exec "$ts_config(product_root)/bin/$arch/qconf -dattr hostgroup hostlist $execd @allhosts" } result ]
   puts $CHECK_OUTPUT $result
 
   if { $catch_result != 0 } {
      add_proc_error "qconf_de_check" "-1" "could not remove host from hostgroup @allhosts: $result"
   }

 
   # Test
   puts $CHECK_OUTPUT "doing qconf -de $execd"
   set catch_result [ catch {  eval exec "$ts_config(product_root)/bin/$arch/qconf" "-de" "$execd" } result ]
   puts $CHECK_OUTPUT $result
   
   set EXEC_HOST_REMOVED [translate $ts_config(master_host) 1 0 0 [sge_macro MSG_SGETEXT_REMOVEDFROMLIST_SSSS] $CHECK_USER [resolve_host $ts_config(master_host) 1] [resolve_host $execd 1] "execution host"]

   puts $CHECK_OUTPUT "looking for : \"$EXEC_HOST_REMOVED\""
   puts $CHECK_OUTPUT "answer was  : \"$result\""

   if { [ string match "*$EXEC_HOST_REMOVED*" $result ] == 0 } {
      add_proc_error "qconf_de_check" "-1" "could not delete live execd: $result\nBug 1269: qconf -de still crashes qmaster"
   }
   puts $CHECK_OUTPUT "removed execd $execd from cluster"

   puts $CHECK_OUTPUT "doing qconf -Ae $tmp_file"
   catch { eval exec "$ts_config(product_root)/bin/$arch/qconf -Ae $tmp_file" } result 
   puts $CHECK_OUTPUT $result

   puts $CHECK_OUTPUT "doing qconf -aattr hostgroup hostlist $execd @allhosts"
   catch { eval exec "$ts_config(product_root)/bin/$arch/qconf -aattr hostgroup hostlist $execd @allhosts" } result
   puts $CHECK_OUTPUT $result

   puts $CHECK_OUTPUT "added execd $execd to cluster"

   set_error 0 "ok"
}
