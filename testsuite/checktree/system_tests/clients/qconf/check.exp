#!/vol2/TCL_TK/glinux/bin/expect
# global variables ... (defined in main check routine, but you can use it)
#___INFO__MARK_BEGIN__
##########################################################################
#
#  The Contents of this file are made available subject to the terms of
#  the Sun Industry Standards Source License Version 1.2
#
#  Sun Microsystems Inc., March, 2001
#
#
#  Sun Industry Standards Source License Version 1.2
#  =================================================
#  The contents of this file are subject to the Sun Industry Standards
#  Source License Version 1.2 (the "License"); You may not use this file
#  except in compliance with the License. You may obtain a copy of the
#  License at http://www.gridengine.sunsource.net/license.html
#
#  Software provided under this License is provided on an "AS IS" basis,
#  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
#  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
#  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
#  See the License for the specific provisions governing your rights and
#  obligations concerning the Software.
#
#  The Initial Developer of the Original Code is: Sun Microsystems, Inc.
#
#  Copyright: 2001 by Sun Microsystems, Inc.
#
#  All Rights Reserved.
#
##########################################################################
#___INFO__MARK_END__

# Define the global veriables to give them back
global check_name 
global check_description 
global check_needs
global check_functions 
global check_errno 
global check_errstr 
global check_highest_level
global check_init_level_procedure
global check_root_access_needs
global env

# define a level initialization procedure:
set check_init_level_procedure "init_level"

# define test's name and run level descriptions
set check_name            "qconf"
set check_highest_level    0
set check_description(0)  "add/remove queues"

# define test's dependencies
set check_needs        "init_core_system qstat qsub"       ;# dependencies of this check (name of other check)

set check_functions     "qconf_addqueues"             ;# functions to call (in order)
#lappend check_functions "qconf_aattr_check"
#lappend check_functions "qconf_rattr_check"
#lappend check_functions "qconf_Aattr_check"
#lappend check_functions "qconf_Rattr_check"

#lappend check_functions "qconf_dattr_check"
#lappend check_functions "qconf_Dattr_check"
#lappend check_functions "qconf_mattr_check"
#lappend check_functions "qconf_Mattr_check"

lappend check_functions "qconf_removequeues"


global queue_names


global submitjob_jobid

# run level initialization
#                                                             max. column:     |
#****** qconf/init_level() ******
# 
#  NAME
#     init_level -- ??? 
#
#  SYNOPSIS
#     init_level { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc init_level {} {
  global CHECK_ACT_LEVEL CHECK_HOST hold_state pending_state queue_names

  set queue_names     ""
  for { set i 0 } { $i < 200 }  {incr i 1} {
     lappend queue_names "$CHECK_HOST.qconf$i"
  }

  switch -- $CHECK_ACT_LEVEL {
     "0" {  return 0   } 
  } 
  return -1  ;# no other level else
}



# run qconf -aq
#                                                             max. column:     |
#****** qconf/qconf_addqueues() ******
# 
#  NAME
#     qconf_addqueues -- ??? 
#
#  SYNOPSIS
#     qconf_addqueues { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc qconf_addqueues {} {
   global CHECK_PRODUCT_ROOT CHECK_ARCH CHECK_HOST queue_names

   set q_param(hostname)              "$CHECK_HOST"
   set q_param(load_thresholds)       "np_load_avg=7.00"
   set q_param(migr_load_thresholds)  "np_load_avg=10.00"
 
   foreach queue $queue_names {
      set q_param(qname) "$queue"
      add_queue q_param
   }

   set_error 0 "ok"
}



#                                                             max. column:     |
#****** qconf/qconf_removequeues() ******
# 
#  NAME
#     qconf_removequeues -- ??? 
#
#  SYNOPSIS
#     qconf_removequeues { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc qconf_removequeues {} {
   global CHECK_HOST queue_names

   foreach queue $queue_names {
     del_queue $queue
   }

   set_error 0 "ok"
}

#                                                             max. column:     |
#****** qconf/check_exec_conf() ******
# 
#  NAME
#     check_exec_conf -- ??? 
#
#  SYNOPSIS
#     check_exec_conf { host_list attr_name check_value } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#     host_list   - ??? 
#     attr_name   - ??? 
#     check_value - ??? 
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc check_exec_conf { host_list attr_name check_value } {
  global CHECK_OUTPUT

  foreach host $host_list {
     get_exechost host_config $host
     set host_attr_value $host_config($attr_name)

     puts $CHECK_OUTPUT "host \"$host\": $attr_name is set to \"$host_attr_value\"" 

     if { [ string compare $check_value $host_attr_value ] != 0 } {
        puts $CHECK_OUTPUT "\"$check_value\" is not \"$host_attr_value\""
        add_proc_error "check_exec_conf" -1 "\"$check_value\" is not \"$host_attr_value\"" 
     }
  } 
}

# check all queues in queue_list for attr_name and compare it with check_value
#                                                             max. column:     |
#****** qconf/check_queue_conf() ******
# 
#  NAME
#     check_queue_conf -- ??? 
#
#  SYNOPSIS
#     check_queue_conf { queue_list attr_name check_value } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#     queue_list  - ??? 
#     attr_name   - ??? 
#     check_value - ??? 
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc check_queue_conf { queue_list attr_name check_value } {

  global CHECK_OUTPUT

  foreach queue $queue_list {
     get_queue $queue q_config
     set q_attr_value $q_config($attr_name)

     puts $CHECK_OUTPUT "queue \"$queue\": $attr_name is set to \"$q_attr_value\"" 

     if { [ string compare $check_value $q_attr_value ] != 0 } {
        puts $CHECK_OUTPUT "\"$check_value\" is not \"$q_attr_value\""
        add_proc_error "check_queue_conf" -1 "\"$check_value\" is not \"$q_attr_value\"" 
     }
  } 
}



# obj_nm is "queue" or "exechost" 
# attr_nm is "object"
# val is value
# obj_id_lst is a list with names of the queues or hostnames to be modified
#                                                             max. column:     |
#****** qconf/qconf_aattr_check() ******
# 
#  NAME
#     qconf_aattr_check -- ??? 
#
#  SYNOPSIS
#     qconf_aattr_check { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc qconf_aattr_check {} {
   global CHECK_HOST CHECK_OUTPUT CHECK_PRODUCT_ROOT CHECK_ARCH queue_names CHECK_CORE_EXECD


   # check queue add normal attribute
   check_queue_conf $queue_names qtype "BATCH INTERACTIVE"
   puts $CHECK_OUTPUT "adding qtype PARALLEL to queues $queue_names"
   set result [ catch { 
       eval exec "$CHECK_PRODUCT_ROOT/bin/$CHECK_ARCH/qconf -aattr queue qtype PARALLEL $queue_names" 
   } output ]
   if {$result != 0} {
     set_error -1 "exit state is not 0"
   }          
   puts $CHECK_OUTPUT $output
   check_queue_conf $queue_names qtype "BATCH INTERACTIVE PARALLEL"

    
   # check queue add parameter list
   check_queue_conf $queue_names load_thresholds "np_load_avg=7.00"
   puts $CHECK_OUTPUT "adding qtype PARALLEL to queues $queue_names"
   set result [ catch { 
       eval exec "$CHECK_PRODUCT_ROOT/bin/$CHECK_ARCH/qconf -aattr queue load_thresholds \"mem_free=1M\" $queue_names" 
   } output ]
   if {$result != 0} {
     set_error -1 "exit state is not 0"
   }          
   puts $CHECK_OUTPUT $output
   check_queue_conf $queue_names load_thresholds "np_load_avg=7.00,mem_free=1M"

   # check global host add user_lists list
   check_exec_conf $CHECK_CORE_EXECD user_lists "NONE"

   puts $CHECK_OUTPUT "adding deadlineusers to user_lists of all execd hosts"
   set result [ catch { 
       eval exec "$CHECK_PRODUCT_ROOT/bin/$CHECK_ARCH/qconf -aattr exechost user_lists \"deadlineusers\" $CHECK_CORE_EXECD" 
   } output ]
   if {$result != 0} {
     set_error -1 "exit state is not 0"
   }          
   puts $CHECK_OUTPUT $output
   check_exec_conf $CHECK_CORE_EXECD user_lists "deadlineusers"

   puts $CHECK_OUTPUT "adding defaultdepartment to user_lists of all execd hosts"
   set result [ catch { 
       eval exec "$CHECK_PRODUCT_ROOT/bin/$CHECK_ARCH/qconf -aattr exechost user_lists \"defaultdepartment\" $CHECK_CORE_EXECD" 
   } output ]
   if {$result != 0} {
     set_error -1 "exit state is not 0"
   }          
   puts $CHECK_OUTPUT $output
   check_exec_conf $CHECK_CORE_EXECD user_lists "deadlineusers defaultdepartment"

   set_error 0 "ok"
}

#                                                             max. column:     |
#****** qconf/qconf_Aattr_check() ******
# 
#  NAME
#     qconf_Aattr_check -- ??? 
#
#  SYNOPSIS
#     qconf_Aattr_check { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc qconf_Aattr_check {} {
   global CHECK_HOST CHECK_OUTPUT CHECK_PRODUCT_ROOT CHECK_ARCH queue_names CHECK_CORE_EXECD
   global CHECK_ACTUAL_TEST_PATH

   # check queue add normal attribute
   check_queue_conf $queue_names qtype "BATCH INTERACTIVE"
   check_queue_conf $queue_names load_thresholds "np_load_avg=7.00"

   puts $CHECK_OUTPUT "adding qtype PARALLEL and load_thresholds mem_free=1M to queues $queue_names"
   set result [ catch { 
       eval exec "$CHECK_PRODUCT_ROOT/bin/$CHECK_ARCH/qconf -Aattr queue $CHECK_ACTUAL_TEST_PATH/Aattr_file_queue_wrong_syntax  $queue_names" 
   } output ]
   if {$result != 1} {
      set_error -1 "exit state is not 1 (used wrong file syntax format)"
   }
   
   set result [ catch { 
       eval exec "$CHECK_PRODUCT_ROOT/bin/$CHECK_ARCH/qconf -Aattr queue $CHECK_ACTUAL_TEST_PATH/Aattr_file_queue $queue_names" 
   } output ]

   if {$result != 0} {
     set_error -1 "exit state is not 0"
   }          
   puts $CHECK_OUTPUT $output
   check_queue_conf $queue_names qtype "BATCH INTERACTIVE PARALLEL"
   check_queue_conf $queue_names load_thresholds "np_load_avg=7.00,mem_free=1M"

   set_error 0 "ok"
}

#                                                             max. column:     |
#****** qconf/qconf_dattr_check() ******
# 
#  NAME
#     qconf_dattr_check -- ??? 
#
#  SYNOPSIS
#     qconf_dattr_check { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc qconf_dattr_check {} {
}

#                                                             max. column:     |
#****** qconf/qconf_Dattr_check() ******
# 
#  NAME
#     qconf_Dattr_check -- ??? 
#
#  SYNOPSIS
#     qconf_Dattr_check { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc qconf_Dattr_check {} {
}

#                                                             max. column:     |
#****** qconf/qconf_mattr_check() ******
# 
#  NAME
#     qconf_mattr_check -- ??? 
#
#  SYNOPSIS
#     qconf_mattr_check { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc qconf_mattr_check {} {
}

#                                                             max. column:     |
#****** qconf/qconf_Mattr_check() ******
# 
#  NAME
#     qconf_Mattr_check -- ??? 
#
#  SYNOPSIS
#     qconf_Mattr_check { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc qconf_Mattr_check {} {
}

#                                                             max. column:     |
#****** qconf/qconf_rattr_check() ******
# 
#  NAME
#     qconf_rattr_check -- ??? 
#
#  SYNOPSIS
#     qconf_rattr_check { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc qconf_rattr_check {} {
   global CHECK_HOST CHECK_OUTPUT CHECK_PRODUCT_ROOT CHECK_ARCH queue_names CHECK_CORE_EXECD

   puts $CHECK_OUTPUT "replaceing exechost user_lists with NONE"
   set result [ catch { 
       eval exec "$CHECK_PRODUCT_ROOT/bin/$CHECK_ARCH/qconf -rattr exechost user_lists \"NONE\" $CHECK_CORE_EXECD" 
   } output ]
   if {$result != 0} {
     set_error -1 "exit state is not 0"
   }          
   puts $CHECK_OUTPUT $output

   check_exec_conf $CHECK_CORE_EXECD user_lists "NONE"

   puts $CHECK_OUTPUT "replaceing queues qtype with BATCH INTERACTIVE"
   set result [ catch { 
       eval exec "$CHECK_PRODUCT_ROOT/bin/$CHECK_ARCH/qconf -rattr queue qtype \"BATCH INTERACTIVE\" $queue_names" 
   } output ]
   if {$result != 0} {
     set_error -1 "exit state is not 0"
   }          
   puts $CHECK_OUTPUT $output
   check_queue_conf $queue_names qtype "BATCH INTERACTIVE"

   puts $CHECK_OUTPUT "replaceing queues load_thresholds with np_load_avg=7.00"
   set result [ catch { 
       eval exec "$CHECK_PRODUCT_ROOT/bin/$CHECK_ARCH/qconf -rattr queue load_thresholds \"np_load_avg=7.00\" $queue_names" 
   } output ]
   if {$result != 0} {
     set_error -1 "exit state is not 0"
   }          
   puts $CHECK_OUTPUT $output
   check_queue_conf $queue_names load_thresholds "np_load_avg=7.00"



   set_error 0 "ok"
}

#                                                             max. column:     |
#****** qconf/qconf_Rattr_check() ******
# 
#  NAME
#     qconf_Rattr_check -- ??? 
#
#  SYNOPSIS
#     qconf_Rattr_check { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc qconf_Rattr_check {} {
}
