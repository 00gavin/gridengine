#!/vol2/TCL_TK/glinux/bin/expect
#___INFO__MARK_BEGIN__
##########################################################################
#
#  The Contents of this file are made available subject to the terms of
#  the Sun Industry Standards Source License Version 1.2
#
#  Sun Microsystems Inc., March, 2001
#
#
#  Sun Industry Standards Source License Version 1.2
#  =================================================
#  The contents of this file are subject to the Sun Industry Standards
#  Source License Version 1.2 (the "License"); You may not use this file
#  except in compliance with the License. You may obtain a copy of the
#  License at http://gridengine.sunsource.net/Gridengine_SISSL_license.html
#
#  Software provided under this License is provided on an "AS IS" basis,
#  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
#  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
#  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
#  See the License for the specific provisions governing your rights and
#  obligations concerning the Software.
#
#  The Initial Developer of the Original Code is: Sun Microsystems, Inc.
#
#  Copyright: 2001 by Sun Microsystems, Inc.
#
#  All Rights Reserved.
#
##########################################################################
#___INFO__MARK_END__

# Define the global veriables to give them back
global check_name check_description check_needs check_functions check_errno check_errstr row
global check_category
set check_name         "qmod_general"
set check_category     "COMPATIBILITY SYSTEM"
set check_root_access_needs "yes"

set check_description(0)  "checking all options, except rescheduling (-r)"
set check_needs        "init_core_system"  ;# dependencies of this check (name of other check)
set check_functions    "" 
lappend check_functions    "addqueue"           ;# functions to call (in order)
lappend check_functions    "qmod_check_default_status"
lappend check_functions    "qmod_help"
lappend check_functions    "qmod_disable"
lappend check_functions    "qmod_enable"
lappend check_functions    "qmod_suspend"
lappend check_functions    "qmod_unsuspend"
lappend check_functions    "qmod_clearerrorstate"
lappend check_functions    "qmod_verify"
lappend check_functions    "qmod_forceaction"
lappend check_functions    "removequeue"


global test_queue

#                                                             max. column:     |
#****** qmod/addqueue() ******
# 
#  NAME
#     addqueue -- ??? 
#
#  SYNOPSIS
#     addqueue { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc addqueue {} {
  global CHECK_HOST test_queue

  set test_queue "${CHECK_HOST}_qmod.q"

  set q_param(qname)                 "$test_queue" 
  set q_param(hostname)              "$CHECK_HOST" 
  set q_param(slots)                 "2"
  set q_param(load_thresholds)       "np_load_avg=6.75"
 
  add_queue q_param

  set_error 0 "ok"  
}                                                                          

#                                                             max. column:     |
#****** qmod/removequeue() ******
# 
#  NAME
#     removequeue -- ??? 
#
#  SYNOPSIS
#     removequeue { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc removequeue {} {
  global test_queue

  del_queue $test_queue

  set_error 0 "ok"
}


#                                                             max. column:     |
#****** qmod/qmod_check_default_status() ******
# 
#  NAME
#     qmod_check_default_status -- ??? 
#
#  SYNOPSIS
#     qmod_check_default_status { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc qmod_check_default_status {} {

  global CHECK_OUTPUT test_queue

  set status [ get_queue_state "$test_queue" ]
  puts $CHECK_OUTPUT $status

  if { [string compare $status ""] != 0 } {
     set_error -1 "queue $test_queue is not in default status (= no state)"
  } 
  set_error 0 "ok"
}

#                                                             max. column:     |
#****** qmod/qmod_help() ******
# 
#  NAME
#     qmod_help -- ??? 
#
#  SYNOPSIS
#     qmod_help { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc qmod_help {} {
   global CHECK_PRODUCT_ROOT CHECK_ARCH CHECK_OUTPUT CHECK_PRODUCT_VERSION_NUMBER

   set state [ catch {exec "$CHECK_PRODUCT_ROOT/bin/$CHECK_ARCH/qmod" "-help" } output ]

   puts $CHECK_OUTPUT "qmod output    : \n---\n$output\n---"
   puts $CHECK_OUTPUT "qmod exit state: $state"

   if {$state != 0} {
      set_error -1 "exit state is not 0"
   }

   if { [ string first $CHECK_PRODUCT_VERSION_NUMBER $output] < 0 } {
      set_error -1 "version string ($CHECK_PRODUCT_VERSION_NUMBER) not found"
   } 
 
   set lines [ split $output "\n"]
   set nr_of_lines [ llength $lines ] 

   puts $CHECK_OUTPUT "Output has $nr_of_lines lines"

   if { $nr_of_lines != 15 } {
      set_error -1 "help output has not $line_count lines"
   }
   set_error 0 "ok"
}

#                                                             max. column:     |
#****** qmod/qmod_disable() ******
# 
#  NAME
#     qmod_disable -- ??? 
#
#  SYNOPSIS
#     qmod_disable { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc qmod_disable {} {
   global CHECK_PRODUCT_ROOT CHECK_ARCH test_queue 
   
   set result [ catch { eval exec "$CHECK_PRODUCT_ROOT/bin/$CHECK_ARCH/qmod -d $test_queue" } output ]
   
   if {$result != 0} {
     set_error -1 "exit state of \"qmod -d $test_queue\" is not 0"
   }            
   
   set state [ get_queue_state $test_queue ] 
   if { [ string first $state "d" ] < 0  } {
      set_error -1 "queue $test_queue is not disabled"
   }
   
   set_error 0 "ok"
}

#                                                             max. column:     |
#****** qmod/qmod_enable() ******
# 
#  NAME
#     qmod_enable -- ??? 
#
#  SYNOPSIS
#     qmod_enable { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc qmod_enable {} {
   global CHECK_PRODUCT_ROOT CHECK_ARCH test_queue 
   
   set result [ catch { eval exec "$CHECK_PRODUCT_ROOT/bin/$CHECK_ARCH/qmod -e $test_queue" } output ]
   
   if {$result != 0} {
     set_error -1 "exit state of \"qmod -e $test_queue\" is not 0"
   }            
   
   set state [ get_queue_state $test_queue ] 
   if { [ string compare $state "" ] != 0  } {
      set_error -1 "queue $test_queue is not in original state"
   }
   
   set_error 0 "ok"
}

#                                                             max. column:     |
#****** qmod/qmod_suspend() ******
# 
#  NAME
#     qmod_suspend -- ??? 
#
#  SYNOPSIS
#     qmod_suspend { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc qmod_suspend {} {
   global CHECK_PRODUCT_ROOT CHECK_ARCH test_queue 
   
   set result [ catch { eval exec "$CHECK_PRODUCT_ROOT/bin/$CHECK_ARCH/qmod -s $test_queue" } output ]
   
   if {$result != 0} {
     set_error -1 "exit state of \"qmod -s $test_queue\" is not 0"
   }            
   
   set state [ get_queue_state $test_queue ] 
   if { [ string first $state "s" ] < 0 } {
      set_error -1 "queue $test_queue is not in suspend state"
   }
   set_error 0 "ok"
}

#                                                             max. column:     |
#****** qmod/qmod_unsuspend() ******
# 
#  NAME
#     qmod_unsuspend -- ??? 
#
#  SYNOPSIS
#     qmod_unsuspend { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc qmod_unsuspend {} {
   global CHECK_PRODUCT_ROOT CHECK_ARCH test_queue 
   
   set result [ catch { eval exec "$CHECK_PRODUCT_ROOT/bin/$CHECK_ARCH/qmod -us $test_queue" } output ]
   
   if {$result != 0} {
     set_error -1 "exit state of \"qmod -us $test_queue\" is not 0"
   }            
   
   set state [ get_queue_state $test_queue ] 
   if { [ string compare $state "" ] != 0  } {
      set_error -1 "queue $test_queue is not in original state"
   }
   set_error 0 "ok"
}



#                                                             max. column:     |
#****** qmod/qmod_clearerrorstate() ******
# 
#  NAME
#     qmod_clearerrorstate -- ??? 
#
#  SYNOPSIS
#     qmod_clearerrorstate { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc qmod_clearerrorstate {} {
   
   global CHECK_PRODUCT_TYPE CHECK_PRODUCT_ROOT CHECK_ARCH test_queue CHECK_HOST


   if { [have_root_passwd] == -1 } {
      set_error -3 "root access required"
      return
   } 
 

   set file_name "sge_shepherd"

   # rename the shepherd binary to produce error state
   #set result [ catch { file rename "$CHECK_PRODUCT_ROOT/bin/$CHECK_ARCH/$file_name" "$CHECK_PRODUCT_ROOT/bin/$CHECK_ARCH/${file_name}.tmp" } ]
   #if { $result != 0 } {
   #   set_error -1 "could not rename the $file_name binary to produce error state"
   #}
   set output [ run_command_as_user "$CHECK_HOST" "root" "/bin/mv" "$CHECK_PRODUCT_ROOT/bin/$CHECK_ARCH/$file_name $CHECK_PRODUCT_ROOT/bin/$CHECK_ARCH/${file_name}.tmp" 1 ] 
   wait_for_file "$CHECK_PRODUCT_ROOT/bin/$CHECK_ARCH/$file_name" 200 1    ;# wait for shepherd binary to disappear
   

   # submit testjob to set the queue in error
   set job_id [ submit_job "-o /dev/null -e /dev/null -l q=$test_queue $CHECK_PRODUCT_ROOT/examples/jobs/sleeper.sh 15" ] 

   # wait for queue to get in error state
   set time [timestamp]
   while {1} {
   
      set state [ get_queue_state $test_queue ] 
      if { [ string first "E" $state ] >=  0  } {
         break;
      }

      set runtime [expr ( [timestamp] - $time) ]
      if { $runtime >= 300 } {
         set_error -1 "timeout waiting for queue $test_queue to get in error state"
         break;
      }
      sleep 1
   }
  
   # set the shepherd binary to his orignal filename
   # set result [ catch { file rename $CHECK_PRODUCT_ROOT/bin/$CHECK_ARCH/$file_name.tmp $CHECK_PRODUCT_ROOT/bin/$CHECK_ARCH/$file_name } ]
   # if { $result != 0 } {
   #   set_error -1 "could not rename the $file_name binary to original name"
   # }
   set output [ run_command_as_user "$CHECK_HOST" "root" "/bin/mv" "$CHECK_PRODUCT_ROOT/bin/$CHECK_ARCH/${file_name}.tmp $CHECK_PRODUCT_ROOT/bin/$CHECK_ARCH/$file_name" 1 ] 
   wait_for_file "$CHECK_PRODUCT_ROOT/bin/$CHECK_ARCH/$file_name" 200    ;# wait for shepherd binary to appear



   # now wait for jobstart
   set result [wait_for_jobstart $job_id "leeper" 120 0]
   if {$result != -1} {
      set_error -1 "job $job_id should not start until yet"
   }


   # clear error state
   set result [ catch { eval exec "$CHECK_PRODUCT_ROOT/bin/$CHECK_ARCH/qmod -c $test_queue" } output ]
   
   if {$result != 0} {
     set_error -1 "exit state of \"qmod -c $test_queue\" is not 0"
   }            
   
   set state [ get_queue_state $test_queue ] 
   if { [ string compare $state "" ] != 0  } {
      set_error -1 "queue $test_queue is not in original state"
   }

   
 
   # now wait for jobend
   wait_for_jobstart $job_id "leeper" 300
   wait_for_jobend   $job_id "leeper" 300 

   set_error 0 "ok" 
}  

#                                                             max. column:     |
#****** qmod/qmod_verify() ******
# 
#  NAME
#     qmod_verify -- ??? 
#
#  SYNOPSIS
#     qmod_verify { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc qmod_verify {} {
   global CHECK_PRODUCT_ROOT CHECK_ARCH test_queue 
   
   set result [ catch { eval exec "$CHECK_PRODUCT_ROOT/bin/$CHECK_ARCH/qmod -verify -s $test_queue" } output ]
   if {$result != 0} {
     set_error -1 "exit state of \"qmod -verify -s $test_queue\" is not 0"
   }            
   
   set state [ get_queue_state $test_queue ] 
   if { [ string compare $state "" ] != 0  } {
      set_error -1 "queue $test_queue is not in original state"
   }
   set_error 0 "ok"
}




# do to:
# 1) set running job to suspend
# 2) manualy (kill command) set job to running
# 3) set suspended job to suspend 
# 4) command must write something like (job allready suspended)
# 5) manualy check if job is still running (should run)
# 6) use -f flag (force) to suspend job again
# 7) manualy check if job is still running (should be suspended again)
#                                                             max. column:     |
#****** qmod/qmod_forceaction() ******
# 
#  NAME
#     qmod_forceaction -- ??? 
#
#  SYNOPSIS
#     qmod_forceaction { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc qmod_forceaction {} {
   global CHECK_PRODUCT_ROOT CHECK_ARCH test_queue CHECK_OUTPUT CHECK_ACTUAL_TEST_PATH

   # submit testjob to set the queue in error
   set job_id [ submit_job "-l q=$test_queue -o /dev/null -e /dev/null $CHECK_ACTUAL_TEST_PATH/qmod_job.sh 5 $CHECK_ACTUAL_TEST_PATH/qmod_job.sh" ] 
   # now wait for jobstart
   wait_for_jobstart $job_id "blocking" 300
   wait_for_end_of_transfer $job_id 300 
  

   # now wait for 5 processes in this process group
   set time_out [ expr ( [timestamp] + 60 ) ]
   set procgroup_ok 0
   while { [timestamp] < $time_out } {
      set state [ get_suspend_state_of_job $job_id "pid_list" 0] 
      set grppid [ get_grppid_of_job $job_id ]
      puts $CHECK_OUTPUT "Job has real state \"$state\""
      puts $CHECK_OUTPUT "Job has grp pid \"$grppid\""
      puts $CHECK_OUTPUT "pitlist is $pid_list and has length [llength $pid_list]"
      if { [llength $pid_list] == 5 } {
         puts $CHECK_OUTPUT "found 5 process mebmers - ok"
         set procgroup_ok 1
         break;
      }
   }
   if { $procgroup_ok != 1 } {
      set_error -1 "not 5 processes in processgroup \"$grppid\""
   }
 

   # set job in suspend mode
   puts $CHECK_OUTPUT "setting job in suspend mode ..."
   set result [ catch { eval exec "$CHECK_PRODUCT_ROOT/bin/$CHECK_ARCH/qmod -s $job_id" } output ]
   if {$result != 0} {
     set_error -1 "exit state of \"qmod -s $job_id\" is not 0"
   }          
   puts $CHECK_OUTPUT $output
 
   set state [ get_suspend_state_of_job $job_id ] 
   set grppid [ get_grppid_of_job $job_id ]
   puts $CHECK_OUTPUT "Job has real state \"$state\""
   puts $CHECK_OUTPUT "Job has grp pid \"$grppid\""
   
   if { [string compare "T" $state] != 0 } {
      set_error -1 "job $job_id (grppid: $grppid) is not in suspend state"
   }


   puts $CHECK_OUTPUT "unsuspend job with kill command ..."
   # unsunspend job per kill command
   switch -- $CHECK_ARCH {
      "glinux" {
            foreach pidnr $pid_list {
            set result [ catch { eval exec "/bin/kill -CONT $pidnr" } ]
         }
      }
      "alinux" {
         # on our alinux they have changed the CONT and STOP signal numbers ;-)
         set result [ catch { eval exec "/bin/kill -STOP -$grppid" } ]
      }

      default {
         set result [ catch { eval exec "kill -CONT -$grppid" } ]
      }
   }

#   sleep 5

   set state [ get_suspend_state_of_job $job_id ] 
   puts $CHECK_OUTPUT "Job has real state \"$state\""

   if { [string compare "T" $state] == 0 } {
      set_error -1 "job $job_id (grppid: $grppid) is still in suspend state"
   }   
   
   puts $CHECK_OUTPUT "set job in suspend mode (queueing system things it is still suspended) ..."

   # set job in suspend mode (is allready in suspend (in SGE system))
   set result [ catch { eval exec "$CHECK_PRODUCT_ROOT/bin/$CHECK_ARCH/qmod -s $job_id" } output ]
   if {$result != 0} {
     set_error -1 "exit state of \"qmod -s $job_id\" is not 0"
   }          
   puts $CHECK_OUTPUT $output

   set state [ get_suspend_state_of_job $job_id ] 
   puts $CHECK_OUTPUT "Job has real state \"$state\""
   
   if { [string compare "T" $state] == 0 } {
      set_error -1 "job $job_id (grppid: $grppid) is still in suspend state without force flag"
   }    

   puts $CHECK_OUTPUT "set job in suspend mode with force flag ..." 
   
 
   # set job in suspend mode (is allready in suspend (in SGE system)) with force flag set
   set result [ catch { eval exec "$CHECK_PRODUCT_ROOT/bin/$CHECK_ARCH/qmod -f -s $job_id" } output ]
   if {$result != 0} {
     set_error -1 "exit state of \"qmod -f -s $job_id\" is not 0"
   }          
   puts $CHECK_OUTPUT $output

   set state [ get_suspend_state_of_job $job_id ] 
   puts $CHECK_OUTPUT "Job has real state \"$state\""
   
   if { [string compare "T" $state] != 0 } {
      set_error -1 "job $job_id (grppid: $grppid) is still not in suspend state with using force flag"
   }    

   puts $CHECK_OUTPUT "set job in unsuspend mode ..."
   

   # ok unsuspend the job
   # set job in unsuspend mode
   set result [ catch { eval exec "$CHECK_PRODUCT_ROOT/bin/$CHECK_ARCH/qmod -us $job_id" } output ]
   if {$result != 0} {
     set_error -1 "exit state of \"qmod -us $job_id\" is not 0"
   }          
   puts $CHECK_OUTPUT $output


   puts $CHECK_OUTPUT "release job and wait for jobend ..."

   

   # release job
   set result [ catch { eval exec "$CHECK_PRODUCT_ROOT/bin/$CHECK_ARCH/qdel $job_id" } output ]


   # wait for jobend 
   set break_time [timestamp]
   set break_time [ expr ( $break_time + 300 ) ]
   while { [timestamp] < $break_time } {
      if { [was_job_running $job_id 0] != -1 } {
         break;
      }
   }
   # let's see if all processes are killed
   get_ps_info
   
   for {set i 0} {$i < $ps_info(proc_count) } {incr i 1} {
      puts $CHECK_OUTPUT "ps_info(pgid,$i)     = $ps_info(pgid,$i), command is \"$ps_info(command,$i)\""
      
      if { $ps_info(pgid,$i) == $grppid } {
         puts $CHECK_OUTPUT "process $ps_info(pid,$i) is still in ps list"
         set_error -1 "process $ps_info(pid,$i) is still in ps list"
      }
   }
   set_error 0 "ok"
}




