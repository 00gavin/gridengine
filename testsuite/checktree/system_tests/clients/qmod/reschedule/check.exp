#!/vol2/TCL_TK/glinux/bin/expect
#___INFO__MARK_BEGIN__
##########################################################################
#
#  The Contents of this file are made available subject to the terms of
#  the Sun Industry Standards Source License Version 1.2
#
#  Sun Microsystems Inc., March, 2001
#
#
#  Sun Industry Standards Source License Version 1.2
#  =================================================
#  The contents of this file are subject to the Sun Industry Standards
#  Source License Version 1.2 (the "License"); You may not use this file
#  except in compliance with the License. You may obtain a copy of the
#  License at http://gridengine.sunsource.net/Gridengine_SISSL_license.html
#
#  Software provided under this License is provided on an "AS IS" basis,
#  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
#  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
#  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
#  See the License for the specific provisions governing your rights and
#  obligations concerning the Software.
#
#  The Initial Developer of the Original Code is: Sun Microsystems, Inc.
#
#  Copyright: 2001 by Sun Microsystems, Inc.
#
#  All Rights Reserved.
#
##########################################################################
#___INFO__MARK_END__

# define global variable in this namespace
global check_name 
global check_category
global check_description 
global check_needs
global check_functions 
global check_errno 
global check_errstr 
global check_highest_level
global check_init_level_procedure
global check_root_access_needs
global env

# we need root access 
set check_root_access_needs "yes"

# define a level initialization procedure:
set check_init_level_procedure "init_level"

# define test's name and run level descriptions
set check_name            "qmod_reschedule"
set check_category        "COMPATIBILITY SYSTEM"
set check_highest_level   0
set check_description(0)  "checking reschedule option of qmod"

# define test's dependencies
set check_needs           "init_core_system" 

# define test's procedure order
set check_functions ""
lappend check_functions "reschedule_setup"
lappend check_functions "reschedule_submit_jobs"
lappend check_functions "reschedule_checkpointing"
lappend check_functions "reschedule_checkpointing_forced"
lappend check_functions "reschedule_qsh_qlogin_qrsh_qrlogin"
lappend check_functions "reschedule_pe_jobs"
lappend check_functions "reschedule_deleted_job"
lappend check_functions "reschedule_cleanup"



# -------- local test procedures -----------------------------------------------
global rerun_queue rerun_queue2
set rerun_queue    "re_true.q"
set rerun_queue2   "re_true2.q"

global no_rerun_queue
set no_rerun_queue "resch_false.q"

global rerun_host no_rerun_host
global stored_configuration
global pe_names pe_alloc_rule
set pe_names      ""
set pe_alloc_rule ""
lappend pe_names      "reschpe_1" 
lappend pe_alloc_rule "1"
lappend pe_names      "reschpe_2" 
lappend pe_alloc_rule "2"
lappend pe_names      "reschpe_rr" 
lappend pe_alloc_rule "\$round_robin"
lappend pe_names      "reschpe_fill" 
lappend pe_alloc_rule "\$fill_up"


#
#                                                             max. column:     |
#
#****** check/init_level() ******
#  NAME
#     init_level -- ??? 
#
#  SYNOPSIS
#     init_level { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
#
proc init_level {} {
  global CHECK_ACT_LEVEL CHECK_HOST hold_state pending_state queue
  global rerun_host no_rerun_host CHECK_CORE_EXECD CHECK_OUTPUT


  if { [ llength $CHECK_CORE_EXECD ] >= 2 } {
     set rerun_host    [ lindex $CHECK_CORE_EXECD 0  ]
     set no_rerun_host [ lindex $CHECK_CORE_EXECD 1  ]
  }

  switch -- $CHECK_ACT_LEVEL {
     "0" { return 0 } 
  } 
  return -1  ;# no other level else
}


#
#                                                             max. column:     |
#
#****** check/is_version_ok() ******
#  NAME
#     is_version_ok() -- ??? 
#
#  SYNOPSIS
#     is_version_ok { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
#
proc is_version_ok {} {
  
  set version [ resolve_version ]
  if { $version >= 1 } {
     return 0 ;# ok 

  } 
  return -1  ;# version not ok
}


#
#                                                             max. column:     |
#
#****** check/reschedule_setup() ******
#  NAME
#     reschedule_setup -- ??? 
#
#  SYNOPSIS
#     reschedule_setup { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
#
proc reschedule_setup {} {
   global pe_names pe_alloc_rule
   global rerun_queue no_rerun_queue CHECK_OUTPUT rerun_host no_rerun_host
   global CHECK_CORE_EXECD stored_configuration rerun_queue2


   if { [ llength $CHECK_CORE_EXECD ] < 2 } {
      set_error -3 "need 2 execd hosts"
      return
   }

   if { [is_version_ok] != 0 } {
      set_error -3 "This feature is not supportet for version [get_version_info]"
      return -3
   }


   set schedd_config(schedule_interval) "0:0:4"
   set_schedd_config schedd_config

   if { [info exists stored_configuration] } {
      unset stored_configuration
   }
   get_config stored_configuration
   set myconfig(load_report_time) "00:00:6"
   set_config myconfig

   puts $CHECK_OUTPUT "disabling all cluster queues"
   foreach elem $CHECK_CORE_EXECD {
      puts "${elem}.q"
      disable_queue "${elem}.q"
   }

#   set rerun_host    [ lindex $CHECK_CORE_EXECD 0  ]
   puts $CHECK_OUTPUT "using host \"$rerun_host\" for queue with rerun=TRUE"

#   set no_rerun_host [ lindex $CHECK_CORE_EXECD 1  ]
   puts $CHECK_OUTPUT "using host \"$no_rerun_host\" for queue with rerun=FALSE"

   set new_queue(qname)    $rerun_queue
   set new_queue(hostname) $rerun_host
   set new_queue(rerun)    "TRUE"
   set new_queue(qtype)    "BATCH INTERACTIVE PARALLEL CHECKPOINTING"
   set new_queue(load_thresholds) "np_load_avg=8.00"
   set new_queue(slots)    "100"

   add_queue new_queue 
 
   set new_queue(qname)    $rerun_queue2
   set new_queue(hostname) $no_rerun_host 
   add_queue new_queue

   set new_queue(qname)    $no_rerun_queue
   set new_queue(hostname) $no_rerun_host
   set new_queue(rerun)    "FALSE"

   add_queue new_queue



   # add checkpointobject for test
   puts $CHECK_OUTPUT "creating checkpointobjects ..."
   set new_checkpointobj(ckpt_name)  "qmod_with_r"
   set new_checkpointobj(interface)  "userdefined"
   set new_checkpointobj(queue_list) $rerun_queue
   set new_checkpointobj(when) "r"
   add_checkpointobj "new_checkpointobj"

   set new_checkpointobj(ckpt_name)  "qmod_without_r"
   set new_checkpointobj(when) "s"
   add_checkpointobj "new_checkpointobj"


   # add pe_object for test
   puts $CHECK_OUTPUT "creating pe object ..."
   set new_peobj(queue_list)       "$rerun_queue2 $rerun_queue" 
   set new_peobj(slots)            "5"
   set index 0
   foreach elem $pe_names { 
      set new_peobj(pe_name) $elem
      set new_peobj(allocation_rule) [lindex $pe_alloc_rule $index]
      incr index 1
      add_pe "new_peobj" 
   } 


   set_error 0 "ok"
}


#
#                                                             max. column:     |
#
#****** check/reschedule_submit_jobs() ******
#  NAME
#     reschedule_submit_jobs -- ??? 
#
#  SYNOPSIS
#     reschedule_submit_jobs { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
#
proc reschedule_submit_jobs {} {
   global rerun_queue no_rerun_queue CHECK_OUTPUT rerun_host no_rerun_host
   global CHECK_PRODUCT_ROOT CHECK_ARCH CHECK_CORE_EXECD
  
   if { [ llength $CHECK_CORE_EXECD ] < 2 } {
      set_error -3 "need 2 execd hosts"
      return
   }


   if { [is_version_ok] != 0 } {
      set_error -3 "This feature is not supportet for version [get_version_info]"
      return -3
   }

 
   set jobs ""
   set my_outputs "-o /dev/null -e /dev/null"
   set arguments "$my_outputs -q $rerun_queue -r y $CHECK_PRODUCT_ROOT/examples/jobs/sleeper.sh 1000"
   lappend jobs [submit_job $arguments]
   
   set arguments "$my_outputs -q $rerun_queue -r n $CHECK_PRODUCT_ROOT/examples/jobs/sleeper.sh 1000"
   lappend jobs [ submit_job $arguments ]

   set arguments "$my_outputs -q $rerun_queue $CHECK_PRODUCT_ROOT/examples/jobs/sleeper.sh 1000"
   lappend jobs [ submit_job $arguments ]

   set arguments "$my_outputs -q $no_rerun_queue -r n $CHECK_PRODUCT_ROOT/examples/jobs/sleeper.sh 1000"
   lappend jobs [ submit_job $arguments ]

   set arguments "$my_outputs -q $no_rerun_queue -r y $CHECK_PRODUCT_ROOT/examples/jobs/sleeper.sh 1000"
   lappend jobs [ submit_job $arguments ]
 
   set arguments "$my_outputs -q $no_rerun_queue $CHECK_PRODUCT_ROOT/examples/jobs/sleeper.sh 1000"
   lappend jobs [ submit_job $arguments ]

   set jobs_string ""
   foreach elem $jobs {
      wait_for_jobstart $elem "Sleeper" 300
      wait_for_end_of_transfer $elem 300
      append jobs_string "$elem "
   }

   puts $CHECK_OUTPUT "running jobs: $jobs_string"

   puts $CHECK_OUTPUT "disabling queues $no_rerun_queue and $rerun_queue"
   disable_queue $no_rerun_queue
   disable_queue $rerun_queue

   
   # send qmod -r to each job
  
   puts $CHECK_OUTPUT "sending qmod -r to jobs $jobs_string"   
   set result [ catch { eval exec "$CHECK_PRODUCT_ROOT/bin/$CHECK_ARCH/qmod -r $jobs_string" } output ]
   
   puts $CHECK_OUTPUT $output

  
   set sched_jobs    "[lindex $jobs 0] [lindex $jobs 2] [lindex $jobs 4 ]"
   set no_sched_jobs "[lindex $jobs 1] [lindex $jobs 3] [lindex $jobs 5 ]"
   puts $CHECK_OUTPUT "jobs $sched_jobs should be pending ..."
   foreach elem $sched_jobs {
      wait_for_jobpending $elem "Sleeper" 300
   }
   
   puts $CHECK_OUTPUT "jobs $no_sched_jobs should still run ..."
   foreach elem $no_sched_jobs {
      wait_for_jobstart $elem "Sleeper" 300
   }

   puts $CHECK_OUTPUT "using force flag for job [lindex $jobs 1] ..."
   set result [ catch { eval exec "$CHECK_PRODUCT_ROOT/bin/$CHECK_ARCH/qmod -f -r [lindex $jobs 1]" } output ]
   puts $CHECK_OUTPUT $output
   puts $CHECK_OUTPUT "waiting for job [lindex $jobs 1] to get in pending state ..."
   wait_for_jobpending [lindex $jobs 1] "Sleeper" 300




   enable_queue $no_rerun_queue
   enable_queue $rerun_queue

   foreach elem $jobs {
      wait_for_jobstart $elem "Sleeper" 300
      wait_for_end_of_transfer $elem 300
   }
   
   puts $CHECK_OUTPUT "disabling queues $no_rerun_queue and $rerun_queue"
   disable_queue $no_rerun_queue
   disable_queue $rerun_queue


   # send qmod -r to each job in queue 
   puts $CHECK_OUTPUT "sending qmod -r to queues $no_rerun_queue and $rerun_queue"   
   set result [ catch { eval exec "$CHECK_PRODUCT_ROOT/bin/$CHECK_ARCH/qmod -r $no_rerun_queue $rerun_queue" } output ]
   puts $CHECK_OUTPUT $output


   puts $CHECK_OUTPUT "jobs $sched_jobs should be pending ..."
   foreach elem $sched_jobs {
      wait_for_jobpending $elem "Sleeper" 300
   }
   
   puts $CHECK_OUTPUT "jobs $no_sched_jobs should still run ..."
   foreach elem $no_sched_jobs {
      wait_for_jobstart $elem "Sleeper" 300
   }

   puts $CHECK_OUTPUT "using force flag for job [lindex $jobs 1] ..."
   set result [ catch { eval exec "$CHECK_PRODUCT_ROOT/bin/$CHECK_ARCH/qmod -f -r [lindex $jobs 1]" } output ]
   puts $CHECK_OUTPUT $output
   puts $CHECK_OUTPUT "waiting for job [lindex $jobs 1] to get in pending state ..."
   wait_for_jobpending [lindex $jobs 1] "Sleeper" 300

   
   enable_queue $no_rerun_queue
   enable_queue $rerun_queue

   foreach elem $jobs {
      wait_for_jobstart $elem "Sleeper" 300
      wait_for_end_of_transfer $elem 300
   }

   # cleanup jobs
   foreach elem $jobs {
      delete_job $elem
      wait_for_jobend $elem "Sleeper" 300 0
   }
   set_error 0 "ok"
}

#
#                                                             max. column:     |
#
#****** check/reschedule_checkpointing() ******
#  NAME
#     reschedule_checkpointing -- ??? 
#
#  SYNOPSIS
#     reschedule_checkpointing { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
#
proc reschedule_checkpointing {} {
   global rerun_queue no_rerun_queue CHECK_OUTPUT rerun_host no_rerun_host
   global CHECK_PRODUCT_ROOT CHECK_ARCH CHECK_CORE_EXECD
   
   if { [ llength $CHECK_CORE_EXECD ] < 2 } {
      set_error -3 "need 2 execd hosts"
      return
   }


   if { [is_version_ok] != 0 } {
      set_error -3 "This feature is not supportet for version [get_version_info]"
      return -3
   }

 
   set jobs ""
   set my_outputs "-o /dev/null -e /dev/null"
   set arguments "$my_outputs -ckpt qmod_with_r $CHECK_PRODUCT_ROOT/examples/jobs/sleeper.sh 1000"
   lappend jobs [submit_job $arguments]
   
   set arguments "$my_outputs -ckpt qmod_without_r $CHECK_PRODUCT_ROOT/examples/jobs/sleeper.sh 1000"
   lappend jobs [ submit_job $arguments ]

   set arguments "$my_outputs -ckpt qmod_with_r -r n $CHECK_PRODUCT_ROOT/examples/jobs/sleeper.sh 1000"
   lappend jobs [submit_job $arguments]
   
   set arguments "$my_outputs -ckpt qmod_without_r -r y $CHECK_PRODUCT_ROOT/examples/jobs/sleeper.sh 1000"
   lappend jobs [ submit_job $arguments ]
 

   set jobs_string ""
   foreach elem $jobs {
      wait_for_jobstart $elem "Sleeper" 80
      wait_for_end_of_transfer $elem 80
      append jobs_string "$elem "
   }

   puts $CHECK_OUTPUT "running jobs: $jobs_string"

   

   puts $CHECK_OUTPUT "disabling queue $rerun_queue"
   disable_queue $rerun_queue

   
   # send qmod -r to each job
  
   puts $CHECK_OUTPUT "sending qmod -r to jobs $jobs_string"   
   set result [ catch { eval exec "$CHECK_PRODUCT_ROOT/bin/$CHECK_ARCH/qmod -r $jobs_string" } output ]
   
   puts $CHECK_OUTPUT $output

  
   set sched_jobs    "[lindex $jobs 0]"
   set no_sched_jobs "[lindex $jobs 1] [lindex $jobs 2] [lindex $jobs 3]"
   puts $CHECK_OUTPUT "jobs $sched_jobs should be pending ..."
   foreach elem $sched_jobs {
      wait_for_jobpending $elem "Sleeper" 80
   }
   
   puts $CHECK_OUTPUT "jobs $no_sched_jobs should still run ..."
   foreach elem $no_sched_jobs {
      wait_for_jobstart $elem "Sleeper" 80
   }
   enable_queue $rerun_queue
   foreach elem $jobs {
      wait_for_jobstart $elem "Sleeper" 80
      wait_for_end_of_transfer $elem 80
   }
   
   puts $CHECK_OUTPUT "disabling queue $rerun_queue"
   disable_queue $rerun_queue


   # send qmod -r to each job in queue 
   puts $CHECK_OUTPUT "sending qmod -r to queue $rerun_queue"   
   set result [ catch { eval exec "$CHECK_PRODUCT_ROOT/bin/$CHECK_ARCH/qmod -r $rerun_queue" } output ]
   puts $CHECK_OUTPUT $output


   puts $CHECK_OUTPUT "jobs $sched_jobs should be pending ..."
   foreach elem $sched_jobs {
      wait_for_jobpending $elem "Sleeper" 80
   }
   
   puts $CHECK_OUTPUT "jobs $no_sched_jobs should still run ..."
   foreach elem $no_sched_jobs {
      wait_for_jobstart $elem "Sleeper" 80
   }

   enable_queue $rerun_queue

   foreach elem $jobs {
      wait_for_jobstart $elem "Sleeper" 80
      wait_for_end_of_transfer $elem 80
   }

   # cleanup jobs
   foreach elem $jobs {
      delete_job $elem
      wait_for_jobend $elem "Sleeper" 80 0
   }
 
   set_error 0 "ok"
}

proc reschedule_checkpointing_forced {} {
   global rerun_queue no_rerun_queue CHECK_OUTPUT rerun_host no_rerun_host
   global CHECK_PRODUCT_ROOT CHECK_ARCH CHECK_CORE_EXECD
 
   if { [ llength $CHECK_CORE_EXECD ] < 2 } {
      set_error -3 "need 2 execd hosts"
      return
   }


   if { [is_version_ok] != 0 } {
      set_error -3 "This feature is not supportet for version [get_version_info]"
      return -3
   }

 
   set jobs ""
   set my_outputs "-o /dev/null -e /dev/null"
   set arguments "$my_outputs -ckpt qmod_with_r $CHECK_PRODUCT_ROOT/examples/jobs/sleeper.sh 1000"
   lappend jobs [submit_job $arguments]
   
   set arguments "$my_outputs -ckpt qmod_without_r $CHECK_PRODUCT_ROOT/examples/jobs/sleeper.sh 1000"
   lappend jobs [ submit_job $arguments ]

   set arguments "$my_outputs -ckpt qmod_with_r -r n $CHECK_PRODUCT_ROOT/examples/jobs/sleeper.sh 1000"
   lappend jobs [submit_job $arguments]
   
   set arguments "$my_outputs -ckpt qmod_without_r -r y $CHECK_PRODUCT_ROOT/examples/jobs/sleeper.sh 1000"
   lappend jobs [ submit_job $arguments ]
 

   set jobs_string ""
   foreach elem $jobs {
      wait_for_jobstart $elem "Sleeper" 80
      wait_for_end_of_transfer $elem 80
      append jobs_string "$elem "
   }

   puts $CHECK_OUTPUT "running jobs: $jobs_string"

   

   puts $CHECK_OUTPUT "disabling queue $rerun_queue"
   disable_queue $rerun_queue

   
   # send qmod -r to each job
  
   puts $CHECK_OUTPUT "sending qmod -f -r to jobs $jobs_string"   
   set result [ catch { eval exec "$CHECK_PRODUCT_ROOT/bin/$CHECK_ARCH/qmod -f -r $jobs_string" } output ]
   
   puts $CHECK_OUTPUT $output

  
   set sched_jobs    "[lindex $jobs 0] [lindex $jobs 1] [lindex $jobs 2] [lindex $jobs 3]"
   set no_sched_jobs ""
   puts $CHECK_OUTPUT "jobs $sched_jobs should be pending ..."
   foreach elem $sched_jobs {
      wait_for_jobpending $elem "Sleeper" 80
   }
   
   puts $CHECK_OUTPUT "jobs $no_sched_jobs should still run ..."
   foreach elem $no_sched_jobs {
      wait_for_jobstart $elem "Sleeper" 80
   }
   enable_queue $rerun_queue
   foreach elem $jobs {
      wait_for_jobstart $elem "Sleeper" 80
      wait_for_end_of_transfer $elem 80
   }
   
   puts $CHECK_OUTPUT "disabling queue $rerun_queue"
   disable_queue $rerun_queue


   # send qmod -r to each job in queue 
   puts $CHECK_OUTPUT "sending qmod -f -r to queue $rerun_queue"   
   set result [ catch { eval exec "$CHECK_PRODUCT_ROOT/bin/$CHECK_ARCH/qmod -f -r $rerun_queue" } output ]
   puts $CHECK_OUTPUT $output


   puts $CHECK_OUTPUT "jobs $sched_jobs should be pending ..."
   foreach elem $sched_jobs {
      wait_for_jobpending $elem "Sleeper" 80
   }
   
   puts $CHECK_OUTPUT "jobs $no_sched_jobs should still run ..."
   foreach elem $no_sched_jobs {
      wait_for_jobstart $elem "Sleeper" 80
   }

   enable_queue $rerun_queue

   foreach elem $jobs {
      wait_for_jobstart $elem "Sleeper" 80
      wait_for_end_of_transfer $elem 80
   }

   # cleanup jobs
   foreach elem $jobs {
      delete_job $elem
      wait_for_jobend $elem "Sleeper" 80 0
   }
 
   set_error 0 "ok"
}


#
#                                                             max. column:     |
#
#****** check/reschedule_qsh_qlogin_qrsh_qrlogin() ******
#  NAME
#     reschedule_qsh_qlogin_qrsh_qrlogin -- ??? 
#
#  SYNOPSIS
#     reschedule_qsh_qlogin_qrsh_qrlogin { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
#
proc reschedule_qsh_qlogin_qrsh_qrlogin {} {
   global rerun_queue no_rerun_queue CHECK_OUTPUT rerun_host no_rerun_host
   global CHECK_PRODUCT_ROOT CHECK_ARCH CHECK_HOST CHECK_DEBUG_LEVEL CHECK_USER
   global CHECK_FIRST_FOREIGN_SYSTEM_USER CHECK_SCRIPT_FILE_DIR CHECK_CORE_EXECD
   

   if { [ llength $CHECK_CORE_EXECD ] < 2 } {
      set_error -3 "need 2 execd hosts"
      return
   }

   if { [is_version_ok] != 0 } {
      set_error -3 "This feature is not supportet for version [get_version_info]"
      return -3
   }

   
   set qrsh_id    [ open_spawn_process "$CHECK_PRODUCT_ROOT/bin/$CHECK_ARCH/qrsh -q $rerun_queue" ]
   set qrsh_id2   [ open_spawn_process "$CHECK_PRODUCT_ROOT/bin/$CHECK_ARCH/qrsh -q $rerun_queue sleep 10000" ]
   set qsh_id     [ open_spawn_process "$CHECK_PRODUCT_ROOT/bin/$CHECK_ARCH/qsh -q $rerun_queue" ]
   if { [have_root_passwd] == -1 } {
      set_error -3 "root access required for submitting qlogin"
      set no_jobs 3
   } else {

#      set qlogin_id  [ open_root_spawn_process "$CHECK_PRODUCT_ROOT/bin/$CHECK_ARCH/qlogin -q $rerun_queue" ]
#      set qlogin_id  [ open_remote_spawn_process $CHECK_HOST "root" "$CHECK_PRODUCT_ROOT/bin/$CHECK_ARCH/qlogin" "-q $rerun_queue" ]
      
      catch { eval exec "rm /tmp/qlogin_out.txt" }


      set qlogin_id  [ open_spawn_process "$CHECK_SCRIPT_FILE_DIR/qlogin.sh $CHECK_PRODUCT_ROOT/bin/$CHECK_ARCH/qlogin -q $rerun_queue" ]

      set no_jobs 4
      set result ""
      set my_timeout [timestamp]
      incr my_timeout 60
      while { [ string first "login:" $result] < 0 } {     
         sleep 2
         catch { eval exec "cat /tmp/qlogin_out.txt" } result
         puts $CHECK_OUTPUT $result
         if { $my_timeout < [timestamp] } {
            break;
         } 
      }

      if { [ string first "login:" $result] < 0 } {
          add_proc_error "reschedule_qsh_qlogin_qrsh_qrlogin" -1 "qlogin error"
      }
      
      send "$CHECK_USER\n"
      set timeout 5
      expect {
         eof { 
             puts $CHECK_OUTPUT "got eof" 
             add_proc_error "reschedule_qsh_qlogin_qrsh_qrlogin" -1 "qlogin unexpected eof"
         }
         timeout {
             puts $CHECK_OUTPUT "got timeout"
         }
      }

      set result ""
      set my_timeout [timestamp]
      incr my_timeout 60
      set timeout 0
      while { [ string first "assword:" $result] < 0 } {     
         sleep 2
         catch { eval exec "cat /tmp/qlogin_out.txt" } result
         puts $CHECK_OUTPUT $result
         if { $my_timeout < [timestamp] } {
            break;
         } 
      }

      if { [ string first "closed" $result] >= 0 } {
          add_proc_error "reschedule_qsh_qlogin_qrsh_qrlogin" -1 "qlogin error, connection closed"
      }


   } 


   set end_time [expr ( [timestamp] + 60 )]
   set ru_jobs 0
   while { $ru_jobs != $no_jobs } {
      get_extended_job_info ""
      set running_jobs [ split $job_info(index) "," ]
      set jobs ""
      set jobs_string ""
      set job_names "" 
      foreach elem $running_jobs {
         set jobid [ string trim $elem ]
         if { $jobid >= 0 } {
            if { [ string first [string trim $job_info($jobid,queue)] $rerun_queue ] >= 0 } {
               lappend jobs $jobid
               append jobs_string "$jobid "
               lappend job_names "$job_info($jobid,name)"
            }
            puts $CHECK_OUTPUT "job: $jobid, name: $job_info($jobid,name), $job_info($jobid,queue)"
         }
      }
      set ru_jobs [ llength $jobs ]
      puts $CHECK_OUTPUT "found $ru_jobs jobs"
      unset job_info
      sleep 1
      set now [timestamp]
      if { $now > $end_time } {
         add_proc_error "reschedule_qsh_qlogin_qrsh_qrlogin" "-1" "timeout waiting for processes"
         break
      }
   }

   puts $CHECK_OUTPUT "disabling queue $rerun_queue"
   disable_queue $rerun_queue

   # send qmod -r to each job
  
   puts $CHECK_OUTPUT "sending qmod -r to jobs $jobs_string"   
   set result [ catch { eval exec "$CHECK_PRODUCT_ROOT/bin/$CHECK_ARCH/qmod -r $jobs_string" } output ]
   puts $CHECK_OUTPUT $output

  
    
   puts $CHECK_OUTPUT "jobs $jobs_string should still run ..."
   set index 0
   foreach elem $jobs {
      wait_for_jobstart $elem [lindex $job_names $index] 80
      wait_for_end_of_transfer $elem 80
      incr index 1
   }

   enable_queue $rerun_queue
 
   foreach elem $jobs {
      delete_job $elem
   }
   puts $CHECK_OUTPUT "closing jobs"

   close_spawn_process $qrsh_id 1
   close_spawn_process $qrsh_id2 1
   close_spawn_process $qsh_id 1
   if { [have_root_passwd] != -1 } {
      send -i $qlogin_id "\003"
      close_spawn_process $qlogin_id 1
      catch { eval exec "rm /tmp/qlogin_out.txt" }
   }
   set_error 0 "ok"

}

#
#                                                             max. column:     |
#
#****** check/reschedule_pe_jobs() ******
#  NAME
#     reschedule_pe_jobs -- ??? 
#
#  SYNOPSIS
#     reschedule_pe_jobs { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
#
proc reschedule_pe_jobs {} {
   global rerun_queue no_rerun_queue CHECK_OUTPUT rerun_host no_rerun_host
   global CHECK_CORE_EXECD stored_configuration rerun_queue2 pe_names
   global CHECK_PRODUCT_ROOT CHECK_ARCH CHECK_CORE_EXECD


   if { [ llength $CHECK_CORE_EXECD ] < 2 } {
      set_error -3 "need 2 execd hosts"
      return
   }

   if { [is_version_ok] != 0 } {
      set_error -3 "This feature is not supportet for version [get_version_info]"
      return -3
   }


   foreach pe $pe_names {

       puts $CHECK_OUTPUT "submitting job to pe $pe ..."
       set my_outputs "-o /dev/null -e /dev/null"
       set my_job "$CHECK_PRODUCT_ROOT/examples/jobs/sleeper.sh 5000"
       set arguments "$my_outputs -pe $pe 2 -masterq $rerun_queue $my_job"
       set job [submit_job $arguments]
       puts $CHECK_OUTPUT "job $job submitted"

       wait_for_jobstart $job "Sleeper" 100
       
       set mytime [ expr ( [timestamp] + 100 ) ]
       set run 1
       set master_queue ""
       set slave_queue ""
       while { $run == 1 } {
          set job_info [get_standard_job_info $job 1]
          foreach elem $job_info {
             puts $CHECK_OUTPUT $elem
             if { [string first "MASTER" $elem ] >= 0 } {
                set master_queue [lindex $elem 7]
                puts $CHECK_OUTPUT "master runs on queue $master_queue"
             }
             if { [string first "SLAVE" $elem ] >= 0 } {
                set slave_queue [lindex $elem 7]
                puts $CHECK_OUTPUT "slave runs on queue $slave_queue"
             }
          }
          puts $CHECK_OUTPUT "-----------" 
          if { [llength $job_info] == 2 } {
             puts $CHECK_OUTPUT "MASTER and SLAVE task are running!"
             set run 0
          }
          set nowtime [timestamp]
          if { $nowtime > $mytime } {
             set run 0
             add_proc_error "reschedule_pe_jobs" -1 "timeout waiting for MASTER and SLAVE task of job $job, pe $pe"
          } 
          sleep 1
       }


       if { [string compare $master_queue $rerun_queue] != 0 } {
          puts $CHECK_OUTPUT "\"$master_queue\"\n\"$rerun_queue\""
          add_proc_error "reschedule_pe_jobs" "-1" "job $job: master task is not on queue $rerun_queue, pe $pe"
       }
      
       if { [string compare $pe "reschpe_1"] == 0 } {
          if { [string compare $slave_queue $rerun_queue2] != 0 } {
             puts $CHECK_OUTPUT "\"$slave_queue\"\n\"$rerun_queue2\""
             add_proc_error "reschedule_pe_jobs" "-1" "job $job: slave task is not on queue $rerun_queue2, pe $pe"
          }
       }


       # ok jobs are running and we now his running queues now
       puts $CHECK_OUTPUT "disabling queue $rerun_queue and $rerun_queue2"
       disable_queue $rerun_queue
       disable_queue $rerun_queue2


       if { [ string compare $slave_queue $master_queue ] != 0 } {
          puts $CHECK_OUTPUT "rescheduling SLAVE task queue \"$slave_queue\""     
          set result [ catch { eval exec "$CHECK_PRODUCT_ROOT/bin/$CHECK_ARCH/qmod -r $slave_queue" } output ]
          puts $CHECK_OUTPUT $output

          sleep 10          

          puts $CHECK_OUTPUT "job $job should still run ..."
          wait_for_jobstart $job "Sleeper" 100
       } 
 
       puts $CHECK_OUTPUT "rescheduling MASTER task queue \"$master_queue\""     
       set result [ catch { eval exec "$CHECK_PRODUCT_ROOT/bin/$CHECK_ARCH/qmod -r $master_queue" } output ]
       puts $CHECK_OUTPUT $output

       wait_for_jobpending $job "Sleeper" 100
       set run 1
       set job_info [get_standard_job_info $job 1]
       foreach elem $job_info {
          puts $CHECK_OUTPUT $elem
          if { [string first "MASTER" $elem ] >= 0 } {
             add_proc_error "reschedule_pe_jobs" -1 "no MASTER task should run, pe $pe"
          }
          if { [string first "SLAVE" $elem ] >= 0 } {
             add_proc_error "reschedule_pe_jobs" -1 "no SLAVE task should run, pe $pe"
          }
       } 



       puts $CHECK_OUTPUT "enable queue $rerun_queue and $rerun_queue2"
       enable_queue $rerun_queue
       enable_queue $rerun_queue2
 
       if { [wait_for_jobstart $job "Sleeper" 45] == 0 } {
          set mytime [ expr ( [timestamp] + 45 ) ]
          set run 1
          set master_queue ""
          set slave_queue ""
          while { $run == 1 } {
             set job_info [get_standard_job_info $job 1]
             foreach elem $job_info {
                puts $CHECK_OUTPUT $elem
                if { [string first "MASTER" $elem ] >= 0 } {
                   set master_queue [lindex $elem 7]
                   puts $CHECK_OUTPUT "master runs on queue $master_queue"
                }
                if { [string first "SLAVE" $elem ] >= 0 } {
                   set slave_queue [lindex $elem 7]
                   puts $CHECK_OUTPUT "slave runs on queue $slave_queue"
                }
             } 
             if { [llength $job_info] == 2 } {
                puts $CHECK_OUTPUT "MASTER and SLAVE task are running!"
                set run 0
             }
             set nowtime [timestamp]
             if { $nowtime > $mytime } {
                set run 0
                add_proc_error "reschedule_pe_jobs" -1 "timeout waiting for MASTER and SLAVE task of job $job, pe $pe"
             } 
             sleep 1
          }
       } else {
          add_proc_error "reschedule_pe_jobs" -1 "job $job does not start, pe $pe"
       } 
       delete_job $job
       wait_for_jobend $job "Sleeper" 100
   }
   set_error 0 "ok"
}

#
#                                                             max. column:     |
#
#****** check/reschedule_deleted_job() ******
#  NAME
#     reschedule_deleted_job -- ??? 
#
#  SYNOPSIS
#     reschedule_deleted_job { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
#
proc reschedule_deleted_job {} {
   global rerun_queue no_rerun_queue CHECK_OUTPUT rerun_host no_rerun_host
   global CHECK_CORE_EXECD stored_configuration rerun_queue2
   global pe_names pe_alloc_rule CHECK_ADMIN_USER_SYSTEM
   global CHECK_PRODUCT_ROOT CHECK_PRODUCT_TYPE CHECK_ARCH
   global CHECK_ADMIN_USER_SYSTEM CHECK_CORE_EXECD


   if { [ llength $CHECK_CORE_EXECD ] < 2 } {
      set_error -3 "need 2 execd hosts"
      return
   }

   if { [is_version_ok] != 0 } {
      set_error -3 "This feature is not supportet for version [get_version_info]"
      return -3
   }


   if { [have_root_passwd] == -1 } {
      set_error -3 "root access required"
      return
   }
 
   puts $CHECK_OUTPUT "submitting job to queue $no_rerun_queue ..."
   set my_outputs "-o /dev/null -e /dev/null"
   set arguments "$my_outputs -q $no_rerun_queue -r y $CHECK_PRODUCT_ROOT/examples/jobs/sleeper.sh 10000"
   set job_id [ submit_job $arguments ]

   wait_for_jobstart $job_id "Sleeper" 100
   wait_for_end_of_transfer $job_id 100


   # shutdown execd
   puts $CHECK_OUTPUT "shutdown execd on host $no_rerun_host ..."
   catch {exec $CHECK_PRODUCT_ROOT/bin/$CHECK_ARCH/qconf -ke $no_rerun_host} output
   puts $output

   puts $CHECK_OUTPUT "deleting job $job_id ..."
   delete_job $job_id


   puts $CHECK_OUTPUT "job should still be in queue, but in delete state ..."
   if { [is_job_running $job_id "Sleeper"] != 1 } {
      add_proc_error "reschedule_deleted_job" -1 "job $job_id is not running!! (queue: $no_rerun_queue)"
   }


   puts $CHECK_OUTPUT "reschedule of job $job_id ..."
   set result [ catch { eval exec "$CHECK_PRODUCT_ROOT/bin/$CHECK_ARCH/qmod -r $job_id" } output ]
   puts $CHECK_OUTPUT $output

   
 
   # restart execd
   puts $CHECK_OUTPUT "restarting execd on host $no_rerun_host ..."
   startup_execd $no_rerun_host
   wait_for_load_from_all_queues 200 

   wait_for_jobend $job_id "Sleeper" 200 0
   
   set_error 0 "ok"
}

#
#                                                             max. column:     |
#
#****** check/reschedule_cleanup() ******
#  NAME
#     reschedule_cleanup -- ??? 
#
#  SYNOPSIS
#     reschedule_cleanup { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
#
proc reschedule_cleanup {} {

   global rerun_queue no_rerun_queue CHECK_OUTPUT rerun_host no_rerun_host
   global CHECK_CORE_EXECD stored_configuration rerun_queue2
   global pe_names pe_alloc_rule CHECK_CORE_EXECD
 

   if { [ llength $CHECK_CORE_EXECD ] < 2 } {
      set_error -3 "need 2 execd hosts"
      return
   }

   if { [is_version_ok] != 0 } {
      set_error -3 "This feature is not supportet for version [get_version_info]"
      return -3
   }


   reset_schedd_config
   set_config stored_configuration

   puts $CHECK_OUTPUT "removing checkpointobjects ..."
   del_checkpointobj "qmod_with_r"
   del_checkpointobj "qmod_without_r"

   foreach elem $pe_names { 
      del_pe $elem
   } 

  
   puts $CHECK_OUTPUT "removing queues ..."
   del_queue $rerun_queue
   del_queue $no_rerun_queue
   del_queue $rerun_queue2

   puts $CHECK_OUTPUT "enabling queues ..."
   foreach elem $CHECK_CORE_EXECD {
      puts "${elem}.q"
      enable_queue "${elem}.q"
   }

   
   set_error 0 "ok"
}
