#!/vol2/TCL_TK/glinux/bin/expect
#___INFO__MARK_BEGIN__
##########################################################################
#
#  The Contents of this file are made available subject to the terms of
#  the Sun Industry Standards Source License Version 1.2
#
#  Sun Microsystems Inc., March, 2001
#
#
#  Sun Industry Standards Source License Version 1.2
#  =================================================
#  The contents of this file are subject to the Sun Industry Standards
#  Source License Version 1.2 (the "License"); You may not use this file
#  except in compliance with the License. You may obtain a copy of the
#  License at http://www.gridengine.sunsource.net/license.html
#
#  Software provided under this License is provided on an "AS IS" basis,
#  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
#  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
#  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
#  See the License for the specific provisions governing your rights and
#  obligations concerning the Software.
#
#  The Initial Developer of the Original Code is: Sun Microsystems, Inc.
#
#  Copyright: 2001 by Sun Microsystems, Inc.
#
#  All Rights Reserved.
#
##########################################################################
#___INFO__MARK_END__

# define global variable in this namespace
global check_name 
global check_description 
global check_needs
global check_functions 
global check_errno 
global check_errstr 
global check_highest_level
global check_init_level_procedure
global check_root_access_needs
global env

# we need root access 
set check_root_access_needs "yes"

# define a level initialization procedure:
set check_init_level_procedure "init_level"

# define test's name and run level descriptions
set check_name            "qmod_auto_reschedule"
set check_highest_level   1 
set check_description(0)  "checking auto_reschedule with global reschedule_unknown 00:03:00"
set check_description(1)  "checking auto_reschedule with global reschedule_unknown 00:00:00"


# define test's dependencies
set check_needs           "init_core_system" 

# define test's procedure order
set check_functions ""
lappend check_functions "auto_reschedule_setup"
lappend check_functions "auto_reschedule_unknown_check"
lappend check_functions "auto_reschedule_unknown_check_master"
lappend check_functions "auto_reschedule_cleanup"



# -------- local test procedures -----------------------------------------------

global host1 host2 queue1 queue2 global_resch
global stored_configuration
global stored_host1_config
set queue1 "queue1"
set queue2 "queue2"

#
#                                                             max. column:     |
#
#****** check/init_level() ******
#  NAME
#     init_level -- ??? 
#
#  SYNOPSIS
#     init_level { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
#
proc init_level {} {
  global CHECK_ACT_LEVEL CHECK_HOST global_resch
  global host1 host2 CHECK_CORE_EXECD CHECK_OUTPUT
  

  if { [ llength $CHECK_CORE_EXECD ] >= 2 } {
     set host1  [ lindex $CHECK_CORE_EXECD 0  ]
     set host2  [ lindex $CHECK_CORE_EXECD 1  ]
  }

  set global_resch 1

  switch -- $CHECK_ACT_LEVEL {
     "0" { set global_resch 1
           return 0
         }
     "1" { set global_resch 0
           return 0 
         }
  } 
  return -1  ;# no other level else
}


#
#                                                             max. column:     |
#
#****** check/is_version_ok() ******
#  NAME
#     is_version_ok() -- ??? 
#
#  SYNOPSIS
#     is_version_ok { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
#
proc is_version_ok {} {
  
#  set version [ resolve_version ]
#  if { $version <= 10 } {
#     return -1
#  } 
  return 0
}

#
#                                                             max. column:     |
#
#****** check/auto_reschedule_setup() ******
#  NAME
#     auto_reschedule_setup -- ??? 
#
#  SYNOPSIS
#     auto_reschedule_setup { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
#
proc auto_reschedule_setup {} {
   global queue1 queue2 CHECK_OUTPUT host1 host2 
   global CHECK_CORE_EXECD stored_configuration 
   global stored_host1_config global_resch

   if { [ llength $CHECK_CORE_EXECD ] < 2 } {
      set_error -3 "need 2 execd hosts"
      return
   }

   if { [is_version_ok] != 0 } {
      set_error -3 "This feature is not supportet for version [get_version_info]"
      return -3
   }

   set schedd_config(schedule_interval) "00:00:04"
   set_schedd_config schedd_config

   if { [info exists stored_configuration] } {
      unset stored_configuration
   }
   get_config stored_configuration

   set myconfig(load_report_time)   "00:00:06"
   set myconfig(max_unheard)        "00:00:30"

   if { $global_resch != 0 } {
      set myconfig(reschedule_unknown) "00:03:00"
   } else {
      set myconfig(reschedule_unknown) "00:00:00"
   }
   set_config myconfig

   get_config stored_host1_config $host1
   if { [info exists stored_host1_config(reschedule_unknown)] != 1 } {
       set stored_host1_config(reschedule_unknown) ""
   }
   set myhostconfig(reschedule_unknown) "00:01:00"
   set_config myhostconfig $host1

 

   puts $CHECK_OUTPUT "disabling all cluster queues"
   foreach elem $CHECK_CORE_EXECD {
      puts "${elem}.q"
      disable_queue "${elem}.q"
   }

   set new_queue(qname)    $queue1
   set new_queue(hostname) $host1
   set new_queue(rerun)    "TRUE"
   set new_queue(qtype)    "BATCH INTERACTIVE PARALLEL CHECKPOINTING"
   set new_queue(load_thresholds) "np_load_avg=8.00"
   set new_queue(slots)    "100"
   add_queue new_queue 
 
   set new_queue(qname)    $queue2
   set new_queue(hostname) $host2 
   add_queue new_queue

   set_error 0 "ok"
}

#
#                                                             max. column:     |
#
#****** check/auto_reschedule_unknown_check_master() ******
#  NAME
#     auto_reschedule_unknown_check_master -- ??? 
#
#  SYNOPSIS
#     auto_reschedule_unknown_check_master { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
#
proc auto_reschedule_unknown_check_master {} {
   global queue1 queue2 CHECK_OUTPUT host1 host2
   global CHECK_CORE_EXECD stored_configuration CHECK_PRODUCT_ROOT
   global CHECK_ADMIN_USER_SYSTEM CHECK_ARCH CHECK_PRODUCT_TYPE
   global global_resch CHECK_CORE_MASTER

   if { [is_version_ok] != 0 } {
      set_error -3 "This feature is not supportet for version [get_version_info]"
      return -3
   }


   puts $CHECK_OUTPUT "submitting job to queue $queue1 ..."
   set my_outputs "-o /dev/null -e /dev/null"
   set arguments "$my_outputs -q $queue1 -r y $CHECK_PRODUCT_ROOT/examples/jobs/sleeper.sh 10000"
   set job_id1 [ submit_job $arguments ]

   puts $CHECK_OUTPUT "submitting job to queue $queue2 ..."
   set my_outputs "-o /dev/null -e /dev/null"
   set arguments "$my_outputs -q $queue2 -r y $CHECK_PRODUCT_ROOT/examples/jobs/sleeper.sh 10000"
   set job_id2 [ submit_job $arguments ]

   
   wait_for_jobstart $job_id1 "Sleeper" 100
   wait_for_jobstart $job_id2 "Sleeper" 100

   wait_for_end_of_transfer $job_id1 100
   wait_for_end_of_transfer $job_id2 100

   get_config my_config
   shutdown_master_and_scheduler $CHECK_CORE_MASTER $my_config(qmaster_spool_dir) 


   puts $CHECK_OUTPUT "killing execd on host $host2"
   shutdown_system_daemon $host2 "execd"
   

   startup_qmaster

   if { $global_resch != 0 } {
      # here we have global reshedule_unkown enabled
      wait_for_jobpending $job_id2 "Sleeper" 300
   } else {
      # here we have global reshedule_unkown set to 00:00:00
      set my_timeout [ expr ( [timestamp] + 260 ) ]
      while { [timestamp] <= $my_timeout }  {
         set j_state [ is_job_running $job_id2 "Sleeper" ]
         if { $j_state != 1 } {
            add_proc_error "auto_reschedule_unknown_check" -1 "job $job_id2 should still run"
            break
         } else {
            set to_go [ expr ( $my_timeout - [timestamp] ) ]
            puts $CHECK_OUTPUT "job $job_id2 still running, continue in $to_go seconds ... "
         }
         sleep 10
      }
   }

   wait_for_jobstart $job_id1 "Sleeper" 100
   wait_for_end_of_transfer $job_id1 100


   # restart execds
   startup_execd $host2

   wait_for_jobstart $job_id2 "Sleeper" 300
   wait_for_end_of_transfer $job_id2 100


   delete_job $job_id1
   delete_job $job_id2
   
   wait_for_jobend $job_id1 "Sleeper" 200 0
   wait_for_jobend $job_id2 "Sleeper" 200 0

   set_error 0 "ok"
}

#
#                                                             max. column:     |
#
#****** check/auto_reschedule_unknown_check() ******
#  NAME
#     auto_reschedule_unknown_check -- ??? 
#
#  SYNOPSIS
#     auto_reschedule_unknown_check { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
#
proc auto_reschedule_unknown_check {} {
   global queue1 queue2 CHECK_OUTPUT host1 host2
   global CHECK_CORE_EXECD stored_configuration CHECK_PRODUCT_ROOT
   global CHECK_ADMIN_USER_SYSTEM CHECK_ARCH CHECK_PRODUCT_TYPE
   global global_resch 

   if { [is_version_ok] != 0 } {
      set_error -3 "This feature is not supportet for version [get_version_info]"
      return -3
   }


   puts $CHECK_OUTPUT "submitting job to queue $queue1 ..."
   set my_outputs "-o /dev/null -e /dev/null"
   set arguments "$my_outputs -q $queue1 -r y $CHECK_PRODUCT_ROOT/examples/jobs/sleeper.sh 10000"
   set job_id1 [ submit_job $arguments ]

   puts $CHECK_OUTPUT "submitting job to queue $queue2 ..."
   set my_outputs "-o /dev/null -e /dev/null"
   set arguments "$my_outputs -q $queue2 -r y $CHECK_PRODUCT_ROOT/examples/jobs/sleeper.sh 10000"
   set job_id2 [ submit_job $arguments ]

   
   wait_for_jobstart $job_id1 "Sleeper" 100
   wait_for_jobstart $job_id2 "Sleeper" 100

   wait_for_end_of_transfer $job_id1 100
   wait_for_end_of_transfer $job_id2 100


   # shutdown execds
   puts $CHECK_OUTPUT "shutdown execd on host $host1 ..."
   catch {exec $CHECK_PRODUCT_ROOT/bin/$CHECK_ARCH/qconf -ke $host1 } output
   puts $output
   puts $CHECK_OUTPUT "shutdown execd on host $host2 ..."
   catch {exec $CHECK_PRODUCT_ROOT/bin/$CHECK_ARCH/qconf -ke $host2 } output
   puts $output
   

   if { $global_resch != 0 } {
      # here we have global reshedule_unkown enabled
      wait_for_jobpending $job_id1  "Sleeper" 80
      set j_state [ is_job_running $job_id2 "Sleeper" ]
      if { $j_state != 1 } {
          add_proc_error "auto_reschedule_unknown_check" -1 "job $job_id2 should still run"
      }
      wait_for_jobpending $job_id2  "Sleeper" 180
   } else {
      # here we have global reshedule_unkown set to 00:00:00
      set my_timeout [ expr ( [timestamp] + 250 ) ]
      wait_for_jobpending $job_id1  "Sleeper" 80
      while { [timestamp] <= $my_timeout }  {
         set j_state [ is_job_running $job_id2 "Sleeper" ]
         if { $j_state != 1 } {
            add_proc_error "auto_reschedule_unknown_check" -1 "job $job_id2 should still run"
            break
         } else {
            set to_go [ expr ( $my_timeout - [timestamp] ) ]
            puts $CHECK_OUTPUT "job $job_id2 still running, continue in $to_go seconds ... "
         }
         sleep 10
      }
      
   }


   # restart execds
   startup_execd $host1
   startup_execd $host2 

   wait_for_load_from_all_queues 200 

   wait_for_jobstart $job_id1 "Sleeper" 100
   wait_for_jobstart $job_id2 "Sleeper" 100

   wait_for_end_of_transfer $job_id1 100
   wait_for_end_of_transfer $job_id2 100
   
   delete_job $job_id1
   delete_job $job_id2
   
   wait_for_jobend $job_id1 "Sleeper" 200 0
   wait_for_jobend $job_id2 "Sleeper" 200 0


   set_error 0 "ok"
}

#
#                                                             max. column:     |
#
#****** check/auto_reschedule_cleanup() ******
#  NAME
#     auto_reschedule_cleanup -- ??? 
#
#  SYNOPSIS
#     auto_reschedule_cleanup { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
#
proc auto_reschedule_cleanup {} {

   global queue1 queue2 CHECK_OUTPUT host1 host2
   global CHECK_CORE_EXECD stored_configuration
   global stored_host1_config

   if { [is_version_ok] != 0 } {
      set_error -3 "This feature is not supportet for version [get_version_info]"
      return -3
   }

 
   reset_schedd_config
   set_config stored_configuration
   set_config stored_host1_config $host1

   puts $CHECK_OUTPUT "removing queues ..."
   del_queue $queue1
   del_queue $queue2

   puts $CHECK_OUTPUT "enabling queues ..."
   foreach elem $CHECK_CORE_EXECD {
      puts "${elem}.q"
      enable_queue "${elem}.q"
   }

   set_error 0 "ok"
}
