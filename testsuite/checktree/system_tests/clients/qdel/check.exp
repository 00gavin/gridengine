#!/vol2/TCL_TK/glinux/bin/expect
#___INFO__MARK_BEGIN__
##########################################################################
#
#  The Contents of this file are made available subject to the terms of
#  the Sun Industry Standards Source License Version 1.2
#
#  Sun Microsystems Inc., March, 2001
#
#
#  Sun Industry Standards Source License Version 1.2
#  =================================================
#  The contents of this file are subject to the Sun Industry Standards
#  Source License Version 1.2 (the "License"); You may not use this file
#  except in compliance with the License. You may obtain a copy of the
#  License at http://gridengine.sunsource.net/Gridengine_SISSL_license.html
#
#  Software provided under this License is provided on an "AS IS" basis,
#  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
#  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
#  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
#  See the License for the specific provisions governing your rights and
#  obligations concerning the Software.
#
#  The Initial Developer of the Original Code is: Sun Microsystems, Inc.
#
#  Copyright: 2001 by Sun Microsystems, Inc.
#
#  All Rights Reserved.
#
##########################################################################
#___INFO__MARK_END__

# define global variable in this namespace
global check_name 
global check_category
global check_description 
global check_needs
global check_functions 
global check_errno 
global check_errstr 
global check_highest_level
global check_init_level_procedure
global check_root_access_needs
global env

set check_root_access_needs "yes"

# define a level initialization procedure:
set check_init_level_procedure "init_level"


# define test's name and run level descriptions
set check_name            "qdel"
set check_category        "COMPATIBILITY SYSTEM L10N VERIFIED"
set check_highest_level   3
set check_description(0)  "checking all options in job pending state"
set check_description(1)  "checking all options in job pending and hold state"
set check_description(2)  "checking all options in job running state"
set check_description(3)  "checking all options in job running and hold state" 

# define test's dependencies
set check_needs           "init_core_system" 


# define test's procedure order
set check_functions ""
lappend check_functions "qdel_setup"
lappend check_functions "qdel_help"                   ;# print this help
lappend check_functions "qdel_submit_delete_when_transfered"
lappend check_functions "qdel_job_task_list"          ;# delete all jobs given in list
lappend check_functions "qdel_delete_job_0"           ;# try to delete job id 0
lappend check_functions "qdel_delete_unknown_jobid"   ;# delete job not running
lappend check_functions "qdel_delete_negative_jobid"
lappend check_functions "qdel_all"                   ;# delete all jobs of current user
lappend check_functions "qdel_uall"                  ;# delete all jobs of all users
lappend check_functions "qdel_user_list"             ;# delete all jobs of users specified in list
lappend check_functions "qdel_force"                 ;# force action

# check's globals
global hold_state
global pending_state
global queue

# run level initialization
#                                                             max. column:     |
#****** qdel/init_level() ******
# 
#  NAME
#     init_level -- ??? 
#
#  SYNOPSIS
#     init_level { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc init_level {} {
  global CHECK_ACT_LEVEL CHECK_HOST hold_state pending_state queue

  set queue "qdel.q"

  

  switch -- $CHECK_ACT_LEVEL {
     "0" { set hold_state 0 ; set pending_state 1 ; return 0   } 
     "1" { set hold_state 1 ; set pending_state 1 ; return 0   }
     "2" { set hold_state 0 ; set pending_state 0 ; return 0   }
     "3" { set hold_state 1 ; set pending_state 0 ; return 0   }
  } 
  return -1  ;# no other level else
}

# -------- local test procedures -----------------------------------------------

#                                                             max. column:     |
#****** qdel/qdel_setup() ******
# 
#  NAME
#     qdel_setup -- ??? 
#
#  SYNOPSIS
#     qdel_setup { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc qdel_setup {} {
   global queue CHECK_HOST 

   set q_param(load_thresholds)       "np_load_avg=7.00"
   set q_param(slots)                 "50"

   add_queue $queue $CHECK_HOST q_param
   set_error 0 "ok"
}

#                                                             max. column:     |
#****** qdel/qdel_cleanup() ******
# 
#  NAME
#     qdel_cleanup -- ??? 
#
#  SYNOPSIS
#     qdel_cleanup { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc qdel_cleanup {} {
   global queue CHECK_CORE_EXECD CHECK_PRODUCT_ROOT CHECK_ARCH CHECK_OUTPUT
   global CHECK_HOST CHECK_USER CHECK_FIRST_FOREIGN_SYSTEM_USER 
   global CHECK_SECOND_FOREIGN_SYSTEM_USER

   delete_all_jobs
   wait_for_end_of_all_jobs 120

   del_queue $queue $CHECK_HOST 0 1

   puts $CHECK_OUTPUT "do qmod -c for all queues"
   foreach hostname $CHECK_CORE_EXECD {
      set result [ catch { eval exec "$CHECK_PRODUCT_ROOT/bin/$CHECK_ARCH/qmod -c [get_queue_instance all.q $hostname]" } output ]
      puts $CHECK_OUTPUT $output
   }


   set_error 0 "ok"
}

proc qdel_submit_delete_when_transfered { } {
   global CHECK_OUTPUT CHECK_PRODUCT_ROOT CHECK_ARCH
   global submit_del_qconfig submit_del_check_queue CHECK_USER
   global CHECK_CORE_EXECD CHECK_HOST CHECK_PRODUCT_ROOT CHECK_DEBUG_LEVEL
   global CHECK_ACT_LEVEL ts_config
 
   if { $CHECK_ACT_LEVEL == 0 } {
      if { $ts_config(gridengine_version) == 60 } {
         set JOB_SUBMITTED       [translate $CHECK_HOST 1 0 0 [sge_macro MSG_QSUB_YOURJOBHASBEENSUBMITTED_SS] "*" "*"]
         set JOB_SUBMITTED_DUMMY [translate $CHECK_HOST 1 0 0 [sge_macro MSG_QSUB_YOURJOBHASBEENSUBMITTED_SS] "__JOB_ID__" "__JOB_NAME__"]
      } else {
         set JOB_SUBMITTED       [translate $CHECK_HOST 1 0 0 [sge_macro MSG_JOB_SUBMITJOB_USS] "*" "*" "*"]
         set JOB_SUBMITTED_DUMMY [translate $CHECK_HOST 1 0 0 [sge_macro MSG_JOB_SUBMITJOB_USS] "__JOB_ID__" "__JOB_NAME__" "__JOB_ARG__"]
      }
      set job_id_pos [ string first "__JOB_ID__" $JOB_SUBMITTED_DUMMY ]
      set job_name_pos [ string first "__JOB_NAME__" $JOB_SUBMITTED_DUMMY ]
      if { $job_id_pos > $job_name_pos } {
         add_proc_error "qdel_submit_delete_when_transfered" "-1" "locale switches parameter for qsub string! This is not supported yet"
      }
      incr job_id_pos -1
      set job_id_prefix [ string range $JOB_SUBMITTED_DUMMY 0 $job_id_pos ]
      set job_id_prefix_length [ string length $job_id_prefix]
      puts $CHECK_OUTPUT "job id prefix is: \"$job_id_prefix\""

      set arch [resolve_arch $CHECK_HOST]
      set qsub_program "$CHECK_PRODUCT_ROOT/bin/$arch/qsub"
      set qdel_program "$CHECK_PRODUCT_ROOT/bin/$arch/qdel"
      set job_script "$CHECK_PRODUCT_ROOT/examples/jobs/sleeper.sh"
      wait_for_end_of_all_jobs 100
      set runs 25
      while { $runs > 0 } { 
         foreach elem $CHECK_CORE_EXECD {
            set arguments "-o /dev/null -e /dev/null -q [get_queue_instance all.q $elem]"
      #      start_remote_prog $CHECK_HOST $CHECK_USER "qdel" "`qsub $arguments $job_script | cut -d\" \" -f3`"
            set catch_return [ catch { eval exec "$qsub_program $arguments $job_script" } result ]
            puts $CHECK_OUTPUT $result
            set id_pos [string first $job_id_prefix $result]
            incr id_pos $job_id_prefix_length
            set job_id [string range $result $id_pos end]
            set space_pos [ string first " " $job_id ]
            set job_id [string range $job_id 0 $space_pos ]
            set job_id [string trim $job_id]
            puts $CHECK_OUTPUT "submitted job $job_id"
            catch {  eval exec "$CHECK_PRODUCT_ROOT/bin/$arch/qconf" "-tsm" } result
            set job_state [ wait_for_jobstart $job_id "leeper" 120 ]
            if { $job_state == -1 } {
               set runs 0
            }
            set catch_return [ catch { eval exec "$qdel_program $job_id" } result ]
            puts $CHECK_OUTPUT $result
            puts $CHECK_OUTPUT "deleted job $job_id"
         }
         incr runs -1
      }
      wait_for_end_of_all_jobs 100
   }

   puts $CHECK_OUTPUT "do qmod -c for all queues"
   foreach hostname $CHECK_CORE_EXECD {
      set result [ catch { eval exec "$CHECK_PRODUCT_ROOT/bin/$CHECK_ARCH/qmod -c [get_queue_instance all.q ${hostname}]" } output ]
      puts $CHECK_OUTPUT $output
   }

   set_error 0 "ok"
}


#                                                             max. column:     |
#****** qdel/are_jobs_deleted() ******
# 
#  NAME
#     are_jobs_deleted -- ??? 
#
#  SYNOPSIS
#     are_jobs_deleted { job_list } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#     job_list - ??? 
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc are_jobs_deleted { job_list } {

   global CHECK_OUTPUT
   set del_jobs ""

   set time [timestamp] 
   while {1} {
       set jobs_deleted 0
       foreach job_id $job_list {
          set result [ is_job_running $job_id "qdel_check" ]
          if {$result == -1} {
             if { [ lsearch $del_jobs "$job_id" ] != 0 } { 
                lappend del_jobs $job_id 
             }
             incr jobs_deleted 1
          }
       }
     
       puts $CHECK_OUTPUT "Jobs_deleted: $del_jobs"
       puts $CHECK_OUTPUT "All jobs:     $job_list"
 
       if {$jobs_deleted == [llength $job_list]} {
          return 0
       }

       set runtime [expr ( [timestamp] - $time ) ]
       if { $runtime >= 120 } {
          return -1
       }
       sleep 1
   }   

}

#                                                             max. column:     |
#****** qdel/submit_testjobs() ******
# 
#  NAME
#     submit_testjobs -- ??? 
#
#  SYNOPSIS
#     submit_testjobs { { user "" } } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#     { user "" } - ??? 
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc submit_testjobs { { user "" } { additional_job_args "" }} {
  global CHECK_PRODUCT_ROOT queue hold_state pending_state CHECK_TESTSUITE_ROOT 
  global CHECK_OUTPUT CHECK_ARCH CHECK_HOST CHECK_HOST ts_config

  set joblist ""
  set year [exec date "+%Y"] 
  set year [ expr ( $year + 1 ) ]

  set jobargs "-o /dev/null -e /dev/null -N qdel_check"

  if { ($pending_state == 1)  } {
     set jobargs "$jobargs -a ${year}12312359"   ;# start at silvester next year!

     if { ($hold_state == 1)  } {
        set jobargs "$jobargs -h"   ;# set hold flag
     }
  }
 
  set jobargs "$additional_job_args $jobargs -q [get_queue_instance $queue $CHECK_HOST] $CHECK_PRODUCT_ROOT/examples/jobs/sleeper.sh 3000"

  if { [string compare "" $user] == 0 } {
     # no user specified (using local user name (starter of testsuite))
     for {set count 1} {$count <= 4} {incr count +1} {
       set jobresult [submit_job $jobargs]     ;# submit_job has it's own error handling
       if {$jobresult > 0 } {
          lappend joblist $jobresult
       }
     }
  } else {
     # perform su to user and submit jobs as user $user
     
     set result [ run_command_as_user "$CHECK_HOST" "$user" "qsub" "$jobargs" 4]
      if { $ts_config(gridengine_version) == 60 } {
         set JOB_SUBMITTED       [translate $CHECK_HOST 1 0 0 [sge_macro MSG_QSUB_YOURJOBHASBEENSUBMITTED_SS] "*" "*"]
         set JOB_SUBMITTED_DUMMY [translate $CHECK_HOST 1 0 0 [sge_macro MSG_QSUB_YOURJOBHASBEENSUBMITTED_SS] "__JOB_ID__" "__JOB_NAME__"]
      } else {
         set JOB_SUBMITTED       [translate $CHECK_HOST 1 0 0 [sge_macro MSG_JOB_SUBMITJOB_USS] "*" "*" "*"]
         set JOB_SUBMITTED_DUMMY [translate $CHECK_HOST 1 0 0 [sge_macro MSG_JOB_SUBMITJOB_USS] "__JOB_ID__" "__JOB_NAME__" "__JOB_ARG__"]
      }
      set job_id_pos [ string first "__JOB_ID__" $JOB_SUBMITTED_DUMMY ]
      set job_name_pos [ string first "__JOB_NAME__" $JOB_SUBMITTED_DUMMY ]
      if { $job_id_pos > $job_name_pos } {
         add_proc_error "qdel_submit_delete_when_transfered" "-1" "locale switches parameter for qsub string! This is not supported yet"
      }
      incr job_id_pos -1
      set job_id_prefix [ string range $JOB_SUBMITTED_DUMMY 0 $job_id_pos ]
      set job_id_prefix_length [ string length $job_id_prefix]
      puts $CHECK_OUTPUT "job id prefix is: \"$job_id_prefix\""
 
     set test [ split $result "\n" ] 
     foreach elem $test {
        # l10n
        set id_pos [string first $job_id_prefix $elem]
        if { $id_pos >= 0 && [string first "qdel_check" $elem] >= 0 } {
           incr id_pos $job_id_prefix_length
           set job_id [string range $elem $id_pos end]
           set space_pos [ string first " " $job_id ]
           set job_id [string range $job_id 0 $space_pos ]
           set jobresult [string trim $job_id]
           if {$jobresult > 0} { 
              lappend joblist $jobresult
           }
        }
     }
  }
  if { $pending_state == 0 } {
     # wait for all job to run
     foreach elem $joblist {
        wait_for_jobstart  $elem "qdel_check" 400  
     }

     if { ($hold_state == 1)  } {
        # set hold flag for all jobs 
        foreach elem $joblist {
           hold_job $elem 
        } 
     }
  } else {
     # wait for all job to get in pending state
     foreach elem $joblist {
        wait_for_jobpending $elem "qdel_check" 400  
     }
  }

  return $joblist
}

# ------------------------------------------------------------------------------

#                                                             max. column:     |
#****** qdel/qdel_delete_job_0() ******
# 
#  NAME
#     qdel_delete_job_0 -- ??? 
#
#  SYNOPSIS
#     qdel_delete_job_0 { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc qdel_delete_job_0 {} {
   global CHECK_PRODUCT_ROOT CHECK_ARCH CHECK_OUTPUT CHECK_HOST

   set state [ catch {exec "$CHECK_PRODUCT_ROOT/bin/$CHECK_ARCH/qdel" "0" } output ]
   
   puts $CHECK_OUTPUT "qdel output    : \n---\n$output\n---"
   puts $CHECK_OUTPUT "qdel exit state: $state"  
 
   if {$state != 1 } {
      set_error -1 "exit state is not 1"
   }

   set output_length [string length $output]
   puts $CHECK_OUTPUT "output length: $output_length"

   if {$output_length < 10 } {
      set_error -1 "possible wrong output - please check output manually"
   }

   set_error 0 "ok"
}


#                                                             max. column:     |
#****** qdel/qdel_help() ******
# 
#  NAME
#     qdel_help -- ??? 
#
#  SYNOPSIS
#     qdel_help { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc qdel_help {} {
   global CHECK_PRODUCT_ROOT CHECK_ARCH CHECK_OUTPUT CHECK_PRODUCT_VERSION_NUMBER CHECK_HOST
   global qdel_help_lines

   set state [ catch {exec "$CHECK_PRODUCT_ROOT/bin/$CHECK_ARCH/qdel" "-help" } output ]

   puts $CHECK_OUTPUT "qdel output    : \n---\n$output\n---"
   puts $CHECK_OUTPUT "qdel exit state: $state"

   if {$state != 0} {
      set_error -1 "exit state is not 0"
   }

   if { [ string first $CHECK_PRODUCT_VERSION_NUMBER $output] < 0 } {
      set_error -1 "version string ($CHECK_PRODUCT_VERSION_NUMBER) not found"
   } 
 
   set lines [ split $output "\n"]
   set nr_of_lines [ llength $lines ] 

   puts $CHECK_OUTPUT "Output has $nr_of_lines lines"

   if { $nr_of_lines != $qdel_help_lines } {
      set_error -1 "help output hasn't $qdel_help_lines lines"
   }

   set_error 0 "ok"
}

#                                                             max. column:     |
#****** qdel/qdel_job_task_list() ******
# 
#  NAME
#     qdel_job_task_list -- ??? 
#
#  SYNOPSIS
#     qdel_job_task_list { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc qdel_job_task_list {} {

    global CHECK_OUTPUT CHECK_PRODUCT_ROOT CHECK_ARCH env CHECK_HOST

    # submit jobs to delete
    set job_list [submit_testjobs]

    set result 0

    set result [ catch { eval exec "$CHECK_PRODUCT_ROOT/bin/$CHECK_ARCH/qdel $job_list" } qdel_output ] 
    
    puts $CHECK_OUTPUT "qdel_result = $result"
    puts $CHECK_OUTPUT "qdel_output = $qdel_output"

    # Errorhandling not functional yet because qdel returns always 0 it doesn't matter if the job exists or not
    if { $result != 0 } {
       set_error -1 "qdel_job_task_list: Could not delete jobs (exit status: $result) "
    }

    set time [timestamp]
    while {1} {
       set jobs_deleted 0
       foreach job_id $job_list {
          set result [ is_job_running $job_id "qdel_check" ]
          if {$result != -1} {
             incr jobs_deleted 1
          }
       }

       if {$jobs_deleted == 0} {
          set_error 0 "no error"
          return
       }

       set runtime [expr ( [timestamp] - $time ) ]
       if { $runtime >= 300 } {
          set_error -1 "timeout while waiting for end of testjobs $job_list"
          break  
       }
    }    
}

#                                                             max. column:     |
#****** Checks/qdel/qdel_delete_unknown_jobid() ******
# 
#  NAME
#     qdel_delete_unknown_jobid -- check deletion of unknown jobs / tasks
#
#  SYNOPSIS
#     qdel_delete_unknown_jobid { } 
#
#  FUNCTION
#     Execute qdel commands to delete jobs, tasks and taskranges that
#     are unknown to the system.
#     Checks if the errors output match the expected patterns.
#
#*******************************
proc qdel_delete_unknown_jobid {} {
   global ts_config
   global CHECK_PRODUCT_ROOT CHECK_ARCH CHECK_HOST CHECK_USER

   # submit jobs to delete
   set job_list [submit_testjobs]

   # add a unknown jobid
   set unknown_jobid [ expr ( [ lindex $job_list [ expr ( [ llength $job_list] - 1 ) ] ] + 1 ) ]
   lappend job_list $unknown_jobid 
   if {$ts_config(gridengine_version) == 53} {
      set default_output [translate $CHECK_HOST 1 0 0 [sge_macro MSG_SGETEXT_DOESNOTEXIST_SU] "job" $unknown_jobid ]  
   } else {
      set default_output [translate $CHECK_HOST 1 0 0 [sge_macro MSG_SGETEXT_DOESNOTEXIST_SS] "job" $unknown_jobid]  
   }

   qdel_delete_unknown_jobid_proc $job_list "$default_output"

   # submit jobs to delete
   set job_list [submit_testjobs]

   # add a unknown taskid
   set last_jobid "[lindex $job_list end]"
   set unknown_taskid 5
   set job_list [lreplace $job_list end end "$last_jobid.$unknown_taskid"]
   if {$ts_config(gridengine_version) == 53} {
      set default_output [translate $CHECK_HOST 1 0 0 [sge_macro MSG_SGETEXT_DOESNOTEXISTTASK_UU] $last_jobid $unknown_taskid] 
   } else {
      set default_output [translate $CHECK_HOST 1 0 0 [sge_macro MSG_SGETEXT_DOESNOTEXISTTASK_SU] $last_jobid $unknown_taskid] 
   }
   qdel_delete_unknown_jobid_proc $job_list "$default_output"
   delete_job $last_jobid

   # submit jobs to delete
   set job_list [submit_testjobs]

   # add a unknown taskid range
   set last_jobid "[lindex $job_list end]"
   set empty_taskrange "5-10:2"
   set job_list [lreplace $job_list end end "$last_jobid.$empty_taskrange"]
   if {$ts_config(gridengine_version) == 53} {
      set default_output [translate $CHECK_HOST 1 0 0 [sge_macro MSG_SGETEXT_DOESNOTEXISTTASKRANGE_UUUU] $last_jobid "5" "10" "2"]
   } else {
      set default_output [translate $CHECK_HOST 1 0 0 [sge_macro MSG_SGETEXT_DOESNOTEXISTTASKRANGE_SUUU] $last_jobid "5" "9" "2"]
   }
   qdel_delete_unknown_jobid_proc $job_list "$default_output"
   delete_job $last_jobid 1
   # wait for job to leave queue
#      sleep 5
}

proc qdel_delete_unknown_jobid_proc {job_list default_output} {
  global CHECK_OUTPUT CHECK_PRODUCT_ROOT CHECK_ARCH env CHECK_HOST

  set result [ catch { eval exec "$CHECK_PRODUCT_ROOT/bin/$CHECK_ARCH/qdel $job_list" } qdel_output ] 

  puts $CHECK_OUTPUT "qdel_result = $result"
  puts $CHECK_OUTPUT "qdel_output = $qdel_output"

  if { [string first "\[" $qdel_output ] == 0  } {
     #remove [xxxxx] message id
     puts $CHECK_OUTPUT "removing message id from output ..."
     set cut [string first "\]" $qdel_output ]
     incr cut 2
     set qdel_output [string range $qdel_output $cut end] 
     puts $CHECK_OUTPUT "qsub qdel_output is: \"$qdel_output\""
  }
 

  if { $result != 0 } {
     set_error -1 "exit state is not 0"
  } 

  set nr_of_jobs [llength $job_list]
  set qd_out [split $qdel_output "\n"]
  set nr_of_output_lines [llength $qd_out]

  puts $CHECK_OUTPUT "nr_of_jobs = $nr_of_jobs"
  puts $CHECK_OUTPUT "nr_of_output_lines = $nr_of_output_lines"

  if { $nr_of_jobs != $nr_of_output_lines } {
     set_error -1 "nr of jobs doesn't match output lines"
  }

  set last_job_output [ lindex $qd_out [ expr ( $nr_of_output_lines - 1 ) ] ]
  if { [string first "\[" $last_job_output ] == 0  } {
     #remove [xxxxx] message id
     puts $CHECK_OUTPUT "removing message id from output ..."
     set cut [string first "\]" $last_job_output ]
     incr cut 2
     set last_job_output [string range $last_job_output $cut end] 
     puts $CHECK_OUTPUT "qsub last_job_output is: \"$last_job_output\""
  }

  puts $CHECK_OUTPUT "last job output: \"$last_job_output\""
  puts $CHECK_OUTPUT "should be:       \"$default_output\""

  if { [ string compare $default_output $last_job_output  ] != 0 } {
     set_error -1 "deleting of not existing job produces wrong output (\"$last_job_output\")"
  } else {
     puts $CHECK_OUTPUT "ok"
  }

  set_error 0 "ok"
}




#                                                             max. column:     |
#****** qdel/qdel_delete_negative_jobid() ******
# 
#  NAME
#     qdel_delete_negative_jobid -- ??? 
#
#  SYNOPSIS
#     qdel_delete_negative_jobid { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc qdel_delete_negative_jobid {} {
   global CHECK_PRODUCT_ROOT CHECK_ARCH CHECK_OUTPUT CHECK_HOST

   set state [ catch {exec "$CHECK_PRODUCT_ROOT/bin/$CHECK_ARCH/qdel" "-1" } output ]
   
   puts $CHECK_OUTPUT "qdel output    : \n---\n$output\n---"
   puts $CHECK_OUTPUT "qdel exit state: $state"  
 
   if {$state != 1 } {
      set_error -1 "exit state is not 1"
   }

   set output_length [string length $output]
   puts $CHECK_OUTPUT "output length: $output_length"

   if {$output_length < 10 } {
      set_error -1 "possible wrong output - please check output manually"
   }

   set_error 0 "ok"
}

#                                                             max. column:     |
#****** qdel/qdel_all() ******
# 
#  NAME
#     qdel_all -- ??? 
#
#  SYNOPSIS
#     qdel_all { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc qdel_all {} {
   global ts_config
   global CHECK_OUTPUT CHECK_FIRST_FOREIGN_SYSTEM_USER CHECK_PRODUCT_ROOT CHECK_ARCH
   global CHECK_HOST

   if {$ts_config(gridengine_version) == 53} {
      set all_args "all"
      set all_args_remote "all"
   } else {
      set all_args "*"
      set all_args_remote "'*'"
   }

   # submit jobs to delete
   set job_list_user1 [submit_testjobs] 
   puts $CHECK_OUTPUT "user 1 has jobs $job_list_user1"
 

   set job_list_user2 [submit_testjobs $CHECK_FIRST_FOREIGN_SYSTEM_USER]
   puts $CHECK_OUTPUT "user 2 has jobs $job_list_user2"
 
   
   # now delete jobs of user 1
   set result [ catch { exec "$CHECK_PRODUCT_ROOT/bin/$CHECK_ARCH/qdel" "$all_args" } qdel_output ] 
   puts $CHECK_OUTPUT "qdel_result = $result"
   puts $CHECK_OUTPUT "qdel_output = $qdel_output" 
   if { $result != 0 } {
       set_error -1 "qdel_job_task_list: Could not delete jobs $job_list_user1 (exit status: $result) "
   }

   set time [timestamp] 
   while {1} {
       set jobs_deleted 0
       foreach job_id $job_list_user1 {
          set result [ is_job_running $job_id "qdel_check" ]
          if {$result == -1} {
             incr jobs_deleted 1
          }
       }
 
       if {$jobs_deleted == 4} {
          break;
       }

       set runtime [expr ( [timestamp] - $time ) ]
       if { $runtime >= 60 } {
          set_error -1 "timeout while waiting for end of testjobs $job_list_user1"
          break  
       }
       puts -nonewline $CHECK_OUTPUT "."
       flush $CHECK_OUTPUT
       sleep 1 
   }    


   # now check if user2 has still his jobs
   foreach job_id $job_list_user2 {
          set result [ is_job_running $job_id "qdel_check" ]
          if {$result == -1} {
             set_error -1 "(3) jobs of different user deleted" 
          }
   } 
  
   # now submit new jobs for user 1
   set job_list_user1 [submit_testjobs]  
   puts $CHECK_OUTPUT "user 1 has jobs $job_list_user1"

   # now delete jobs of user 2
   set result [ run_command_as_user "$CHECK_HOST" "$CHECK_FIRST_FOREIGN_SYSTEM_USER" "qdel" "$all_args_remote" 1 ]
   puts $CHECK_OUTPUT "qdel_output = \n$result" 

   set time [timestamp] 
   while {1} {
       set jobs_deleted 0
       foreach job_id $job_list_user2 {
          set result [ is_job_running $job_id "qdel_check" ]
          if {$result == -1} {
             incr jobs_deleted 1
          }
       }
 
       if {$jobs_deleted == 4} {
          break;
       }

       set runtime [expr ( [timestamp] - $time ) ]
       if { $runtime >= 60 } {
          set_error -1 "timeout while waiting for end of testjobs $job_list_user2"
          break  
       }
       puts -nonewline $CHECK_OUTPUT "."
       flush $CHECK_OUTPUT
       sleep 1
   }     

   # now check if user1 has still his jobs
   foreach job_id $job_list_user1 {
          set result [ is_job_running $job_id "qdel_check" ]
          if {$result == -1} {
             set_error -1 "(4) jobs of different user deleted" 
          }
   } 

   # now delete jobs of user1
   set result [ catch { exec "$CHECK_PRODUCT_ROOT/bin/$CHECK_ARCH/qdel" "$all_args" } qdel_output ] 
   puts $CHECK_OUTPUT "qdel_result = $result"
   puts $CHECK_OUTPUT "qdel_output = $qdel_output" 
   if { $result != 0 } {
       set_error -1 "qdel_job_task_list: Could not delete jobs $job_list_user1 (exit status: $result) "
   }

   set time [timestamp] 
   while {1} {
       set jobs_deleted 0
       foreach job_id $job_list_user1 {
          set result [ is_job_running $job_id "qdel_check" ]
          if {$result == -1} {
             incr jobs_deleted 1
          }
       }
 
       if {$jobs_deleted == 4} {
          break;
       }

       set runtime [expr ( [timestamp] - $time ) ]
       if { $runtime >= 60 } {
          set_error -1 "timeout while waiting for end of testjobs $job_list_user1"
          break  
       }
       sleep 1
       puts -nonewline $CHECK_OUTPUT "."
       flush $CHECK_OUTPUT
   }   


   set_error 0 "no errors"
}

#                                                             max. column:     |
#****** qdel/qdel_uall() ******
# 
#  NAME
#     qdel_uall -- ??? 
#
#  SYNOPSIS
#     qdel_uall { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc qdel_uall {} {
   global ts_config
   global CHECK_OUTPUT CHECK_USER CHECK_FIRST_FOREIGN_SYSTEM_USER 
   global CHECK_SECOND_FOREIGN_SYSTEM_USER CHECK_PRODUCT_ROOT CHECK_ARCH
   global CHECK_HOST

   if { [have_root_passwd] == -1 } {
      set_error -3 "root access required"
      return
   } 

   if {$ts_config(gridengine_version) == 53} {
      set uall_args "-uall"
   } else {
      set uall_args "-u '*'"
   }

   # submit jobs to delete
   set job_list_user1 [submit_testjobs]  
   puts $CHECK_OUTPUT "user 1 has jobs $job_list_user1"
 
   set job_list_user2 [submit_testjobs $CHECK_FIRST_FOREIGN_SYSTEM_USER]
   puts $CHECK_OUTPUT "user 2 has jobs $job_list_user2"

   set job_list_user3 [submit_testjobs $CHECK_SECOND_FOREIGN_SYSTEM_USER]
   puts $CHECK_OUTPUT "user 3 has jobs $job_list_user3"


   # now delete all jobs as user 2 ( only submit user )
   set result [ run_command_as_user "$CHECK_HOST" "$CHECK_FIRST_FOREIGN_SYSTEM_USER" "qdel" $uall_args 1 ]
   puts $CHECK_OUTPUT "qdel_output = \n$result" 

   # now delete all jobs as user 3 ( only submit user )
   set result [ run_command_as_user "$CHECK_HOST" "$CHECK_SECOND_FOREIGN_SYSTEM_USER" "qdel" $uall_args 1 ]
   puts $CHECK_OUTPUT "qdel_output = \n$result" 

   # test if all jobs are still there:
   set all_jobs "$job_list_user1 $job_list_user2 $job_list_user3"
   puts $CHECK_OUTPUT "following jobs must be in the system: $all_jobs"
   foreach job_id $all_jobs {
          set result [ is_job_running $job_id "qdel_check" ]
          if {$result == -1} {
             set_error -1 "(5) jobs of different user deleted" 
          }
   } 

   # now delete all jobs as user 1 ( manager )
   set result [ run_command_as_user "$CHECK_HOST" "$CHECK_USER" "qdel" $uall_args 1 ]
   puts $CHECK_OUTPUT "qdel_output = \n$result" 

   # now check if all jobs are deleted
   set time [timestamp] 
   while {1} {
       set jobs_deleted 0
       foreach job_id $all_jobs {
          set result [ is_job_running $job_id "qdel_check" ]
          if {$result == -1} {
             incr jobs_deleted 1
          }
       }
 
       if {$jobs_deleted == 12} {
          break;
       }

       set runtime [expr ( [timestamp] - $time ) ]
       if { $runtime >= 300 } {
          set_error -1 "timeout while waiting for end of testjobs $all_jobs"
          break  
       }
       sleep 1
   }   
   set_error 0 "no errors"
}

#                                                             max. column:     |
#****** qdel/qdel_user_list() ******
# 
#  NAME
#     qdel_user_list -- ??? 
#
#  SYNOPSIS
#     qdel_user_list { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc qdel_user_list {} {

   global CHECK_OUTPUT CHECK_USER CHECK_FIRST_FOREIGN_SYSTEM_USER CHECK_HOST
   global CHECK_SECOND_FOREIGN_SYSTEM_USER CHECK_PRODUCT_ROOT CHECK_ARCH
   if { [have_root_passwd] == -1 } {
      set_error -3 "root access required"
      return
   } 

   # submit jobs to delete
   set job_list_user1 [submit_testjobs]  
   puts $CHECK_OUTPUT "user 1 has jobs $job_list_user1"
 
   set job_list_user2 [submit_testjobs $CHECK_FIRST_FOREIGN_SYSTEM_USER]
   puts $CHECK_OUTPUT "user 2 has jobs $job_list_user2"

   set job_list_user3 [submit_testjobs $CHECK_SECOND_FOREIGN_SYSTEM_USER]
   puts $CHECK_OUTPUT "user 3 has jobs $job_list_user3"


   # now delete all jobs as user 2 ( only submit user ) of user 3 ( only submit user)
   set result [ run_command_as_user "$CHECK_HOST" "$CHECK_FIRST_FOREIGN_SYSTEM_USER" "qdel" "-u $CHECK_SECOND_FOREIGN_SYSTEM_USER" 1 ]
   puts $CHECK_OUTPUT "qdel_output = \n$result" 

   # now delete all jobs as user 2 ( only submit user ) of user 1 ( manager )
   set result [ run_command_as_user "$CHECK_HOST" "$CHECK_FIRST_FOREIGN_SYSTEM_USER" "qdel" "-u $CHECK_USER" 1 ]
   puts $CHECK_OUTPUT "qdel_output = \n$result" 

   # now delete all jobs as user 2 ( only submit user ) of user 1 && user 3
   set result [ run_command_as_user "$CHECK_HOST" "$CHECK_FIRST_FOREIGN_SYSTEM_USER" "qdel" "-u $CHECK_USER,$CHECK_SECOND_FOREIGN_SYSTEM_USER" 1 ]
   puts $CHECK_OUTPUT "qdel_output = \n$result" 


   # test if all jobs are still there:
   set all_jobs "$job_list_user1 $job_list_user2 $job_list_user3"
   puts $CHECK_OUTPUT "following jobs must be in the system: $all_jobs"
   foreach job_id $all_jobs {
          set result [ is_job_running $job_id "qdel_check" ]
          if {$result == -1} {
             set_error -1 "(1) jobs of different user deleted" 
          }
   } 


   # now delete all jobs as user 2 ( only submit user ) of user 2 ( himself ) 
   set result [ run_command_as_user "$CHECK_HOST" "$CHECK_FIRST_FOREIGN_SYSTEM_USER" "qdel" "-u $CHECK_FIRST_FOREIGN_SYSTEM_USER" 1 ]
   puts $CHECK_OUTPUT "qdel_output = \n$result" 

   # now test if his jobs are deleted
   if { [ are_jobs_deleted $job_list_user2] != 0 } {
      set_error -1 "(1) not all jobs of $CHECK_FIRST_FOREIGN_SYSTEM_USER are deleted"
   } 

   # submit new jobs for user 2
   set job_list_user2 [submit_testjobs $CHECK_FIRST_FOREIGN_SYSTEM_USER]
   puts $CHECK_OUTPUT "user 2 has jobs $job_list_user2"
   set all_jobs "$job_list_user1 $job_list_user2 $job_list_user3"



   # now delete all jobs as user 2
   set result [ run_command_as_user "$CHECK_HOST" "$CHECK_FIRST_FOREIGN_SYSTEM_USER" "qdel" "-u $CHECK_FIRST_FOREIGN_SYSTEM_USER,$CHECK_USER,$CHECK_SECOND_FOREIGN_SYSTEM_USER" 1 ]
   puts $CHECK_OUTPUT "starting qdel -u $CHECK_FIRST_FOREIGN_SYSTEM_USER,$CHECK_USER,$CHECK_SECOND_FOREIGN_SYSTEM_USER"
   puts $CHECK_OUTPUT "as user $CHECK_FIRST_FOREIGN_SYSTEM_USER"
   puts $CHECK_OUTPUT "qdel_output = \n$result" 

   # now test if his jobs are deleted
   if { [ are_jobs_deleted $job_list_user2] != 0 } {
      set_error -1 "(2) not all jobs of $CHECK_FIRST_FOREIGN_SYSTEM_USER deleted"
   } 
   # now test if the jobs of user1 and user3 are still here
   set all_jobs "$job_list_user1 $job_list_user3"
   puts $CHECK_OUTPUT "following jobs must be in the system: $all_jobs"
   foreach job_id $all_jobs {
          set result [ is_job_running $job_id "qdel_check" ]
          if {$result == -1} {
             puts $CHECK_OUTPUT "job $job_id is not running"
             set_error -1 "(2) jobs of different user deleted" 
          }
   }  

   # submit new jobs for user 2
   set job_list_user2 [submit_testjobs $CHECK_FIRST_FOREIGN_SYSTEM_USER]
   puts $CHECK_OUTPUT "user 2 has jobs $job_list_user2"
   set all_jobs "$job_list_user1 $job_list_user2 $job_list_user3"

   # now delete all jobs as user 1 (manager)
   set result [ catch { 
      eval exec "$CHECK_PRODUCT_ROOT/bin/$CHECK_ARCH/qdel -u $CHECK_FIRST_FOREIGN_SYSTEM_USER,$CHECK_USER,$CHECK_SECOND_FOREIGN_SYSTEM_USER" 
   } qdel_output ] 
   puts $CHECK_OUTPUT "starting qdel -u $CHECK_FIRST_FOREIGN_SYSTEM_USER,$CHECK_USER,$CHECK_SECOND_FOREIGN_SYSTEM_USER"
   puts $CHECK_OUTPUT "qdel_result = $result"
   puts $CHECK_OUTPUT "qdel_output = $qdel_output" 
   if { $result != 0 } {
       set_error -1 "Could not delete jobs $job_list_user1 (exit status: $result)"
   }

   set all_jobs "$job_list_user1 $job_list_user2 $job_list_user3" 

   set mytimeout [ expr ( [timestamp] + 30 ) ]
   set was_error 1
   while { [timestamp] < $mytimeout } {
      if { [ are_jobs_deleted $all_jobs] == 0 } {
         set was_error 0
         break
      } 
   }
   if { $was_error != 0 } {
      set_error -1 "not all jobs are deleted ($all_jobs)"
   } else {
      set_error 0 "no errors"
   }
}

#                                                             max. column:     |
#****** qdel/qdel_force() ******
# 
#  NAME
#     qdel_force -- ??? 
#
#  SYNOPSIS
#     qdel_force { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc qdel_force {} {
   global CHECK_OUTPUT CHECK_USER CHECK_FIRST_FOREIGN_SYSTEM_USER 
   global CHECK_SECOND_FOREIGN_SYSTEM_USER CHECK_PRODUCT_ROOT CHECK_ARCH 
   global CHECK_HOST pending_state CHECK_PRODUCT_TYPE CHECK_HOST CHECK_COMMD_PORT

   if { [have_root_passwd] == -1 } {
      set_error -3 "root access required"
      return
   } 


   # unset ENABLE_FORCED_QDEL with set_config
   get_config change_array 
   puts $CHECK_OUTPUT "qmaster_params=$change_array(qmaster_params)"
   set saved_qmaster_params $change_array(qmaster_params) 
   set change_array(qmaster_params) "none"  
#   set change_array(execd_params) "none"
   set_config change_array
    

   # submit jobs to delete
   set job_list_user1 [submit_testjobs]  
   puts $CHECK_OUTPUT "user 1 has jobs $job_list_user1"

   set job_list_user2 [submit_testjobs $CHECK_FIRST_FOREIGN_SYSTEM_USER]
   puts $CHECK_OUTPUT "user 2 has jobs $job_list_user2"

   # shutdown execd
   catch {exec $CHECK_PRODUCT_ROOT/bin/$CHECK_ARCH/qconf -ke $CHECK_HOST} output
   sleep 2
   puts $output

   # now test if his jobs still running or pending 
   set all_jobs "$job_list_user1 $job_list_user2"
   foreach job_id $all_jobs {
          set result [ is_job_running $job_id "qdel_check" ]
          if {$result == -1} {
             set_error -1 "jobs $all_jobs should still be in the queueing system" 
          }
   }  

   # delete the jobs of user 1 as user 1 without -f switch
   set result [ catch { eval exec "$CHECK_PRODUCT_ROOT/bin/$CHECK_ARCH/qdel $job_list_user1" } qdel_output ] 

   puts $CHECK_OUTPUT "qdel_result = $result"
   puts $CHECK_OUTPUT "qdel_output = $qdel_output"

   if { $result != 0 } {
      set_error -1 "exit state is not 0"
   }    

   # delete the jobs of user 2 as user 2 without -f switch
   set result [ run_command_as_user "$CHECK_HOST" "$CHECK_FIRST_FOREIGN_SYSTEM_USER" "qdel" "$job_list_user2" 1 ]
   puts $CHECK_OUTPUT "qdel_output = \n$result" 


   if { $pending_state == 0} {
      # when jobs were in running state
      puts $CHECK_OUTPUT "running jobs must still be in the queue"
      sleep 10
      # now test if his jobs still running or pending 
      set all_jobs "$job_list_user1 $job_list_user2"
      foreach job_id $all_jobs {
          set result [ is_job_running $job_id "qdel_check" ]
          if {$result == -1} {
             set_error -1 "jobs $all_jobs should still be in the queueing system" 
          }
      }
     
      # now restart execd
      startup_execd $CHECK_HOST
   } 

   # wait for deletion of the jobs
   if { [ are_jobs_deleted $all_jobs] != 0 } {
       set_error -1 "(3) not all jobs of $CHECK_FIRST_FOREIGN_SYSTEM_USER deleted"
   } 

   if {$pending_state != 0} { 

      # now restart execd
      startup_execd $CHECK_HOST
   }
  # ok - qdel without execd is ok, now check the -f option 

   # submit jobs to delete
   set job_list_user1 [submit_testjobs]  
   puts $CHECK_OUTPUT "user 1 has jobs $job_list_user1"

   set job_list_user2 [submit_testjobs $CHECK_FIRST_FOREIGN_SYSTEM_USER]
   puts $CHECK_OUTPUT "user 2 has jobs $job_list_user2"

   # shutdown execd
   catch {exec $CHECK_PRODUCT_ROOT/bin/$CHECK_ARCH/qconf -ke $CHECK_HOST} output
   sleep 2
   puts $output

   # now test if his jobs still running or pending 
   set all_jobs "$job_list_user1 $job_list_user2"
   foreach job_id $all_jobs {
          set result [ is_job_running $job_id "qdel_check" ]
          if {$result == -1} {
             set_error -1 "jobs $all_jobs should still be in the queueing system" 
          }
   }  

   # delete the jobs of user 1 as user 1 with -f switch
   set result [ catch { eval exec "$CHECK_PRODUCT_ROOT/bin/$CHECK_ARCH/qdel -f $job_list_user1" } qdel_output ] 

   puts $CHECK_OUTPUT "qdel_result = $result"
   puts $CHECK_OUTPUT "qdel_output = $qdel_output"

   if { $result != 0 } {
      set_error -1 "exit state is not 0"
   }    

   # delete the jobs of user 2 as user 2 with -f switch
   set result [ run_command_as_user "$CHECK_HOST" "$CHECK_FIRST_FOREIGN_SYSTEM_USER" "qdel" "-f $job_list_user2" 1 ]
   puts $CHECK_OUTPUT "qdel_output = \n$result" 

   # wait for deletion of the jobs of user 1 (manager)
   if { [ are_jobs_deleted $job_list_user1] != 0 } {
       set_error -1 "(4) not all jobs of $CHECK_FIRST_FOREIGN_SYSTEM_USER deleted"
   } 

   if {$pending_state != 0} {
      # wait for deletion of the jobs of user 2 (submit user)
      if { [ are_jobs_deleted $job_list_user2] != 0 } {
          set_error -1 "(5) not all jobs of $CHECK_FIRST_FOREIGN_SYSTEM_USER deleted"
      }  
   } else {
      puts $CHECK_OUTPUT "running jobs of user $CHECK_FIRST_FOREIGN_SYSTEM_USER must still be in the queue"
      sleep 10
      # if jobs were running the submituser (user2) can't use the force flag!   
      # now test if his jobs still running or pending 
      foreach job_id $job_list_user2 {
          set result [ is_job_running $job_id "qdel_check" ]
          if {$result == -1} {
             set_error -1 "jobs $all_jobs should still be in the queueing system" 
          }
      }
      
      # set ENABLE_FORCED_QDEL with set_config
      set change_array(qmaster_params) "ENABLE_FORCED_QDEL" 
      set_config change_array          
      puts $CHECK_OUTPUT "qmaster_params set to $change_array(qmaster_params)"

      # delete the jobs of user 2 as user 2 with -f switch
      set result [ run_command_as_user "$CHECK_HOST" "$CHECK_FIRST_FOREIGN_SYSTEM_USER" "qdel" "-f $job_list_user2" 1 ]
      puts $CHECK_OUTPUT "qdel_output = \n$result" 

      # wait for deletion of the jobs of user 2 (submit user) (now it must go)
      if { [ are_jobs_deleted $job_list_user2] != 0 } {
          set_error -1 "(6) not all jobs of $CHECK_FIRST_FOREIGN_SYSTEM_USER deleted (ENABLE_FORCED_QDEL is not working)"
      }  

   } 

   set change_array(qmaster_params) $saved_qmaster_params
   set_config change_array 
   puts $CHECK_OUTPUT "qmaster_params set to $change_array(qmaster_params)"

   # now restart execd
   startup_execd $CHECK_HOST
   wait_for_load_from_all_queues 300

   set_error 0 "no errors"
}


# ------------------------------------------
























