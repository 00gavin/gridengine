#!/vol2/TCL_TK/glinux/bin/expect
#___INFO__MARK_BEGIN__
##########################################################################
#
#  The Contents of this file are made available subject to the terms of
#  the Sun Industry Standards Source License Version 1.2
#
#  Sun Microsystems Inc., March, 2001
#
#
#  Sun Industry Standards Source License Version 1.2
#  =================================================
#  The contents of this file are subject to the Sun Industry Standards
#  Source License Version 1.2 (the "License"); You may not use this file
#  except in compliance with the License. You may obtain a copy of the
#  License at http://gridengine.sunsource.net/Gridengine_SISSL_license.html
#
#  Software provided under this License is provided on an "AS IS" basis,
#  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
#  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
#  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
#  See the License for the specific provisions governing your rights and
#  obligations concerning the Software.
#
#  The Initial Developer of the Original Code is: Sun Microsystems, Inc.
#
#  Copyright: 2001 by Sun Microsystems, Inc.
#
#  All Rights Reserved.
#
##########################################################################
#___INFO__MARK_END__

# Define the global veriables to give them back
global check_name check_description check_needs check_functions check_errno check_errstr 
global check_category
global check_highest_level check_init_level_procedure
global CHECK_CORE_EXECD
global check_root_access_needs

# some parameters to huge_script test
global HUGE_SCRIPT_SIZE HUGE_SCRIPT_PATTERN HUGE_SCRIPT_TIMEOUT
global HUGE_SCRIPT_STEPS HUGE_SCRIPT_MAX_SIZE

set check_root_access_needs "yes"

set HUGE_SCRIPT_MIN_SIZE 0
set HUGE_SCRIPT_MAX_SIZE [expr 16 * 1024 * 1024]
set HUGE_SCRIPT_STEPS    100
set HUGE_SCRIPT_TIMEOUT  1000
set HUGE_SCRIPT_PATTERN  "generated huge script file for testsuite, 100 characters per line .............................. end"

# setup check's highest level

set check_highest_level [llength $CHECK_CORE_EXECD]
incr check_highest_level -1

# set description for each level
for {set i 0} { $i <= $check_highest_level } { incr i} {
   set check_description($i)  "check every option for queue [lindex $CHECK_CORE_EXECD $i].q" 
}

set check_init_level_procedure "select_queue"
set check_name         "qsub"
set check_category     "COMPATIBILITY SYSTEM L10N"
set check_needs        "init_core_system"       ;# dependencies of this check (name of other check)
set check_functions    ""
lappend check_functions "check_setup_config"
lappend check_functions "check_submit"
lappend check_functions "qsub_starter_method"
lappend check_functions "check_start_time"  
lappend check_functions "check_hold"           
# lappend check_functions "check_deadline" 
lappend check_functions "check_option_ac"
lappend check_functions "check_option_A"
lappend check_functions "check_option_clear"
lappend check_functions "check_option_c"
lappend check_functions "check_option_ckpt"
lappend check_functions "check_option_cwd"
lappend check_functions "check_option_C"
lappend check_functions "check_option_dc"
lappend check_functions "check_option_e"
lappend check_functions "check_option_hard"
lappend check_functions "check_option_help"
lappend check_functions "check_option_hold_jid"
lappend check_functions "check_option_j_y"
lappend check_functions "check_option_j_n"
lappend check_functions "check_option_l"
lappend check_functions "check_option_m"
lappend check_functions "check_option_notify"
lappend check_functions "check_option_now_yes"
lappend check_functions "check_option_now_no"
lappend check_functions "check_option_M"
lappend check_functions "check_option_N"
lappend check_functions "check_option_o"
lappend check_functions "check_option_P"
lappend check_functions "check_option_p"
lappend check_functions "check_option_pe"
lappend check_functions "check_option_q"
lappend check_functions "check_option_qs_args"
lappend check_functions "check_option_r_y"
lappend check_functions "check_option_r_n"
lappend check_functions "check_option_sc"
lappend check_functions "check_option_soft"
lappend check_functions "check_option_S"
lappend check_functions "check_option_t"
lappend check_functions "check_option_v"
lappend check_functions "check_option_verify"
lappend check_functions "check_option_V"
lappend check_functions "check_option_w"
lappend check_functions "check_option_@"
lappend check_functions "check_huge_script"
lappend check_functions "check_qhold_jobname"
lappend check_functions "check_cleanup_config"


# test specific globals:
global job_output_dir
global actual_queue
set job_output_dir "."


#                                                             max. column:     |
#****** qsub/select_queue() ******
# 
#  NAME
#     select_queue -- ??? 
#
#  SYNOPSIS
#     select_queue { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc select_queue {} {
   global actual_queue CHECK_ACT_LEVEL CHECK_CORE_EXECD
   global HUGE_SCRIPT_SIZE HUGE_SCRIPT_TIMEOUT HUGE_SCRIPT_STEPS steps_per_queue size_interval
   global HUGE_SCRIPT_MAX_SIZE 

   set num_queues [llength $CHECK_CORE_EXECD] 

   # setup huge_script test
   set steps_per_queue [expr $HUGE_SCRIPT_STEPS / $num_queues]
   if {[expr $steps_per_queue * $num_queues] < $HUGE_SCRIPT_STEPS} {
      incr steps_per_queue
   } 
   set steps_total [expr $steps_per_queue * $num_queues]
   set size_interval [expr $HUGE_SCRIPT_MAX_SIZE / $steps_total]
   
   if { $CHECK_ACT_LEVEL < $num_queues } {
     
      set actual_queue "[lindex $CHECK_CORE_EXECD $CHECK_ACT_LEVEL].q" 
      return 0
   } 
   return -1 
}

#                                                             max. column:     |
#****** qsub/check_submit() ******
# 
#  NAME
#     check_submit -- ??? 
#
#  SYNOPSIS
#     check_submit { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc check_submit {} {
   global CHECK_PRODUCT_ROOT CHECK_ARCH CHECK_HOST CHECK_CORE_EXECD
   global check_errno job_output_dir actual_queue
   global check_errstr CHECK_OUTPUT


   # first clean up output directory:  
   setup_output_directory
  

   foreach host $CHECK_CORE_EXECD {
     set jobargs "-q ${actual_queue} -o $job_output_dir -e $job_output_dir $CHECK_PRODUCT_ROOT/examples/jobs/sleeper.sh 5" 
     set result [submit_job $jobargs 1 30 $host] 

     if {$result < 0} {
        set_error -1 "could not submit job on host $host to queue $actual_queue"
     }
     # Wait job to run and for end of job
     set back [ wait_for_jobstart $result "leeper" 300 ]
     if { $back != 0 } {
        set_error -1 "job $result doesn't start"
     }

     # Wait for end of job
     set back [ wait_for_jobend $result "leeper" 300 ]
     if { $back != 0 } {
        set_error -1 "job $result doesn't stop"
     } 
     set back [ del_job_files $result $job_output_dir 2 ]
     if { $back != 2 } {
        set_error -1 "job $result did not produce error and output file\njobargs: $jobargs"
     }
   }
   set_error 0 "no errors"
}


proc qsub_starter_method {} {
   global CHECK_PRODUCT_ROOT CHECK_ARCH CHECK_HOST CHECK_CORE_EXECD
   global check_errno job_output_dir
   global check_errstr CHECK_OUTPUT CHECK_ACTUAL_TEST_PATH
   global actual_queue


   # first clean up output directory:  
   setup_output_directory
  

   # set starter method
   set change_array(starter_method) "$CHECK_ACTUAL_TEST_PATH/starter.sh"
   set_queue $actual_queue change_array

   set jobargs "-q ${actual_queue} -o $job_output_dir -e $job_output_dir $CHECK_PRODUCT_ROOT/examples/jobs/sleeper.sh 5" 
   set result [submit_job $jobargs] 

   if {$result < 0} {
      set_error -1 "could not submit job: $jobargs"
   }
   # Wait job to run and for end of job
   set back [ wait_for_jobstart $result "leeper" 300 ]
   if { $back != 0 } {
      set_error -1 "job $result doesn't start"
   }

   # Wait for end of job
   set back [ wait_for_jobend $result "leeper" 300 ]
   if { $back != 0 } {
      set_error -1 "job $result doesn't stop"
   }

   # check output file, should contain output from starter method
   sleep 2
   set outfilename "$job_output_dir/Sleeper.o$result"
   puts $CHECK_OUTPUT "checking output file $outfilename"

   if { ![file exists $outfilename]} {
    add_proc_error "qsub_starter_method" -1 "output file for job $result in queue $actual_queue does not exist"
   } else {
      set f [open $outfilename r]
      set ok 0
      set num_lines 0
      while {[gets $f line] >= 0} {
       incr num_lines
       puts $CHECK_OUTPUT $line
        if {[string compare $line "starter method started"] == 0} {
          set ok 1
          break
        }
      }
      if {$num_lines == 0} {
        add_proc_error "qsub_starter_method" -1 "error reading from job output file for job $result in queue $actual_queue"
      } else {
        if {$ok == 0} {
          add_proc_error "qsub_starter_method" -1 "starter method was not started for job $result in queue $actual_queue"
        }
      }  
      close $f
   }   

   set back [ del_job_files $result $job_output_dir 2 ]
   if { $back != 2 } {
      set_error -1 "job $result did not produce error and output file\njobargs: $jobargs"
   }

   # unset starter method
   set change_array(starter_method) "none"
   set_queue $actual_queue change_array

   set_error 0 "no errors"
}



#                                                             max. column:     |
#****** qsub/setup_output_directory() ******
# 
#  NAME
#     setup_output_directory -- ??? 
#
#  SYNOPSIS
#     setup_output_directory { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc setup_output_directory {} {

   global CHECK_JOB_OUTPUT_DIR CHECK_OUTPUT job_output_dir 
   
   set files_deleted 0
   set job_output_dir "$CHECK_JOB_OUTPUT_DIR"
   if {[file isdirectory "$job_output_dir"] != 1} {
      file mkdir "$job_output_dir"
      puts $CHECK_OUTPUT "new output directory \"$job_output_dir\" generated!"
   } else {
      if { [ string length $job_output_dir  ] > 5 } {
         puts $CHECK_OUTPUT "deleting all files in output directory \"$job_output_dir\"!"
         set files [ glob -nocomplain $job_output_dir/* ]
         foreach elem $files {
             puts $CHECK_OUTPUT $elem
             if { [ file isfile $elem ] == 1 } {
                puts $CHECK_OUTPUT "deleting file $elem"
                incr files_deleted
                delete_file $elem
             } 
         }
      } else {
         set_error -1 "job output dir path must at least have 5 characters"
      }
   }
   sleep 3
   set_error "0" "deleted $files_deleted files"
   return $files_deleted 
}



#                                                             max. column:     |
#****** qsub/check_hold() ******
# 
#  NAME
#     check_hold -- ??? 
#
#  SYNOPSIS
#     check_hold { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc check_hold {} {
   
   global check_errno CHECK_PRODUCT_ROOT CHECK_ARCH CHECK_OUTPUT CHECK_HOST job_output_dir actual_queue
 
   # first clean up output directory:  
   setup_output_directory

   set jobargs "-h -l q=${actual_queue} -o $job_output_dir -e $job_output_dir $CHECK_PRODUCT_ROOT/examples/jobs/sleeper.sh 30" 
   set result [submit_job $jobargs] 
 
   # wait for job to get in pending state 
   if { [wait_for_jobpending $result "leeper" 200] != 0 } {
      set_error -1 "job $result is not in pending state"
      return
   } 

   puts $CHECK_OUTPUT "check_hold - set hold for job $result, job should not start"

   # job should not run within the next 2 minutes 
   if { [wait_for_jobstart $result "leeper" 120 0] != -1 } {
      set_error -1 "job $result should not run until yet"
      return 
   } 

   # release job 
   puts $CHECK_OUTPUT "check_hold - ok now we release the job"
   release_job $result

   # wait for job to start
   if { [wait_for_jobstart $result "leeper" 300] == -1 } {
      set_error -1 "check_hold - job $result doesn't start"
      return 
   } 
 
   # wait for end of job
   if { [wait_for_jobend $result "leeper" 300] == -1 } {
      set_error -1 "check_hold - job $result doesn't stop"
      return 
   } 
   

   set back [ del_job_files $result $job_output_dir 2 ] 
   if { $back != 2 } {
      set_error -1 "job $result did not produce error and output file\njobargs: $jobargs"
   }

   set_error 0 "no errors"
}

proc check_qhold_jobname {} {
 global check_errno CHECK_PRODUCT_ROOT CHECK_ARCH CHECK_OUTPUT CHECK_HOST job_output_dir actual_queue
 global CHECK_FIRST_FOREIGN_SYSTEM_USER

   # first clean up output directory:  
   setup_output_directory

   set jobargs "-h -l q=${actual_queue} -N FIRST -o $job_output_dir -e $job_output_dir $CHECK_PRODUCT_ROOT/examples/jobs/sleeper.sh 90" 
   set hold_job1 [submit_job $jobargs] 

   set jobargs "-hold_jid FIRST -l q=${actual_queue} -o $job_output_dir -e $job_output_dir $CHECK_PRODUCT_ROOT/examples/jobs/sleeper.sh 30" 
   set hold_job2 [submit_job $jobargs] 



   # wait for jobs to get in pending state
   wait_for_jobpending $hold_job1 "FIRST" 200
   wait_for_jobpending $hold_job2 "Sleeper" 200 



   # job 1 should not run within the next 60 seconds  
   if { [wait_for_jobstart $hold_job1 "Sleeper" 60 0] != -1 } {
      add_proc_error "check_qhold_jobname" -1 "job $hold_job1 should not run until yet(1)"
   } 


   # release job 1
   release_job $hold_job1 
   wait_for_jobstart $hold_job1 "FIRST" 100




   # job 2 should not run within the next minute 
   if { [wait_for_jobstart $hold_job2 "Sleeper" 60 0] != -1 } {
      add_proc_error "check_qhold_jobname" -1 "job $hold_job2 should not run until yet(2)"
   } 


   

   # job1 will stop in ca. 30 sec
   wait_for_jobend $hold_job1 "FIRST" 100
   
   # job2 should run now
   wait_for_jobstart $hold_job2 "Sleeper" 100

   # job2 should run till end
   wait_for_jobend $hold_job2 "Sleeper" 100 




   set back [ del_job_files $hold_job1 $job_output_dir 2 ] 
   if { $back != 2 } {
      add_proc_error "check_qhold_jobname" -1 "job $hold_job1 did not produce error and output file"
   }

   set back [ del_job_files $hold_job2 $job_output_dir 2 ] 
   if { $back != 2 } {
      add_proc_error "check_qhold_jobname" -1 "job $hold_job2 did not produce error and output file"
   }


   

   puts $CHECK_OUTPUT "Test wait for not existant job (job should immediately run)"
   set jobargs "-hold_jid FIRST -l q=${actual_queue} -o /dev/null -e /dev/null $CHECK_PRODUCT_ROOT/examples/jobs/sleeper.sh 30" 
   set job_id [submit_job $jobargs] 
   wait_for_jobstart $job_id "Sleeper" 60
   wait_for_jobend $job_id "Sleeper" 60



   puts $CHECK_OUTPUT "additional job submit with same name test"
   set jobargs "-h -l q=${actual_queue} -N FIRST -o /dev/null -e /dev/null $CHECK_PRODUCT_ROOT/examples/jobs/sleeper.sh 30" 
   set hold_job1 [submit_job $jobargs] 

   puts $CHECK_OUTPUT "additional job submit with same name test"
   set jobargs "-h -l q=${actual_queue} -N FIRST -o /dev/null -e /dev/null $CHECK_PRODUCT_ROOT/examples/jobs/sleeper.sh 30" 
   set hold_job2 [submit_job $jobargs] 


   wait_for_jobpending $hold_job1 "FIRST" 60
   wait_for_jobpending $hold_job2 "FIRST" 60

   set jobargs "-hold_jid FIRST -l q=${actual_queue} -o /dev/null -e /dev/null $CHECK_PRODUCT_ROOT/examples/jobs/sleeper.sh 30" 
   set hold_job3 [submit_job $jobargs 0]
   if { $hold_job3 != -14 } {
      add_proc_error "check_qhold_jobname" -1 "job $hold_job3 should produce non-ambiguous error"
   } else {
      puts $CHECK_OUTPUT "got non-ambiguous error: $hold_job3 - correct"
   } 
    
   delete_job $hold_job1



   puts $CHECK_OUTPUT "submitting hold job ..."
   set jobargs "-hold_jid FIRST -l q=${actual_queue} -o /dev/null -e /dev/null $CHECK_PRODUCT_ROOT/examples/jobs/sleeper.sh 30" 
   set hold_job3 [submit_job $jobargs]
    

   puts $CHECK_OUTPUT "submitting job with same name (FIRST) ..."
   set jobargs "-h -l q=${actual_queue} -N FIRST -o /dev/null -e /dev/null $CHECK_PRODUCT_ROOT/examples/jobs/sleeper.sh 30" 
   puts $CHECK_OUTPUT $jobargs
   set hold_job1 [submit_job $jobargs 0] 
   if { $hold_job1 != -15 } {
      add_proc_error "check_qhold_jobname" -1 "job $hold_job1 should produce violates reference unambiguousness error"
   } else {
      puts $CHECK_OUTPUT "got violates reference unambiguousness error: $hold_job1 - correct"
   } 


   puts $CHECK_OUTPUT "submitting job with same name (FIRST) as user $CHECK_FIRST_FOREIGN_SYSTEM_USER ..."
   set jobargs "-h -l q=${actual_queue} -N FIRST -o /dev/null -e /dev/null $CHECK_PRODUCT_ROOT/examples/jobs/sleeper.sh 30" 
   puts $CHECK_OUTPUT $jobargs
   set hold_job1 [submit_job $jobargs 1 30 "" $CHECK_FIRST_FOREIGN_SYSTEM_USER ] 

   release_job $hold_job1
   wait_for_jobstart $hold_job1 "FIRST" 75
   wait_for_jobend $hold_job1 "FIRST" 75

   delete_job $hold_job2
 
   wait_for_jobstart $hold_job3 "Sleeper" 75
   wait_for_jobend $hold_job3 "Sleeper" 75



   # test foreign user influence ...
   puts $CHECK_OUTPUT "checking hold for foreign user ..."

   puts $CHECK_OUTPUT "submitting job with same name (FIRST) as user $CHECK_FIRST_FOREIGN_SYSTEM_USER ..."
   set jobargs "-h -l q=${actual_queue} -N FIRST -o /dev/null -e /dev/null $CHECK_PRODUCT_ROOT/examples/jobs/sleeper.sh 30" 
   puts $CHECK_OUTPUT $jobargs
   set hold_job1 [submit_job $jobargs 1 30 "" $CHECK_FIRST_FOREIGN_SYSTEM_USER ] 

   puts $CHECK_OUTPUT "submitting hold job ..."
   set jobargs "-hold_jid FIRST -l q=${actual_queue} -o /dev/null -e /dev/null $CHECK_PRODUCT_ROOT/examples/jobs/sleeper.sh 30" 
   set hold_job3 [submit_job $jobargs]

   wait_for_jobstart $hold_job3 "Sleeper" 75
   wait_for_jobend $hold_job3 "Sleeper" 75



   puts $CHECK_OUTPUT "additional job submit with same name test"
   set jobargs "-h -l q=${actual_queue} -N FIRST -o /dev/null -e /dev/null $CHECK_PRODUCT_ROOT/examples/jobs/sleeper.sh 30" 
   set hold_job2 [submit_job $jobargs] 


   puts $CHECK_OUTPUT "submitting hold job ..."
   set jobargs "-hold_jid FIRST -l q=${actual_queue} -o /dev/null -e /dev/null $CHECK_PRODUCT_ROOT/examples/jobs/sleeper.sh 30" 
   set hold_job3 [submit_job $jobargs]

   if { [wait_for_jobstart $hold_job3 "Sleeper" 60 0] != -1 } {
      add_proc_error "check_qhold_jobname" -1 "job $hold_job3 should not run until yet(3)"
   } 


   delete_job $hold_job3
   delete_job $hold_job2
   
   release_job $hold_job1
   wait_for_jobstart $hold_job1 "FIRST" 60
   wait_for_jobend $hold_job1 "FIRST" 60

   puts $CHECK_OUTPUT "done."   

   set_error 0 "no errors"
}

#                                                             max. column:     |
#****** qsub/check_start_time() ******
# 
#  NAME
#     check_start_time -- ??? 
#
#  SYNOPSIS
#     check_start_time { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc check_start_time {} {
   global CHECK_PRODUCT_ROOT CHECK_ARCH CHECK_HOST CHECK_CORE_EXECD
   global check_errno job_output_dir
   global check_errstr CHECK_OUTPUT actual_queue

   # first clean up output directory:  
   setup_output_directory
   
   set hour [exec date "+%H"]
   set minute [exec date "+%M"]

   if { [string first "0" $hour] == 0 } {
      set hour [string index $hour 1 ]
   }  
   if { [string first "0" $minute] == 0 } {
      set minute [string index $minute 1 ]
   }  

   if {$minute < 58 } {
     set minute [expr ($minute + 2) ]
   } else {
     set minute [expr ($minute + 2 - 60) ]
 
     if {$hour < 23 } {
        set hour [expr ($hour + 1) ]
     } else {
        set hour "00"
     }
   }

   set rhour $hour
   set rminute $minute

   if {$hour < 10} {
     set rhour "0$hour"
   }
   if {$minute < 10} {
     set rminute "0$minute"
   }
   
   set start "[exec date +\%Y\%m\%d]$rhour$rminute"

   set jobargs "-a $start -l q=${actual_queue} -o $job_output_dir -e $job_output_dir $CHECK_PRODUCT_ROOT/examples/jobs/sleeper.sh 60" 

   set time [timestamp]
   set seconds [exec date "+%S"]
   if { [string first "0" $seconds] == 0 } {
      set seconds [string index $seconds 1 ]
   }     

   # submit job
   set result [submit_job $jobargs] 

   # wait for job to get in pending state
   if { [wait_for_jobpending $result "leeper" 200] != 0 } {
      set_error -1 "job $result is not in pending state"
   } 
   
   # calulate time until job should run
   set pend_time [expr ( [timestamp] - $time )]
   set wait_time [expr ( 120 - $pend_time - $seconds - 10 ) ] ;# 10 seconds are ok  
   puts $CHECK_OUTPUT "check_start_time - job should not start the next $wait_time seconds"
   set time [timestamp]
   if { [wait_for_jobstart $result "leeper" $wait_time 0] != -1 } {
      puts $CHECK_OUTPUT "check_start_time - time left: [expr ($wait_time - [expr ( [timestamp] - $time)] ) ]"
      set_error -1 "check_start_time - job $result should not run until yet"
      return
   } 


   # wait for job to start
   puts $CHECK_OUTPUT "check_start_time - ok now the job should start"
   if { [wait_for_jobstart $result "leeper" 300] == -1 } {
      set_error -1 "check_start_time - job $result doesn't start"
      return 
   } 
 
   # wait for end of job
   if { [wait_for_jobend $result "leeper" 300] == -1 } {
      set_error -1 "check_start_time - job $result doesn't stop"
      return 
   } 
  

   set back [ del_job_files $result $job_output_dir 2 ] 
   if { $back != 2 } {
      set_error -1 "job $result did not produce error and output file\njobargs: $jobargs"
   }
   set_error 0 "no errors"
}



#                                                             max. column:     |
#****** qsub/check_deadline() ******
# 
#  NAME
#     check_deadline -- ??? 
#
#  SYNOPSIS
#     check_deadline { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc check_deadline {} {
   global CHECK_PRODUCT_ROOT CHECK_ARCH CHECK_HOST CHECK_CORE_EXECD CHECK_PRODUCT_TYPE
   global check_errno CHECK_JOB_OUTPUT_DIR actual_queue
   global check_errstr CHECK_OUTPUT job_output_dir

   if { [ string compare $CHECK_PRODUCT_TYPE "sge" ] == 0 } {
      set_error 0 "not possible for sge system"   
      return
   }

   set job_output_dir "$CHECK_JOB_OUTPUT_DIR"

   # Wait for zero deadlinejobs
   set nub_deadline_jobs 1
   while { $nub_deadline_jobs != 0 } {
      set nub_deadline_jobs 0 
      set job_list [ get_job_info -1 ]
      foreach line $job_list { 
        if { [ lindex $line 17 ] > 0 } {
            incr nub_deadline_jobs 
        }  
      }
      puts $CHECK_OUTPUT "waiting for zero deadline job count"
      sleep 1
   }

   # get current hour
   set hour [exec date "+%H"]
   if { [string first "0" $hour] == 0 } {
      set hour [string index $hour 1 ]
   }  

   # get current minute
   set minute [exec date "+%M"]
   if { [string first "0" $minute] == 0 } {
      set minute [string index $minute 1 ]
   }  


   # add 5 minutes
   set future_time 5

   if {$minute < [expr (60 - $future_time )] } {
     set minute [expr ($minute + $future_time) ]
   } else {
     set minute [expr ($minute + $future_time - 60) ]
 
     if {$hour < 23 } {
        set hour [expr ($hour + 1) ]
     } else {
        set hour "0"
     }
   }

   # use rhour and rminute for command string
   set rhour $hour
   set rminute $minute
   if {$hour < 10} {
     set rhour "0$hour"
   }
   if {$minute < 10} {
     set rminute "0$minute"
   }
  
   # finally get command option string 
   set deadline "[exec date +\%Y\%m\%d]$rhour$rminute"

   # deadline job (10 min) with deadline in 5 minutes
   set jobargs "-dl $deadline -l q=${actual_queue} -o $job_output_dir -e $job_output_dir $CHECK_PRODUCT_ROOT/examples/jobs/sleeper.sh 500" 
   # start job
   set result [submit_job $jobargs] 
   if {$result < 0 } {
      set_error -1 "could not submit job"
      return
   }


   # now job is in queueing system (get timestamp now)
   set time [timestamp]

   # look if only one job is running
   # if not delete the hob with higher jobid 
   set nub_deadline_jobs 0
   while { $nub_deadline_jobs != 1 } {
      sleep 2
      set nub_deadline_jobs 0 
      set job_list [ get_job_info -1 ]
      foreach line $job_list { 
        if { [ lindex $line 17 ] > 0 } {
            incr nub_deadline_jobs
            if {$nub_deadline_jobs > 1} {
               catch { exec $CHECK_PRODUCT_ROOT/bin/$CHECK_ARCH/qdel [lindex $line 0] }
               puts $CHECK_OUTPUT "check_deadline - delete job [lindex $line 0] "
               # retry if deleted job is from me
               if { $result == [lindex $line 0] } {
                  check_deadline
                  return
               }
            } 
        }  
      }
      
      puts $CHECK_OUTPUT "check_deadline - waiting for 1 deadline job (current count: $nub_deadline_jobs)"
   }
  
   puts $CHECK_OUTPUT "looking for job id $result"
   
   set old_tickets 0
   set deadl_jobs 1
   while {1} {
      set nub_deadline_jobs 0
      set job_tickets 0
      set job_info "none"
      set run_time [ expr ( [timestamp] - $time ) ]
      set job_list [ get_job_info -1 ]
      set found 0
      foreach line $job_list { 
         if { [lindex $line 0] == $result } {
            set job_info $line
            set job_tickets [ lindex $line 17 ]
            set found 1
         } 
         if { [ lindex $line 17 ] > 0 } {
            incr nub_deadline_jobs 
         } 
      }     
      
      if { ([was_job_running $result 0] != -1) } {
         set_error 0 "check_deadline - no errors"
         set back [ del_job_files $result $job_output_dir 2 ] 
         if { $back != 2 } {
            set_error -1 "job $result did not produce error and output file"
         }
         return
      }       
 
      if { $found == 0 } {
         continue
      }

      if { $job_tickets == 0 } {
         incr nub_deadline_jobs 1  
      } 
      set max_tickets 10000
      if { $nub_deadline_jobs > 1 } {
         set max_tickets [ expr ($max_tickets / $nub_deadline_jobs) ]
      }      

      puts $CHECK_OUTPUT "runtime: $run_time"
      puts $CHECK_OUTPUT "number of deadline jobs: $nub_deadline_jobs"
      puts $CHECK_OUTPUT "current tickets: $job_tickets"
 
      if { $deadl_jobs != $nub_deadline_jobs} {
         puts $CHECK_OUTPUT "deadline job count canched - can't use this run"
         set deadl_jobs $nub_deadline_jobs
      } else {
         # use dlcontr in case of 6.0
         if { ($run_time < 90) && ($job_tickets > [expr ($max_tickets / 2) ]  ) } {
            set_error -1 "check_deadline - job shouldn't have so much tickets until yet"
            return 
         }
         
         if { ($run_time > 200) && ($job_tickets < [expr ($max_tickets / 2) ] ) } {
            set_error -1 "check_deadline - job should have more tickets at this point of time"  
            return 
         }

         if { ($run_time > 400) && ($job_tickets < $max_tickets ) } {
            set_error -1 "check_deadline - job should have all tickets now"
            return   
         }
          
      }

      puts $CHECK_OUTPUT "$job_info"
      set old_tickets $job_tickets

      sleep 15
   }
   set back [ del_job_files $result $job_output_dir  2 ] 
   if { $back != 2 } {
      set_error -1 "job $result did not produce error and output file"
   }
}

#                                                             max. column:     |
#****** qsub/check_option_ac() ******
# 
#  NAME
#     check_option_ac -- ??? 
#
#  SYNOPSIS
#     check_option_ac { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc check_option_ac {} {

   global job_output_dir CHECK_PRODUCT_ROOT CHECK_OUTPUT CHECK_HOST actual_queue

   # first clean up output directory:  
   setup_output_directory

   set option "-ac myvar=test -ac myvar2=test2"
   set jobargs "$option -l q=${actual_queue} -o $job_output_dir -e $job_output_dir $CHECK_PRODUCT_ROOT/examples/jobs/sleeper.sh 5" 
  
   set result [submit_job $jobargs 0]  
   puts $CHECK_OUTPUT "\njob $result has args: \"$jobargs\""

   if { $result < 0 } {
      set_error -1 "could not submit job"
      return
   }

   set time [ expr ( [timestamp] + 300  ) ] 

   while { [timestamp] < $time }  {
      sleep 1
      set back [was_job_running $result 0] 
      if {$back != -1} {
         set back [ del_job_files $result $job_output_dir 2 ] 
         if { $back != 2 } {
            set_error -1 "job $result did not produce error and output file\njobargs: $jobargs"
            return
         } else {
            set_error 0 "no error"
            return
         }
      }
   }
 
   set_error -1 "timeout while waiting for job accounting"
}


#                                                             max. column:     |
#****** qsub/check_option_A() ******
# 
#  NAME
#     check_option_A -- ??? 
#
#  SYNOPSIS
#     check_option_A { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc check_option_A {} {

   global job_output_dir CHECK_PRODUCT_ROOT CHECK_OUTPUT CHECK_HOST actual_queue

   # first clean up output directory:  
   setup_output_directory

   set option "-A blahblah"
   set jobargs "$option -l q=${actual_queue} -o $job_output_dir -e $job_output_dir $CHECK_PRODUCT_ROOT/examples/jobs/sleeper.sh 5" 
  
   set result [submit_job $jobargs 0]  
   puts $CHECK_OUTPUT "\njob $result has args: \"$jobargs\""

   if { $result < 0 } {
      set_error -1 "could not submit job"
      return
   }

   set time [ expr ( [timestamp] + 300  ) ] 

   while { [timestamp] < $time }  {
      sleep 1
      set back [was_job_running $result 0] 
      if {$back != -1} {
         set back [ del_job_files $result $job_output_dir 2 ] 
         if { $back != 2 } {
            set_error -1 "job $result did not produce error and output file\njobargs: $jobargs"
            return
         } else {
            set_error 0 "no error"
            return
         }
      }
   }
 
   set_error -1 "timeout while waiting for job accounting"
}


#                                                             max. column:     |
#****** qsub/check_option_clear() ******
# 
#  NAME
#     check_option_clear -- ??? 
#
#  SYNOPSIS
#     check_option_clear { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc check_option_clear {} {

   global job_output_dir CHECK_PRODUCT_ROOT CHECK_OUTPUT CHECK_HOST actual_queue

   # first clean up output directory:  
   setup_output_directory

   set option "-clear"
   set jobargs "$option -l q=${actual_queue} -o $job_output_dir -e $job_output_dir $CHECK_PRODUCT_ROOT/examples/jobs/sleeper.sh 5" 
  
   set result [submit_job $jobargs 0]  
   puts $CHECK_OUTPUT "\njob $result has args: \"$jobargs\""

   if { $result < 0 } {
      set_error -1 "could not submit job"
      return
   }

   set time [ expr ( [timestamp] + 300  ) ] 

   while { [timestamp] < $time }  {
      sleep 1
      set back [was_job_running $result 0] 
      if {$back != -1} {
         set back [ del_job_files $result $job_output_dir 2 ] 
         if { $back != 2 } {
            set_error -1 "job $result did not produce error and output file\njobargs: $jobargs"
            return
         } else {
            set_error 0 "no error"
            return
         }
      }
   }
 
   set_error -1 "timeout while waiting for job accounting"
}



#                                                             max. column:     |
#****** qsub/check_option_c() ******
# 
#  NAME
#     check_option_c -- ??? 
#
#  SYNOPSIS
#     check_option_c { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc check_option_c {} {

   global job_output_dir CHECK_PRODUCT_ROOT CHECK_OUTPUT CHECK_HOST actual_queue

   # first clean up output directory:  
   setup_output_directory

   set option "-c n"
   set jobargs "$option -l q=${actual_queue} -o $job_output_dir -e $job_output_dir $CHECK_PRODUCT_ROOT/examples/jobs/sleeper.sh 5" 
  
   set result [submit_job $jobargs 0]  
   puts $CHECK_OUTPUT "\njob $result has args: \"$jobargs\""

   if { $result < 0 } {
      set_error -1 "could not submit job"
      return
   }

   set time [ expr ( [timestamp] + 300  ) ] 

   while { [timestamp] < $time }  {
      sleep 1
      set back [was_job_running $result 0] 
      if {$back != -1} {
         set back [ del_job_files $result $job_output_dir 2 ] 
         if { $back != 2 } {
            set_error -1 "job $result did not produce error and output file\njobargs: $jobargs"
            return
         } else {
            set_error 0 "no error"
            return
         }
      }
   }
 
   set_error -1 "timeout while waiting for job accounting"
}

#                                                             max. column:     |
#****** qsub/check_option_ckpt() ******
# 
#  NAME
#     check_option_ckpt -- ??? 
#
#  SYNOPSIS
#     check_option_ckpt { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc check_option_ckpt {} {

   global job_output_dir CHECK_PRODUCT_ROOT CHECK_OUTPUT CHECK_HOST actual_queue

   # first clean up output directory:  
   setup_output_directory

   set option "-ckpt testcheckpointobject"
   set jobargs "$option -l q=${actual_queue} -o $job_output_dir -e $job_output_dir $CHECK_PRODUCT_ROOT/examples/jobs/sleeper.sh 5" 
  
   set result [submit_job $jobargs 0]  
   puts $CHECK_OUTPUT "\njob $result has args: \"$jobargs\""

   if { $result < 0 } {
      set_error -1 "could not submit job"
      return
   }

   set time [ expr ( [timestamp] + 300  ) ] 

   while { [timestamp] < $time }  {
      sleep 1
      set back [was_job_running $result 0] 
      if {$back != -1} {
         set back [ del_job_files $result $job_output_dir 2 ] 
         if { $back != 2 } {
            set_error -1 "job $result did not produce error and output file\njobargs: $jobargs"
            return
         } else {
            set_error 0 "no error"
            return
         }
      }
   }
 
   set_error -1 "timeout while waiting for job accounting"
}

#                                                             max. column:     |
#****** qsub/check_option_cwd() ******
# 
#  NAME
#     check_option_cwd -- ??? 
#
#  SYNOPSIS
#     check_option_cwd { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc check_option_cwd {} {

   global job_output_dir CHECK_PRODUCT_ROOT CHECK_OUTPUT CHECK_HOST actual_queue

   # first clean up output directory:  
   setup_output_directory

   set option "-cwd"
   set jobargs "$option -l q=${actual_queue} -o $job_output_dir -e $job_output_dir $CHECK_PRODUCT_ROOT/examples/jobs/sleeper.sh 5" 
  
   set result [submit_job $jobargs 0]  
   puts $CHECK_OUTPUT "\njob $result has args: \"$jobargs\""

   if { $result < 0 } {
      set_error -1 "could not submit job"
      return
   }

   set time [ expr ( [timestamp] + 300  ) ] 

   while { [timestamp] < $time }  {
      sleep 1
      set back [was_job_running $result 0] 
      if {$back != -1} {
         set back [ del_job_files $result $job_output_dir 2 ] 
         if { $back != 2 } {
            set_error -1 "job $result did not produce error and output file\njobargs: $jobargs"
            return
         } else {
            set_error 0 "no error"
            return
         }
      }
   }
 
   set_error -1 "timeout while waiting for job accounting"
}

#                                                             max. column:     |
#****** qsub/check_option_C() ******
# 
#  NAME
#     check_option_C -- ??? 
#
#  SYNOPSIS
#     check_option_C { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc check_option_C {} {

   global job_output_dir CHECK_PRODUCT_ROOT CHECK_OUTPUT CHECK_HOST actual_queue

   # first clean up output directory:  
   setup_output_directory

   set option "-C TESTPREFIX"
   set jobargs "$option -l q=${actual_queue} -o $job_output_dir -e $job_output_dir $CHECK_PRODUCT_ROOT/examples/jobs/sleeper.sh 5" 
  
   set result [submit_job $jobargs 0]  
   puts $CHECK_OUTPUT "\njob $result has args: \"$jobargs\""

   if { $result < 0 } {
      set_error -1 "could not submit job"
      return
   }

   set time [ expr ( [timestamp] + 300  ) ] 

   while { [timestamp] < $time }  {
      sleep 1
      set back [was_job_running $result 0] 
      if {$back != -1} {
         set back [ del_job_files $result $job_output_dir 2 ] 
         if { $back != 2 } {
            set_error -1 "job $result did not produce error and output file\njobargs: $jobargs"
            return
         } else {
            set_error 0 "no error"
            return
         }
      }
   }
 
   set_error -1 "timeout while waiting for job accounting"
}

#                                                             max. column:     |
#****** qsub/check_option_dc() ******
# 
#  NAME
#     check_option_dc -- ??? 
#
#  SYNOPSIS
#     check_option_dc { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc check_option_dc {} {

   global job_output_dir CHECK_PRODUCT_ROOT CHECK_OUTPUT CHECK_HOST actual_queue

   # first clean up output directory:  
   setup_output_directory

   set option "-dc myvar,myvar2"
   set jobargs "$option -l q=${actual_queue} -o $job_output_dir -e $job_output_dir $CHECK_PRODUCT_ROOT/examples/jobs/sleeper.sh 5" 
  
   set result [submit_job $jobargs 0]  
   puts $CHECK_OUTPUT "\njob $result has args: \"$jobargs\""

   if { $result < 0 } {
      set_error -1 "could not submit job"
      return
   }

   set time [ expr ( [timestamp] + 300  ) ] 

   while { [timestamp] < $time }  {
      sleep 1
      set back [was_job_running $result 0] 
      if {$back != -1} {
         set back [ del_job_files $result $job_output_dir 2 ] 
         if { $back != 2 } {
            set_error -1 "job $result did not produce error and output file\njobargs: $jobargs"
            return
         } else {
            set_error 0 "no error"
            return
         }
      }
   }
 
   set_error -1 "timeout while waiting for job accounting"
}

#                                                             max. column:     |
#****** qsub/check_option_e() ******
# 
#  NAME
#     check_option_e -- ??? 
#
#  SYNOPSIS
#     check_option_e { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc check_option_e {} {

   global job_output_dir CHECK_PRODUCT_ROOT CHECK_OUTPUT CHECK_HOST actual_queue

   # first clean up output directory:  
   setup_output_directory

   set option ""
   set jobargs "$option -l q=${actual_queue} -o $job_output_dir -e $job_output_dir $CHECK_PRODUCT_ROOT/examples/jobs/sleeper.sh 5" 
  
   set result [submit_job $jobargs 0]  
   puts $CHECK_OUTPUT "\njob $result has args: \"$jobargs\""

   if { $result < 0 } {
      set_error -1 "could not submit job"
      return
   }

   set time [ expr ( [timestamp] + 300  ) ] 

   while { [timestamp] < $time }  {
      sleep 1
      set back [was_job_running $result 0] 
      if {$back != -1} {
         set back [ del_job_files $result $job_output_dir 2 ] 
         if { $back != 2 } {
            set_error -1 "job $result did not produce error and output file\njobargs: $jobargs"
            return
         } else {
            set_error 0 "no error"
            return
         }
      }
   }
 
   set_error -1 "timeout while waiting for job accounting"
}

#                                                             max. column:     |
#****** qsub/check_option_hard() ******
# 
#  NAME
#     check_option_hard -- ??? 
#
#  SYNOPSIS
#     check_option_hard { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc check_option_hard {} {

   global job_output_dir CHECK_PRODUCT_ROOT CHECK_OUTPUT CHECK_HOST actual_queue

   # first clean up output directory:  
   setup_output_directory

   set option "-hard"
   set jobargs "$option -l q=${actual_queue} -o $job_output_dir -e $job_output_dir $CHECK_PRODUCT_ROOT/examples/jobs/sleeper.sh 5" 
  
   set result [submit_job $jobargs 0]  
   puts $CHECK_OUTPUT "\njob $result has args: \"$jobargs\""

   if { $result < 0 } {
      set_error -1 "could not submit job"
      return
   }

   set time [ expr ( [timestamp] + 300  ) ] 

   while { [timestamp] < $time }  {
      sleep 1
      set back [was_job_running $result 0] 
      if {$back != -1} {
         set back [ del_job_files $result $job_output_dir 2 ] 
         if { $back != 2 } {
            set_error -1 "job $result did not produce error and output file\njobargs: $jobargs"
            return
         } else {
            set_error 0 "no error"
            return
         }
      }
   }
 
   set_error -1 "timeout while waiting for job accounting"
}

#                                                             max. column:     |
#****** qsub/check_option_help() ******
# 
#  NAME
#     check_option_help -- ??? 
#
#  SYNOPSIS
#     check_option_help { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc check_option_help {} {

   global job_output_dir CHECK_PRODUCT_ROOT CHECK_OUTPUT CHECK_HOST actual_queue

   # first clean up output directory:  
   setup_output_directory

   set option "-help"
   set jobargs "$option -l q=${actual_queue} -o $job_output_dir -e $job_output_dir $CHECK_PRODUCT_ROOT/examples/jobs/sleeper.sh 5" 
  
   set result [submit_job $jobargs 0] 

   if { $result != -2 } {
      set_error -1 "no help output on -help option"
   }  
 
 
   set_error 0 "no error"
}

#                                                             max. column:     |
#****** qsub/check_option_hold_jid() ******
# 
#  NAME
#     check_option_hold_jid -- ??? 
#
#  SYNOPSIS
#     check_option_hold_jid { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc check_option_hold_jid {} {

   global job_output_dir CHECK_PRODUCT_ROOT CHECK_OUTPUT CHECK_HOST actual_queue

   # first clean up output directory:  
   setup_output_directory

   set option "-hold_jid 1,2,3"
   set jobargs "$option -l q=${actual_queue} -o $job_output_dir -e $job_output_dir $CHECK_PRODUCT_ROOT/examples/jobs/sleeper.sh 5" 
  
   set result [submit_job $jobargs 0]  
   puts $CHECK_OUTPUT "\njob $result has args: \"$jobargs\""

   if { $result < 0 } {
      set_error -1 "could not submit job"
      return
   }

   set time [ expr ( [timestamp] + 300  ) ] 

   while { [timestamp] < $time }  {
      sleep 1
      set back [was_job_running $result 0] 
      if {$back != -1} {
         set back [ del_job_files $result $job_output_dir 2 ] 
         if { $back != 2 } {
            set_error -1 "job $result did not produce error and output file\njobargs: $jobargs"
            return
         } else {
            set_error 0 "no error"
            return
         }
      }
   }
 
   set_error -1 "timeout while waiting for job accounting"
}

#                                                             max. column:     |
#****** qsub/check_option_j_y() ******
# 
#  NAME
#     check_option_j_y -- ??? 
#
#  SYNOPSIS
#     check_option_j_y { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc check_option_j_y {} {

   global job_output_dir CHECK_PRODUCT_ROOT CHECK_OUTPUT CHECK_HOST actual_queue

   # first clean up output directory:  
   setup_output_directory

   set option "-j y"
   set jobargs "$option -l q=${actual_queue} -o $job_output_dir -e $job_output_dir $CHECK_PRODUCT_ROOT/examples/jobs/sleeper.sh 5" 
  
   set result [submit_job $jobargs 0]  
   puts $CHECK_OUTPUT "\njob $result has args: \"$jobargs\""

   if { $result < 0 } {
      set_error -1 "could not submit job"
      return
   }

   set time [ expr ( [timestamp] + 300  ) ] 

   while { [timestamp] < $time }  {
      sleep 1
      set back [was_job_running $result 0] 
      if {$back != -1} {
         set back [ del_job_files $result $job_output_dir 1 ] 
         if { $back != 1 } {
            set_error -1 "job $result did not merge error and output file\njobargs: $jobargs"
            return
         } else {
            set_error 0 "no error"
            return
         }
      }
   }
 
   set_error -1 "timeout while waiting for job accounting"
}

#                                                             max. column:     |
#****** qsub/check_option_j_n() ******
# 
#  NAME
#     check_option_j_n -- ??? 
#
#  SYNOPSIS
#     check_option_j_n { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc check_option_j_n {} {

   global job_output_dir CHECK_PRODUCT_ROOT CHECK_OUTPUT CHECK_HOST actual_queue

   # first clean up output directory:  
   setup_output_directory

   set option "-j n"
   set jobargs "$option -l q=${actual_queue} -o $job_output_dir -e $job_output_dir $CHECK_PRODUCT_ROOT/examples/jobs/sleeper.sh 5" 
  
   set result [submit_job $jobargs 0]  
   puts $CHECK_OUTPUT "\njob $result has args: \"$jobargs\""

   if { $result < 0 } {
      set_error -1 "could not submit job"
      return
   }

   set time [ expr ( [timestamp] + 300  ) ] 

   while { [timestamp] < $time }  {
      sleep 1
      set back [was_job_running $result 0] 
      if {$back != -1} {
         set back [ del_job_files $result $job_output_dir 2 ] 
         if { $back != 2 } {
            set_error -1 "job $result did not produce error and output file\njobargs: $jobargs"
            return
         } else {
            set_error 0 "no error"
            return
         }
      }
   }
 
   set_error -1 "timeout while waiting for job accounting"
}

#                                                             max. column:     |
#****** qsub/check_option_l() ******
# 
#  NAME
#     check_option_l -- ??? 
#
#  SYNOPSIS
#     check_option_l { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc check_option_l {} {

   global job_output_dir CHECK_PRODUCT_ROOT CHECK_OUTPUT CHECK_HOST actual_queue

   # first clean up output directory:  
   setup_output_directory

   set option "-l q=${actual_queue}"
   set jobargs "$option -o $job_output_dir -e $job_output_dir $CHECK_PRODUCT_ROOT/examples/jobs/sleeper.sh 5" 
  
   set result [submit_job $jobargs 0]  
   puts $CHECK_OUTPUT "\njob $result has args: \"$jobargs\""

   if { $result < 0 } {
      set_error -1 "could not submit job"
      return
   }

   set time [ expr ( [timestamp] + 300  ) ] 

   while { [timestamp] < $time }  {
      sleep 1
      set back [was_job_running $result 0] 
      if {$back != -1} {
         set back [ del_job_files $result $job_output_dir 2 ] 
         if { $back != 2 } {
            set_error -1 "job $result did not produce error and output file\njobargs: $jobargs"
            return
         } else {
            set_error 0 "no error"
            return
         }
      }
   }
 
   set_error -1 "timeout while waiting for job accounting"
}

#                                                             max. column:     |
#****** qsub/check_option_m() ******
# 
#  NAME
#     check_option_m -- ??? 
#
#  SYNOPSIS
#     check_option_m { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc check_option_m {} {

   global job_output_dir CHECK_PRODUCT_ROOT CHECK_OUTPUT CHECK_HOST actual_queue

   # first clean up output directory:  
   setup_output_directory

   set option "-m beas"
   set jobargs "$option -l q=${actual_queue} -o $job_output_dir -e $job_output_dir $CHECK_PRODUCT_ROOT/examples/jobs/sleeper.sh 5" 
  
   set result [submit_job $jobargs 0]  
   puts $CHECK_OUTPUT "\njob $result has args: \"$jobargs\""

   if { $result < 0 } {
      set_error -1 "could not submit job"
      return
   }

   set time [ expr ( [timestamp] + 300  ) ] 

   while { [timestamp] < $time }  {
      sleep 1
      set back [was_job_running $result 0] 
      if {$back != -1} {
         set back [ del_job_files $result $job_output_dir 2 ] 
         if { $back != 2 } {
            set_error -1 "job $result did not produce error and output file\njobargs: $jobargs"
            return
         } else {
            set_error 0 "no error"
            return
         }
      }
   }
 
   set_error -1 "timeout while waiting for job accounting"
}

#                                                             max. column:     |
#****** qsub/check_option_notify() ******
# 
#  NAME
#     check_option_notify -- ??? 
#
#  SYNOPSIS
#     check_option_notify { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc check_option_notify {} {

   global job_output_dir CHECK_PRODUCT_ROOT CHECK_OUTPUT CHECK_HOST actual_queue

   # first clean up output directory:  
   setup_output_directory

   set option "-notify"
   set jobargs "$option -l q=${actual_queue} -o $job_output_dir -e $job_output_dir $CHECK_PRODUCT_ROOT/examples/jobs/sleeper.sh 5" 
  
   set result [submit_job $jobargs 0]  
   puts $CHECK_OUTPUT "\njob $result has args: \"$jobargs\""

   if { $result < 0 } {
      set_error -1 "could not submit job"
      return
   }

   set time [ expr ( [timestamp] + 300  ) ] 

   while { [timestamp] < $time }  {
      sleep 1
      set back [was_job_running $result 0] 
      if {$back != -1} {
         set back [ del_job_files $result $job_output_dir 2 ] 
         if { $back != 2 } {
            set_error -1 "job $result did not produce error and output file\njobargs: $jobargs"
            return
         } else {
            set_error 0 "no error"
            return
         }
      }
   }
 
   set_error -1 "timeout while waiting for job accounting"
}

#                                                             max. column:     |
#****** qsub/check_option_now_yes() ******
# 
#  NAME
#     check_option_now_yes -- ??? 
#
#  SYNOPSIS
#     check_option_now_yes { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc check_option_now_yes {} {

   global job_output_dir CHECK_PRODUCT_ROOT CHECK_OUTPUT CHECK_HOST actual_queue

   # first clean up output directory:  
   setup_output_directory

   set option "-now yes"
   set jobargs "$option -l q=${actual_queue} -o $job_output_dir -e $job_output_dir $CHECK_PRODUCT_ROOT/examples/jobs/sleeper.sh 5" 
  
   set result [submit_job $jobargs 0]  
   puts $CHECK_OUTPUT "\njob $result has args: \"$jobargs\""

   if { $result < 0 } {
      set_error -1 "could not submit job"
      return
   }

   set time [ expr ( [timestamp] + 300  ) ] 

   while { [timestamp] < $time }  {
      sleep 1
      set back [was_job_running $result 0] 
      if {$back != -1} {
         set back [ del_job_files $result $job_output_dir 2 ] 
         if { $back != 2 } {
            set_error -1 "job $result did not produce error and output file\njobargs: $jobargs"
            return
         } else {
            set_error 0 "no error"
            return
         }
      }
   }
 
   set_error -1 "timeout while waiting for job accounting"
}

#                                                             max. column:     |
#****** qsub/check_option_now_no() ******
# 
#  NAME
#     check_option_now_no -- ??? 
#
#  SYNOPSIS
#     check_option_now_no { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc check_option_now_no {} {

   global job_output_dir CHECK_PRODUCT_ROOT CHECK_OUTPUT CHECK_HOST actual_queue

   # first clean up output directory:  
   setup_output_directory

   set option "-now no"
   set jobargs "$option -l q=${actual_queue} -o $job_output_dir -e $job_output_dir $CHECK_PRODUCT_ROOT/examples/jobs/sleeper.sh 5" 
  
   set result [submit_job $jobargs 0]  
   puts $CHECK_OUTPUT "\njob $result has args: \"$jobargs\""

   if { $result < 0 } {
      set_error -1 "could not submit job"
      return
   }

   set time [ expr ( [timestamp] + 300  ) ] 

   while { [timestamp] < $time }  {
      sleep 1
      set back [was_job_running $result 0] 
      if {$back != -1} {
         set back [ del_job_files $result $job_output_dir 2 ] 
         if { $back != 2 } {
            set_error -1 "job $result did not produce error and output file\njobargs: $jobargs"
            return
         } else {
            set_error 0 "no error"
            return
         }
      }
   }
 
   set_error -1 "timeout while waiting for job accounting"
}

#                                                             max. column:     |
#****** qsub/check_option_M() ******
# 
#  NAME
#     check_option_M -- ??? 
#
#  SYNOPSIS
#     check_option_M { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc check_option_M {} {

   global job_output_dir CHECK_PRODUCT_ROOT CHECK_OUTPUT CHECK_HOST actual_queue CHECK_USER CHECK_REPORT_EMAIL_TO

   if { [ string compare $CHECK_REPORT_EMAIL_TO "none" ] == 0 } {
      add_proc_error "check_option_M" -1 "no email address specified"  
      return
   }

   # first clean up output directory:  
   setup_output_directory

   set option "-M $CHECK_REPORT_EMAIL_TO"
   set jobargs "$option -l q=${actual_queue} -o $job_output_dir -e $job_output_dir $CHECK_PRODUCT_ROOT/examples/jobs/sleeper.sh 5" 
  
   set result [submit_job $jobargs 0]  
   puts $CHECK_OUTPUT "\njob $result has args: \"$jobargs\""

   if { $result < 0 } {
      set_error -1 "could not submit job"
      return
   }

   set time [ expr ( [timestamp] + 300  ) ] 

   while { [timestamp] < $time }  {
      sleep 1
      set back [was_job_running $result 0] 
      if {$back != -1} {
         set back [ del_job_files $result $job_output_dir 2 ] 
         if { $back != 2 } {
            set_error -1 "job $result did not produce error and output file\njobargs: $jobargs"
            return
         } else {
            set_error 0 "no error"
            return
         }
      }
   }
 
   set_error -1 "timeout while waiting for job accounting"
}

#                                                             max. column:     |
#****** qsub/check_option_N() ******
# 
#  NAME
#     check_option_N -- ??? 
#
#  SYNOPSIS
#     check_option_N { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc check_option_N {} {

   global job_output_dir CHECK_PRODUCT_ROOT CHECK_OUTPUT CHECK_HOST actual_queue

   # first clean up output directory:  
   setup_output_directory

   set option "-N leeper_job"
   set jobargs "$option -l q=${actual_queue} -o $job_output_dir -e $job_output_dir $CHECK_PRODUCT_ROOT/examples/jobs/sleeper.sh 5" 
  
   set result [submit_job $jobargs 0]  
   puts $CHECK_OUTPUT "\njob $result has args: \"$jobargs\""

   if { $result < 0 } {
      set_error -1 "could not submit job"
      return
   }

   set time [ expr ( [timestamp] + 300  ) ] 

   while { [timestamp] < $time }  {
      sleep 1
      set back [was_job_running $result 0] 
      if {$back != -1} {
         set back [ del_job_files $result $job_output_dir 2 ] 
         if { $back != 2 } {
            set_error -1 "job $result did not produce error and output file\njobargs: $jobargs"
            return
         } else {
            set_error 0 "no error"
            return
         }
      }
   }
 
   set_error -1 "timeout while waiting for job accounting"
}


#                                                             max. column:     |
#****** qsub/check_option_o() ******
# 
#  NAME
#     check_option_o -- ??? 
#
#  SYNOPSIS
#     check_option_o { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc check_option_o {} {

   global job_output_dir CHECK_PRODUCT_ROOT CHECK_OUTPUT CHECK_HOST actual_queue

   # first clean up output directory:  
   setup_output_directory

   set option ""
   set jobargs "$option -l q=${actual_queue} -o $job_output_dir -e $job_output_dir $CHECK_PRODUCT_ROOT/examples/jobs/sleeper.sh 5" 
  
   set result [submit_job $jobargs 0]  
   puts $CHECK_OUTPUT "\njob $result has args: \"$jobargs\""

   if { $result < 0 } {
      set_error -1 "could not submit job"
      return
   }

   set time [ expr ( [timestamp] + 300  ) ] 

   while { [timestamp] < $time }  {
      sleep 1
      set back [was_job_running $result 0] 
      if {$back != -1} {
         set back [ del_job_files $result $job_output_dir 2 ] 
         if { $back != 2 } {
            set_error -1 "job $result did not produce error and output file\njobargs: $jobargs"
            return
         } else {
            set_error 0 "no error"
            return
         }
      }
   }
 
   set_error -1 "timeout while waiting for job accounting"
}

#                                                             max. column:     |
#****** qsub/check_option_P() ******
# 
#  NAME
#     check_option_P -- ??? 
#
#  SYNOPSIS
#     check_option_P { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc check_option_P {} {

   global job_output_dir CHECK_PRODUCT_ROOT CHECK_OUTPUT CHECK_HOST actual_queue

   # first clean up output directory:  
   setup_output_directory

   set option "-P mytestproject"
   set jobargs "$option -l q=${actual_queue} -o $job_output_dir -e $job_output_dir $CHECK_PRODUCT_ROOT/examples/jobs/sleeper.sh 5" 
  
   set result [submit_job $jobargs 0]  
   puts $CHECK_OUTPUT "\njob $result has args: \"$jobargs\""

   if { $result < 0 } {
      set_error -1 "could not submit job"
      return
   }

   set time [ expr ( [timestamp] + 300  ) ] 

   while { [timestamp] < $time }  {
      sleep 1
      set back [was_job_running $result 0] 
      if {$back != -1} {
         set back [ del_job_files $result $job_output_dir 2 ] 
         if { $back != 2 } {
            set_error -1 "job $result did not produce error and output file\njobargs: $jobargs"
            return
         } else {
            set_error 0 "no error"
            return
         }
      }
   }
 
   set_error -1 "timeout while waiting for job accounting"
}

#                                                             max. column:     |
#****** qsub/check_option_p() ******
# 
#  NAME
#     check_option_p -- ??? 
#
#  SYNOPSIS
#     check_option_p { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc check_option_p {} {

   global job_output_dir CHECK_PRODUCT_ROOT CHECK_OUTPUT CHECK_HOST actual_queue

   # first clean up output directory:  
   setup_output_directory

   set option "-p 1024"
   set jobargs "$option -l q=${actual_queue} -o $job_output_dir -e $job_output_dir $CHECK_PRODUCT_ROOT/examples/jobs/sleeper.sh 5" 
  
   set result [submit_job $jobargs 0]  
   puts $CHECK_OUTPUT "\njob $result has args: \"$jobargs\""

   if { $result < 0 } {
      set_error -1 "could not submit job"
      return
   }

   set time [ expr ( [timestamp] + 300  ) ] 

   while { [timestamp] < $time }  {
      sleep 1
      set back [was_job_running $result 0] 
      if {$back != -1} {
         set back [ del_job_files $result $job_output_dir 2 ] 
         if { $back != 2 } {
            set_error -1 "job $result did not produce error and output file\njobargs: $jobargs"
            return
         } else {
            set_error 0 "no error"
            return
         }
      }
   }
 
   set_error -1 "timeout while waiting for job accounting"
}

#                                                             max. column:     |
#****** qsub/check_option_pe() ******
# 
#  NAME
#     check_option_pe -- ??? 
#
#  SYNOPSIS
#     check_option_pe { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc check_option_pe {} {

   global job_output_dir CHECK_PRODUCT_ROOT CHECK_OUTPUT CHECK_HOST actual_queue

   # first clean up output directory:  
   setup_output_directory

   set option "-pe mytestpe 1-3"
   set jobargs "$option -l q=${actual_queue} -o $job_output_dir -e $job_output_dir $CHECK_PRODUCT_ROOT/examples/jobs/sleeper.sh 5" 
  
   set result [submit_job $jobargs 0]  
   puts $CHECK_OUTPUT "\njob $result has args: \"$jobargs\""

   if { $result < 0 } {
      set_error -1 "could not submit job"
      return
   }

   set time [ expr ( [timestamp] + 300  ) ] 

   while { [timestamp] < $time }  {
      sleep 1
      set back [was_job_running $result 0] 
      if {$back != -1} {
         set back [ del_job_files $result $job_output_dir 4 ] 
         if { $back != 4 } {
            set_error -1 "job $result did not produce 4 files\njobargs: $jobargs"
            return
         } else {
            set_error 0 "no error"
            return
         }
      }
   }
 
   set_error -1 "timeout while waiting for job accounting"
}

#                                                             max. column:     |
#****** qsub/check_option_q() ******
# 
#  NAME
#     check_option_q -- ??? 
#
#  SYNOPSIS
#     check_option_q { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc check_option_q {} {

   global job_output_dir CHECK_PRODUCT_ROOT CHECK_OUTPUT CHECK_HOST actual_queue

   # first clean up output directory:  
   setup_output_directory

   set option "-q ${actual_queue}"
   set jobargs "$option -o $job_output_dir -e $job_output_dir $CHECK_PRODUCT_ROOT/examples/jobs/sleeper.sh 5" 
  
   set result [submit_job $jobargs 0]  
   puts $CHECK_OUTPUT "\njob $result has args: \"$jobargs\""

   if { $result < 0 } {
      set_error -1 "could not submit job"
      return
   }

   set time [ expr ( [timestamp] + 300  ) ] 

   while { [timestamp] < $time }  {
      sleep 1
      set back [was_job_running $result 0] 
      if {$back != -1} {
         set back [ del_job_files $result $job_output_dir 2 ] 
         if { $back != 2 } {
            set_error -1 "job $result did not produce error and output file\njobargs: $jobargs"
            return
         } else {
            set_error 0 "no error"
            return
         }
      }
   }
 
   set_error -1 "timeout while waiting for job accounting"
}

#                                                             max. column:     |
#****** qsub/check_option_qs_args() ******
# 
#  NAME
#     check_option_qs_args -- ??? 
#
#  SYNOPSIS
#     check_option_qs_args { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc check_option_qs_args {} {

   global job_output_dir CHECK_PRODUCT_ROOT CHECK_OUTPUT CHECK_HOST actual_queue

   # first clean up output directory:  
   setup_output_directory

   set option "-qs_args arg1 arg2 arg3 -qs_end"
   set jobargs "$option -l q=${actual_queue} -o $job_output_dir -e $job_output_dir $CHECK_PRODUCT_ROOT/examples/jobs/sleeper.sh 5" 
  
   set result [submit_job $jobargs 0]  
   puts $CHECK_OUTPUT "\njob $result has args: \"$jobargs\""

   if { $result < 0 } {
      set_error -1 "could not submit job"
      return
   }

   set time [ expr ( [timestamp] + 300  ) ] 

   while { [timestamp] < $time }  {
      sleep 1
      set back [was_job_running $result 0] 
      if {$back != -1} {
         set back [ del_job_files $result $job_output_dir 2 ] 
         if { $back != 2 } {
            set_error -1 "job $result did not produce error and output file\njobargs: $jobargs"
            return
         } else {
            set_error 0 "no error"
            return
         }
      }
   }
 
   set_error -1 "timeout while waiting for job accounting"
}

#                                                             max. column:     |
#****** qsub/check_option_r_y() ******
# 
#  NAME
#     check_option_r_y -- ??? 
#
#  SYNOPSIS
#     check_option_r_y { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc check_option_r_y {} {

   global job_output_dir CHECK_PRODUCT_ROOT CHECK_OUTPUT CHECK_HOST actual_queue

   # first clean up output directory:  
   setup_output_directory

   set option "-r y"
   set jobargs "$option -l q=${actual_queue} -o $job_output_dir -e $job_output_dir $CHECK_PRODUCT_ROOT/examples/jobs/sleeper.sh 5" 
  
   set result [submit_job $jobargs 0]  
   puts $CHECK_OUTPUT "\njob $result has args: \"$jobargs\""

   if { $result < 0 } {
      set_error -1 "could not submit job"
      return
   }

   set time [ expr ( [timestamp] + 300  ) ] 

   while { [timestamp] < $time }  {
      sleep 1
      set back [was_job_running $result 0] 
      if {$back != -1} {
         set back [ del_job_files $result $job_output_dir 2 ] 
         if { $back != 2 } {
            set_error -1 "job $result did not produce error and output file\njobargs: $jobargs"
            return
         } else {
            set_error 0 "no error"
            return
         }
      }
   }
 
   set_error -1 "timeout while waiting for job accounting"
}

#                                                             max. column:     |
#****** qsub/check_option_r_n() ******
# 
#  NAME
#     check_option_r_n -- ??? 
#
#  SYNOPSIS
#     check_option_r_n { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc check_option_r_n {} {

   global job_output_dir CHECK_PRODUCT_ROOT CHECK_OUTPUT CHECK_HOST actual_queue

   # first clean up output directory:  
   setup_output_directory

   set option "-r n"
   set jobargs "$option -l q=${actual_queue} -o $job_output_dir -e $job_output_dir $CHECK_PRODUCT_ROOT/examples/jobs/sleeper.sh 5" 
  
   set result [submit_job $jobargs 0]  
   puts $CHECK_OUTPUT "\njob $result has args: \"$jobargs\""

   if { $result < 0 } {
      set_error -1 "could not submit job"
      return
   }

   set time [ expr ( [timestamp] + 300  ) ] 

   while { [timestamp] < $time }  {
      sleep 1
      set back [was_job_running $result 0] 
      if {$back != -1} {
         set back [ del_job_files $result $job_output_dir 2 ] 
         if { $back != 2 } {
            set_error -1 "job $result did not produce error and output file\njobargs: $jobargs"
            return
         } else {
            set_error 0 "no error"
            return
         }
      }
   }
 
   set_error -1 "timeout while waiting for job accounting"
}

#                                                             max. column:     |
#****** qsub/check_option_sc() ******
# 
#  NAME
#     check_option_sc -- ??? 
#
#  SYNOPSIS
#     check_option_sc { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc check_option_sc {} {

   global job_output_dir CHECK_PRODUCT_ROOT CHECK_OUTPUT CHECK_HOST actual_queue

   # first clean up output directory:  
   setup_output_directory

   set option "-sc myvar=test3"
   set jobargs "$option -l q=${actual_queue} -o $job_output_dir -e $job_output_dir $CHECK_PRODUCT_ROOT/examples/jobs/sleeper.sh 5" 
  
   set result [submit_job $jobargs 0]  
   puts $CHECK_OUTPUT "\njob $result has args: \"$jobargs\""

   if { $result < 0 } {
      set_error -1 "could not submit job"
      return
   }

   set time [ expr ( [timestamp] + 300  ) ] 

   while { [timestamp] < $time }  {
      sleep 1
      set back [was_job_running $result 0] 
      if {$back != -1} {
         set back [ del_job_files $result $job_output_dir 2 ] 
         if { $back != 2 } {
            set_error -1 "job $result did not produce error and output file\njobargs: $jobargs"
            return
         } else {
            set_error 0 "no error"
            return
         }
      }
   }
 
   set_error -1 "timeout while waiting for job accounting"
}

#                                                             max. column:     |
#****** qsub/check_option_soft() ******
# 
#  NAME
#     check_option_soft -- ??? 
#
#  SYNOPSIS
#     check_option_soft { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc check_option_soft {} {

   global job_output_dir CHECK_PRODUCT_ROOT CHECK_OUTPUT CHECK_HOST actual_queue

   # first clean up output directory:  
   setup_output_directory

   set option "-soft"
   set jobargs "$option -l q=${actual_queue} -o $job_output_dir -e $job_output_dir $CHECK_PRODUCT_ROOT/examples/jobs/sleeper.sh 5" 
  
   set result [submit_job $jobargs 0]  
   puts $CHECK_OUTPUT "\njob $result has args: \"$jobargs\""

   if { $result < 0 } {
      set_error -1 "could not submit job"
      return
   }

   set time [ expr ( [timestamp] + 300  ) ] 

   while { [timestamp] < $time }  {
      sleep 1
      set back [was_job_running $result 0] 
      if {$back != -1} {
         set back [ del_job_files $result $job_output_dir 2 ] 
         if { $back != 2 } {
            set_error -1 "job $result did not produce error and output file\njobargs: $jobargs"
            return
         } else {
            set_error 0 "no error"
            return
         }
      }
   }
 
   set_error -1 "timeout while waiting for job accounting"
}

#                                                             max. column:     |
#****** qsub/check_option_S() ******
# 
#  NAME
#     check_option_S -- ??? 
#
#  SYNOPSIS
#     check_option_S { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc check_option_S {} {

   global job_output_dir CHECK_PRODUCT_ROOT CHECK_OUTPUT CHECK_HOST actual_queue

   # first clean up output directory:  
   setup_output_directory

   set option "-S /bin/sh"
   set jobargs "$option -l q=${actual_queue} -o $job_output_dir -e $job_output_dir $CHECK_PRODUCT_ROOT/examples/jobs/sleeper.sh 5" 
  
   set result [submit_job $jobargs 0]  
   puts $CHECK_OUTPUT "\njob $result has args: \"$jobargs\""

   if { $result < 0 } {
      set_error -1 "could not submit job"
      return
   }

   set time [ expr ( [timestamp] + 300  ) ] 

   while { [timestamp] < $time }  {
      sleep 1
      set back [was_job_running $result 0] 
      if {$back != -1} {
         set back [ del_job_files $result $job_output_dir 2 ] 
         if { $back != 2 } {
            set_error -1 "job $result did not produce error and output file\njobargs: $jobargs"
            return
         } else {
            set_error 0 "no error"
            return
         }
      }
   }
 
   set_error -1 "timeout while waiting for job accounting"
}

#                                                             max. column:     |
#****** qsub/check_option_t() ******
# 
#  NAME
#     check_option_t -- ??? 
#
#  SYNOPSIS
#     check_option_t { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc check_option_t {} {

   global job_output_dir CHECK_PRODUCT_ROOT CHECK_OUTPUT CHECK_HOST actual_queue

   # first clean up output directory:  
   setup_output_directory

   set option "-t 1-2:-1"
   set jobargs "$option -l q=${actual_queue} -o $job_output_dir -e $job_output_dir $CHECK_PRODUCT_ROOT/examples/jobs/sleeper.sh 15" 

   set result [submit_job $jobargs 0]
   if { $result != -20 } {
      add_proc_error "check_option_t" -1 "Negative step in range should produce an error"
   } 
 
   set option "-t 1-2:xx"
   set jobargs "$option -l q=${actual_queue} -o $job_output_dir -e $job_output_dir $CHECK_PRODUCT_ROOT/examples/jobs/sleeper.sh 15"

   set result [submit_job $jobargs 0]

   if { $result != -21 } {
      add_proc_error "check_option_t" -1 "Invalid range spec should produce an error"
   }

   set option "-t 2-8:2"
   set jobargs "$option -l q=${actual_queue} -o $job_output_dir -e $job_output_dir $CHECK_PRODUCT_ROOT/examples/jobs/sleeper.sh 15" 
  
   set result [submit_job $jobargs 0]  
   puts $CHECK_OUTPUT "\njob $result has args: \"$jobargs\""

   if { $result < 0 } {
      set_error -1 "could not submit job"
      return
   }


   set time [ expr ( [timestamp] + 300  ) ] 

   while { [timestamp] < $time }  {
      sleep 1
      set back [was_job_running $result 0] 
      if {$back != -1} {
         set back [ del_job_files $result $job_output_dir 8 ] 
         if { $back != 8 } {
            set_error -1 "job $result did not produce 8 files\njobargs: $jobargs"
            return
         } else {
            set_error 0 "no error"
            return
         }
      }
   }
 
   set_error -1 "timeout while waiting for job accounting"
}

#                                                             max. column:     |
#****** qsub/check_option_v() ******
# 
#  NAME
#     check_option_v -- ??? 
#
#  SYNOPSIS
#     check_option_v { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc check_option_v {} {

   global job_output_dir CHECK_PRODUCT_ROOT CHECK_OUTPUT CHECK_HOST actual_queue

   # first clean up output directory:  
   setup_output_directory

   set option "-v DISPLAY"
   set jobargs "$option -l q=${actual_queue} -o $job_output_dir -e $job_output_dir $CHECK_PRODUCT_ROOT/examples/jobs/sleeper.sh 5" 
  
   set result [submit_job $jobargs 0]  
   puts $CHECK_OUTPUT "\njob $result has args: \"$jobargs\""

   if { $result < 0 } {
      set_error -1 "could not submit job"
      return
   }

   set time [ expr ( [timestamp] + 300  ) ] 

   while { [timestamp] < $time }  {
      sleep 1
      set back [was_job_running $result 0] 
      if {$back != -1} {
         set back [ del_job_files $result $job_output_dir 2 ] 
         if { $back != 2 } {
            set_error -1 "job $result did not produce error and output file\njobargs: $jobargs"
            return
         } else {
            set_error 0 "no error"
            return
         }
      }
   }
 
   set_error -1 "timeout while waiting for job accounting"
}

#                                                             max. column:     |
#****** qsub/check_option_verify() ******
# 
#  NAME
#     check_option_verify -- ??? 
#
#  SYNOPSIS
#     check_option_verify { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc check_option_verify {} {

   global job_output_dir CHECK_PRODUCT_ROOT CHECK_OUTPUT CHECK_HOST actual_queue

   # first clean up output directory:  
   setup_output_directory

   set option "-verify"
   set jobargs "$option -l q=${actual_queue} -o $job_output_dir -e $job_output_dir $CHECK_PRODUCT_ROOT/examples/jobs/sleeper.sh 5" 
  
   set result [submit_job $jobargs 0]  
   puts $CHECK_OUTPUT "\njob $result has args: \"$jobargs\""

   if { $result != -4 } {
      set_error -1 "no verify output on -verify command"
      return
   }

   set_error 0 "no error"
}

#                                                             max. column:     |
#****** qsub/check_option_V() ******
# 
#  NAME
#     check_option_V -- ??? 
#
#  SYNOPSIS
#     check_option_V { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc check_option_V {} {

   global job_output_dir CHECK_PRODUCT_ROOT CHECK_OUTPUT CHECK_HOST actual_queue

   # first clean up output directory:  
   setup_output_directory

   set option "-V"
   set jobargs "$option -l q=${actual_queue} -o $job_output_dir -e $job_output_dir $CHECK_PRODUCT_ROOT/examples/jobs/sleeper.sh 5" 
  
   set result [submit_job $jobargs 0]  
   puts $CHECK_OUTPUT "\njob $result has args: \"$jobargs\""

   if { $result < 0 } {
      set_error -1 "could not submit job"
      return
   }

   set time [ expr ( [timestamp] + 300  ) ] 

   while { [timestamp] < $time }  {
      sleep 1
      set back [was_job_running $result 0] 
      if {$back != -1} {
         set back [ del_job_files $result $job_output_dir 2 ] 
         if { $back != 2 } {
            set_error -1 "job $result did not produce error and output file\njobargs: $jobargs"
            return
         } else {
            set_error 0 "no error"
            return
         }
      }
   }
 
   set_error -1 "timeout while waiting for job accounting"
}

#                                                             max. column:     |
#****** qsub/check_option_w() ******
# 
#  NAME
#     check_option_w -- ??? 
#
#  SYNOPSIS
#     check_option_w { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc check_option_w {} {

   global job_output_dir CHECK_PRODUCT_ROOT CHECK_OUTPUT CHECK_HOST actual_queue

   # first clean up output directory:  
   setup_output_directory

   set option "-w e"
   set jobargs "$option -l q=${actual_queue} -o $job_output_dir -e $job_output_dir $CHECK_PRODUCT_ROOT/examples/jobs/sleeper.sh 5" 
  
   set result [submit_job $jobargs 0]  
   puts $CHECK_OUTPUT "\njob $result has args: \"$jobargs\""

   if { $result < 0 } {
      set_error -1 "could not submit job"
      return
   }

   set time [ expr ( [timestamp] + 300  ) ] 

   while { [timestamp] < $time }  {
      sleep 1
      set back [was_job_running $result 0] 
      if {$back != -1} {
         set back [ del_job_files $result $job_output_dir 2 ] 
         if { $back != 2 } {
            set_error -1 "job $result did not produce error and output file\njobargs: $jobargs"
            return
         } else {
            set_error 0 "no error"
            return
         }
      }
   }
 
   set_error -1 "timeout while waiting for job accounting"
}

#                                                             max. column:     |
#****** qsub/check_option_@() ******
# 
#  NAME
#     check_option_@ -- ??? 
#
#  SYNOPSIS
#     check_option_@ { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc check_option_@ {} {

   global job_output_dir CHECK_PRODUCT_ROOT CHECK_OUTPUT CHECK_HOST actual_queue CHECK_ACTUAL_TEST_PATH

   # first clean up output directory:  
   setup_output_directory

   set option "-@ $CHECK_ACTUAL_TEST_PATH/commandfile.txt"
   set jobargs "$option -l q=${actual_queue} -o $job_output_dir -e $job_output_dir $CHECK_PRODUCT_ROOT/examples/jobs/sleeper.sh 5" 
  
   set result [submit_job $jobargs 0]  

   if { $result != -2 } {
      set_error -1 "no help output on -@ commandfile option"
      return
   }

   set_error 0 "no errors"
}

#                                                             max. column:     |
#****** qsub/check_huge_script() ******
# 
#  NAME
#     check_huge_script -- ??? 
#
#  SYNOPSIS
#     check_huge_script { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc check_huge_script {} {
   global job_output_dir CHECK_PROTOCOL_DIR CHECK_ACT_LEVEL
   global CHECK_PRODUCT_ROOT CHECK_OUTPUT CHECK_HOST CHECK_ACTUAL_TEST_PATH actual_queue
   global HUGE_SCRIPT_SIZE HUGE_SCRIPT_PATTERN HUGE_SCRIPT_TIMEOUT steps_per_queue size_interval

   # first clean up output directory:  
   setup_output_directory

   # protocol
   set protocol_filename "$CHECK_PROTOCOL_DIR/qsub_huge_script.txt"
   if { $CHECK_ACT_LEVEL == 0 } {
      set protocol [open $protocol_filename "w"]
      puts $protocol "submitting huge scripts"
      puts $protocol "size       = size of the script"
      puts $protocol "submittime = time needed to submit the script, timeout after $HUGE_SCRIPT_TIMEOUT s"
      puts $protocol "schedtime  = time the job needs to startup"
      puts $protocol "runtime    = runtime of the job"
      puts $protocol ""
      puts $protocol "size\tsubmittime\tschedtime\truntime"
      flush $protocol
   } else {
      set protocol [open $protocol_filename "a"]
   }

   for { set step 0 } { $step < $steps_per_queue } { incr step } {
      # create a huge sleeper.sh
      set filename "$job_output_dir/sleeper.sh"
      file copy -force "$CHECK_PRODUCT_ROOT/examples/jobs/sleeper.sh" "$filename"
      set f [open $filename a]
      puts $f "exit 0"
      set times [expr ($CHECK_ACT_LEVEL * $size_interval * $steps_per_queue + $size_interval * $step) / [string length "$HUGE_SCRIPT_PATTERN"]]
      for { set i 0 } { $i < $times } { incr i} {
         puts $f "$HUGE_SCRIPT_PATTERN"
      }
      close $f
   
      set submit_size [file size $filename]
      puts $CHECK_OUTPUT "submitting job script of size $submit_size bytes allowing a timeout of $HUGE_SCRIPT_TIMEOUT s"
   
      set jobargs "-l q=${actual_queue} -o $job_output_dir -e $job_output_dir $filename 5" 
      #puts $CHECK_OUTPUT "\njob has args: \"$jobargs\""
      
      set submit_start [clock seconds]
      set result [submit_job $jobargs 1 $HUGE_SCRIPT_TIMEOUT]
      if { $result < 0 } {
         set_error -1 "could not submit job (result: $result)"
         close $protocol
         return
      } else {
         set sched_start [clock seconds]
         set submit_time [expr $sched_start - $submit_start]
         puts $CHECK_OUTPUT "submitting lasted $submit_time s"
         wait_for_jobstart $result "Sleeper" $HUGE_SCRIPT_TIMEOUT
         set run_start [clock seconds]
         set sched_time [expr $run_start - $sched_start]
         wait_for_jobend $result "Sleeper" $HUGE_SCRIPT_TIMEOUT
         set run_end [clock seconds]
         set run_time [expr $run_end - $run_start]
         puts $protocol "$submit_size\t$submit_time\t$sched_time\t$run_time"
         flush $protocol
      }
   
      file delete $filename
   
      set back [ del_job_files $result $job_output_dir 2 ] 
      if { $back != 2 } {
         set_error -1 "job $result did not produce error and output file\njobargs: $jobargs"
         close $protocol
         return
      }
   }

   close $protocol
   set_error 0 "ok"
}

proc check_setup_config {} {
   global ts_config
   global stored_configuration


   if { $ts_config(gridengine_version) == 53 } {
      get_config stored_configuration
      set my_config(schedd_params) "$stored_configuration(schedd_params),FLUSH_SUBMIT_SEC=0"
      set_config my_config
   } else {
      set my_schedd_conf(flush_submit_sec) "1"
      set_schedd_config my_schedd_conf 
   }
   set_error 0 "ok"
}

proc check_cleanup_config {} {
   global ts_config
   global stored_configuration

   if {$ts_config(gridengine_version) == 60} {
      reset_schedd_config
   } else {
      set_config stored_configuration
   }
   set_error 0 "ok"
}
