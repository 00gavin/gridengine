#!/vol2/TCL_TK/glinux/bin/expect
# expect script 
# test SGE/SGEEE System
#___INFO__MARK_BEGIN__
##########################################################################
#
#  The Contents of this file are made available subject to the terms of
#  the Sun Industry Standards Source License Version 1.2
#
#  Sun Microsystems Inc., March, 2001
#
#
#  Sun Industry Standards Source License Version 1.2
#  =================================================
#  The contents of this file are subject to the Sun Industry Standards
#  Source License Version 1.2 (the "License"); You may not use this file
#  except in compliance with the License. You may obtain a copy of the
#  License at http://gridengine.sunsource.net/Gridengine_SISSL_license.html
#
#  Software provided under this License is provided on an "AS IS" basis,
#  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
#  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
#  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
#  See the License for the specific provisions governing your rights and
#  obligations concerning the Software.
#
#  The Initial Developer of the Original Code is: Sun Microsystems, Inc.
#
#  Copyright: 2001 by Sun Microsystems, Inc.
#
#  All Rights Reserved.
#
##########################################################################
#___INFO__MARK_END__





global daemon_debug 
set daemon_debug 0
global master_debug
set master_debug 0
global schedd_debug
set schedd_debug 0

global no_action                   ;# just used for testing/debug  procedures
set no_action 0
global be_quiet
set be_quiet 0
global write_mail_to_file
set write_mail_to_file 0
global do_close_rlogin
set do_close_rlogin 0

global do_compile
global CHECK_TESTSUITE_LOCKFILE
set CHECK_TESTSUITE_LOCKFILE "testsuite_lockfile"

# path/file variables
global CHECK_TESTSUITE_ROOT        ;# path to TESTSUITE directory
global CHECK_CHECKTREE_ROOT        ;# path where checktree lies

# never touch these dirs: begin
global CHECK_RESULT_DIR            ;# check result directory            
global CHECK_BAD_RESULT_DIR        ;# check rusult directory for failed checkes
global CHECK_CORE_RESULT_DIR       ;# check result core system directory
global CHECK_CORE_BAD_RESULT_DIR   ;# check result directory for failed core system checkes
# never touch these dirs : end

# this is for new tests:
global CHECK_PROTOCOL_DIR          ;# directory for test protocols, logs etc.
global CHECK_JOB_OUTPUT_DIR        ;# directory for qsub job outputs
############################################################################

global CHECK_ACTUAL_TEST_PATH      ;# directory of current running test
global CHECK_PRODUCT_ROOT          ;# path to sge system
global CHECK_OUTPUT                ;# output from testsuite 
global CHECK_CURRENT_WORKING_DIR   ;# current work directory
global CHECK_HTML_DIRECTORY        ;# directory for HTML output of testsuite 
set CHECK_HTML_DIRECTORY ""
# globals for source code specific staff
global CHECK_SOURCE_DIR            ;# path to source code directory (c4)
global CHECK_SOURCE_CVS_RELEASE    ;# release name to check out e.g. V52_BRANCH
set CHECK_SOURCE_CVS_RELEASE "maintrunc"    ;# default is "maintrunc"
global CHECK_SOURCE_HOSTNAME       ;# name of host with cvs installed on (e.g. fangorn)
global CHECK_SOURCE_COMPILE_HOSTS     ;# list of hostnames on which the source should be compiled
global CHECK_AIMK_COMPILE_OPTIONS     ;# optional: aimk options
global CHECK_DIST_INSTALL_OPTIONS     ;# optional: mydistinst options
global CHECK_PACKAGE_DIRECTORY        ;# optional: no compile directory, use distribution (tar or sun packages)
global CHECK_PACKAGE_TYPE             ;# zip or tar
set CHECK_PACKAGE_TYPE "tar"
global CHECK_QMASTER_INSTALL_OPTIONS  ;# optional: qmaster install parameter
global CHECK_EXECD_INSTALL_OPTIONS    ;# optional: execd install parameter 
set CHECK_AIMK_COMPILE_OPTIONS "-secure"
set CHECK_DIST_INSTALL_OPTIONS "-allall"
set CHECK_PACKAGE_DIRECTORY "none"
set CHECK_QMASTER_INSTALL_OPTIONS ""
set CHECK_EXECD_INSTALL_OPTIONS   ""

# test system specific 
global CHECK_L10N  ;# is sge/sgeee system l10n'ed ?
set CHECK_L10N 0
global CHECK_DNS_DOMAINNAME
set CHECK_DNS_DOMAINNAME ""
global CHECK_REMOTE_ENVIRONMENT
set CHECK_REMOTE_ENVIRONMENT ""
global CHECK_DISPLAY_OUTPUT 
if { [info exists env(DISPLAY)] } {
set CHECK_DISPLAY_OUTPUT [set env(DISPLAY)]
} else {
set CHECK_DISPLAY_OUTPUT "undefined"  
}
global CHECK_SETTINGS_VERSION    ;# settings file version number
set CHECK_SETTINGS_VERSION "undefined"
global CHECK_PRODUCT_VERSION_NUMBER ;# version string of qstat -help of tested system
set CHECK_PRODUCT_VERSION_NUMBER "unknown"
global CHECK_PRODUCT_TYPE           ;# "sgeee" or "sge" 
global CHECK_PRODUCT_FEATURE       ;# product feature e.g. csp
set CHECK_PRODUCT_FEATURE "none"
global CHECK_START_SCRIPT_NAME     ;# rcsge
set CHECK_START_SCRIPT_NAME "rcsge"
global CHECK_COMMD_PORT            ;# commd port
global CHECK_ARCH                  ;# architecture of this system (e.g. irix6)
set CHECK_ARCH "unknown"
global CHECK_USER                  ;# user who start test
global CHECK_GROUP                 ;# group of user who start test
global CHECK_HOST                  ;# hostname of this system (e.g. DWAIN)
global CHECK_CORE_EXECD            ;# known execd hostnames
set CHECK_CORE_EXECD ""
global CHECK_ADDITIONAL_COMPILE_HOSTS
set CHECK_ADDITIONAL_COMPILE_HOSTS ""
global CHECK_SUBMIT_ONLY_HOSTS     ;# list of submithosts (no execd/commd running)
set CHECK_SUBMIT_ONLY_HOSTS ""
global CHECK_CORE_MASTER           ;# qmaster hostname
set CHECK_CORE_MASTER ""
global CHECK_CORE_PROCESSORS       ;# real number of processors (in order of CHECK_CORE_EXECD)
global CHECK_ACT_LEVEL             ;# actual check level ( value from 0 up to xxx )
global CHECK_ROOT_PASSWORD         ;# stored root password ( only stored in a variable )
global CHECK_SPOOL_DIR_CONFIG_FILE ;# file for local spooldirs in $CHECK_CONFIG_DIR path
set CHECK_SPOOL_DIR_CONFIG_FILE "local-spool.conf"
global CHECK_LOCAL_BINARY_DIR_CONFIG_FILE ;# file for local spooldirs in $CHECK_CONFIG_DIR path
set CHECK_LOCAL_BINARY_DIR_CONFIG_FILE "local-bin.conf"
global CHECK_BINARY_DIR_CONFIG_FILE ;# file for binary directories in $CHECK_CONFIG_DIR
set CHECK_BINARY_DIR_CONFIG_FILE "binary-path.conf"
global CHECK_LOADSENSOR_DIR_CONFIG_FILE ;# file for architecture specific loadsensor binaries in
set CHECK_LOADSENSOR_DIR_CONFIG_FILE "loadsensor.conf" ;# $CHECK_CONFIG_DIR
global CHECK_MAIL_OUTPUT_FILE
set CHECK_MAIL_OUTPUT_FILE "all_test_mails.txt"

global check_use_installed_system   ;# used only for install_core_system test (noinst parameter)
set check_use_installed_system 0    ;# set to 1 when installed system parameter is set

global check_reinit_on_tcl_error
set check_reinit_on_tcl_error 0

global CHECK_FIRST_FOREIGN_SYSTEM_USER       ;# other system user for e.g. submitting jobs 
set CHECK_FIRST_FOREIGN_SYSTEM_USER "nobody"

global CHECK_SECOND_FOREIGN_SYSTEM_USER      ;# other system user for e.g. submitting jobs 
set CHECK_SECOND_FOREIGN_SYSTEM_USER "nobody"

global CHECK_FIRST_FOREIGN_SYSTEM_GROUP      ;# other system group for e.g. submitting jobs
set CHECK_FIRST_FOREIGN_SYSTEM_GROUP "nogroup" 

global CHECK_SECOND_FOREIGN_SYSTEM_GROUP      ;# other system group for e.g. submitting jobs
set CHECK_SECOND_FOREIGN_SYSTEM_GROUP "nogroup" 

global CHECK_DEFAULT_DOMAIN                ;# default domain for install test
set CHECK_DEFAULT_DOMAIN "none"

global CHECK_MAILX_HOST                    ;# host where the mailx binary is available
set CHECK_MAILX_HOST "none"

global CHECK_REPORT_EMAIL_TO               ;# mail reports/errors to this email-account
set CHECK_REPORT_EMAIL_TO "none"

global CHECK_REPORT_EMAIL_CC               ;# cc reports/errors to this email-accounts
set CHECK_REPORT_EMAIL_CC "none"                 

global CHECK_SEND_ERROR_MAILS              ;# flag 0 off  1 on
set CHECK_SEND_ERROR_MAILS "1"

global CHECK_MAX_ERROR_MAILS              ;# max mails on run all test
set CHECK_MAX_ERROR_MAILS 400

global CHECK_USE_SSH                             ;# enable/disable use of ssh (o means disable)     
set CHECK_USE_SSH 0

global CHECK_TCL_SCRIPTFILE_DIR   ;# testsuite's subdir for tcl files
set CHECK_TCL_SCRIPTFILE_DIR "tcl_files"

global CHECK_SCRIPT_FILE_DIR  ;# testsuite's subdir for script files
set CHECK_SCRIPT_FILE_DIR "scripts"

global CHECK_EXPECT_MATCH_MAX_BUFFER   ;# read buffer for expect
set CHECK_EXPECT_MATCH_MAX_BUFFER 640000

# to redefine in checks:
global check_name                  ;# name of actual check module 
global check_category              ;# check category name array (z.b. COMPATIBILITY, NONROOT, SYSTEM, PERFORMANCE)
global check_description           ;# description of actual check module (append more levels as list)
global check_needs                 ;# dependencies of this check (name of other check)
global check_functions             ;# functions to call (in order)
global check_init_level_procedure   ;# name of procedure to call before starting level run
global check_errno                ;# 0 -> OK , != 0 means error (-2 = break test , -1 failure )
global check_errstr                 ;# short error description in text form   
global check_highest_level         ;# here a check can define his check levels count 0 ...

# for global procedures
global check_cur_proc_error        ;# short error description in text form ( in public procedures )
global check_cur_proc_result       ;# 0 -> OK , != 0 means error (-2 = break test , -1 failure )    


# testsuite intern
global CHECK_INFORMATION_FILE      ;# filename of check information (check.exp)
global CHECK_DIRECTORIES           ;# all sub directories with check's in actual checkpath
global CHECK_REPORT_FILE           ;# filename (with path) for report
global CHECK_MAIN_RESULTS_DIR      ;# check result root directory for all RESULTS
global CHECK_CONFIG_DIR            ;# global configuration testsuite directory
global CHECK_DEFAULTS_FILE         ;# default settings save file
global CHECK_DO_SETUP              ;# flag: do setup option called ?
global CHECK_CUR_PROC_NAME         ;# name of current running test procedure
global CHECK_CUR_PROC_ERRORS       ;# list of procedure errors   ({error text} {error text} ... )
global CHECK_CUR_PROC_RESULTS      ;# list of procedure results  (0 -1 -2 0 ...)
global CHECK_GUILTY_RUNLEVELS      ;# enabled runlevels
global CHECK_GUILTY_CATEGORIES     ;# enabled categories
global CHECK_MAX_LEVEL             ;# highest level number of all subtests
global CHECK_ACT_PATH              ;# actual checkpath (while switching in menu mode)
global arch_cache                  ;# cache for architecture names (lower case) e.g. solaris64
global pe_for_version_check_result ;# cache for pe/checkpnt version
global upper_arch_cache            ;# cache for architecture names (upper case) e.g. SOLARIS64
global l10n_raw_cache              ;# chche for l10n translation strings
global l10n_install_cache          ;# cache for l10n installation script strings
global set_error_proc_called       ;# flag
global open_spawn_buffer           ;# buffer for open_spawn_process arguments
global have_ssh_access_state       ;# global variable for have_ssh_access procedure (remember state)
global check_timestamp             ;# for use in is_job_running
global CHECK_SGE_DEBUG_LEVEL       ;# SGE_DEBUG_LEVEL for starting qmaster and scheduler in debug mode
set CHECK_SGE_DEBUG_LEVEL "2 0 0 0 0 0 0 0"
global CHECK_MAILS_SENT            ;# counter for send mails
set CHECK_MAILS_SENT 0
global CHECK_ENABLE_MAIL           ;# is mail sending enabled
set CHECK_ENABLE_MAIL 1
global CHECK_ADMIN_USER_SYSTEM     ;# if no root account is possible
set CHECK_ADMIN_USER_SYSTEM 0
set check_timestamp [timestamp]
set have_ssh_access_state -1
set pe_for_version_check_result "undefined"
set CHECK_ROOT_PASSWORD    "none"
set CHECK_GUILTY_RUNLEVELS "0"
set CHECK_GUILTY_CATEGORIES {}
set CHECK_DO_SETUP         0
set CHECK_INFORMATION_FILE "check.exp"   ;# this is the filename of each check in different
                                         ;# subdirectories of "checktree"
                                         ;# every file with this name is interpreded as check routine


# debuglevel 0 - none
# debuglevel 1 - more output
# debuglevel 2 - wait for user response (sometimes!)

global CHECK_DEBUG_LEVEL
set CHECK_DEBUG_LEVEL 0 

#
#                                                             max. column:     |
#****** check/debug_puts() ******
#  NAME
#     debug_puts -- ??? 
#
#  SYNOPSIS
#     debug_puts { args } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#     args - ??? 
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
#
proc debug_puts { args } {
   global CHECK_OUTPUT CHECK_DEBUG_LEVEL
   global CHECK_CUR_PROC_NAME CHECK_HOST
   if { $CHECK_DEBUG_LEVEL == 0 } {
      return
   }
   set output ""
   foreach elem $args {
      set output "$output $elem"
   }   

   if { [info exists CHECK_HOST ] == 0 } {
      set CHECK_HOST "unknown"
   }

   puts $CHECK_OUTPUT "\[host: $CHECK_HOST, debug/$CHECK_CUR_PROC_NAME\] $output" 
}

#
#                                                             max. column:     |
#****** check/dump_ts_config() ******
#  NAME
#     dump_ts_config -- dump the testsuite configuration
#
#  SYNOPSIS
#     dump_ts_config { outputfile } 
#
#  FUNCTION
#     Dumps the contents of the ts_config array holding the testsuite 
#     configuration.
#     It is written to a file with the given outputfile name in a 
#     TAB separated ASCII file format:
#     The fields Name, Value and Description are written where
#     - Name is the name of the parameter
#     - Value is the value of the parameter in the current configuration
#     - Description is the testsuite internal description of the parameter
#
#  INPUTS
#     outputfile - name of the output file 
#
#  EXAMPLE
#     A call of
#     expect check.exp execute_func dump_ts_config ts_config.txt
#
#     will generate a file as follows:
#
#     Name    Value   Description
#     add_compile_archs       none    Forced compilation for architectures
#     aimk_compile_options    -secure Aimk compile options
#     checktree_root_dir   ...
#
#*******************************
#
proc dump_ts_config {outputfile} {
   global ts_config
  
   set output [open "$outputfile" w]
  
   set names {}
   
   foreach name [array names ts_config] {
      if {[string first "," $name] == -1} {
         lappend names $name
      }
   }

   puts $output "Name\tValue\tDescription\t"
   foreach name [lsort -dictionary $names] {
      puts $output [format "%s\t%s\t%s" "$name" "$ts_config($name)" "$ts_config($name,desc)"]
   }

   close $output
}



#                                                             max. column:     |
#****** check/get_current_working_dir() ******
# 
#  NAME
#     get_current_working_dir -- ??? 
#
#  SYNOPSIS
#     get_current_working_dir { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc get_current_working_dir { } {

  set work_dir [pwd]
  debug_puts "working dir is $work_dir"
  set help0 $work_dir
  while  { 1 } {
     set help [ split $help0 "/" ]
     set help2 [ lreplace $help 0 1 ]
     set new_work_dir "/[ join $help2 "/" ]"
     set help0 $new_work_dir
     set catch_return_1 [ catch { 
         eval exec "ls $work_dir"
     } result_1 ] 

     set catch_return_2 [ catch { 
         eval exec "ls $new_work_dir" 
     } result_2 ]
     if { $catch_return_1 == 0 && $catch_return_2 == 0} {
        if { [ string compare $result_1 $result_2 ] == 0 } {
           # possibly mounted directory try to create a file
           set f_name "testsuite_test_[timestamp]"
           set catch_return_3 [ catch { 
              eval exec "touch $work_dir/$f_name" 
           } result_3 ]
           if { [ file isfile "$new_work_dir/$f_name" ] } {
              puts "--> mount prefix found, using $new_work_dir"
              set work_dir $new_work_dir
           }
           set catch_return_4 [ catch { 
              eval exec "rm $work_dir/$f_name" 
           } result_4 ]
        }
     }
     if { [string compare $help0 "/" ] == 0 } {
        break;
     }
  }
  return $work_dir 
}

set CHECK_CURRENT_WORKING_DIR [get_current_working_dir]
set CHECK_DEFAULTS_FILE    "$CHECK_CURRENT_WORKING_DIR/defaults.sav"

set CHECK_TESTSUITE_ROOT "$CHECK_CURRENT_WORKING_DIR"
set CHECK_CHECKTREE_ROOT "$CHECK_CURRENT_WORKING_DIR/checktree"
set CHECK_MAIN_RESULTS_DIR "$CHECK_CURRENT_WORKING_DIR/results"
set CHECK_TESTSUITE_LOCKFILE "$CHECK_CURRENT_WORKING_DIR/testsuite_lockfile"

#set CHECK_OUTPUT [open /dev/null "w"]
set CHECK_OUTPUT stdout 


# setup_names  (for edit setup file)
global CHECK_SETUP_NAMES
global CHECK_SETUP_CHANGES
set CHECK_SETUP_CHANGES ""

global CHECK_CURRENT_SETTINGS_VERSION
set CHECK_CURRENT_SETTINGS_VERSION "7"
set CHECK_SETTINGS_VERSION $CHECK_CURRENT_SETTINGS_VERSION

set CHECK_SETUP_NAMES(index) "settings_version"
set CHECK_SETUP_NAMES(settings_version) "CHECK_SETTINGS_VERSION"
set CHECK_SETUP_NAMES(settings_version,reinstall) 0   ;# 1 = re pre install system after setup change
                                                      ;# 2 = only shutdown system
                                                      ;# 0 = no restarting

lappend CHECK_SETUP_NAMES(index) "testsuite_root_directory"
set CHECK_SETUP_NAMES(testsuite_root_directory) "CHECK_TESTSUITE_ROOT"
set CHECK_SETUP_NAMES(testsuite_root_directory,reinstall) 1

lappend CHECK_SETUP_NAMES(index) "testsuite_config_dir"
set CHECK_SETUP_NAMES(testsuite_config_dir) "CHECK_CONFIG_DIR"
set CHECK_SETUP_NAMES(testsuite_config_dir,reinstall) 1

lappend CHECK_SETUP_NAMES(index) "checktree_root_directory"
set CHECK_SETUP_NAMES(checktree_root_directory) "CHECK_CHECKTREE_ROOT"
set CHECK_SETUP_NAMES(checktree_root_directory,reinstall) 0

lappend CHECK_SETUP_NAMES(index) "results_root_directory"
set CHECK_SETUP_NAMES(results_root_directory) "CHECK_MAIN_RESULTS_DIR"
set CHECK_SETUP_NAMES(results_root_directory,reinstall) 0

lappend CHECK_SETUP_NAMES(index) "qmaster_host"
set CHECK_SETUP_NAMES(qmaster_host) "CHECK_CORE_MASTER"
set CHECK_SETUP_NAMES(qmaster_host,reinstall) 1

lappend CHECK_SETUP_NAMES(index) "list_of_execution_hosts"
set CHECK_SETUP_NAMES(list_of_execution_hosts) "CHECK_CORE_EXECD"
set CHECK_SETUP_NAMES(list_of_execution_hosts,reinstall) 1

lappend CHECK_SETUP_NAMES(index) "processors_on_each_execution_host"
set CHECK_SETUP_NAMES(processors_on_each_execution_host) "CHECK_CORE_PROCESSORS"
set CHECK_SETUP_NAMES(processors_on_each_execution_host,reinstall) 1

lappend CHECK_SETUP_NAMES(index) "list_of_submit_only_hosts"
set CHECK_SETUP_NAMES(list_of_submit_only_hosts) "CHECK_SUBMIT_ONLY_HOSTS"
set CHECK_SETUP_NAMES(list_of_submit_only_hosts,reinstall) 2

lappend CHECK_SETUP_NAMES(index) "commd_portnumber"
set CHECK_SETUP_NAMES(commd_portnumber) "CHECK_COMMD_PORT"
set CHECK_SETUP_NAMES(commd_portnumber,reinstall) 2

lappend CHECK_SETUP_NAMES(index) "product_type"
set CHECK_SETUP_NAMES(product_type) "CHECK_PRODUCT_TYPE"
set CHECK_SETUP_NAMES(product_type,reinstall) 1

lappend CHECK_SETUP_NAMES(index) "product_feature"
set CHECK_SETUP_NAMES(product_feature) "CHECK_PRODUCT_FEATURE"
set CHECK_SETUP_NAMES(product_feature,reinstall) 1 

lappend CHECK_SETUP_NAMES(index) "product_root_directory"
set CHECK_SETUP_NAMES(product_root_directory) "CHECK_PRODUCT_ROOT"
set CHECK_SETUP_NAMES(product_root_directory,reinstall) 1

lappend CHECK_SETUP_NAMES(index) "source_root_directory"
set CHECK_SETUP_NAMES(source_root_directory) "CHECK_SOURCE_DIR"
set CHECK_SETUP_NAMES(source_root_directory,reinstall) 1

lappend CHECK_SETUP_NAMES(index) "cvs_hostname"
set CHECK_SETUP_NAMES(cvs_hostname) "CHECK_SOURCE_HOSTNAME"
set CHECK_SETUP_NAMES(cvs_hostname,reinstall) 0

lappend CHECK_SETUP_NAMES(index) "cvs_release_tag"
set CHECK_SETUP_NAMES(cvs_release_tag) "CHECK_SOURCE_CVS_RELEASE"
set CHECK_SETUP_NAMES(cvs_release_tag,reinstall) 1

lappend CHECK_SETUP_NAMES(index) "list_of_compile_hosts"
set CHECK_SETUP_NAMES(list_of_compile_hosts) "CHECK_SOURCE_COMPILE_HOSTS"
set CHECK_SETUP_NAMES(list_of_compile_hosts,reinstall) 1

lappend CHECK_SETUP_NAMES(index) "aimk_compile_options"
set CHECK_SETUP_NAMES(aimk_compile_options) "CHECK_AIMK_COMPILE_OPTIONS"
set CHECK_SETUP_NAMES(aimk_compile_options,reinstall) 1

lappend CHECK_SETUP_NAMES(index) "dist_install_options"
set CHECK_SETUP_NAMES(dist_install_options) "CHECK_DIST_INSTALL_OPTIONS"
set CHECK_SETUP_NAMES(dist_install_options,reinstall) 1

lappend CHECK_SETUP_NAMES(index) "package_directory"
set CHECK_SETUP_NAMES(package_directory) "CHECK_PACKAGE_DIRECTORY"
set CHECK_SETUP_NAMES(package_directory,reinstall) 1

lappend CHECK_SETUP_NAMES(index) "package_type"
set CHECK_SETUP_NAMES(package_type) "CHECK_PACKAGE_TYPE"
set CHECK_SETUP_NAMES(package_type,reinstall) 1


lappend CHECK_SETUP_NAMES(index) "qmaster_install_options"
set CHECK_SETUP_NAMES(qmaster_install_options) "CHECK_QMASTER_INSTALL_OPTIONS"
set CHECK_SETUP_NAMES(qmaster_install_options,reinstall) 2

lappend CHECK_SETUP_NAMES(index) "execd_install_options"
set CHECK_SETUP_NAMES(execd_install_options) "CHECK_EXECD_INSTALL_OPTIONS"
set CHECK_SETUP_NAMES(execd_install_options,reinstall) 2

lappend CHECK_SETUP_NAMES(index) "dns_domain_name"
set CHECK_SETUP_NAMES(dns_domain_name) "CHECK_DNS_DOMAINNAME"
set CHECK_SETUP_NAMES(dns_domain_name,reinstall) 2

lappend CHECK_SETUP_NAMES(index) "user_environment"
set CHECK_SETUP_NAMES(user_environment) "CHECK_REMOTE_ENVIRONMENT"
set CHECK_SETUP_NAMES(user_environment,reinstall) 0

lappend CHECK_SETUP_NAMES(index) "first_foreign_system_username"
set CHECK_SETUP_NAMES(first_foreign_system_username) "CHECK_FIRST_FOREIGN_SYSTEM_USER"
set CHECK_SETUP_NAMES(first_foreign_system_username,reinstall) 2

lappend CHECK_SETUP_NAMES(index) "second_foreign_system_username"
set CHECK_SETUP_NAMES(second_foreign_system_username) "CHECK_SECOND_FOREIGN_SYSTEM_USER"
set CHECK_SETUP_NAMES(second_foreign_system_username,reinstall) 2

lappend CHECK_SETUP_NAMES(index) "first_foreign_system_groupname"
set CHECK_SETUP_NAMES(first_foreign_system_groupname) "CHECK_FIRST_FOREIGN_SYSTEM_GROUP"
set CHECK_SETUP_NAMES(first_foreign_system_groupname,reinstall) 2

lappend CHECK_SETUP_NAMES(index) "second_foreign_system_groupname"
set CHECK_SETUP_NAMES(second_foreign_system_groupname) "CHECK_SECOND_FOREIGN_SYSTEM_GROUP"
set CHECK_SETUP_NAMES(second_foreign_system_groupname,reinstall) 2

lappend CHECK_SETUP_NAMES(index) "default_domain"
set CHECK_SETUP_NAMES(default_domain) "CHECK_DEFAULT_DOMAIN"
set CHECK_SETUP_NAMES(default_domain,reinstall) 2

lappend CHECK_SETUP_NAMES(index) "mailx_hostname"
set CHECK_SETUP_NAMES(mailx_hostname) "CHECK_MAILX_HOST"
set CHECK_SETUP_NAMES(mailx_hostname,reinstall) 0


lappend CHECK_SETUP_NAMES(index) "mail_to"
set CHECK_SETUP_NAMES(mail_to) "CHECK_REPORT_EMAIL_TO"
set CHECK_SETUP_NAMES(mail_to,reinstall) 0


lappend CHECK_SETUP_NAMES(index) "mail_cc"
set CHECK_SETUP_NAMES(mail_cc) "CHECK_REPORT_EMAIL_CC"
set CHECK_SETUP_NAMES(mail_cc,reinstall) 0


lappend CHECK_SETUP_NAMES(index) "enable_error_mails"
set CHECK_SETUP_NAMES(enable_error_mails) "CHECK_SEND_ERROR_MAILS"
set CHECK_SETUP_NAMES(enable_error_mails,reinstall) 0


lappend CHECK_SETUP_NAMES(index) "max_run_all_mails"
set CHECK_SETUP_NAMES(max_run_all_mails) "CHECK_MAX_ERROR_MAILS"
set CHECK_SETUP_NAMES(max_run_all_mails,reinstall) 0

lappend CHECK_SETUP_NAMES(index) "use_ssh"
set CHECK_SETUP_NAMES(use_ssh) "CHECK_USE_SSH"
set CHECK_SETUP_NAMES(use_ssh,reinstall) 2



global ts_user_config               ;# new testsuite user configuration array
global actual_ts_user_config_version      ;# actual user config version number
set    actual_ts_user_config_version "1.0"

# ts_user_config defaults
set parameter "version"
set ts_user_config($parameter)            "$actual_ts_user_config_version"
set ts_user_config($parameter,desc)       "Testuite user configuration setup"
set ts_user_config($parameter,default)    "$actual_ts_user_config_version"
set ts_user_config($parameter,setup_func) ""
set ts_user_config($parameter,onchange)   "stop"
set ts_user_config($parameter,pos)        1

set parameter "userlist"
set ts_user_config($parameter)            ""
set ts_user_config($parameter,desc)       "Grid Engine cluster user list"
set ts_user_config($parameter,default)    ""
set ts_user_config($parameter,setup_func) "user_config_$parameter"
set ts_user_config($parameter,onchange)   ""
set ts_user_config($parameter,pos)        2

set parameter "first_foreign_user"
set ts_user_config($parameter)            ""
set ts_user_config($parameter,desc)       "First testsuite cluster user name"
set ts_user_config($parameter,default)    ""
set ts_user_config($parameter,setup_func) "user_config_$parameter"
set ts_user_config($parameter,onchange)   ""
set ts_user_config($parameter,pos)        3

set parameter "second_foreign_user"
set ts_user_config($parameter)            ""
set ts_user_config($parameter,desc)       "Second testsuite cluster user name"
set ts_user_config($parameter,default)    ""
set ts_user_config($parameter,setup_func) "user_config_$parameter"
set ts_user_config($parameter,onchange)   ""
set ts_user_config($parameter,pos)        4
 
set parameter "first_foreign_group"
set ts_user_config($parameter)            ""
set ts_user_config($parameter,desc)       "First testsuite cluster user's group name"
set ts_user_config($parameter,default)    ""
set ts_user_config($parameter,setup_func) "user_config_$parameter"
set ts_user_config($parameter,onchange)   ""
set ts_user_config($parameter,pos)        5

set parameter "second_foreign_group"
set ts_user_config($parameter)            ""
set ts_user_config($parameter,desc)       "Second testsuite cluster user's group name"
set ts_user_config($parameter,default)    ""
set ts_user_config($parameter,setup_func) "user_config_$parameter"
set ts_user_config($parameter,onchange)   ""
set ts_user_config($parameter,pos)        6


global ts_host_config               ;# new testsuite host configuration array
global actual_ts_host_config_version      ;# actual host config version number
set    actual_ts_host_config_version "1.1"

# ts_host_config defaults
set parameter "version"
set ts_host_config($parameter)            "$actual_ts_host_config_version"
set ts_host_config($parameter,desc)       "Testuite host configuration setup"
set ts_host_config($parameter,default)    "$actual_ts_host_config_version"
set ts_host_config($parameter,setup_func) ""
set ts_host_config($parameter,onchange)   "stop"
set ts_host_config($parameter,pos)        1

set parameter "hostlist"
set ts_host_config($parameter)            ""
set ts_host_config($parameter,desc)       "Testsuite cluster host list"
set ts_host_config($parameter,default)    ""
set ts_host_config($parameter,setup_func) "host_config_$parameter"
set ts_host_config($parameter,onchange)   "install"
set ts_host_config($parameter,pos)        2




global ts_config                     ;# new testsuite configuration array
global actual_ts_config_version      ;# actual config version number
set actual_ts_config_version "1.2"


# ts_config defaults 
set ts_pos 1
set parameter "version"
set ts_config($parameter)            "$actual_ts_config_version"
set ts_config($parameter,desc)       "Testsuite configuration setup"
set ts_config($parameter,default)    "$actual_ts_config_version"
set ts_config($parameter,setup_func) ""
set ts_config($parameter,onchange)   "stop"
set ts_config($parameter,pos)        $ts_pos
incr ts_pos 1

set parameter "testsuite_root_dir"
set ts_config($parameter)            ""
set ts_config($parameter,desc)       "Testsuite's root directory"
set ts_config($parameter,default)    $CHECK_CURRENT_WORKING_DIR
set ts_config($parameter,setup_func) "config_testsuite_root_dir"
set ts_config($parameter,onchange)   "stop"
set ts_config($parameter,pos)        $ts_pos
incr ts_pos 1


set parameter "checktree_root_dir"
set ts_config($parameter)            ""
set ts_config($parameter,desc)       "Testsuite's checktree directory"
set ts_config($parameter,default)    ""   ;# depend on testsuite root dir 
set ts_config($parameter,setup_func) "config_checktree_root_dir"
set ts_config($parameter,onchange)   "stop"
set ts_config($parameter,pos)        $ts_pos
incr ts_pos 1

set parameter "results_dir"
set ts_config($parameter)            ""
set ts_config($parameter,desc)       "Testsuite's directory to save test results (html/txt files)"
set ts_config($parameter,default)    ""   ;# depend on testsuite root dir
set ts_config($parameter,setup_func) "config_$parameter"
set ts_config($parameter,onchange)   "stop"
set ts_config($parameter,pos)        $ts_pos
incr ts_pos 1

set parameter "use_ssh"
set ts_config($parameter)            ""
set ts_config($parameter,desc)       "Using ssh to connect to cluster hosts"
set ts_config($parameter,default)    "none"
set ts_config($parameter,setup_func) "config_$parameter"
set ts_config($parameter,onchange)   "stop"
set ts_config($parameter,pos)        $ts_pos
incr ts_pos 1


set parameter "source_dir"
set ts_config($parameter)            ""
set ts_config($parameter,desc)       "Path to Grid Engine source directory"
set ts_config($parameter,default)    ""   ;# depend on testsuite root dir
set ts_config($parameter,setup_func) "config_$parameter"
set ts_config($parameter,onchange)   "stop"
set ts_config($parameter,pos)        $ts_pos
incr ts_pos 1

set parameter "source_cvs_hostname"
set ts_config($parameter)            ""
set ts_config($parameter,desc)       "Host used for cvs commands"
set ts_config($parameter,default)    ""   ;# depend on testsuite root dir
set ts_config($parameter,setup_func) "config_$parameter"
set ts_config($parameter,onchange)   "stop"
set ts_config($parameter,pos)        $ts_pos
incr ts_pos 1

set parameter "source_cvs_release"
set ts_config($parameter)            ""
set ts_config($parameter,desc)       "Used cvs release tag"
set ts_config($parameter,default)    ""   ;# depend on testsuite root dir
set ts_config($parameter,setup_func) "config_$parameter"
set ts_config($parameter,onchange)   "stop"
set ts_config($parameter,pos)        $ts_pos
incr ts_pos 1

set parameter "host_config_file"
set ts_config($parameter)            ""
set ts_config($parameter,desc)       "Testsuite's global cluster host configuration file"
set ts_config($parameter,default)    $CHECK_CURRENT_WORKING_DIR/testsuite_host.conf
set ts_config($parameter,setup_func) "config_$parameter"
set ts_config($parameter,onchange)   "install"
set ts_config($parameter,pos)        $ts_pos
incr ts_pos 1

set parameter "user_config_file"
set ts_config($parameter)            ""
set ts_config($parameter,desc)       "Testsuite's global user configuration file"
set ts_config($parameter,default)    $CHECK_CURRENT_WORKING_DIR/testsuite_user.conf
set ts_config($parameter,setup_func) "config_$parameter"
set ts_config($parameter,onchange)   "install"
set ts_config($parameter,pos)        $ts_pos
incr ts_pos 1

set parameter "master_host"
set ts_config($parameter)            ""
set ts_config($parameter,desc)       "Grid Engine master host"
set ts_config($parameter,default)    ""
set ts_config($parameter,setup_func) "config_$parameter"
set ts_config($parameter,onchange)   "install"
set ts_config($parameter,pos)        $ts_pos
incr ts_pos 1

set parameter "execd_hosts"
set ts_config($parameter)            ""
set ts_config($parameter,desc)       "Grid Engine execution daemon hosts"
set ts_config($parameter,default)    ""
set ts_config($parameter,setup_func) "config_$parameter"
set ts_config($parameter,onchange)   "install"
set ts_config($parameter,pos)        $ts_pos
incr ts_pos 1

set parameter "submit_only_hosts"
set ts_config($parameter)            ""
set ts_config($parameter,desc)       "Grid Engine submit only hosts"
set ts_config($parameter,default)    ""
set ts_config($parameter,setup_func) "config_$parameter"
set ts_config($parameter,onchange)   "install"
set ts_config($parameter,pos)        $ts_pos
incr ts_pos 1

set parameter "add_compile_archs"
set ts_config($parameter)            ""
set ts_config($parameter,desc)       "Forced compilation for architectures"
set ts_config($parameter,default)    "none"
set ts_config($parameter,setup_func) "config_$parameter"
set ts_config($parameter,onchange)   ""
set ts_config($parameter,pos)        $ts_pos
incr ts_pos 1


set parameter "commd_port"
set ts_config($parameter)            ""
set ts_config($parameter,desc)       "Grid Engine COMMD_PORT"
set ts_config($parameter,default)    "7777"
set ts_config($parameter,setup_func) "config_$parameter"
set ts_config($parameter,onchange)   "install"
set ts_config($parameter,pos)        $ts_pos
incr ts_pos 1


set parameter "product_root"
set ts_config($parameter)            ""
set ts_config($parameter,desc)       "Grid Engine directory"
set ts_config($parameter,default)    ""
set ts_config($parameter,setup_func) "config_$parameter"
set ts_config($parameter,onchange)   "install"
set ts_config($parameter,pos)        $ts_pos
incr ts_pos 1


set parameter "product_type"
set ts_config($parameter)            ""
set ts_config($parameter,desc)       "Grid Engine product mode"
set ts_config($parameter,default)    "sge"
set ts_config($parameter,setup_func) "config_$parameter"
set ts_config($parameter,onchange)   "install"
set ts_config($parameter,pos)        $ts_pos
incr ts_pos 1

set parameter "product_feature"
set ts_config($parameter)            ""
set ts_config($parameter,desc)       "Grid Engine features"
set ts_config($parameter,default)    "none"
set ts_config($parameter,setup_func) "config_$parameter"
set ts_config($parameter,onchange)   "install"
set ts_config($parameter,pos)        $ts_pos
incr ts_pos 1

set parameter "l10n_test_locale"
set ts_config($parameter)            ""
set ts_config($parameter,desc)       "Specify localization environment (LANG)"
set ts_config($parameter,default)    "none"
set ts_config($parameter,setup_func) "config_$parameter"
set ts_config($parameter,onchange)   "stop"
set ts_config($parameter,pos)        $ts_pos
incr ts_pos 1

set parameter "aimk_compile_options"
set ts_config($parameter)            ""
set ts_config($parameter,desc)       "Aimk compile options"
set ts_config($parameter,default)    "-secure"
set ts_config($parameter,setup_func) "config_$parameter"
set ts_config($parameter,onchange)   "compile"
set ts_config($parameter,pos)        $ts_pos
incr ts_pos 1

set parameter "dist_install_options"
set ts_config($parameter)            ""
set ts_config($parameter,desc)       "Distribution install options"
set ts_config($parameter,default)    "-allall"
set ts_config($parameter,setup_func) "config_$parameter"
set ts_config($parameter,onchange)   "compile"
set ts_config($parameter,pos)        $ts_pos
incr ts_pos 1

set parameter "qmaster_install_options"
set ts_config($parameter)            ""
set ts_config($parameter,desc)       "Grid Engine qmaster install options"
set ts_config($parameter,default)    "none"
set ts_config($parameter,setup_func) "config_$parameter"
set ts_config($parameter,onchange)   "install"
set ts_config($parameter,pos)        $ts_pos
incr ts_pos 1

set parameter "execd_install_options"
set ts_config($parameter)            ""
set ts_config($parameter,desc)       "Grid Engine execd install options"
set ts_config($parameter,default)    "none"
set ts_config($parameter,setup_func) "config_$parameter"
set ts_config($parameter,onchange)   "install"
set ts_config($parameter,pos)        $ts_pos
incr ts_pos 1

set parameter "package_directory"
set ts_config($parameter)            ""
set ts_config($parameter,desc)       "Directory with Grid Engine pkgadd or zip file packages"
set ts_config($parameter,default)    "none"
set ts_config($parameter,setup_func) "config_$parameter"
set ts_config($parameter,onchange)   "compile"
set ts_config($parameter,pos)        $ts_pos
incr ts_pos 1

set parameter "package_type"
set ts_config($parameter)            ""
set ts_config($parameter,desc)       "Default package type to test"
set ts_config($parameter,default)    "tar"
set ts_config($parameter,setup_func) "config_$parameter"
set ts_config($parameter,onchange)   "compile"
set ts_config($parameter,pos)        $ts_pos
incr ts_pos 1

set parameter "dns_domain"
set ts_config($parameter)            ""
set ts_config($parameter,desc)       "Local DNS domain name"
set ts_config($parameter,default)    ""
set ts_config($parameter,setup_func) "config_$parameter"
set ts_config($parameter,onchange)   "stop"
set ts_config($parameter,pos)        $ts_pos
incr ts_pos 1

set parameter "dns_for_install_script"
set ts_config($parameter)            ""
set ts_config($parameter,desc)       "DNS domain name used in Grid Engine installation procedure"
set ts_config($parameter,default)    "none"
set ts_config($parameter,setup_func) "config_$parameter"
set ts_config($parameter,onchange)   "install"
set ts_config($parameter,pos)        $ts_pos
incr ts_pos 1

set parameter "mailx_host"
set ts_config($parameter)            ""
set ts_config($parameter,desc)       "Name of host used for sending mails (mailx must work on this host)"
set ts_config($parameter,default)    ""
set ts_config($parameter,setup_func) "config_$parameter"
set ts_config($parameter,onchange)   ""
set ts_config($parameter,pos)        $ts_pos
incr ts_pos 1

set parameter "report_mail_to"
set ts_config($parameter)            ""
set ts_config($parameter,desc)       "E-mail address used for report mails"
set ts_config($parameter,default)    ""
set ts_config($parameter,setup_func) "config_$parameter"
set ts_config($parameter,onchange)   ""
set ts_config($parameter,pos)        $ts_pos
incr ts_pos 1

set parameter "report_mail_cc"
set ts_config($parameter)            ""
set ts_config($parameter,desc)       "E-mail address used for cc report mails"
set ts_config($parameter,default)    "none"
set ts_config($parameter,setup_func) "config_$parameter"
set ts_config($parameter,onchange)   ""
set ts_config($parameter,pos)        $ts_pos
incr ts_pos 1

set parameter "enable_error_mails"
set ts_config($parameter)            ""
set ts_config($parameter,desc)       "Max number of e-mails send through one testsuite session"
set ts_config($parameter,default)    "400"
set ts_config($parameter,setup_func) "config_$parameter"
set ts_config($parameter,onchange)   ""
set ts_config($parameter,pos)        $ts_pos
incr ts_pos 1


# some useful functions for test implementation



# 
#                                                             max. column:     |
#****** check/add_proc_error() ******
# 
#  NAME
#     add_proc_error -- append testsuite error message
#
#  SYNOPSIS
#     add_proc_error { proc_name result text } 
#
#  FUNCTION
#     This procedure adds a new error to the global error arrays for the global 
#     procedures.  
#
#     So a test programmer doesn't have to set the error states after calling 
#     a global procedure which uses add_proc_error. Each global procedure 
#     set the error state by itself. 
#
#     The test run will report ALL global errors and doesn't set the test run 
#     to a correct state if such an error is reported. 
#
#     Some global procedures have an optional flag to switch off the global 
#     error report. For some cases it is necessary to turn off the error 
#     reporting. (e.g. forced timeout test)
#
#  INPUTS
#     proc_name - name of the calling procedure
#     result    - error state (e.g. -1)
#     text      - error text (e.g. "open file xxx failed)
#
#  RESULT
#     no result
#
#  SEE ALSO
#     check/set_error
#*******************************
proc add_proc_error { proc_name result text } {
   global CHECK_CUR_PROC_ERRORS CHECK_CUR_PROC_RESULTS CHECK_CUR_PROC_NAME CHECK_OUTPUT check_name CHECK_TESTSUITE_ROOT
   global CHECK_ARCH CHECK_HOST CHECK_PRODUCT_ROOT CHECK_ACT_LEVEL CHECK_CORE_MASTER CHECK_CORE_EXECD
   global CHECK_USER CHECK_TESTSUITE_ROOT CHECK_SCRIPT_FILE_DIR check_name

   lappend CHECK_CUR_PROC_RESULTS $result
   set new_error ""
   lappend new_error "$proc_name|$text|$check_name|$CHECK_CUR_PROC_NAME"
   lappend CHECK_CUR_PROC_ERRORS $new_error

   if { $check_name != "setup" } {
      show_proc_error $result $new_error
   } else {
      puts $CHECK_OUTPUT [ create_error_message $new_error ]
   }
}

#                                                             max. column:     |
#****** check/show_proc_error() ******
# 
#  NAME
#     show_proc_error -- ??? 
#
#  SYNOPSIS
#     show_proc_error { result new_error } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#     result    - ??? 
#     new_error - ??? 
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc show_proc_error { result new_error } {
   global CHECK_CUR_PROC_ERRORS CHECK_CUR_PROC_RESULTS CHECK_CUR_PROC_NAME CHECK_OUTPUT check_name CHECK_TESTSUITE_ROOT
   global CHECK_ARCH CHECK_HOST CHECK_PRODUCT_ROOT CHECK_ACT_LEVEL CHECK_CORE_MASTER CHECK_CORE_EXECD
   global CHECK_SEND_ERROR_MAILS

   if { $result != 0 } {
      set category "error"
      if { $result == -3 } {
         set category "unsupported test warning"
      }
      puts $CHECK_OUTPUT ">>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>"
      puts $CHECK_OUTPUT ">>> $category"
      puts $CHECK_OUTPUT ">>> runlevel    : \"[get_run_level_name $CHECK_ACT_LEVEL]\", ($CHECK_ACT_LEVEL)"
      puts $CHECK_OUTPUT ">>> "
      set error_output [ create_error_message $new_error ]
      puts $CHECK_OUTPUT $error_output 


      flush $CHECK_OUTPUT
      if { $CHECK_SEND_ERROR_MAILS == 1 } {
         append mail_body "\nDate                     : [exec date]\n"
         append mail_body "testsuite root directory : \"$CHECK_TESTSUITE_ROOT\"\n"
         append mail_body "check host               : \"$CHECK_HOST\"\n"
         append mail_body "architecture             : \"$CHECK_ARCH\"\n"
         append mail_body "product version          : \"[get_version_info]\"\n"
         append mail_body "product root directory   : \"$CHECK_PRODUCT_ROOT\"\n"
         append mail_body "master host              : \"$CHECK_CORE_MASTER\"\n"
         append mail_body "execution hosts          : \"$CHECK_CORE_EXECD\"\n\n"
         append mail_body "-----------------------------------------------------\n\n"
         append mail_body "check_name  : \"$check_name\"\n"
         append mail_body "category    : \"$category\"\n"
         append mail_body "runlevel    : \"[get_run_level_name $CHECK_ACT_LEVEL]\", ($CHECK_ACT_LEVEL)\n"
         append mail_body $error_output
         catch {
            foreach level "1 2 3 4" {
               upvar $level expect_out out
               if {[info exists out]} {
                  append mail_body "----- expect buffer in upper level $level --------\n"
                  foreach i [array names out] {
                     append mail_body "$i:\t$out($i)\n"
                  }
               }
            }
         }
         mail_report "testsuite $category - $check_name" $mail_body
      }
    }
}

#                                                             max. column:     |
#****** check/create_error_message() ******
# 
#  NAME
#     create_error_message -- ??? 
#
#  SYNOPSIS
#     create_error_message { error_array } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#     error_array - ??? 
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc create_error_message { error_array} {

  set catch_return [catch {
  set err_string [lindex $error_array 0]
  } ]
  if { $catch_return != 0 } {
     set err_string "catch error: error reading error_array"
  }
  
  set err_complete [ split $err_string "|" ]
  set err_procedure [ lindex $err_complete 0 ]
  set err_text      [ lindex $err_complete 1 ]
  set err_checkname [ lindex $err_complete 2 ]
  set err_calledby  [ lindex $err_complete 3 ]
  set output ">>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>\n"
  append output ">>> check \"$err_checkname\", procedure \"$err_procedure\"\n"
  if { [ string compare $err_calledby $err_procedure ] != 0 } {
     append output ">>> called from \"$err_calledby\":\n"
  }
  append output "\"$err_text\"\n"
  append output ">>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>\n\n"

  return $output
}

#                                                             max. column:     |
#****** check/have_ssh_access() ******
# 
#  NAME
#     have_ssh_access -- is ssh accessable ?
#
#  SYNOPSIS
#     have_ssh_access { } 
#
#  FUNCTION
#     This procedure tries to get a ssh (secure shell) connection to each execd 
#     host from the cluster. The result of this test is stored in a global 
#     variable so the next call will not cause the connection test again.
#
#  INPUTS
#
#  RESULT
#     0: no ssh access
#     1: ok
#
#  SEE ALSO
#     ???/???
#*******************************
proc have_ssh_access {} {
  global CHECK_CORE_EXECD open_spawn_buffer CHECK_OUTPUT have_ssh_access_state CHECK_USE_SSH CHECK_HOST


  if { $have_ssh_access_state != -1 } {
     return $have_ssh_access_state
  }

  if { $CHECK_USE_SSH == 0 } {
     set have_ssh_access_state 0
     return $have_ssh_access_state
  }

  set run_again 0
  if { [ info exists CHECK_CORE_EXECD ] != 1 } {
     puts $CHECK_OUTPUT "no execd hosts defined, checking only local ssh connection"
     set run_again 1
     set host_array $CHECK_HOST 
  } else {
     set host_array $CHECK_CORE_EXECD
  }

  log_user 0
  set have_complete_access 1
  
  foreach elem $host_array { 
 
     set catch_state [ catch {

        puts $CHECK_OUTPUT "trying ssh -l root $elem id"

        set id [ open_spawn_process "ssh" "-l" "root" "$elem" "id"]
        set sp_id [ lindex $id 1 ] 
 
        set timeout 30
        set end_val 0
        set have_access 0
        while { $end_val == 0} {
           log_user 0
           expect {
               -i $sp_id full_buffer {
                  add_proc_error "have_ssh_access" "-1" "buffer overflow please increment CHECK_EXPECT_MATCH_MAX_BUFFER value"
               }

               -i $sp_id "uid*0*root" {
                  log_user 1 
                  puts $CHECK_OUTPUT "--> having ssh access to host $elem"
                  set end_val 1
                  set have_access 1
               }
               -i $sp_id "assword" {
                  set end_val 1
               }
               -i $sp_id timeout {
                  log_user 1 
                  puts $CHECK_OUTPUT "--> timeout waiting to get root access"
                  set end_val 1
               }
               -i $sp_id eof {
                  log_user 1 
                  puts $CHECK_OUTPUT "--> end of file dedected"
                  set end_val 1
               }
           }
        }
        set log_user 0
        close_spawn_process $id 1
        if { $have_access != 1 } {
            log_user 1
            set have_complete_access 0
            puts $CHECK_OUTPUT "--> no ssh access to host $elem"
            add_proc_error "have_ssh_access" "-1" "--> no ssh access to host $elem"
        }
     } ] ;# end of chatch
     if { $catch_state != 0} {
        puts $CHECK_OUTPUT "--> no ssh access to host $elem (maybe no ssh installed)"
        add_proc_error "have_ssh_access" "-1" "--> no ssh access to host $elem (maybe no ssh installed)"
        set have_complete_access 0
     }
  }
  log_user 1
  if { $run_again == 0 } {
     set have_ssh_access_state $have_complete_access
  }
  return $have_complete_access
}

#****** check/set_root_passwd() ******
# 
#  NAME
#     set_root_passwd -- ask user for root password
#
#  SYNOPSIS
#     set_root_passwd { } 
#
#  FUNCTION
#     This procedure reads in the root password from stdin. If the root password 
#     is not used ( ssh access garanted) the procedure returns immediately.
#     The root password is tested with an id call as root on the local machine.
#
#  INPUTS
#
#  SEE ALSO
#     check/have_root_passwd
#     check/get_root_passwd
#*******************************
proc set_root_passwd {} {
  global CHECK_ROOT_PASSWORD CHECK_OUTPUT CHECK_HOST CHECK_ADMIN_USER_SYSTEM

  if { $CHECK_ADMIN_USER_SYSTEM != 0 } {
     puts $CHECK_OUTPUT "--> running without root access"
     set CHECK_ROOT_PASSWORD "none"
     return
  }
  set result "no password" 
  puts "root access needed, please enter root password: "
  if { [have_ssh_access] == 0 } {
     stty -echo
     set  CHECK_ROOT_PASSWORD [wait_for_enter 1]
#     gets stdin CHECK_ROOT_PASSWORD
     stty echo
     if { [ string compare "" $CHECK_ROOT_PASSWORD ] == 0 } {
        set CHECK_ROOT_PASSWORD "none"
        puts $CHECK_OUTPUT "--> root password not set!"
     } else {
        puts $CHECK_OUTPUT "--> testing root access ..."
        set result [ start_remote_prog $CHECK_HOST "root" "id" "" ]
     }
  }
  
  if {[string first "root" $result] < 0 } {
     puts $CHECK_OUTPUT "--> id as root output:\n$result"
     puts $CHECK_OUTPUT "--> no root access"
     puts $CHECK_OUTPUT "enter \"noroot\" to start testsuite without root access\nOR\npress >ENTER< to type in the root password again"
     set user_input [wait_for_enter 1]
     if { [ string compare "noroot" $user_input ] != 0 } {
         set_root_passwd
         return
     } else { 
         set CHECK_ADMIN_USER_SYSTEM 1

     }
  } else {
     puts $CHECK_OUTPUT "--> id as root output:\n$result"
  }
 

  puts $CHECK_OUTPUT "starting now ..."
  flush $CHECK_OUTPUT
}

# 0 no action
# 1 new pre_install
# 2 only shutdown system
proc get_setup_change_state {} {
   global CHECK_OUTPUT CHECK_SETUP_CHANGES CHECK_SETUP_NAMES
   global CHECK_SETTINGS_VERSION CHECK_CURRENT_SETTINGS_VERSION
   global CHECK_CHECKTREE_ROOT CHECK_CORE_MASTER CHECK_CORE_EXECD CHECK_CORE_PROCESSORS
   global CHECK_SUBMIT_ONLY_HOSTS CHECK_COMMD_PORT CHECK_TESTSUITE_ROOT
   global CHECK_MAIN_RESULTS_DIR CHECK_PRODUCT_TYPE 
   global CHECK_PRODUCT_FEATURE CHECK_PRODUCT_ROOT CHECK_DEFAULTS_FILE
   global CHECK_SOURCE_DIR CHECK_SOURCE_HOSTNAME CHECK_SOURCE_COMPILE_HOSTS
   global CHECK_AIMK_COMPILE_OPTIONS CHECK_DIST_INSTALL_OPTIONS
   global CHECK_PACKAGE_DIRECTORY CHECK_PACKAGE_TYPE
   global CHECK_QMASTER_INSTALL_OPTIONS CHECK_EXECD_INSTALL_OPTIONS
   global CHECK_DNS_DOMAINNAME CHECK_REMOTE_ENVIRONMENT
   global CHECK_FIRST_FOREIGN_SYSTEM_USER CHECK_SECOND_FOREIGN_SYSTEM_USER 
   global CHECK_FIRST_FOREIGN_SYSTEM_GROUP CHECK_SECOND_FOREIGN_SYSTEM_GROUP
   global CHECK_DEFAULT_DOMAIN
   global CHECK_MAILX_HOST 
   global CHECK_REPORT_EMAIL_TO CHECK_REPORT_EMAIL_CC  CHECK_USE_SSH CHECK_SOURCE_CVS_RELEASE
   global CHECK_OUTPUT CHECK_SETUP_NAMES CHECK_CONFIG_DIR CHECK_SEND_ERROR_MAILS
   global CHECK_MAX_ERROR_MAILS CHECK_HOST CHECK_USER
   global CHECK_SETUP_CHANGES

   set restart 0
   set pre_install 0

   foreach change $CHECK_SETUP_CHANGES {
      puts $CHECK_OUTPUT "cange of $change"
      puts $CHECK_OUTPUT "  old value: \"$CHECK_SETUP_NAMES($change,old)\""
      puts $CHECK_OUTPUT "  new value: \"[ set $CHECK_SETUP_NAMES($change)]\""

      switch -- $change {
         "qmaster_host" { 
            set help $CHECK_CORE_MASTER
            set  CHECK_CORE_MASTER $CHECK_SETUP_NAMES($change,old)
            puts $CHECK_OUTPUT "shutting down old system ..."  
            shutdown_core_system
            set CHECK_CORE_MASTER $help
         }
         "list_of_execution_hosts" {
            set help $CHECK_CORE_EXECD
            set  CHECK_CORE_EXECD  $CHECK_SETUP_NAMES($change,old)
            puts $CHECK_OUTPUT "shutting down old system ..."
            shutdown_core_system
            set CHECK_CORE_EXECD $help
         }
      }
 
      switch -- $CHECK_SETUP_NAMES($change,reinstall) {
         1 { incr pre_install  }
         2 { incr restart }
      }
   }
   set CHECK_SETUP_CHANGES ""
   if { $restart == 0 && $pre_install == 0 } { return 0 }
   if { $pre_install > 0 } { return 1 }
   if { $restart > 0 } { return 2 }

}


#                                                             max. column:     |
#****** check/have_root_passwd() ******
# 
#  NAME
#     have_root_passwd -- is root password available ?
#
#  SYNOPSIS
#     have_root_passwd { } 
#
#  FUNCTION
#     test if root password was typed in 
#
#  INPUTS
#     0  : root password should be ok
#     -1 : no root access
#  RESULT
#     
#
#  SEE ALSO
#     check/set_root_passwd
#     check/get_root_passwd
#*******************************
proc have_root_passwd {} {
  global CHECK_ROOT_PASSWORD

  if { [have_ssh_access] == 1 } {
     puts "--> ssh access ok" 
     return 0
  }

  if { [string compare "none" $CHECK_ROOT_PASSWORD ] == 0 } {
     puts "you have no ssh access and no root password"
     return -1
  }
  return 0
}

#                                                             max. column:     |
#****** check/get_root_passwd() ******
# 
#  NAME
#     get_root_passwd -- return root password 
#
#  SYNOPSIS
#     get_root_passwd { } 
#
#  FUNCTION
#     This procedure returns the root password, typed in by the user.
#
#  INPUTS
#
#  RESULT
#     string with root password
#
#  SEE ALSO
#     check/have_root_passwd
#     check/set_root_passwd
#*******************************
proc get_root_passwd {} {
  global CHECK_ROOT_PASSWORD
  
  if { [ string compare "none" $CHECK_ROOT_PASSWORD ] == 0 } {
     add_proc_error "get_root_passwd" "-2" "root password not set"
  }

  return $CHECK_ROOT_PASSWORD    
}





#                                                  max. column:     |
#****** check/mail_report() ******
# 
#  NAME
#     mail_report -- send mail
#
#  SYNOPSIS
#     mail_report { subject body } 
#
#  FUNCTION
#     This procedure sends an e-mail to the e-mail-address configured
#     with the global variables CHECK_REPORT_EMAIL_CC  and 
#     CHECK_REPORT_EMAIL_TO. Subject and body of the mail is taken 
#     from the parameters subject and body.
#
#  INPUTS
#     subject - e-mail subject text
#     body    - e-mail body text
#
#  SEE ALSO
#     check/send_mail
#*******************************
proc mail_report { subject body } {
  global CHECK_REPORT_EMAIL_TO CHECK_REPORT_EMAIL_CC CHECK_OUTPUT

  if { [string compare $CHECK_REPORT_EMAIL_TO "none"] == 0 } {
     puts $CHECK_OUTPUT "--> mail_report - no mail address"
     return
  }

  set mail_cc ""
  if { [string compare $CHECK_REPORT_EMAIL_CC "none"] != 0 } {
      set mail_cc $CHECK_REPORT_EMAIL_CC
  }

  send_mail $CHECK_REPORT_EMAIL_TO $mail_cc $subject $body 
}



#                                                             max. column:     |
#****** check/send_mail() ******
# 
#  NAME
#     send_mail -- send mail  
#
#  SYNOPSIS
#     send_mail { address cc subject body } 
#
#  FUNCTION
#     This procedure calls the mailx binary by using remote shell to 
#     send an e-mail. 
#
#  INPUTS
#     address - e-mail address
#     cc      - e-mail CC address
#     subject - e-mail subject text  
#     body    - e-mail body text 
#
#  SEE ALSO
#     check/mail_report
#*******************************
proc send_mail { address cc subject body } {

  global CHECK_TESTSUITE_ROOT CHECK_MAILX_HOST CHECK_OUTPUT
  global CHECK_MAILS_SENT CHECK_ENABLE_MAIL CHECK_USER CHECK_MAX_ERROR_MAILS
  global write_mail_to_file CHECK_MAIL_OUTPUT_FILE CHECK_ENABLE_MAIL


  if { $write_mail_to_file != 0 } {
     set fd [ open $CHECK_MAIL_OUTPUT_FILE "a" ]
     puts $fd "-=*************************************************************=-"
     puts $fd "Grid Engine Version: [get_version_info]"
     puts $fd "Subject            : $subject"
     puts $fd "-=*************************************************************=-"
     puts $fd "$body"
     puts $fd "-=*=-"
     flush $fd
     close $fd 
     puts $CHECK_OUTPUT "Added entry in mail output file $CHECK_MAIL_OUTPUT_FILE"
     return
  }

  set new_subject "[get_version_info] - $subject"

  if { $CHECK_ENABLE_MAIL != 1 } {
     puts $CHECK_OUTPUT "mail sending disabled, mails sent: $CHECK_MAILS_SENT"
     puts $CHECK_OUTPUT "mail new_subject: $new_subject"
     puts $CHECK_OUTPUT "mail body:"
     puts $CHECK_OUTPUT "$body"
     return
  }


  file delete "$CHECK_TESTSUITE_ROOT/mailbody_testsuite_tmp" 

  set output_file [ open "$CHECK_TESTSUITE_ROOT/mailbody_testsuite_tmp" "w"]
  puts $output_file $body
  flush $output_file
  close $output_file

  set file_size 0
   while { $file_size == 0 } {
      catch { set file_size [file size "$CHECK_TESTSUITE_ROOT/mailbody_testsuite_tmp"]}
      if { $file_size == 0 } { 
         puts $CHECK_OUTPUT "--> file size of \"$CHECK_TESTSUITE_ROOT/mailbody_testsuite_tmp\": $file_size ; waiting for filesize > 0"
         sleep 1
      }
   }



  catch { exec "touch" "$CHECK_TESTSUITE_ROOT/mailbody_testsuite_tmp" } result
  catch { exec "chmod" "0755" "$CHECK_TESTSUITE_ROOT/mailbody_testsuite_tmp" } result

  if { [string compare $cc "none"] != 0 } {
     set mail_args "-s \"$new_subject\" -c \"$cc\" \"$address\" < \"$CHECK_TESTSUITE_ROOT/mailbody_testsuite_tmp\""
  } else {
     set mail_args "-s \"$new_subject\" \"$address\" < \"$CHECK_TESTSUITE_ROOT/mailbody_testsuite_tmp\""
  }
  set mail_output [ start_remote_prog $CHECK_MAILX_HOST $CHECK_USER "mailx" "$mail_args" prg_exit_state 60 0 "" 1 0 ]

  if { $prg_exit_state != 0 } {
     puts $CHECK_OUTPUT "--> send_mail - could not send mail:\n$mail_output"
  } else {
     puts $CHECK_OUTPUT "--> send_mail - mail sent to $address"
     incr CHECK_MAILS_SENT 1
     if { $CHECK_MAILS_SENT == $CHECK_MAX_ERROR_MAILS } {
        if { [string compare $cc "none"] != 0 } {
           set mail_args "-s \"max mail count reached\" -c \"$cc\" \"$address\" < \"$CHECK_TESTSUITE_ROOT/mailbody_testsuite_tmp\""
        } else {
           set mail_args "-s \"max mail count reached\" \"$address\" < \"$CHECK_TESTSUITE_ROOT/mailbody_testsuite_tmp\""
        }
        start_remote_prog $CHECK_MAILX_HOST $CHECK_USER "mailx" "$mail_args" prg_exit_state 60 0 "" 1 0 
        set CHECK_ENABLE_MAIL 0
     }  
  }
  file delete "$CHECK_TESTSUITE_ROOT/mailbody_testsuite_tmp" 


}




# This procedure simply sets the global variables check_errno 
# and check_errstr to the given parameters. It 
#                                                             max. column:     |
#****** check/set_error() ******
# 
#  NAME
#     set_error -- set error for current check 
#
#  SYNOPSIS
#     set_error { erno errtext } 
#
#  FUNCTION
#     This procedure simply sets the global variables check_errno and 
#     check_errstr to the given parameters. Beyond it the procedure 
#     add_proc_error is called in order to append the errors to the global error 
#     list.
#
#  INPUTS
#     erno    - integer
#               0  = no error
#               -1 = error, but the check will run till end
#               -2 = error, the current check will stop (no further check function
#                    is called)
#               -3 = warning, (e.g. test can not run on this host)
#
#     errtext - short error description
#
#
#  EXAMPLE
#     set_error 0 "ok"  ;# Test is "OK"
#
#  SEE ALSO
#     check/add_proc_error
#*******************************
proc set_error {erno errtext} {
  global check_errno 
  global check_errstr CHECK_CUR_PROC_RESULTS
  global set_error_proc_called

  set set_error_proc_called 1
  set check_errno $erno
  set check_errstr $errtext

  add_proc_error "set_error" $erno $errtext

  if { $check_errno == 0 } {
    foreach element $CHECK_CUR_PROC_RESULTS {
      if { $element != 0 && $element != -3 } {   ;# there was a former error in this test !!
         set check_errno -1
         set check_errstr "error!"
      }
    }
  }
}


#                                                             max. column:     |
#****** check/save_defaults() ******
# 
#  NAME
#     save_defaults -- ??? 
#
#  SYNOPSIS
#     save_defaults { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc save_defaults {} {
  global CHECK_SETTINGS_VERSION
  global CHECK_CHECKTREE_ROOT CHECK_CORE_MASTER CHECK_CORE_EXECD 
  global CHECK_CORE_PROCESSORS CHECK_SUBMIT_ONLY_HOSTS 
  global CHECK_COMMD_PORT CHECK_TESTSUITE_ROOT
  global CHECK_MAIN_RESULTS_DIR CHECK_PRODUCT_TYPE 
  global CHECK_PRODUCT_FEATURE CHECK_PRODUCT_ROOT CHECK_DEFAULTS_FILE
  global CHECK_SOURCE_DIR CHECK_SOURCE_HOSTNAME CHECK_SOURCE_COMPILE_HOSTS
  global CHECK_AIMK_COMPILE_OPTIONS CHECK_DIST_INSTALL_OPTIONS 
  global CHECK_PACKAGE_DIRECTORY CHECK_PACKAGE_TYPE
  global CHECK_QMASTER_INSTALL_OPTIONS CHECK_EXECD_INSTALL_OPTIONS
  global CHECK_DNS_DOMAINNAME CHECK_REMOTE_ENVIRONMENT
  global CHECK_FIRST_FOREIGN_SYSTEM_USER CHECK_SECOND_FOREIGN_SYSTEM_USER 
  global CHECK_FIRST_FOREIGN_SYSTEM_GROUP CHECK_SECOND_FOREIGN_SYSTEM_GROUP
  global CHECK_DEFAULT_DOMAIN
  global CHECK_MAILX_HOST CHECK_OUTPUT
  global CHECK_REPORT_EMAIL_TO CHECK_REPORT_EMAIL_CC  CHECK_USE_SSH CHECK_SOURCE_CVS_RELEASE
  global CHECK_CONFIG_DIR CHECK_SEND_ERROR_MAILS CHECK_MAX_ERROR_MAILS

  set data ""
  lappend data $CHECK_SETTINGS_VERSION
  lappend data $CHECK_TESTSUITE_ROOT
  lappend data $CHECK_CHECKTREE_ROOT
  lappend data $CHECK_CORE_MASTER
  lappend data $CHECK_CORE_EXECD
  lappend data $CHECK_CORE_PROCESSORS
  if { $CHECK_SETTINGS_VERSION >= 3 } {
     lappend data $CHECK_SUBMIT_ONLY_HOSTS
  }
  lappend data $CHECK_COMMD_PORT
  lappend data $CHECK_MAIN_RESULTS_DIR
  lappend data $CHECK_PRODUCT_TYPE
  if { $CHECK_SETTINGS_VERSION >= 6 } {
     lappend data $CHECK_PRODUCT_FEATURE
  }
  lappend data $CHECK_PRODUCT_ROOT 
  lappend data $CHECK_SOURCE_DIR 
  lappend data $CHECK_SOURCE_HOSTNAME
  lappend data $CHECK_SOURCE_COMPILE_HOSTS
  lappend data $CHECK_AIMK_COMPILE_OPTIONS
  lappend data $CHECK_DIST_INSTALL_OPTIONS

  if { $CHECK_SETTINGS_VERSION >= 7 } {
     lappend data $CHECK_PACKAGE_DIRECTORY
     lappend data $CHECK_PACKAGE_TYPE
  }

  if { $CHECK_SETTINGS_VERSION >= 2 } {
     lappend data $CHECK_QMASTER_INSTALL_OPTIONS
     lappend data $CHECK_EXECD_INSTALL_OPTIONS 
  }
  if { $CHECK_SETTINGS_VERSION >= 4 } {
     lappend data $CHECK_DNS_DOMAINNAME
     lappend data $CHECK_REMOTE_ENVIRONMENT
  }
  lappend data $CHECK_FIRST_FOREIGN_SYSTEM_USER
  lappend data $CHECK_SECOND_FOREIGN_SYSTEM_USER
  lappend data $CHECK_FIRST_FOREIGN_SYSTEM_GROUP
  lappend data $CHECK_SECOND_FOREIGN_SYSTEM_GROUP
  lappend data $CHECK_DEFAULT_DOMAIN
  lappend data $CHECK_MAILX_HOST
  lappend data $CHECK_REPORT_EMAIL_TO
  lappend data $CHECK_REPORT_EMAIL_CC
  lappend data $CHECK_SEND_ERROR_MAILS
  lappend data $CHECK_MAX_ERROR_MAILS
  lappend data $CHECK_USE_SSH
  lappend data $CHECK_SOURCE_CVS_RELEASE 
  lappend data $CHECK_CONFIG_DIR

  set output [open "$CHECK_DEFAULTS_FILE" "w"]  
  puts $output "$data"
  close $output
  get_version_info
  debug_puts "saved $data"
}


#****** check/get_testsuite_root_dir_from_file() *******************************
#  NAME
#     get_testsuite_root_dir_from_file() -- get testsuite root directory
#
#  SYNOPSIS
#     get_testsuite_root_dir_from_file { filename } 
#
#  FUNCTION
#     This procedure greps for the testsuite configuration in the given file.
#     It only returns the testsuite root directory. This function is used
#     to setup the CHECK_TESTSUITE_ROOT variable before sourcing the
#     file procedures script in the tcl_directory.
#
#  INPUTS
#     filename - path to testsuite configuration file (defaults file)
#
#  RESULT
#     testsuite root directory path
#
#  SEE ALSO
#     check/setup2
#     check/source_procedures
#*******************************************************************************
proc get_testsuite_root_dir_from_file { filename } {

   if { [file isfile $filename] != 1 } {
      return "no_such_file" 
   }
   set file [open $filename "r"]
   set found_object 0
   set next 0
   while { [gets $file line] >= 0 } {
      if { $next == 1 } {
         break
      }
      if { [ string first "OBJ_START:testsuite configuration:" $line] >= 0 } { 
         set found_object 1
      }
      if { [ string first ":testsuite_root_dir:" $line] >= 0 && $found_object == 1 } {
         set next 1
      }
   }
   if { $next == 1 } {
      set start [ string first ":" $line ]
      set end   [ string last ":" $line ]   
      incr start 1
      incr end -1
      return [string range $line $start $end]
   } 
   close $file
   return "testsuite_root_dir_not_found"
}

#                                                             max. column:     |
#****** check/source_procedures() ******
# 
#  NAME
#     source_procedures -- ??? 
#
#  SYNOPSIS
#     source_procedures { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc source_procedures {} {
  global CHECK_TESTSUITE_ROOT CHECK_OUTPUT CHECK_TCL_SCRIPTFILE_DIR be_quiet CHECK_DEFAULTS_FILE check_name
  puts $CHECK_OUTPUT "------ SOURCEING TCL SCRIPT FILES --------------"
  puts $CHECK_OUTPUT "testsuite root: $CHECK_TESTSUITE_ROOT"
  if { [ file isfile $CHECK_TESTSUITE_ROOT/$CHECK_TCL_SCRIPTFILE_DIR/file_procedures.tcl ] != 1 } {

     set CHECK_TESTSUITE_ROOT [get_testsuite_root_dir_from_file $CHECK_DEFAULTS_FILE]
     if { [ file isfile $CHECK_TESTSUITE_ROOT/$CHECK_TCL_SCRIPTFILE_DIR/file_procedures.tcl ] != 1 } {
        puts $CHECK_OUTPUT "testsuite root: $CHECK_TESTSUITE_ROOT"
        puts $CHECK_OUTPUT "could not open file: $CHECK_TESTSUITE_ROOT/$CHECK_TCL_SCRIPTFILE_DIR/file_procedures.tcl"
        exit -1
     }
     puts $CHECK_OUTPUT "reading testsuite root directory from defaults file \"$CHECK_DEFAULTS_FILE\""
     puts $CHECK_OUTPUT "testsuite root: $CHECK_TESTSUITE_ROOT"
  }
  source $CHECK_TESTSUITE_ROOT/$CHECK_TCL_SCRIPTFILE_DIR/file_procedures.tcl
  set tcl_files [ get_file_names "$CHECK_TESTSUITE_ROOT/$CHECK_TCL_SCRIPTFILE_DIR" "*.tcl" ]
  foreach elem $tcl_files {
     if { $be_quiet == 0 } { 
        puts $CHECK_OUTPUT "--> source tcl file \"$elem\""
     }
     source $CHECK_TESTSUITE_ROOT/$CHECK_TCL_SCRIPTFILE_DIR/$elem
  }   
  puts $CHECK_OUTPUT "------ SOURCEING TCL SCRIPT FILES DONE ---------"
}

#                                                             max. column:     |
#****** check/edit_defaults() ******
# 
#  NAME
#     edit_defaults -- ??? 
#
#  SYNOPSIS
#     edit_defaults { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc edit_defaults {} {
  global CHECK_OUTPUT CHECK_DEFAULTS_FILE CHECK_HOST CHECK_CONFIG_DIR
  global CHECK_TESTSUITE_ROOT CHECK_SCRIPT_FILE_DIR
  global env

  load_defaults
  set return_value -1
  if { [ write_edit_defaults_file "/tmp/testsuite_tmp_defaults_file" ] != 0 } {
     puts $CHECK_OUTPUT "error open file \"$def_edit_file\" for writing"
     return -1
  }

  puts $def_edit_file
  set exit_edit_loop 0
  while { $exit_edit_loop == 0 } {
     if { $CHECK_CONFIG_DIR != "" } {
        set vim_binary [get_binary_path "$CHECK_HOST" "vim"]
     } else {
        puts $CHECK_OUTPUT "config directory path not set ..."
        set env_variable "EDITOR"
        puts $CHECK_OUTPUT "checking for $env_variable environment setting..."
        if { [info exists env($env_variable)] } {
           puts $CHECK_OUTPUT "$env_variable=$env($env_variable)"
           set vim_binary $env($env_variable)
           puts $CHECK_OUTPUT "using environment $env_variable"
        } else {
           puts $CHECK_OUTPUT "environment $env_variable not set, using default"
           set vim_binary "vim"
        }
        set catch_return [ catch { eval exec which $vim_binary } catch_value ]
        puts $CHECK_OUTPUT "exec \"which $vim_binary\" returns: $catch_return"
        if { $catch_return != 0 } {
           puts $CHECK_OUTPUT "error executing \"which $vim_binary\"!!!"
        } else {
           set vim_binary $catch_value
        }
        if { [file exists $vim_binary] != 1 } {
           puts $CHECK_OUTPUT "could not find binary"
           puts $CHECK_OUTPUT "$vim_binary"
           exit 1
        }
        puts $CHECK_OUTPUT "using \"$vim_binary\" as editor"
     }
     set env(EDITOR) $vim_binary
     set id [ open_spawn_process $vim_binary "$def_edit_file" ]
     interact -o -i [lindex $id 1]
     set exit_state [ close_spawn_process $id ]

     if { $exit_state == 0 } {
        set read_return [ read_edit_defaults_file "$def_edit_file" ] 
        if { $read_return >= 0 } { 
           if { $read_return == 0 } {
              puts $CHECK_OUTPUT "no changes"
              set return_value 1
              set exit_edit_loop 1
           } else {
              puts $CHECK_OUTPUT "$read_return changes in defaults file \"$CHECK_DEFAULTS_FILE\""
              set return_value 0
              set exit_edit_loop 1
           }
        } else {
           puts $CHECK_OUTPUT "error reading file \"$def_edit_file\""
           puts $CHECK_OUTPUT "\n>> press CTRL-C to abort setup configuration!"
           wait_for_enter
        }
     }
  }
  if { [ string first "/tmp/testsuite_tmp_defaults_file" $def_edit_file ] >= 0 } {
     file delete $def_edit_file
     puts $CHECK_OUTPUT "file \"$def_edit_file\" deleted!" 
  }
  return $return_value 
}

#                                                             max. column:     |
#****** check/read_edit_defaults_file() ******
# 
#  NAME
#     read_edit_defaults_file -- ??? 
#
#  SYNOPSIS
#     read_edit_defaults_file { filename } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#     filename - ??? 
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc read_edit_defaults_file { filename } {
   global CHECK_SETTINGS_VERSION CHECK_CURRENT_SETTINGS_VERSION
   global CHECK_CHECKTREE_ROOT CHECK_CORE_MASTER CHECK_CORE_EXECD CHECK_CORE_PROCESSORS
   global CHECK_SUBMIT_ONLY_HOSTS CHECK_COMMD_PORT CHECK_TESTSUITE_ROOT
   global CHECK_MAIN_RESULTS_DIR CHECK_PRODUCT_TYPE 
   global CHECK_PRODUCT_FEATURE CHECK_PRODUCT_ROOT CHECK_DEFAULTS_FILE
   global CHECK_SOURCE_DIR CHECK_SOURCE_HOSTNAME CHECK_SOURCE_COMPILE_HOSTS
   global CHECK_AIMK_COMPILE_OPTIONS CHECK_DIST_INSTALL_OPTIONS
   global CHECK_PACKAGE_DIRECTORY CHECK_PACKAGE_TYPE
   global CHECK_QMASTER_INSTALL_OPTIONS CHECK_EXECD_INSTALL_OPTIONS
   global CHECK_DNS_DOMAINNAME CHECK_REMOTE_ENVIRONMENT
   global CHECK_FIRST_FOREIGN_SYSTEM_USER CHECK_SECOND_FOREIGN_SYSTEM_USER 
   global CHECK_FIRST_FOREIGN_SYSTEM_GROUP CHECK_SECOND_FOREIGN_SYSTEM_GROUP
   global CHECK_DEFAULT_DOMAIN
   global CHECK_MAILX_HOST 
   global CHECK_REPORT_EMAIL_TO CHECK_REPORT_EMAIL_CC  CHECK_USE_SSH CHECK_SOURCE_CVS_RELEASE
   global CHECK_OUTPUT CHECK_SETUP_NAMES CHECK_CONFIG_DIR CHECK_SEND_ERROR_MAILS
   global CHECK_MAX_ERROR_MAILS CHECK_HOST CHECK_USER
   global CHECK_SETUP_CHANGES

   set return_value -1
   set product_mode_change 0

   set catch_return [ catch {
      set input [open "$filename" "r"]
      while { [gets $input data ] >= 0 } {
        set input_data([lindex $data 0]) [lrange $data 1 end]
      }
      close $input 
      set nr_of_changes 0
      foreach elem $CHECK_SETUP_NAMES(index) {
         if { [info exists input_data($elem)] == 1 } {
            set var_name $CHECK_SETUP_NAMES($elem)
            set old_value [ set $var_name]
            set new_value $input_data($elem)
            if {[ string compare $old_value $new_value ] != 0 } {
               lappend CHECK_SETUP_CHANGES $elem
               set CHECK_SETUP_NAMES($elem,old) $old_value
               puts $CHECK_OUTPUT "\n$elem old value: \"$old_value\"" 
               puts $CHECK_OUTPUT "$elem new value: \"$new_value\""
               set $var_name $new_value
               incr nr_of_changes 1
               if { [ string compare $elem "product_type" ] == 0 } {
                  puts $CHECK_OUTPUT "product mode change!!!"
                  set product_mode_change 1
               }
            }
         } else {
            puts $CHECK_OUTPUT "\"$elem\" doesn't exist in file \"$filename\" - config error"
            return -1
         }
      }
      set return_value $nr_of_changes
      
   } ]


   if { [llength $CHECK_CORE_MASTER] != 1 } {
        puts $CHECK_OUTPUT "qmaster_host has more than one hostname entry"
        return -1
   }
   
   if { $CHECK_PACKAGE_DIRECTORY != "none" } {
      if { [file isdirectory $CHECK_PACKAGE_DIRECTORY] != 1} {
         puts $CHECK_OUTPUT "package_directory is no directory"
         return -1
      }
      if { [check_packages_directory $CHECK_PACKAGE_DIRECTORY] != 0 } {
         puts $CHECK_OUTPUT "error checking package_directory! are all package file installed?"
         return -1
      }
      if { $CHECK_PACKAGE_TYPE != "zip" && $CHECK_PACKAGE_TYPE != "tar" } {
         puts $CHECK_OUTPUT "values for package_type are \"zip\" or \"tar\"!!!"
         return -1
      }
   }



   if { $CHECK_FIRST_FOREIGN_SYSTEM_USER == $CHECK_USER } {
        puts $CHECK_OUTPUT "first_foreign_system_user should not be testsuite user"
        return -1
   }
   if { $CHECK_SECOND_FOREIGN_SYSTEM_USER == $CHECK_USER } {
        puts $CHECK_OUTPUT "second_foreign_system_user should not be testsuite user"
        return -1
   }

   if { $CHECK_SECOND_FOREIGN_SYSTEM_USER == $CHECK_FIRST_FOREIGN_SYSTEM_USER } {
        puts $CHECK_OUTPUT "second_foreign_system_user should not be first_foreign_system_user"
        return -1
   }
 
   if { [string length "$CHECK_PRODUCT_ROOT/bin/solaris64/sge_qmaster"] > 60 } {
        puts $CHECK_OUTPUT "path for product_root_directory is to long (60 chars)"
        return -1
   }

   if { $CHECK_FIRST_FOREIGN_SYSTEM_USER == "" || 
        $CHECK_SECOND_FOREIGN_SYSTEM_USER == "" ||
        $CHECK_FIRST_FOREIGN_SYSTEM_GROUP == "" ||
        $CHECK_SECOND_FOREIGN_SYSTEM_GROUP == "" } {
        puts $CHECK_OUTPUT "no value for foreign system users/groups"
        return -1
   }
   if { [llength $CHECK_FIRST_FOREIGN_SYSTEM_GROUP] != 2 } {
        puts $CHECK_OUTPUT "syntax of \"first_foreign_system_groupname\":"
        puts $CHECK_OUTPUT "main group name\[SPACE\]secondary group name, e.g. \"users projectA\""  
        return -1
   }

   if { [llength $CHECK_SECOND_FOREIGN_SYSTEM_GROUP] != 1 } {
        puts $CHECK_OUTPUT "syntax of \"second_foreign_system_groupname\":"
        puts $CHECK_OUTPUT "main group name \"projectB\""  
        return -1
   }



   foreach gname $CHECK_FIRST_FOREIGN_SYSTEM_GROUP {
      if { [ string compare $gname $CHECK_SECOND_FOREIGN_SYSTEM_GROUP] == 0 } {
          puts $CHECK_OUTPUT "\"second_foreign_system_groupname\" should not be member of \"first_foreign_system_groupname\""
          return -1
      } 
   }

   if { [ string compare $CHECK_SETTINGS_VERSION $CHECK_CURRENT_SETTINGS_VERSION ] != 0 } {
        puts $CHECK_OUTPUT "you should not edit the settings_version - config error"
        puts $CHECK_OUTPUT "version should be \"$CHECK_CURRENT_SETTINGS_VERSION\""
        return -1 
   }


   if { ([string compare "sgeee" $CHECK_PRODUCT_TYPE ] != 0) &&
           ([string compare "sge" $CHECK_PRODUCT_TYPE ] != 0) } {
        puts $CHECK_OUTPUT "product_type can only be \"sge\" or \"sgeee\""
        return -1
   }

   set product_mode_file "$CHECK_PRODUCT_ROOT/default/common/product_mode" 

   if { $product_mode_change == 1 && 
        [file isfile $product_mode_file] } {
   # delete product mode file
      puts $CHECK_OUTPUT "deleting old product mode file!"
      file delete $product_mode_file
      puts $CHECK_OUTPUT "please run compile source and preinstall binaries after setup"
   }
 

   if { ([string compare "none"   $CHECK_PRODUCT_FEATURE ] != 0) &&
        ([string compare "csp" $CHECK_PRODUCT_FEATURE ] != 0) } {
        puts $CHECK_OUTPUT "product_feature can only be \"none\" or \"csp\""
        return -1
   }
 
   if { [set_users_environment $CHECK_HOST] == -1 } {
        puts $CHECK_OUTPUT "error setting users environment"
        return -1
   }

   
 
   if { [ string compare $CHECK_CORE_MASTER [lindex $CHECK_CORE_EXECD 0] ] != 0 } {
         set new_core_execd "$CHECK_CORE_MASTER"
         puts $CHECK_OUTPUT "setting qmaster host $CHECK_CORE_MASTER on top of execd list"
         foreach elem $CHECK_CORE_EXECD {
            if {[ string compare -nocase $CHECK_CORE_MASTER $elem ] != 0 } {
               lappend new_core_execd $elem
            }
         }
         set new_proc_numb ""
         foreach elem $new_core_execd {
            set myind 0
            foreach oldname $CHECK_CORE_EXECD {
               if { [ string compare $oldname $elem ] == 0  } {
                  lappend new_proc_numb [lindex $CHECK_CORE_PROCESSORS $myind]
               }
               incr myind 1
            }
         }

         set CHECK_CORE_EXECD $new_core_execd
         set CHECK_CORE_PROCESSORS $new_proc_numb
         puts $CHECK_OUTPUT "new value for execd_list: \"$CHECK_CORE_EXECD\""
         puts $CHECK_OUTPUT "new value for processors_on_each_execution_host: \"$CHECK_CORE_PROCESSORS\""
   }

   if { [llength $CHECK_CORE_EXECD] != [llength $CHECK_CORE_PROCESSORS] } {
         puts $CHECK_OUTPUT "length of \"list_of_execution_hosts\" doesn't match length of \"processors_on_each_execution_host\""
         return -1
   } 

   if {[file isdirectory "$CHECK_MAIN_RESULTS_DIR"] != 1} {
         set catch_return [ catch {  file mkdir "$CHECK_MAIN_RESULTS_DIR" } ]
         if { $catch_return != 0 } {
             puts $CHECK_OUTPUT "could not create directory \"$CHECK_MAIN_RESULTS_DIR\""
             return -1
         } 
   }
   if {[file isdirectory "$CHECK_CONFIG_DIR"] != 1} {
         puts $CHECK_OUTPUT "could not open config directory \"$CHECK_CONFIG_DIR\""
         return -1
   }

   set group1 [lindex $CHECK_FIRST_FOREIGN_SYSTEM_GROUP 0]
   set group2 [lindex $CHECK_FIRST_FOREIGN_SYSTEM_GROUP 1]

   set result [start_remote_prog $CHECK_HOST $CHECK_USER "id" "$CHECK_FIRST_FOREIGN_SYSTEM_USER"]
   puts $CHECK_OUTPUT $result
   if { [string first $group1 $result ] < 0 } {
      puts $CHECK_OUTPUT "first_foreign_system_username ($CHECK_FIRST_FOREIGN_SYSTEM_USER) has not \"$group1\" as main group"
      return -1
   }
   
   set result [start_remote_prog $CHECK_HOST $CHECK_USER "groups" "$CHECK_FIRST_FOREIGN_SYSTEM_USER"]
   puts $CHECK_OUTPUT $result
   if { $prg_exit_state == 0 } {
      if { [string first $group2 $result] < 0 } { 
         puts $CHECK_OUTPUT "first_foreign_system_username ($CHECK_FIRST_FOREIGN_SYSTEM_USER) has not \"$group2\" as secondary group"
         return -1
      }
   }
   set result [start_remote_prog $CHECK_HOST $CHECK_USER "id" "$CHECK_SECOND_FOREIGN_SYSTEM_USER"]
   puts $CHECK_OUTPUT $result
   if { [string first $CHECK_SECOND_FOREIGN_SYSTEM_GROUP $result ] < 0 } {
      puts $CHECK_OUTPUT "first_foreign_system_username ($CHECK_SECOND_FOREIGN_SYSTEM_USER) has not \"$CHECK_SECOND_FOREIGN_SYSTEM_GROUP\" as main group"
      return -1
   }
   

   return $return_value ;# $catch_return
}

#                                                             max. column:     |
#****** check/calc_space() ******
# 
#  NAME
#     calc_space -- ??? 
#
#  SYNOPSIS
#     calc_space { space name } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#     space - ??? 
#     name  - ??? 
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc calc_space {space name} {

  set length [ string length $name ]
  set spaces [ expr ( $space - $length )  ]
  set back ""
  for {set i 0} { $i < $spaces} { incr i 1} {
     set back "$back "
  }
  return $back
}

#                                                             max. column:     |
#****** check/write_edit_defaults_file() ******
# 
#  NAME
#     write_edit_defaults_file -- ??? 
#
#  SYNOPSIS
#     write_edit_defaults_file { filename { unique_file def_edit_file } } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#     filename                      - ??? 
#     { unique_file def_edit_file } - ??? 
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc write_edit_defaults_file { filename { unique_file def_edit_file } } {
  global CHECK_SETTINGS_VERSION
  global CHECK_CHECKTREE_ROOT CHECK_CORE_MASTER CHECK_CORE_EXECD CHECK_CORE_PROCESSORS 
  global CHECK_SUBMIT_ONLY_HOSTS CHECK_COMMD_PORT CHECK_TESTSUITE_ROOT
  global CHECK_MAIN_RESULTS_DIR CHECK_PRODUCT_TYPE 
  global CHECK_PRODUCT_FEATURE  CHECK_PRODUCT_ROOT CHECK_DEFAULTS_FILE
  global CHECK_SOURCE_DIR CHECK_SOURCE_HOSTNAME CHECK_SOURCE_COMPILE_HOSTS
  global CHECK_AIMK_COMPILE_OPTIONS CHECK_DIST_INSTALL_OPTIONS
  global CHECK_PACKAGE_DIRECTORY CHECK_PACKAGE_TYPE
  global CHECK_QMASTER_INSTALL_OPTIONS CHECK_EXECD_INSTALL_OPTIONS
  global CHECK_DNS_DOMAINNAME CHECK_REMOTE_ENVIRONMENT
  global CHECK_FIRST_FOREIGN_SYSTEM_USER CHECK_SECOND_FOREIGN_SYSTEM_USER 
  global CHECK_FIRST_FOREIGN_SYSTEM_GROUP CHECK_SECOND_FOREIGN_SYSTEM_GROUP
  global CHECK_DEFAULT_DOMAIN
  global CHECK_MAILX_HOST CHECK_CONFIG_DIR CHECK_OUTPUT
  global CHECK_REPORT_EMAIL_TO CHECK_REPORT_EMAIL_CC  CHECK_USE_SSH CHECK_SOURCE_CVS_RELEASE CHECK_SETUP_NAMES
  global CHECK_SEND_ERROR_MAILS CHECK_MAX_ERROR_MAILS

  upvar $unique_file newfilename 
  sleep 2   ;# extra timestamp
  set newfilename "$filename.[timestamp]"
  puts $CHECK_OUTPUT "*write_edit_defaults_file*\nwriting/creating defaults file \"$filename\""
  set c 35
  set catch_return [ catch {
     set fout [ open "$newfilename" "w" ] 
     puts $CHECK_OUTPUT "open file \"$newfilename\" ..."
     foreach elem $CHECK_SETUP_NAMES(index) { 
        puts $CHECK_OUTPUT "writing $elem ..."
        set var_name $CHECK_SETUP_NAMES($elem)
        puts $fout "$elem [calc_space $c $elem] [set $var_name]"
     }
     flush $fout
     close $fout
     puts $CHECK_OUTPUT "closing file"
  } ]

  return $catch_return
}

proc get_local_hostname {} {
   global env CHECK_OUTPUT 
   set catch_return [ catch { exec "hostname" } result ]
   if { $catch_return == 0 } {
      set result [split $result "."]
      set newname [lindex $result 0]
      puts $CHECK_OUTPUT "got hostname: \"$newname\""
      return $newname
   } else {
      puts $CHECK_OUTPUT "local hostname error or binary not found"
      puts $CHECK_OUTPUT "error: $result"
      puts $CHECK_OUTPUT "error: $catch_return"
      puts $CHECK_OUTPUT "trying local HOST environment variable ..."
      if { [ info exists env(HOST) ] } {
         set result [split $env(HOST) "."]
         set newname [lindex $result 0]
         if { [ string length $newname ] > 0 } {
             puts $CHECK_OUTPUT "got hostname_ \"$newname\""
             return $newname
         } 
      }
   }
   puts $CHECK_OUTPUT "tcl procedure get_local_hostname() can't get local hostname"
   puts $CHECK_OUTPUT "please set check if binary \"hostname\" is in path or"
   puts $CHECK_OUTPUT "set the environment variable \"HOST\" to the hostname value"
   exit 1
   return "unknown"
}

#                                                             max. column:     |
#****** check/load_defaults() ******
# 
#  NAME
#     load_defaults -- ??? 
#
#  SYNOPSIS
#     load_defaults { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc load_defaults {} {

  global ts_config

  global CHECK_SETTINGS_VERSION CHECK_CURRENT_SETTINGS_VERSION CHECK_OUTPUT
  global CHECK_CHECKTREE_ROOT CHECK_CORE_MASTER CHECK_CORE_EXECD 
  global CHECK_CORE_PROCESSORS CHECK_SUBMIT_ONLY_HOSTS CHECK_COMMD_PORT
  global CHECK_MAIN_RESULTS_DIR env CHECK_PRODUCT_TYPE 
  global CHECK_PRODUCT_FEATURE CHECK_PRODUCT_ROOT CHECK_DEFAULTS_FILE CHECK_TESTSUITE_ROOT
  global CHECK_PROTOCOL_DIR CHECK_CURRENT_WORKING_DIR
  global CHECK_SOURCE_DIR CHECK_SOURCE_HOSTNAME CHECK_SOURCE_COMPILE_HOSTS
  global CHECK_AIMK_COMPILE_OPTIONS CHECK_DIST_INSTALL_OPTIONS
  global CHECK_PACKAGE_DIRECTORY CHECK_PACKAGE_TYPE
  global CHECK_QMASTER_INSTALL_OPTIONS CHECK_EXECD_INSTALL_OPTIONS
  global CHECK_DNS_DOMAINNAME CHECK_REMOTE_ENVIRONMENT
  global CHECK_FIRST_FOREIGN_SYSTEM_USER CHECK_SECOND_FOREIGN_SYSTEM_USER 
  global CHECK_FIRST_FOREIGN_SYSTEM_GROUP CHECK_SECOND_FOREIGN_SYSTEM_GROUP
  global CHECK_DEFAULT_DOMAIN CHECK_DO_SETUP
  global CHECK_MAILX_HOST CHECK_HOST env
  global CHECK_REPORT_EMAIL_TO CHECK_REPORT_EMAIL_CC  CHECK_USE_SSH CHECK_SOURCE_CVS_RELEASE
  global CHECK_PRODUCT_VERSION_NUMBER CHECK_CONFIG_DIR CHECK_GROUP
  global CHECK_SEND_ERROR_MAILS CHECK_MAX_ERROR_MAILS CHECK_JOB_OUTPUT_DIR
  
  set CHECK_TESTSUITE_ROOT "$CHECK_CURRENT_WORKING_DIR"
  set CHECK_CHECKTREE_ROOT "$CHECK_CURRENT_WORKING_DIR/checktree"
  set CHECK_MAIN_RESULTS_DIR "$CHECK_CURRENT_WORKING_DIR/results"
  set CHECK_CORE_PROCESSORS "1"
  set CHECK_SUBMIT_ONLY_HOSTS ""
  set CHECK_COMMD_PORT "7776";
  set CHECK_USER "unknown";
  set CHECK_GROUP "unknown";
  set CHECK_ARCH "unknown";
  set CHECK_HOST [get_local_hostname] 
  set CHECK_CORE_MASTER $CHECK_HOST
  set CHECK_SOURCE_HOSTNAME $CHECK_HOST  
  set CHECK_MAILX_HOST $CHECK_HOST
  set CHECK_CORE_EXECD $CHECK_HOST       
  set CHECK_PROTOCOL_DIR ""
  set CHECK_PRODUCT_TYPE "sge"
  set CHECK_PRODUCT_FEATURE "none"
  set CHECK_PRODUCT_ROOT "unknown"

  set old_dir [pwd]
  cd ..
  catch { cd source }
  set CHECK_SOURCE_DIR [ get_current_working_dir ]
  cd $old_dir

  set CHECK_SOURCE_COMPILE_HOSTS "unknown"
  set CHECK_AIMK_COMPILE_OPTIONS "-secure"
  set CHECK_DIST_INSTALL_OPTIONS "-allall"
  set CHECK_PACKAGE_DIRECTORY "none"
  set CHECK_PACKAGE_TYPE "tar"
  set CHECK_QMASTER_INSTALL_OPTIONS ""
  set CHECK_EXECD_INSTALL_OPTIONS ""
  set CHECK_DNS_DOMAINNAME ""
  set CHECK_REMOTE_ENVIRONMENT ""
  set CHECK_SOURCE_CVS_RELEASE "maintrunc"  
  set CHECK_CONFIG_DIR ""
  if {[file isfile "$CHECK_DEFAULTS_FILE"] != 1} {
     source_procedures
     return -1
  }
  
  if { [read_array_from_file $CHECK_DEFAULTS_FILE "testsuite configuration" tmp_config ] == 0 } {
     puts $CHECK_OUTPUT "new configuration file format"
     wait_for_enter
     source_procedures
     get_version_info
     return 0
  } else {
     set input [open "$CHECK_DEFAULTS_FILE" "r"]
     gets $input data
     close $input 
     set CHECK_SETTINGS_VERSION                 [lindex $data 0]
   
     if { [ string compare $CHECK_CURRENT_SETTINGS_VERSION $CHECK_SETTINGS_VERSION] != 0  } {
        puts $CHECK_OUTPUT "wrong settings file version: $CHECK_SETTINGS_VERSION"
        puts $CHECK_OUTPUT "expected version: $CHECK_CURRENT_SETTINGS_VERSION"
        set catch_return [ catch { eval exec "cp ${CHECK_DEFAULTS_FILE} ${CHECK_DEFAULTS_FILE}.[timestamp]" } ]
         if { $catch_return == 0 } { 
           if { [ string first "/" $CHECK_SETTINGS_VERSION ] >= 0 } {
               puts $CHECK_OUTPUT "this settings file has no version number -> inserting version number"
               set CHECK_SETTINGS_VERSION "1"
               set CHECK_TESTSUITE_ROOT                   [lindex $data 0]
               set CHECK_CHECKTREE_ROOT                   [lindex $data 1]
               set CHECK_CORE_MASTER                      [lindex $data 2]
               set CHECK_CORE_EXECD                       [lindex $data 3]
               set CHECK_CORE_PROCESSORS                  [lindex $data 4]
               set CHECK_COMMD_PORT                       [lindex $data 5]
               set CHECK_MAIN_RESULTS_DIR                 [lindex $data 6]
               set CHECK_PROTOCOL_DIR $CHECK_MAIN_RESULTS_DIR/protocols
               set CHECK_JOB_OUTPUT_DIR "$CHECK_MAIN_RESULTS_DIR/testsuite_job_outputs"
             
               set CHECK_PRODUCT_TYPE                     [lindex $data 7]
               set CHECK_PRODUCT_ROOT                     [lindex $data 8]
               set CHECK_SOURCE_DIR                       [lindex $data 9]
               set CHECK_SOURCE_HOSTNAME                  [lindex $data 10]
               set CHECK_SOURCE_COMPILE_HOSTS             [lindex $data 11]
               set CHECK_AIMK_COMPILE_OPTIONS             [lindex $data 12]
               set CHECK_DIST_INSTALL_OPTIONS             [lindex $data 13] 
               set CHECK_FIRST_FOREIGN_SYSTEM_USER        [lindex $data 14]
               set CHECK_SECOND_FOREIGN_SYSTEM_USER       [lindex $data 15]
               set CHECK_FIRST_FOREIGN_SYSTEM_GROUP       [lindex $data 16]
               set CHECK_SECOND_FOREIGN_SYSTEM_GROUP      [lindex $data 17]
               set CHECK_DEFAULT_DOMAIN                   [lindex $data 18]
               set CHECK_MAILX_HOST                       [lindex $data 19]
               set CHECK_REPORT_EMAIL_TO                  [lindex $data 20]
               set CHECK_REPORT_EMAIL_CC                  [lindex $data 21]
               set CHECK_SEND_ERROR_MAILS                 [lindex $data 22]
               set CHECK_MAX_ERROR_MAILS                  [lindex $data 23]
               set CHECK_USE_SSH                          [lindex $data 24]
               set CHECK_SOURCE_CVS_RELEASE               [lindex $data 25]
               set CHECK_CONFIG_DIR                       [lindex $data 26]
               wait_for_enter
               source_procedures
               save_defaults 
               set CHECK_DO_SETUP 1 
               setup 
               puts $CHECK_OUTPUT "defaults file updated, please restart the testsuite!"
               exit -1
           }
           if { $CHECK_SETTINGS_VERSION == 1 } {
               puts $CHECK_OUTPUT "this settings file has version number 1 -> upgrading to version 2"
               set CHECK_SETTINGS_VERSION "2"
               set CHECK_TESTSUITE_ROOT                   [lindex $data 1]
               set CHECK_CHECKTREE_ROOT                   [lindex $data 2]
               set CHECK_CORE_MASTER                      [lindex $data 3]
               set CHECK_CORE_EXECD                       [lindex $data 4]
               set CHECK_CORE_PROCESSORS                  [lindex $data 5]
               set CHECK_COMMD_PORT                       [lindex $data 6]
               set CHECK_MAIN_RESULTS_DIR                 [lindex $data 7]
               set CHECK_PROTOCOL_DIR $CHECK_MAIN_RESULTS_DIR/protocols
               set CHECK_JOB_OUTPUT_DIR "$CHECK_MAIN_RESULTS_DIR/testsuite_job_outputs"
             
               set CHECK_PRODUCT_TYPE                     [lindex $data 8]
               set CHECK_PRODUCT_ROOT                     [lindex $data 9]
               set CHECK_SOURCE_DIR                       [lindex $data 10]
               set CHECK_SOURCE_HOSTNAME                  [lindex $data 11]
               set CHECK_SOURCE_COMPILE_HOSTS             [lindex $data 12]
               set CHECK_AIMK_COMPILE_OPTIONS             [lindex $data 13]
               set CHECK_DIST_INSTALL_OPTIONS             [lindex $data 14]
               set CHECK_FIRST_FOREIGN_SYSTEM_USER        [lindex $data 15]
               set CHECK_SECOND_FOREIGN_SYSTEM_USER       [lindex $data 16]
               set CHECK_FIRST_FOREIGN_SYSTEM_GROUP       [lindex $data 17]
               set CHECK_SECOND_FOREIGN_SYSTEM_GROUP      [lindex $data 18]
               set CHECK_DEFAULT_DOMAIN                   [lindex $data 19]
               set CHECK_MAILX_HOST                       [lindex $data 20]
               set CHECK_REPORT_EMAIL_TO                  [lindex $data 21]
               set CHECK_REPORT_EMAIL_CC                  [lindex $data 22]
               set CHECK_SEND_ERROR_MAILS                 [lindex $data 23]
               set CHECK_MAX_ERROR_MAILS                  [lindex $data 24]
               set CHECK_USE_SSH                          [lindex $data 25]
               set CHECK_SOURCE_CVS_RELEASE               [lindex $data 26]
               set CHECK_CONFIG_DIR                       [lindex $data 27]
               
               set CHECK_QMASTER_INSTALL_OPTIONS          ""
               set CHECK_EXECD_INSTALL_OPTIONS            ""
               puts $CHECK_OUTPUT "added qmaster_install_options"
               puts $CHECK_OUTPUT "added execd_install_options"
               wait_for_enter
               source_procedures
               save_defaults 
               set CHECK_DO_SETUP 1 
               setup 
               puts $CHECK_OUTPUT "defaults file updated, please restart the testsuite!"
               exit -1
           }
           if { $CHECK_SETTINGS_VERSION == 2 } {
               puts $CHECK_OUTPUT "this settings file has version number 2 -> upgrading to version 3"
               set CHECK_SETTINGS_VERSION "3"
               set CHECK_TESTSUITE_ROOT                   [lindex $data 1]
               set CHECK_CHECKTREE_ROOT                   [lindex $data 2]
               set CHECK_CORE_MASTER                      [lindex $data 3]
               set CHECK_CORE_EXECD                       [lindex $data 4]
               set CHECK_CORE_PROCESSORS                  [lindex $data 5]
               set CHECK_COMMD_PORT                       [lindex $data 6]
               set CHECK_MAIN_RESULTS_DIR                 [lindex $data 7]
               set CHECK_PROTOCOL_DIR $CHECK_MAIN_RESULTS_DIR/protocols
               set CHECK_JOB_OUTPUT_DIR "$CHECK_MAIN_RESULTS_DIR/testsuite_job_outputs"
              
               set CHECK_PRODUCT_TYPE                     [lindex $data 8]
               set CHECK_PRODUCT_ROOT                     [lindex $data 9]
               set CHECK_SOURCE_DIR                       [lindex $data 10]
               set CHECK_SOURCE_HOSTNAME                  [lindex $data 11]
               set CHECK_SOURCE_COMPILE_HOSTS             [lindex $data 12]
               set CHECK_AIMK_COMPILE_OPTIONS             [lindex $data 13]
               set CHECK_DIST_INSTALL_OPTIONS             [lindex $data 14]
               set CHECK_QMASTER_INSTALL_OPTIONS          [lindex $data 15]      ;# added for version 2
               set CHECK_EXECD_INSTALL_OPTIONS            [lindex $data 16]      ;# added for version 2
               set CHECK_FIRST_FOREIGN_SYSTEM_USER        [lindex $data 17]
               set CHECK_SECOND_FOREIGN_SYSTEM_USER       [lindex $data 18]
               set CHECK_FIRST_FOREIGN_SYSTEM_GROUP       [lindex $data 19]
               set CHECK_SECOND_FOREIGN_SYSTEM_GROUP      [lindex $data 20]
               set CHECK_DEFAULT_DOMAIN                   [lindex $data 21]
               set CHECK_MAILX_HOST                       [lindex $data 22]
               set CHECK_REPORT_EMAIL_TO                  [lindex $data 23]
               set CHECK_REPORT_EMAIL_CC                  [lindex $data 24]
               set CHECK_SEND_ERROR_MAILS                 [lindex $data 25]
               set CHECK_MAX_ERROR_MAILS                  [lindex $data 26]
               set CHECK_USE_SSH                          [lindex $data 27]
               set CHECK_SOURCE_CVS_RELEASE               [lindex $data 28]
               set CHECK_CONFIG_DIR                       [lindex $data 29]
                           
               set CHECK_SUBMIT_ONLY_HOSTS                ""
               puts $CHECK_OUTPUT "added list_of_submit_only_hosts"
               wait_for_enter
               source_procedures
               save_defaults 
               set CHECK_DO_SETUP 1 
               setup 
               puts $CHECK_OUTPUT "defaults file updated, please restart the testsuite!"
               exit -1
           }
           if { $CHECK_SETTINGS_VERSION == 3 } {
               puts $CHECK_OUTPUT "this settings file has version number 3 -> upgrading to version 4"
               set CHECK_SETTINGS_VERSION "4"
               set CHECK_TESTSUITE_ROOT                   [lindex $data 1]
               set CHECK_CHECKTREE_ROOT                   [lindex $data 2]
               set CHECK_CORE_MASTER                      [lindex $data 3]
               set CHECK_CORE_EXECD                       [lindex $data 4]
               set CHECK_CORE_PROCESSORS                  [lindex $data 5]
               set CHECK_SUBMIT_ONLY_HOSTS                [lindex $data 6]      ;# added for version 3
               set CHECK_COMMD_PORT                       [lindex $data 7]
               set CHECK_MAIN_RESULTS_DIR                 [lindex $data 8]
               set CHECK_PROTOCOL_DIR $CHECK_MAIN_RESULTS_DIR/protocols
               set CHECK_JOB_OUTPUT_DIR "$CHECK_MAIN_RESULTS_DIR/testsuite_job_outputs"
             
               set CHECK_PRODUCT_TYPE                     [lindex $data 9]
               set CHECK_PRODUCT_ROOT                     [lindex $data 10]
               set CHECK_SOURCE_DIR                       [lindex $data 11]
               set CHECK_SOURCE_HOSTNAME                  [lindex $data 12]
               set CHECK_SOURCE_COMPILE_HOSTS             [lindex $data 13]
               set CHECK_AIMK_COMPILE_OPTIONS             [lindex $data 14]
               set CHECK_DIST_INSTALL_OPTIONS             [lindex $data 15]
               set CHECK_QMASTER_INSTALL_OPTIONS          [lindex $data 16]      ;# added for version 2
               set CHECK_EXECD_INSTALL_OPTIONS            [lindex $data 17]      ;# added for version 2
               set CHECK_FIRST_FOREIGN_SYSTEM_USER        [lindex $data 18]
               set CHECK_SECOND_FOREIGN_SYSTEM_USER       [lindex $data 19]
               set CHECK_FIRST_FOREIGN_SYSTEM_GROUP       [lindex $data 20]
               set CHECK_SECOND_FOREIGN_SYSTEM_GROUP      [lindex $data 21]
               set CHECK_DEFAULT_DOMAIN                   [lindex $data 22]
               set CHECK_MAILX_HOST                       [lindex $data 23]
               set CHECK_REPORT_EMAIL_TO                  [lindex $data 24]
               set CHECK_REPORT_EMAIL_CC                  [lindex $data 25]
               set CHECK_SEND_ERROR_MAILS                 [lindex $data 26]
               set CHECK_MAX_ERROR_MAILS                  [lindex $data 27]
               set CHECK_USE_SSH                          [lindex $data 28]
               set CHECK_SOURCE_CVS_RELEASE               [lindex $data 29]
               set CHECK_CONFIG_DIR                       [lindex $data 30]
   
               set CHECK_DNS_DOMAINNAME                   ""
               set CHECK_REMOTE_ENVIRONMENT               ""
               
               puts $CHECK_OUTPUT "added dns_domain_name" 
               puts $CHECK_OUTPUT "added user_environment"
               wait_for_enter
               source_procedures
               save_defaults 
               set CHECK_DO_SETUP 1 
               setup 
               puts $CHECK_OUTPUT "defaults file updated, please restart the testsuite!"
               exit -1
           }
           if { $CHECK_SETTINGS_VERSION == 4 } {
               puts $CHECK_OUTPUT "this settings file has version number 4 -> upgrading to version 5"
               set CHECK_SETTINGS_VERSION "5"
               set CHECK_TESTSUITE_ROOT                   [lindex $data 1]
               set CHECK_CHECKTREE_ROOT                   [lindex $data 2]
               set CHECK_CORE_MASTER                      [lindex $data 3]
               set CHECK_CORE_EXECD                       [lindex $data 4]
               set CHECK_CORE_PROCESSORS                  [lindex $data 5]
               set CHECK_SUBMIT_ONLY_HOSTS                [lindex $data 6]      ;# added for version 3
               set CHECK_COMMD_PORT                       [lindex $data 7]
               set CHECK_MAIN_RESULTS_DIR                 [lindex $data 8]
               set CHECK_PROTOCOL_DIR $CHECK_MAIN_RESULTS_DIR/protocols
               set CHECK_JOB_OUTPUT_DIR "$CHECK_MAIN_RESULTS_DIR/testsuite_job_outputs"
              
               set CHECK_PRODUCT_TYPE                     [lindex $data 9]
               set CHECK_PRODUCT_ROOT                     [lindex $data 10]
               set CHECK_SOURCE_DIR                       [lindex $data 11]
               set CHECK_SOURCE_HOSTNAME                  [lindex $data 12]
               set CHECK_SOURCE_COMPILE_HOSTS             [lindex $data 13]
               set CHECK_AIMK_COMPILE_OPTIONS             [lindex $data 14]
               set CHECK_DIST_INSTALL_OPTIONS             [lindex $data 15]
               set CHECK_QMASTER_INSTALL_OPTIONS          [lindex $data 16]      ;# added for version 2
               set CHECK_EXECD_INSTALL_OPTIONS            [lindex $data 17]      ;# added for version 2
               set CHECK_DNS_DOMAINNAME                   [lindex $data 18]      ;# added for version 4
               set CHECK_REMOTE_ENVIRONMENT               [lindex $data 19]      ;# added for version 4
               set CHECK_FIRST_FOREIGN_SYSTEM_USER        [lindex $data 20]
               set CHECK_SECOND_FOREIGN_SYSTEM_USER       [lindex $data 21]
               set CHECK_FIRST_FOREIGN_SYSTEM_GROUP       [lindex $data 22]
               set CHECK_SECOND_FOREIGN_SYSTEM_GROUP      [lindex $data 23]
               set CHECK_DEFAULT_DOMAIN                   [lindex $data 24]
               set CHECK_MAILX_HOST                       [lindex $data 25]
               set CHECK_REPORT_EMAIL_TO                  [lindex $data 26]
               set CHECK_REPORT_EMAIL_CC                  [lindex $data 27]
               set CHECK_SEND_ERROR_MAILS                 [lindex $data 28]
               set CHECK_MAX_ERROR_MAILS                  [lindex $data 29]
               set CHECK_USE_SSH                          [lindex $data 30]
               set CHECK_SOURCE_CVS_RELEASE               [lindex $data 31]
               set CHECK_CONFIG_DIR                       [lindex $data 32]
              
               puts $CHECK_OUTPUT "updating second_foreign_system_groupname, first_foreign_system_groupname"
               set CHECK_FIRST_FOREIGN_SYSTEM_GROUP  "$CHECK_FIRST_FOREIGN_SYSTEM_GROUP $CHECK_SECOND_FOREIGN_SYSTEM_GROUP"
               set CHECK_SECOND_FOREIGN_SYSTEM_GROUP ""
               wait_for_enter
               source_procedures
               save_defaults 
               set CHECK_DO_SETUP 1
               setup 
               puts $CHECK_OUTPUT "defaults file updated, please restart the testsuite!"
               exit -1
           }
           if { $CHECK_SETTINGS_VERSION == 5 } {
               puts $CHECK_OUTPUT "this settings file has version number 5 -> upgrading to version 6"
               set CHECK_SETTINGS_VERSION "6"
               set CHECK_TESTSUITE_ROOT                   [lindex $data 1]
               set CHECK_CHECKTREE_ROOT                   [lindex $data 2]
               set CHECK_CORE_MASTER                      [lindex $data 3]
               set CHECK_CORE_EXECD                       [lindex $data 4]
               set CHECK_CORE_PROCESSORS                  [lindex $data 5]
               set CHECK_SUBMIT_ONLY_HOSTS                [lindex $data 6]      ;# added for version 3
               set CHECK_COMMD_PORT                       [lindex $data 7]
               set CHECK_MAIN_RESULTS_DIR                 [lindex $data 8]
               set CHECK_PROTOCOL_DIR $CHECK_MAIN_RESULTS_DIR/protocols
               set CHECK_JOB_OUTPUT_DIR "$CHECK_MAIN_RESULTS_DIR/testsuite_job_outputs"
             
               set CHECK_PRODUCT_TYPE                     [lindex $data 9]
               set CHECK_PRODUCT_ROOT                     [lindex $data 10]
               set CHECK_SOURCE_DIR                       [lindex $data 11]
               set CHECK_SOURCE_HOSTNAME                  [lindex $data 12]
               set CHECK_SOURCE_COMPILE_HOSTS             [lindex $data 13]
               set CHECK_AIMK_COMPILE_OPTIONS             [lindex $data 14]
               set CHECK_DIST_INSTALL_OPTIONS             [lindex $data 15]
               set CHECK_QMASTER_INSTALL_OPTIONS          [lindex $data 16]      ;# added for version 2
               set CHECK_EXECD_INSTALL_OPTIONS            [lindex $data 17]      ;# added for version 2
               set CHECK_DNS_DOMAINNAME                   [lindex $data 18]      ;# added for version 4
               set CHECK_REMOTE_ENVIRONMENT               [lindex $data 19]      ;# added for version 4
               set CHECK_FIRST_FOREIGN_SYSTEM_USER        [lindex $data 20]
               set CHECK_SECOND_FOREIGN_SYSTEM_USER       [lindex $data 21]
               set CHECK_FIRST_FOREIGN_SYSTEM_GROUP       [lindex $data 22]
               set CHECK_SECOND_FOREIGN_SYSTEM_GROUP      [lindex $data 23]
               set CHECK_DEFAULT_DOMAIN                   [lindex $data 24]
               set CHECK_MAILX_HOST                       [lindex $data 25]
               set CHECK_REPORT_EMAIL_TO                  [lindex $data 26]
               set CHECK_REPORT_EMAIL_CC                  [lindex $data 27]
               set CHECK_SEND_ERROR_MAILS                 [lindex $data 28]
               set CHECK_MAX_ERROR_MAILS                  [lindex $data 29]
               set CHECK_USE_SSH                          [lindex $data 30]
               set CHECK_SOURCE_CVS_RELEASE               [lindex $data 31]
               set CHECK_CONFIG_DIR                       [lindex $data 32]
                         
               puts $CHECK_OUTPUT "updating new configuration parameter \"product_feature\" ..."
               set CHECK_PRODUCT_FEATURE "none"
               wait_for_enter
               source_procedures
               save_defaults 
               set CHECK_DO_SETUP 1
               setup 
               puts $CHECK_OUTPUT "defaults file updated, please restart the testsuite!"
               exit -1
           }
           if { $CHECK_SETTINGS_VERSION == 6 } {
               puts $CHECK_OUTPUT "this settings file has version number 6 -> upgrading to version 7"
               set CHECK_SETTINGS_VERSION "7"
               set CHECK_TESTSUITE_ROOT                   [lindex $data 1]
               set CHECK_CHECKTREE_ROOT                   [lindex $data 2]
               set CHECK_CORE_MASTER                      [lindex $data 3]
               set CHECK_CORE_EXECD                       [lindex $data 4]
               set CHECK_CORE_PROCESSORS                  [lindex $data 5]
               set CHECK_SUBMIT_ONLY_HOSTS                [lindex $data 6]      ;# added for version 3
               set CHECK_COMMD_PORT                       [lindex $data 7]
               set CHECK_MAIN_RESULTS_DIR                 [lindex $data 8]
               set CHECK_PROTOCOL_DIR $CHECK_MAIN_RESULTS_DIR/protocols
               set CHECK_JOB_OUTPUT_DIR "$CHECK_MAIN_RESULTS_DIR/testsuite_job_outputs"
             
               set CHECK_PRODUCT_TYPE                     [lindex $data 9]
               set CHECK_PRODUCT_FEATURE                  [lindex $data 10]      ;# added for version 6
               set CHECK_PRODUCT_ROOT                     [lindex $data 11]
               set CHECK_SOURCE_DIR                       [lindex $data 12]
               set CHECK_SOURCE_HOSTNAME                  [lindex $data 13]
               set CHECK_SOURCE_COMPILE_HOSTS             [lindex $data 14]
               set CHECK_AIMK_COMPILE_OPTIONS             [lindex $data 15]
               set CHECK_DIST_INSTALL_OPTIONS             [lindex $data 16]
               set CHECK_QMASTER_INSTALL_OPTIONS          [lindex $data 17]      ;# added for version 2
               set CHECK_EXECD_INSTALL_OPTIONS            [lindex $data 18]      ;# added for version 2
               set CHECK_DNS_DOMAINNAME                   [lindex $data 19]      ;# added for version 4
               set CHECK_REMOTE_ENVIRONMENT               [lindex $data 20]      ;# added for version 4
               set CHECK_FIRST_FOREIGN_SYSTEM_USER        [lindex $data 21]
               set CHECK_SECOND_FOREIGN_SYSTEM_USER       [lindex $data 22]
               set CHECK_FIRST_FOREIGN_SYSTEM_GROUP       [lindex $data 23]
               set CHECK_SECOND_FOREIGN_SYSTEM_GROUP      [lindex $data 24]
               set CHECK_DEFAULT_DOMAIN                   [lindex $data 25]
               set CHECK_MAILX_HOST                       [lindex $data 26]
               set CHECK_REPORT_EMAIL_TO                  [lindex $data 27]
               set CHECK_REPORT_EMAIL_CC                  [lindex $data 28]
               set CHECK_SEND_ERROR_MAILS                 [lindex $data 29]
               set CHECK_MAX_ERROR_MAILS                  [lindex $data 30]
               set CHECK_USE_SSH                          [lindex $data 31]
               set CHECK_SOURCE_CVS_RELEASE               [lindex $data 32]
               set CHECK_CONFIG_DIR                       [lindex $data 33]
   
                                     
               puts $CHECK_OUTPUT "updating new configuration parameter \"package_directory\" ..."
               set CHECK_PACKAGE_DIRECTORY "none"
               puts $CHECK_OUTPUT "updating new configuration parameter \"package_type\" ..."
               set CHECK_PACKAGE_TYPE "tar"
   
               puts $CHECK_OUTPUT "default value of \"package_directory\" is \"$CHECK_PACKAGE_DIRECTORY\""
               puts $CHECK_OUTPUT "default value of \"package_type\"      is \"$CHECK_PACKAGE_TYPE\""
               wait_for_enter
               source_procedures
               save_defaults 
               set CHECK_DO_SETUP 1
               setup 
               puts $CHECK_OUTPUT "defaults file updated, please restart the testsuite!"
               exit -1
           }
           exit -1
         } else {
           puts "could not copy defaults file"
           exit -1 
         }
     }
   
   
   # latest version:
   
     set CHECK_TESTSUITE_ROOT                   [lindex $data 1]              ;# done
     set CHECK_CHECKTREE_ROOT                   [lindex $data 2]              ;# done
     set CHECK_CORE_MASTER                      [lindex $data 3]              ;# done
     set CHECK_CORE_EXECD                       [lindex $data 4] ;# hostconf   # done
     set CHECK_CORE_PROCESSORS                  [lindex $data 5] ;# hostconf   # done
     set CHECK_SUBMIT_ONLY_HOSTS                [lindex $data 6]              ;# done
     set CHECK_COMMD_PORT                       [lindex $data 7]              ;# done
     set CHECK_MAIN_RESULTS_DIR                 [lindex $data 8]              ;# done
     set CHECK_PROTOCOL_DIR $CHECK_MAIN_RESULTS_DIR/protocols                 ;# done
     set CHECK_JOB_OUTPUT_DIR "$CHECK_MAIN_RESULTS_DIR/testsuite_job_outputs" ;# done
   
     set CHECK_PRODUCT_TYPE                     [lindex $data 9]              ;# done
     set CHECK_PRODUCT_FEATURE                  [lindex $data 10]             ;# done
     set CHECK_PRODUCT_ROOT                     [lindex $data 11]             ;# done
     set CHECK_SOURCE_DIR                       [lindex $data 12]             ;# done
     set CHECK_SOURCE_HOSTNAME                  [lindex $data 13]             ;# done
     set CHECK_SOURCE_COMPILE_HOSTS             [lindex $data 14] ;# hostconf  # done
     set CHECK_AIMK_COMPILE_OPTIONS             [lindex $data 15]             ;# done
     set CHECK_DIST_INSTALL_OPTIONS             [lindex $data 16]             ;# done
     set CHECK_PACKAGE_DIRECTORY                [lindex $data 17]             ;# done
     set CHECK_PACKAGE_TYPE                     [lindex $data 18]             ;# done
     set CHECK_QMASTER_INSTALL_OPTIONS          [lindex $data 19]             ;# done
     set CHECK_EXECD_INSTALL_OPTIONS            [lindex $data 20]             ;# done
     set CHECK_DNS_DOMAINNAME                   [lindex $data 21]             ;# done
     set CHECK_REMOTE_ENVIRONMENT               [lindex $data 22] ;# userconf  # done 
     set CHECK_FIRST_FOREIGN_SYSTEM_USER        [lindex $data 23] ;# userconf  # done
     set CHECK_SECOND_FOREIGN_SYSTEM_USER       [lindex $data 24] ;# userconf  # done
     set CHECK_FIRST_FOREIGN_SYSTEM_GROUP       [lindex $data 25] ;# userconf  
     set CHECK_SECOND_FOREIGN_SYSTEM_GROUP      [lindex $data 26] ;# userconf
     set CHECK_DEFAULT_DOMAIN                   [lindex $data 27]             ;# done
     set CHECK_MAILX_HOST                       [lindex $data 28]             ;# done
     set CHECK_REPORT_EMAIL_TO                  [lindex $data 29]             ;# done
     set CHECK_REPORT_EMAIL_CC                  [lindex $data 30]             ;# done 
     set CHECK_SEND_ERROR_MAILS                 [lindex $data 31]             ;# done
     set CHECK_MAX_ERROR_MAILS                  [lindex $data 32]             ;# done
     set CHECK_USE_SSH                          [lindex $data 33]             ;# done
     set CHECK_SOURCE_CVS_RELEASE               [lindex $data 34]             ;# done
     set CHECK_CONFIG_DIR                       [lindex $data 35]             ;# not supported !!!
   
     source_procedures
     get_version_info
     return 0
  }
}


#****** check/check_executable_files() *****************************************
#  NAME
#     check_executable_files() -- check if testsuite files are executable
#
#  SYNOPSIS
#     check_executable_files { } 
#
#  FUNCTION
#     testsuite setup
#
#  SEE ALSO
#     check/setup2()
#*******************************************************************************
proc check_executable_files {  } {

   global CHECK_TESTSUITE_ROOT CHECK_OUTPUT CHECK_SOURCE_DIR

   set filelist ""
   lappend filelist "$CHECK_TESTSUITE_ROOT/scripts/lock.sh"
   lappend filelist "$CHECK_TESTSUITE_ROOT/scripts/remote_submit.sh"
   lappend filelist "$CHECK_TESTSUITE_ROOT/scripts/remote_submit_log.sh"
   lappend filelist "$CHECK_TESTSUITE_ROOT/scripts/remote_tcl_command.sh"
   lappend filelist "$CHECK_TESTSUITE_ROOT/scripts/remotecompile.sh"
   lappend filelist "$CHECK_TESTSUITE_ROOT/scripts/sleeper.sh"
   lappend filelist "$CHECK_TESTSUITE_ROOT/scripts/ssh_progstarter.csh"
   lappend filelist "$CHECK_TESTSUITE_ROOT/checktree/functional/migration/checkpt_job.sh"
   lappend filelist "$CHECK_TESTSUITE_ROOT/checktree/functional/migration/migrate.sh"
   lappend filelist "$CHECK_TESTSUITE_ROOT/checktree/system_tests/clients/qmod/general/qmod_job.sh"
   lappend filelist "$CHECK_TESTSUITE_ROOT/checktree/system_tests/clients/qrsh/qsub_gid.sh"
   lappend filelist "$CHECK_TESTSUITE_ROOT/checktree/system_tests/clients/qrsh/remote_qrsh.sh"
   lappend filelist "$CHECK_TESTSUITE_ROOT/checktree/system_tests/clients/qrsh/sleep_pid.sh"
   lappend filelist "$CHECK_TESTSUITE_ROOT/checktree/system_tests/clients/qrsh/terminate.sh"
   lappend filelist "$CHECK_TESTSUITE_ROOT/checktree/system_tests/clients/qrsh/trap.sh" 
   lappend filelist "$CHECK_TESTSUITE_ROOT/checktree/system_tests/clients/qrsh/ulimit.sh"
   lappend filelist "$CHECK_TESTSUITE_ROOT/checktree/system_tests/qmaster/size/pminiworm.sh"
   lappend filelist "$CHECK_TESTSUITE_ROOT/checktree/system_tests/qmaster/size/flood_sleeper.sh"
   lappend filelist "$CHECK_TESTSUITE_ROOT/checktree/system_tests/qmaster/size/qstat.sh"
   lappend filelist "$CHECK_TESTSUITE_ROOT/checktree/system_tests/qmaster/size/redir_stderr.sh"
   lappend filelist "$CHECK_TESTSUITE_ROOT/checktree/system_tests/qmaster/size/sge_start.sh"
   lappend filelist "$CHECK_SOURCE_DIR/aimk"
   lappend filelist "$CHECK_SOURCE_DIR/dist/examples/jobs/array_submitter.sh"
   lappend filelist "$CHECK_SOURCE_DIR/dist/examples/jobs/env-tester.csh"
   lappend filelist "$CHECK_SOURCE_DIR/dist/examples/jobs/jobnet_submitter.sh"
   lappend filelist "$CHECK_SOURCE_DIR/dist/examples/jobs/pminiworm.sh"
   lappend filelist "$CHECK_SOURCE_DIR/dist/examples/jobs/simple.sh"
   lappend filelist "$CHECK_SOURCE_DIR/dist/examples/jobs/sleeper.sh"
   lappend filelist "$CHECK_SOURCE_DIR/dist/examples/jobs/step_A_array_submitter.sh"
   lappend filelist "$CHECK_SOURCE_DIR/dist/examples/jobs/step_B_array_submitter.sh"
   lappend filelist "$CHECK_SOURCE_DIR/dist/examples/jobs/worker.sh"
   

   set change_files ""


   set file_error 0
   foreach elem $filelist {
      set filename $elem
      if { [ file isfile $filename ] != 1  } {
         puts $CHECK_OUTPUT "file not found: $filename"
         set file_error 1
         continue
      }
      set attribs [ file attributes $filename -permissions] 
      if { [ string compare $attribs "00755" ] != 0 } {
         puts $CHECK_OUTPUT "file not executable (attributes: $attribs):\n $filename"
         lappend change_files $filename
         set file_error 1
         continue
      }
   }

   if { $file_error != 0 } {
      while { 1 } {
         puts $CHECK_OUTPUT "should I set the file permissions to 00755? (yes/no)"
         set answer [wait_for_enter 1]
         if { [ string compare $answer "yes" ] == 0 } {
            foreach elem $change_files {
                catch { file attributes $elem -permissions 00755 }
                set attribs [ file attributes $elem -permissions] 
                if { [ string compare $attribs "00755" ] != 0  } {
                   puts $CHECK_OUTPUT "check_executable_files - error setting file permissions: $elem"
                   exit -1
                }
            }  
            break
         } 
         if { [ string compare $answer "no" ] == 0 } {
            puts $CHECK_OUTPUT "check_executable_files - file errors. exit."
            exit -1
         } 
         puts $CHECK_OUTPUT "please enter \"yes\" or \"no\"!"
      }
   }
}

#****** check/set_users_environment() ******************************************
#  NAME
#     set_users_environment() -- setup user and l10n environment
#
#  SYNOPSIS
#     set_users_environment { host {variable_name env} { show_variables 0 } } 
#
#  FUNCTION
#     This procedure is used to generate the users environment for the
#     local environment and for the create_shell_script() procedure.
#
#  INPUTS
#     host                 - hostname (used for l10n)
#     {variable_name env}  - variable to store environment
#     { show_variables 0 } - if 1: print setting info
#
#  SEE ALSO
#     file_procedures/create_shell_script()
#*******************************************************************************
proc set_users_environment { host {variable_name env} { show_variables 0 } } {
   global CHECK_REMOTE_ENVIRONMENT CHECK_OUTPUT env 
   global CHECK_L10N ts_host_config ts_config

   upvar $variable_name environment

   set remote_environment $CHECK_REMOTE_ENVIRONMENT

   if { $CHECK_L10N == 0 && [llength $remote_environment] == 0 } {
      return 0
   }

   if { $show_variables } {
      puts $CHECK_OUTPUT "==============================================================================="
   }

   if { $CHECK_L10N != 0 } {
      set locale $ts_config(l10n_test_locale)
      if { [ info exist ts_host_config($host,${locale}_locale) ] != 1 } {
         if { [set pos [ string first $ts_config(dns_domain) $host]] >= 0 } {
            if { $ts_config(dns_for_install_script) == "none" } {
                incr pos -2
                set host [ string range $host 0 $pos ]
            }
         }
      }

      if { [ info exist ts_host_config($host,${locale}_locale) ] } {
         set locale_env $ts_host_config($host,${locale}_locale)
         if { $locale_env == "" } {
            debug_puts "no value for ${locale}_locale on host $host, please set LANG, LC_MESSAGES ..."
         }
         append locale_env " SGE_ENABLE_MSG_ID=2 SGE_INFOTEXT_MAX_COLUMN=5000"
         debug_puts "L10N enabled"
         debug_puts "locale = \"$locale\""
         debug_puts "environment on host $host: $locale_env"
         foreach u_env $locale_env {
            debug_puts "environment: $u_env"
            set help [split $u_env "="]
            set env_name  [lindex $help 0]
            set env_value [lindex $help 1]
            debug_puts "env_name: $env_name"
            if { [string compare $env_name ""] == 0 } {
               puts $CHECK_OUTPUT "error setting users environment (setup parameter user_environment)"
               return -1
            }
            debug_puts "env_value: $env_value"
            if { [string compare $env_value ""] == 0 } {
               if { [info exists env($env_name)] } {
                  set env_value $env($env_name)
               } else {
                  puts $CHECK_OUTPUT "error setting users environment (setup parameter user_environment)"
                  return -1
               }
            }
            if { [string compare $variable_name "env"] == 0 } {
               if { $show_variables } {
                  puts $CHECK_OUTPUT "setting local l10n variable $env_name=\"$env_value\""
               }
            } else {
               if { $show_variables } {
                  puts $CHECK_OUTPUT "setting remote l10n variable $env_name=\"$env_value\""
               }
            }
            set environment($env_name) $env_value 
            debug_puts "$env_name set to \"$env_value\""
         }
      } else {
         debug_puts "could not find l10n configuration for host $host"
      }
   }

   foreach u_env $remote_environment {
      debug_puts "environment: $u_env"
      set help [split $u_env "="]
      set env_name  [lindex $help 0]
      set env_value [lindex $help 1]
      debug_puts "env_name: $env_name"
      if { [string compare $env_name ""] == 0 } {
         puts $CHECK_OUTPUT "error setting users environment (setup parameter user_environment)"
         return -1
      }
      debug_puts "env_value: $env_value"
      if { [string compare $env_value ""] == 0 } {
         if { [info exists env($env_name)] } {
            set env_value $env($env_name)
         } else {
            puts $CHECK_OUTPUT "error setting users environment (setup parameter user_environment)"
            return -1
         }
      }
      if { [string compare $variable_name "env"] == 0 } {
         if { $show_variables } {
            puts $CHECK_OUTPUT "setting local variable $env_name=\"$env_value\""
         }
      } else {
         if { $show_variables } {
            puts $CHECK_OUTPUT "setting remote variable $env_name=\"$env_value\""
         }
      }
      set environment($env_name) $env_value 
      debug_puts "$env_name set to \"$env_value\""
   }
   if { $show_variables } {
      puts $CHECK_OUTPUT "==============================================================================="
   }

   return 0
}

proc show_setup_information { } {

   global CHECK_OUTPUT

   clear_screen
   puts $CHECK_OUTPUT "Testsuite Setup Information"
   puts $CHECK_OUTPUT "==========================="
   puts $CHECK_OUTPUT ""
   puts $CHECK_OUTPUT "If you are starting the testsuite for the first time you should read this short"
   puts $CHECK_OUTPUT "setup guide to make it easier for you to understand the setup questions."
   puts $CHECK_OUTPUT ""
   puts $CHECK_OUTPUT "The testsuite needs 3 user accounts:\n"
   puts $CHECK_OUTPUT " a) testsuite user:   The user who is starting the testsuite\n"
   puts $CHECK_OUTPUT " b) first_foreign_system_username:  "
   puts $CHECK_OUTPUT "                      Test user account (used for submitting, deleting jobs)"
   puts $CHECK_OUTPUT "                      This user must be member of two system groups (use <SPACE>"
   puts $CHECK_OUTPUT "                      to seperate the groups)\n"
   puts $CHECK_OUTPUT " c) second_foreign_system_username:"
   puts $CHECK_OUTPUT "                      Test user account (used for submitting, deleting jobs)"
   puts $CHECK_OUTPUT "                      This user must be member of a system group where b) is not"
   puts $CHECK_OUTPUT "                      group member.\n"
 
   wait_for_enter

   clear_screen
   puts $CHECK_OUTPUT "Testsuite Setup Information"
   puts $CHECK_OUTPUT "==========================="
   puts $CHECK_OUTPUT ""
   puts $CHECK_OUTPUT "The 3 user accounts must have rlogin access to the cluster hosts. (.rhost file)\n"
   puts $CHECK_OUTPUT "Every output to stdout in\n"
   puts $CHECK_OUTPUT " /etc/csh.cshrc, /etc/csh.login, \$HOME/.cshrc, \$HOME/.login , ...\n"
   puts $CHECK_OUTPUT "is not allowed. The testsuite will use e.g. rlogin \$EXEC_HOST pwd to get the"
   puts $CHECK_OUTPUT "working directory on that host. Any output made in the files would influence"
   puts $CHECK_OUTPUT "the result of the call.\n" 

   puts $CHECK_OUTPUT "Each of the 3 user must have read access to\n"
   puts $CHECK_OUTPUT "   - testsuite directory"
   puts $CHECK_OUTPUT "   - source code directory"
   puts $CHECK_OUTPUT "   - installation directory (\$SGE_ROOT)"   
  
   wait_for_enter

   clear_screen
   puts $CHECK_OUTPUT "Testsuite Setup Information"
   puts $CHECK_OUTPUT "==========================="
   puts $CHECK_OUTPUT ""
   puts $CHECK_OUTPUT "All path statements have to be absolute. The use of links may cause troubles."
    
   wait_for_enter
}


#****** check/save_host_configuration() ****************************************
#  NAME
#     save_host_configuration() -- save host configuration
#
#  SYNOPSIS
#     save_host_configuration { file } 
#
#  FUNCTION
#     This procedure will save the actual host configuration to the given
#     file. (ts_host_config array)
#
#  INPUTS
#     file - host configuration file
#
#  SEE ALSO
#     check/save_user_configuration()
#     check/save_configuration()
#*******************************************************************************
proc save_host_configuration { file } {
   global ts_host_config
   global CHECK_OUTPUT

   set conf_name "testsuite host configuration"

   if { [ info exists ts_host_config(version) ] == 0 } {
      puts $CHECK_OUTPUT "no version specified - abort saving"
      wait_for_enter
      return -1
   }

   # first get old configuration
   read_array_from_file  $file $conf_name old_host_config
   # save old configuration 
   spool_array_to_file $file "$conf_name.old" old_host_config
   spool_array_to_file $file $conf_name ts_host_config  
   puts $CHECK_OUTPUT "new host configuration saved: version: $ts_host_config(version)"
   wait_for_enter
   return 0
}

#****** check/save_user_configuration() ****************************************
#  NAME
#     save_user_configuration() -- save user configuration file
#
#  SYNOPSIS
#     save_user_configuration { file } 
#
#  FUNCTION
#     This procedure will save the actual user configuration to the given
#     file. (ts_user_config array)
#
#  INPUTS
#     file - user configuration file
#
#  SEE ALSO
#     check/save_host_configuration()
#     check/save_configuration()
#*******************************************************************************
proc save_user_configuration { file } {
   global ts_user_config
   global CHECK_OUTPUT

   if { [ info exists ts_user_config(version) ] == 0 } {
      puts $CHECK_OUTPUT "no version specified - abort saving"
      wait_for_enter
      return -1
   }


   set conf_name "testsuite user configuration"
   # first get old configuration
   read_array_from_file  $file $conf_name old_user_config
   # save old configuration 
   spool_array_to_file $file "$conf_name.old" old_user_config
   spool_array_to_file $file $conf_name ts_user_config  
   
   puts $CHECK_OUTPUT "new user configuration saved"
   wait_for_enter

   return 0
}


#****** check/save_configuration() *********************************************
#  NAME
#     save_configuration() -- save testsuite configuration (ts_config array)
#
#  SYNOPSIS
#     save_configuration { } 
#
#  FUNCTION
#     This procedure will save the actual ts_config array settings to the
#     testsuite setup file.
#
#  SEE ALSO
#     check/restore_configuration()
#*******************************************************************************
proc save_configuration {} {
   global ts_config
   global CHECK_OUTPUT
   global CHECK_DEFAULTS_FILE
   global pe_for_version_check_result

   set conf_name "testsuite configuration"

   if { [ info exists ts_config(version) ] == 0 } {
      puts $CHECK_OUTPUT "no version"
      wait_for_enter
      return -1
   }

   # first get old configuration
   read_array_from_file  $CHECK_DEFAULTS_FILE $conf_name old_config
   # save old configuration 
   spool_array_to_file $CHECK_DEFAULTS_FILE "$conf_name.old" old_config
   spool_array_to_file $CHECK_DEFAULTS_FILE $conf_name ts_config  
   puts $CHECK_OUTPUT "new testsuite configuration saved"

   set pe_for_version_check_result "undefined"

   wait_for_enter

   return 0
}

#****** check/restore_configuration() ******************************************
#  NAME
#     restore_configuration() -- restore old testsuite configuration
#
#  SYNOPSIS
#     restore_configuration { } 
#
#  FUNCTION
#     This procedure can be used to get the previous testsuite configuration
#
#  SEE ALSO
#     check/save_configuration()
#*******************************************************************************
proc restore_configuration { } {
   global ts_config
   global CHECK_OUTPUT
   global CHECK_DEFAULTS_FILE

   set conf_name "testsuite configuration"

   # first get old configuration
   read_array_from_file  $CHECK_DEFAULTS_FILE "$conf_name.old" old_config
   if { [ info exists old_config(version) ] } {
      puts $CHECK_OUTPUT "spooling previous configuration (Version: $old_config(version)"
      spool_array_to_file $CHECK_DEFAULTS_FILE $conf_name old_config
   } else {
      puts $CHECK_OUTPUT "no previous configuration available!"
   }
   puts $CHECK_OUTPUT "reading latest configuration ..."
   read_array_from_file  $CHECK_DEFAULTS_FILE "$conf_name" ts_config

   return 0
}


#****** check/get_configuration_element_name_on_pos() **************************
#  NAME
#     get_configuration_element_name_on_pos() -- return config elem name on pos
#
#  SYNOPSIS
#     get_configuration_element_name_on_pos { config_array config_pos } 
#
#  FUNCTION
#     This procedure returns the name of the configuration element on the
#     given position.
#
#  INPUTS
#     config_array - ts_config, ts_host_config or ts_user_config
#     config_pos   - pos number
#
#  SEE ALSO
#     check/get_configuration_element_count()
#*******************************************************************************
proc get_configuration_element_name_on_pos { config_array config_pos } {
   global CHECK_OUTPUT actual_ts_config_version
   upvar  $config_array config

   set params ""
   set pos_entries [lsort [ array names config "*,pos" ]]
   foreach pos $pos_entries {
      set name_end_pos [ string last "," $pos]
      incr name_end_pos -1
      set name [ string range $pos 0 $name_end_pos ]
      lappend params $name
   }
   set params [lsort $params]

   set max_pos 0
   foreach elem $params {
      if { $config($elem,pos) == $config_pos } {
         return $elem
      }
   }
   return ""
}



#****** check/get_configuration_element_count() ********************************
#  NAME
#     get_configuration_element_count() -- returns number of conig elements
#
#  SYNOPSIS
#     get_configuration_element_count { config_array } 
#
#  FUNCTION
#     This procedure returns the config parameter count for one of the testsuite
#     setup arrays (ts_config, ts_host_config, ts_user_config)
#
#  INPUTS
#     config_array - ts_config, ts_host_config or ts_user_config
#
#  SEE ALSO
#     check/get_configuration_element_name_on_pos()
#*******************************************************************************
proc get_configuration_element_count { config_array } {
   global CHECK_OUTPUT actual_ts_config_version
   upvar  $config_array config

   set params ""
   set pos_entries [lsort [ array names config "*,pos" ]]
   foreach pos $pos_entries {
      set name_end_pos [ string last "," $pos]
      incr name_end_pos -1
      set name [ string range $pos 0 $name_end_pos ]
      lappend params $name
   }
   set params [lsort $params]

   set max_pos 0
   foreach elem $params {
      if { $config($elem,pos) > $max_pos } {
         set max_pos $config($elem,pos)
      }
   }
   return $max_pos
}


#****** check/config_testsuite_root_dir() **************************************
#  NAME
#     config_testsuite_root_dir() -- testsuite root directory setup
#
#  SYNOPSIS
#     config_testsuite_root_dir { only_check name config_array } 
#
#  FUNCTION
#     Testsuite configuration setup - called from verify_config()
#
#  INPUTS
#     only_check   - 0: expect user input
#                    1: just verify user input
#     name         - option name (in ts_config array)
#     config_array - config array name (ts_config)
#
#  SEE ALSO
#     check/setup2()
#     check/verify_config()
#*******************************************************************************
proc config_testsuite_root_dir { only_check name config_array } {
   global CHECK_OUTPUT 
   global CHECK_TESTSUITE_ROOT
   global CHECK_TESTSUITE_LOCKFILE
   global CHECK_USER
   global CHECK_GROUP
   global env

   upvar $config_array config
   
   set actual_value  $config($name)
   set default_value $config($name,default)
   set description   $config($name,desc)

   set value $actual_value
   if { $actual_value == "" } {
      set value $default_value
   }

   if { $only_check == 0 } {
      # do setup
      puts $CHECK_OUTPUT "" 
      puts $CHECK_OUTPUT "Please enter the full pathname of the testsuite root directory, or press >RETURN<"
      puts $CHECK_OUTPUT "to use the default value. If you want to test with root permissions (which is"
      puts $CHECK_OUTPUT "neccessary for a full testing) the root user must have read permissions for this"
      puts $CHECK_OUTPUT "directory."
      puts $CHECK_OUTPUT "(default: $value)"
      puts -nonewline $CHECK_OUTPUT "> "
      set input [ wait_for_enter 1]
      if { [ string length $input] > 0 } {
         set value $input 
      } else {
         puts $CHECK_OUTPUT "using default value"
      }
   } 
   # now verify

   # is full path ?
   if { [ string first "/" $value ] != 0 } {
      puts $CHECK_OUTPUT "Path \"$value\" doesn't start with \"/\""
      return -1
   }

   # is file ?
   if { [ file isfile $value/check.exp ] != 1 } {
      puts $CHECK_OUTPUT "File \"$value/check.exp\" not found"
      return -1
   }

   # set global variables to value
   set CHECK_TESTSUITE_ROOT $value
   set CHECK_TESTSUITE_LOCKFILE "$value/testsuite_lockfile"

   if {[catch {set CHECK_USER [set env(USER)] }] != 0} {
      set CHECK_USER [file attributes $CHECK_TESTSUITE_ROOT/check.exp -owner]
      debug_puts "\nNo USER is set!\n(default: $CHECK_USER)\n"
      set env(USER) $CHECK_USER
   } 

   if {[catch {set CHECK_GROUP [set env(GROUP)] }] != 0} {
      set CHECK_GROUP [file attributes $CHECK_TESTSUITE_ROOT/check.exp -group]
      debug_puts "\nNo GROUP is set!\n(default: $CHECK_GROUP)\n"
      set env(GROUP) $CHECK_GROUP
   }

   return $value
}


#****** check/config_checktree_root_dir() **************************************
#  NAME
#     config_checktree_root_dir() -- checktree root setup
#
#  SYNOPSIS
#     config_checktree_root_dir { only_check name config_array } 
#
#  FUNCTION
#     Testsuite configuration setup - called from verify_config()
#
#  INPUTS
#     only_check   - 0: expect user input
#                    1: just verify user input
#     name         - option name (in ts_config array)
#     config_array - config array name (ts_config)
#
#  SEE ALSO
#     check/setup2()
#     check/verify_config()
#*******************************************************************************
proc config_checktree_root_dir { only_check name config_array } {
   global CHECK_OUTPUT 
   global CHECK_TESTSUITE_ROOT
   global CHECK_TESTSUITE_LOCKFILE
   global CHECK_CHECKTREE_ROOT
   global CHECK_USER CHECK_HOST
   global CHECK_GROUP
   global env

   upvar $config_array config
   
   set actual_value  $config($name)
   set default_value $config($name,default)
   set description   $config($name,desc)

   set value $actual_value
   if { $actual_value == "" } {
      set value $default_value
      if { $default_value == "" } { 
         set value $CHECK_TESTSUITE_ROOT/checktree
      }
   }

   if { $only_check == 0 } {
      # do setup
      puts $CHECK_OUTPUT "" 
      puts $CHECK_OUTPUT "Please enter the full pathname of the testsuite checktree directory, or press >RETURN<"
      puts $CHECK_OUTPUT "to use the default value."
      puts $CHECK_OUTPUT "The checktree directory contains all tests in its subdirectory structure."
      puts $CHECK_OUTPUT "(default: $value)"
      puts -nonewline $CHECK_OUTPUT "> "
      set input [ wait_for_enter 1]
      if { [ string length $input] > 0 } {
         set value $input 
      } else {
         puts $CHECK_OUTPUT "using default value"
      }
   } 
   # now verify

   set local_host [ gethostname ]
   if { $local_host == "unknown" } {
      puts $CHECK_OUTPUT "Could not get local host name" 
      return -1
   }
   set CHECK_HOST $local_host


   # is full path ?
   if { [ string first "/" $value ] != 0 } {
      puts $CHECK_OUTPUT "Path \"$value\" doesn't start with \"/\""
      return -1
   }

   # is file ?
   if { [ file isdirectory $value ] != 1 } {
      puts $CHECK_OUTPUT "Directory \"$value\" not found"
      return -1
   }

   # set global variables to value
   set CHECK_CHECKTREE_ROOT $value

   return $value
}



#****** check/config_host_config_file() ****************************************
#  NAME
#     config_host_config_file() -- host config file setup
#
#  SYNOPSIS
#     config_host_config_file { only_check name config_array } 
#
#  FUNCTION
#     Testsuite configuration setup - called from verify_config()
#
#  INPUTS
#     only_check   - 0: expect user input
#                    1: just verify user input
#     name         - option name (in ts_config array)
#     config_array - config array name (ts_config)
#
#  SEE ALSO
#     check/setup2()
#     check/verify_config()
#*******************************************************************************
proc config_host_config_file { only_check name config_array } {
   global CHECK_OUTPUT 

   upvar $config_array config
   
   set actual_value  $config($name)
   set default_value $config($name,default)
   set description   $config($name,desc)
   
   set value $actual_value
   if { $actual_value == "" } {
      set value $default_value
   }


   if { $only_check == 0 } {
      # do setup  
      puts $CHECK_OUTPUT "" 
      puts $CHECK_OUTPUT "Please enter the full pathname of the host configuration file, or press >RETURN<"
      puts $CHECK_OUTPUT "to use the default value."
      puts $CHECK_OUTPUT "The host configuration file is used to define the cluster hosts setup"
      puts $CHECK_OUTPUT "configuration needed by the testsuite."
      puts $CHECK_OUTPUT "(default: $value)"
      puts -nonewline $CHECK_OUTPUT "> "
      set input [ wait_for_enter 1]
      if { [ string length $input] > 0 } {
         set value $input 
      } else {
         puts $CHECK_OUTPUT "using default value"
      }
   } 

   # now verify
   # is full path ?
   if { [ string first "/" $value ] != 0 } {
      puts $CHECK_OUTPUT "Path \"$value\" doesn't start with \"/\""
      return -1
   }

   # is file ?
   set hconfdone 0

   if { [ file isfile $value ] != 1 && $only_check != 0 } {
      if { $only_check != 0 } {
         puts $CHECK_OUTPUT "File \"$value\" not found"
         return -1
      } else {
         setup_host_config $value
         set hconfdone 1 
      }
   }
 
   if { $hconfdone == 0} {
      setup_host_config $value
   }
  
   return $value
}

#****** check/config_user_config_file() ****************************************
#  NAME
#     config_user_config_file() -- user configuration file setup
#
#  SYNOPSIS
#     config_user_config_file { only_check name config_array } 
#
#  FUNCTION
#     Testsuite configuration setup - called from verify_config()
#
#  INPUTS
#     only_check   - 0: expect user input
#                    1: just verify user input
#     name         - option name (in ts_config array)
#     config_array - config array name (ts_config)
#
#  SEE ALSO
#     check/setup2()
#     check/verify_config()
#*******************************************************************************
proc config_user_config_file { only_check name config_array } {
   global CHECK_OUTPUT 


   upvar $config_array config
   
   set actual_value  $config($name)
   set default_value $config($name,default)
   set description   $config($name,desc)
   
   set value $actual_value
   if { $actual_value == "" } {
      set value $default_value
   }
   if { $only_check == 0 } {
      # do setup  
      puts $CHECK_OUTPUT "" 
      puts $CHECK_OUTPUT "Please enter the full pathname of the user configuration file, or press >RETURN<"
      puts $CHECK_OUTPUT "to use the default value."
      puts $CHECK_OUTPUT "The user configuration file is used to define the cluster user needed by the"
      puts $CHECK_OUTPUT "testsuite."
      puts $CHECK_OUTPUT "(default: $value)"
      puts -nonewline $CHECK_OUTPUT "> "
      set input [ wait_for_enter 1]
      if { [ string length $input] > 0 } {
         set value $input 
      } else {
         puts $CHECK_OUTPUT "using default value"
      }
   } 

   # now verify
   # is full path ?
   if { [ string first "/" $value ] != 0 } {
      puts $CHECK_OUTPUT "Path \"$value\" doesn't start with \"/\""
      return -1
   }

   # is file ?
   set userconfdone 0

   if { [ file isfile $value ] != 1 && $only_check != 0 } {
      if { $only_check != 0 } {
         puts $CHECK_OUTPUT "File \"$value\" not found"
         return -1
      } else {
         setup_user_config $value
         set userconfdone 1 
      }
   }
 
   if { $userconfdone == 0} {
      setup_user_config $value
   }
  
   return $value
}

#****** check/config_results_dir() *********************************************
#  NAME
#     config_results_dir() -- results directory setup
#
#  SYNOPSIS
#     config_results_dir { only_check name config_array } 
#
#  FUNCTION
#     Testsuite configuration setup - called from verify_config()
#
#  INPUTS
#     only_check   - 0: expect user input
#                    1: just verify user input
#     name         - option name (in ts_config array)
#     config_array - config array name (ts_config)
#
#  SEE ALSO
#     check/setup2()
#     check/verify_config()
#*******************************************************************************
proc config_results_dir { only_check name config_array } {
   global CHECK_OUTPUT 
   global CHECK_TESTSUITE_ROOT
   global CHECK_MAIN_RESULTS_DIR
   global CHECK_PROTOCOL_DIR
   global CHECK_JOB_OUTPUT_DIR
   global CHECK_RESULT_DIR 
   global CHECK_BAD_RESULT_DIR 
   global CHECK_REPORT_FILE 
   global CHECK_CORE_RESULT_DIR 
   global CHECK_CORE_BAD_RESULT_DIR 
   global CHECK_HOST


   upvar $config_array config
   set actual_value  $config($name)
   set default_value $config($name,default)
   set description   $config($name,desc)
   set value $actual_value
   if { $actual_value == "" } {
      set value $default_value
      if { $default_value == "" } {
         set value $CHECK_TESTSUITE_ROOT/results
      }
   }
   if { $only_check == 0 } {
      # do setup  
      puts $CHECK_OUTPUT "" 
      puts $CHECK_OUTPUT "Please enter the full pathname of the testsuite results directory, or"
      puts $CHECK_OUTPUT "press >RETURN< to use the default value."
      puts $CHECK_OUTPUT "The testsuite will use this directory to save test results and internal"
      puts $CHECK_OUTPUT "data."
      puts $CHECK_OUTPUT "(default: $value)"
      puts -nonewline $CHECK_OUTPUT "> "
      set input [ wait_for_enter 1]
      if { [ string length $input] > 0 } {
         set value $input 
      } else {
         puts $CHECK_OUTPUT "using default value"
      }
   } 

   # now verify
   # is full path ?
   if { [ string first "/" $value ] != 0 } {
      puts $CHECK_OUTPUT "Path \"$value\" doesn't start with \"/\""
      return -1
   }

   if { [ file isdirectory $value ] != 1 } {
      file mkdir $value
   }

   # is file ?
   if { [ file isdirectory $value ] != 1 } {
      puts $CHECK_OUTPUT "Directory \"$value\" not found"
      return -1
   } 

   # set global values
   set CHECK_MAIN_RESULTS_DIR $value
   set CHECK_PROTOCOL_DIR $CHECK_MAIN_RESULTS_DIR/protocols
   set CHECK_JOB_OUTPUT_DIR "$CHECK_MAIN_RESULTS_DIR/testsuite_job_outputs"

   set CHECK_RESULT_DIR "$CHECK_MAIN_RESULTS_DIR/$CHECK_HOST.completed"
   set CHECK_BAD_RESULT_DIR "$CHECK_MAIN_RESULTS_DIR/$CHECK_HOST.uncompleted"
   set CHECK_REPORT_FILE "$CHECK_MAIN_RESULTS_DIR/$CHECK_HOST.report"
   set CHECK_CORE_RESULT_DIR "$CHECK_MAIN_RESULTS_DIR/core.completed"
   set CHECK_CORE_BAD_RESULT_DIR "$CHECK_MAIN_RESULTS_DIR/core.uncompleted"
 
   if {[file isdirectory "$CHECK_CORE_RESULT_DIR"] != 1} {
        file mkdir "$CHECK_CORE_RESULT_DIR"
   }
   if {[file isdirectory "$CHECK_CORE_BAD_RESULT_DIR"] != 1} {
        file mkdir "$CHECK_CORE_BAD_RESULT_DIR"
   }
   if {[file isdirectory "$CHECK_RESULT_DIR"] != 1} {
        file mkdir "$CHECK_RESULT_DIR"
   }
   if {[file isdirectory "$CHECK_BAD_RESULT_DIR"] != 1} {
        file mkdir "$CHECK_BAD_RESULT_DIR"
   }
   if {[file isdirectory "$CHECK_JOB_OUTPUT_DIR"] != 1} {
        file mkdir "$CHECK_JOB_OUTPUT_DIR"
   }
   return $value
}

#****** check/config_source_dir() **********************************************
#  NAME
#     config_source_dir() -- source directory setup
#
#  SYNOPSIS
#     config_source_dir { only_check name config_array } 
#
#  FUNCTION
#     Testsuite configuration setup - called from verify_config()
#
#  INPUTS
#     only_check   - 0: expect user input
#                    1: just verify user input
#     name         - option name (in ts_config array)
#     config_array - config array name (ts_config)
#
#  SEE ALSO
#     check/setup2()
#     check/verify_config()
#*******************************************************************************
proc config_source_dir { only_check name config_array } {
   global CHECK_OUTPUT 
   global CHECK_TESTSUITE_ROOT
   global CHECK_SOURCE_DIR
   global CHECK_ARCH

   upvar $config_array config
   set actual_value  $config($name)
   set default_value $config($name,default)
   set description   $config($name,desc)
   set value $actual_value
   if { $actual_value == "" } {
      set value $default_value
      if { $default_value == "" } {
         set pos [ string first "/testsuite" $CHECK_TESTSUITE_ROOT ]
         set value [string range $CHECK_TESTSUITE_ROOT 0 $pos]
         append value "source"
      }
   }
   if { $only_check == 0 } {
      # do setup  
      puts $CHECK_OUTPUT "" 
      puts $CHECK_OUTPUT "Please enter the full pathname of the Grid Engine source directory, or"
      puts $CHECK_OUTPUT "press >RETURN< to use the default value."
      puts $CHECK_OUTPUT "The testsuite needs this directory to call aimk (to compile source code)"
      puts $CHECK_OUTPUT "and for resolving the host names (util scripts)."
      puts $CHECK_OUTPUT "(default: $value)"
      puts -nonewline $CHECK_OUTPUT "> "
      set input [ wait_for_enter 1]
      if { [ string length $input] > 0 } {
         set value $input 
      } else {
         puts $CHECK_OUTPUT "using default value"
      }
   } 

   # now verify
   # is full path ?
   if { [ string first "/" $value ] != 0 } {
      puts $CHECK_OUTPUT "Path \"$value\" doesn't start with \"/\""
      return -1
   }

   # is directory ?
   if { [ file isdirectory $value ] != 1 } {
      puts $CHECK_OUTPUT "Directory \"$value\" not found"
      return -1
   }

   # is aimk file present ?
   if { [ file isfile $value/aimk ] != 1 } {
      puts $CHECK_OUTPUT "File \"$value/aimk\" not found"
      return -1
   }
 
   # set global values
   set CHECK_SOURCE_DIR $value

   set local_arch [ resolve_arch ]
   if { $local_arch == "unknown" } {
      puts $CHECK_OUTPUT "Could not resolve local system architecture" 
      return -1
   }
   set CHECK_ARCH $local_arch



   return $value
}

#****** check/config_dns_domain() **********************************************
#  NAME
#     config_dns_domain() -- dns domain setup
#
#  SYNOPSIS
#     config_dns_domain { only_check name config_array } 
#
#  FUNCTION
#     Testsuite configuration setup - called from verify_config()
#
#  INPUTS
#     only_check   - 0: expect user input
#                    1: just verify user input
#     name         - option name (in ts_config array)
#     config_array - config array name (ts_config)
#
#  SEE ALSO
#     check/setup2()
#     check/verify_config()
#*******************************************************************************
proc config_dns_domain { only_check name config_array } {
   global CHECK_OUTPUT 
   global CHECK_DNS_DOMAINNAME
   global CHECK_ARCH
   global CHECK_USER
   global CHECK_HOST

   upvar $config_array config
   set actual_value  $config($name)
   set default_value $config($name,default)
   set description   $config($name,desc)
   set value $actual_value
   if { $actual_value == "" } {
      set value $default_value
   }
   if { $only_check == 0 } {
      # do setup  
      puts $CHECK_OUTPUT "" 
      puts $CHECK_OUTPUT "Please enter your DNS domain name or"
      puts $CHECK_OUTPUT "press >RETURN< to use the default value."
      puts $CHECK_OUTPUT "The DNS domain is used in the qmaster complex test."
      puts $CHECK_OUTPUT "(default: $value)"
      puts -nonewline $CHECK_OUTPUT "> "
      set input [ wait_for_enter 1]
      if { [ string length $input] > 0 } {
         set value $input 
      } else {
         puts $CHECK_OUTPUT "using default value"
      }
   } 

#   set local_arch [ resolve_arch ]
#   if { $local_arch == "unknown" } {
#      puts $CHECK_OUTPUT "Could not resolve local system architecture" 
#      return -1
#   }
#   set CHECK_ARCH $local_arch

   debug_puts "local system : $CHECK_ARCH"
   debug_puts "local host   : $CHECK_HOST"   

   set result [ start_remote_prog $CHECK_HOST $CHECK_USER "echo" "\"hello $CHECK_HOST\"" prg_exit_state 60 0 "" 1 0 ]
   if { $prg_exit_state != 0 } {
      puts $CHECK_OUTPUT "rlogin to host $CHECK_HOST doesn't work correctly"
      return -1
   }
   if { [ string first "hello $CHECK_HOST" $result ] < 0 } {
      puts $CHECK_OUTPUT "$result"
      puts $CHECK_OUTPUT "echo \"hello $CHECK_HOST\" doesn't work"
      return -1
   }

   debug_puts "domain check ..."
   set host "$CHECK_HOST.$value"
   debug_puts "hostname with dns domain: \"$host\""

   set result [ start_remote_prog $host $CHECK_USER "echo" "\"hello $host\"" prg_exit_state 60 0 "" 1 0 ]
   if { $prg_exit_state != 0 } {
      puts $CHECK_OUTPUT "rlogin to host $host doesn't work correctly"
      return -1
   }
   if { [ string first "hello $host" $result ] < 0 } {
      puts $CHECK_OUTPUT "$result"
      puts $CHECK_OUTPUT "echo \"hello $host\" doesn't work"
      return -1
   }

   # set global values
   set CHECK_DNS_DOMAINNAME $value

   return $value
}


#****** check/config_dns_for_install_script() **********************************
#  NAME
#     config_dns_for_install_script() -- domain used for sge installation
#
#  SYNOPSIS
#     config_dns_for_install_script { only_check name config_array } 
#
#  FUNCTION
#     Testsuite configuration setup - called from verify_config()
#
#  INPUTS
#     only_check   - 0: expect user input
#                    1: just verify user input
#     name         - option name (in ts_config array)
#     config_array - config array name (ts_config)
#
#  SEE ALSO
#     check/setup2()
#     check/verify_config()
#*******************************************************************************
proc config_dns_for_install_script { only_check name config_array } {
   global CHECK_OUTPUT 
   global CHECK_DEFAULT_DOMAIN
   global CHECK_ARCH
   global CHECK_USER
   global CHECK_HOST

   upvar $config_array config
   set actual_value  $config($name)
   set default_value $config($name,default)
   set description   $config($name,desc)
   set value $actual_value
   if { $actual_value == "" } {
      set value $default_value
   }
   if { $only_check == 0 } {
      # do setup  
      puts $CHECK_OUTPUT "" 
      puts $CHECK_OUTPUT "Please enter the DNS domain name used for installation script"
      puts $CHECK_OUTPUT "or press >RETURN< to use the default value."
      puts $CHECK_OUTPUT "Set this value to \"none\" if all your cluster hosts are in the"
      puts $CHECK_OUTPUT "same DNS domain."
      puts $CHECK_OUTPUT "(default: $value)"
      puts -nonewline $CHECK_OUTPUT "> "
      set input [ wait_for_enter 1]
      if { [ string length $input] > 0 } {
         set value $input 
      } else {
         puts $CHECK_OUTPUT "using default value"
      }
   } 

   # only check domain if not none
   if { [string compare "none" $value] != 0 } {
      debug_puts "local system : $CHECK_ARCH"
      debug_puts "local host   : $CHECK_HOST"   

      debug_puts "domain check ..."
      set host "$CHECK_HOST.$value"
      debug_puts "hostname with dns domain: \"$host\""
   
      set result [ start_remote_prog $host $CHECK_USER "echo" "\"hello $host\"" prg_exit_state 60 0 "" 1 0 ]
      if { $prg_exit_state != 0 } {
         puts $CHECK_OUTPUT "rlogin to host $host doesn't work correctly"
         return -1
      }
      if { [ string first "hello $host" $result ] < 0 } {
         puts $CHECK_OUTPUT "$result"
         puts $CHECK_OUTPUT "echo \"hello $host\" doesn't work"
         return -1
      }
   }

   # set global values
   set CHECK_DEFAULT_DOMAIN $value

   return $value
}

#****** check/config_mailx_host() **********************************************
#  NAME
#     config_mailx_host() -- mailx option setup
#
#  SYNOPSIS
#     config_mailx_host { only_check name config_array } 
#
#  FUNCTION
#     Testsuite configuration setup - called from verify_config()
#
#  INPUTS
#     only_check   - 0: expect user input
#                    1: just verify user input
#     name         - option name (in ts_config array)
#     config_array - config array name (ts_config)
#
#  SEE ALSO
#     check/setup2()
#     check/verify_config()
#*******************************************************************************
proc config_mailx_host { only_check name config_array } {
   global CHECK_OUTPUT 
   global CHECK_USER 
   global CHECK_MAILX_HOST
   global CHECK_HOST

   upvar $config_array config
   set actual_value  $config($name)
   set default_value $config($name,default)
   set description   $config($name,desc)
   set value $actual_value
   if { $actual_value == "" } {
      set value $default_value
      if { $default_value == "" } {
         set value $CHECK_HOST
      }
   }
   if { $only_check == 0 } {
      # do setup  
      puts $CHECK_OUTPUT "" 
      puts $CHECK_OUTPUT "Please enter the name of the host used for sending e-mail reports"
      puts $CHECK_OUTPUT "or press >RETURN< to use the default value."
      puts $CHECK_OUTPUT "Set this value to \"none\" if you don't want get e-mails from the"
      puts $CHECK_OUTPUT "testsuite."
      puts $CHECK_OUTPUT "(default: $value)"
      puts -nonewline $CHECK_OUTPUT "> "
      set input [ wait_for_enter 1]
      if { [ string length $input] > 0 } {
         set value $input 
      } else {
         puts $CHECK_OUTPUT "using default value"
      }
   } 

   # only check domain if not none
   if { [string compare "none" $value] != 0 } {
      set host $value
      set result [ start_remote_prog $host $CHECK_USER "echo" "\"hello $host\"" prg_exit_state 60 0 "" 1 0 ]
      if { $prg_exit_state != 0 } {
         puts $CHECK_OUTPUT "rlogin to host $host doesn't work correctly"
         return -1
      }
      if { [ string first "hello $host" $result ] < 0 } {
         puts $CHECK_OUTPUT "$result"
         puts $CHECK_OUTPUT "echo \"hello $host\" doesn't work"
         return -1
      }
      set result [ start_remote_prog $host $CHECK_USER "which" "mailx" prg_exit_state 60 0 "" 1 0 ]
      if { $prg_exit_state != 0 } {
         puts $CHECK_OUTPUT $result
         puts $CHECK_OUTPUT "mailx not found on host $host. Please enhance your PATH envirnoment"
         return -1
      } else {
         debug_puts $result
         debug_puts "found mailx binary in path"
      }
   }

   # set global values
   set CHECK_MAILX_HOST $value

   return $value
}

#****** check/config_source_cvs_hostname() *************************************
#  NAME
#     config_source_cvs_hostname() -- cvs hostname setup
#
#  SYNOPSIS
#     config_source_cvs_hostname { only_check name config_array } 
#
#  FUNCTION
#     Testsuite configuration setup - called from verify_config()
#
#  INPUTS
#     only_check   - 0: expect user input
#                    1: just verify user input
#     name         - option name (in ts_config array)
#     config_array - config array name (ts_config)
#
#  SEE ALSO
#     check/setup2()
#     check/verify_config()
#*******************************************************************************
proc config_source_cvs_hostname { only_check name config_array } {
   global CHECK_OUTPUT 
   global CHECK_USER 
   global CHECK_SOURCE_HOSTNAME
   global CHECK_HOST

   upvar $config_array config
   set actual_value  $config($name)
   set default_value $config($name,default)
   set description   $config($name,desc)
   set value $actual_value
   if { $actual_value == "" } {
      set value $default_value
      if { $default_value == "" } {
         set value $CHECK_HOST
      }
   }
   if { $only_check == 0 } {
      # do setup  
      puts $CHECK_OUTPUT "" 
      puts $CHECK_OUTPUT "Please enter the name of the host used for executing cvs commands"
      puts $CHECK_OUTPUT "or press >RETURN< to use the default value."
      puts $CHECK_OUTPUT "(default: $value)"
      puts -nonewline $CHECK_OUTPUT "> "
      set input [ wait_for_enter 1]
      if { [ string length $input] > 0 } {
         set value $input 
      } else {
         puts $CHECK_OUTPUT "using default value"
      }
   } 

   set host $value
   set result [ start_remote_prog $host $CHECK_USER "echo" "\"hello $host\"" prg_exit_state 60 0 "" 1 0 ]
   if { $prg_exit_state != 0 } {
      puts $CHECK_OUTPUT "rlogin to host $host doesn't work correctly"
      return -1
   }
   if { [ string first "hello $host" $result ] < 0 } {
      puts $CHECK_OUTPUT "$result"
      puts $CHECK_OUTPUT "echo \"hello $host\" doesn't work"
      return -1
   }
   set result [ start_remote_prog $host $CHECK_USER "which" "cvs" prg_exit_state 60 0 "" 1 0 ]
   if { $prg_exit_state != 0 } {
      puts $CHECK_OUTPUT $result
      puts $CHECK_OUTPUT "cvs not found on host $host. Please enhance your PATH envirnoment"
      return -1
   } else {
      debug_puts $result
      debug_puts "found cvs command"
   }

   # set global values
   set  CHECK_SOURCE_HOSTNAME $value

   return $value
}

#****** check/config_source_cvs_release() **************************************
#  NAME
#     config_source_cvs_release() -- cvs release setup
#
#  SYNOPSIS
#     config_source_cvs_release { only_check name config_array } 
#
#  FUNCTION
#     Testsuite configuration setup - called from verify_config()
#
#  INPUTS
#     only_check   - 0: expect user input
#                    1: just verify user input
#     name         - option name (in ts_config array)
#     config_array - config array name (ts_config)
#
#  SEE ALSO
#     check/setup2()
#     check/verify_config()
#*******************************************************************************
proc config_source_cvs_release { only_check name config_array } {
   global CHECK_OUTPUT 
   global CHECK_USER 
   global CHECK_SOURCE_DIR
   global CHECK_SOURCE_CVS_RELEASE
   global CHECK_SOURCE_HOSTNAME

   upvar $config_array config
   set actual_value  $config($name)
   set default_value $config($name,default)
   set description   $config($name,desc)
   set value $actual_value
   if { $actual_value == "" } {
      set value $default_value
      if { $default_value == "" } {
         set result [start_remote_prog $CHECK_SOURCE_HOSTNAME $CHECK_USER "cat" "$CHECK_SOURCE_DIR/CVS/Tag" prg_exit_state 60 0 "" 1 0]
         set result [string trim $result]
         if { $prg_exit_state == 0 } {
            if { [ string first "T" $result ] == 0 } {
               set value [ string range $result 1 end ]
            }
         } else {
            set value "maintrunc" 
         }
      }
   }
   if { $only_check == 0 } {
      # do setup  
      puts $CHECK_OUTPUT "" 
      puts $CHECK_OUTPUT "Please enter cvs release tag (\"maintrunc\" specifies no tag)"
      puts $CHECK_OUTPUT "or press >RETURN< to use the default value."
      puts $CHECK_OUTPUT "(default: $value)"
      puts -nonewline $CHECK_OUTPUT "> "
      set input [ wait_for_enter 1]
      if { [ string length $input] > 0 } {
         set value $input 
      } else {
         puts $CHECK_OUTPUT "using default value"
      }
   } 

   set result [start_remote_prog $CHECK_SOURCE_HOSTNAME $CHECK_USER "cat" "$CHECK_SOURCE_DIR/CVS/Tag" prg_exit_state 60 0 "" 1 0]
   set result [string trim $result]
   if { $prg_exit_state == 0 } {
      if { [ string compare $result "T$value" ] != 0 && [string compare $result "N$value"] != 0 } {
         puts $CHECK_OUTPUT "CVS/Tag entry doesn't match cvs release tag \"$value\" in directory $CHECK_SOURCE_HOSTNAME"
         return -1
      }
   } 

   # set global values
   set  CHECK_SOURCE_CVS_RELEASE $value

   return $value
}


#****** check/config_aimk_compile_options() ************************************
#  NAME
#     config_aimk_compile_options() -- aimk compile option setup
#
#  SYNOPSIS
#     config_aimk_compile_options { only_check name config_array } 
#
#  FUNCTION
#     Testsuite configuration setup - called from verify_config()
#
#  INPUTS
#     only_check   - 0: expect user input
#                    1: just verify user input
#     name         - option name (in ts_config array)
#     config_array - config array name (ts_config)
#
#  SEE ALSO
#     check/setup2()
#     check/verify_config()
#*******************************************************************************
proc config_aimk_compile_options { only_check name config_array } {
   global CHECK_OUTPUT 
   global CHECK_AIMK_COMPILE_OPTIONS

   upvar $config_array config
   set actual_value  $config($name)
   set default_value $config($name,default)
   set description   $config($name,desc)
   set value $actual_value
   if { $actual_value == "" } {
      set value $default_value
   }
   if { $only_check == 0 } {
      # do setup  
      puts $CHECK_OUTPUT "" 
      puts $CHECK_OUTPUT "Please enter aimk compile options (use \"none\" for no options)"
      puts $CHECK_OUTPUT "or press >RETURN< to use the default value."
      puts $CHECK_OUTPUT "(default: $value)"
      puts -nonewline $CHECK_OUTPUT "> "
      set input [ wait_for_enter 1]
      if { [ string length $input] > 0 } {
         set value $input 
      } else {
         puts $CHECK_OUTPUT "using default value"
      }
   } 
   # set global values
   set CHECK_AIMK_COMPILE_OPTIONS  $value
   if { [ string compare "none" $value ] == 0  } {
      set  CHECK_AIMK_COMPILE_OPTIONS ""
   }
   return $value
}


#****** check/config_dist_install_options() ************************************
#  NAME
#     config_dist_install_options() -- distrib install options
#
#  SYNOPSIS
#     config_dist_install_options { only_check name config_array } 
#
#  FUNCTION
#     Testsuite configuration setup - called from verify_config()
#
#  INPUTS
#     only_check   - 0: expect user input
#                    1: just verify user input
#     name         - option name (in ts_config array)
#     config_array - config array name (ts_config)
#
#  SEE ALSO
#     check/setup2()
#     check/verify_config()
#*******************************************************************************
proc config_dist_install_options { only_check name config_array } {
   global CHECK_OUTPUT 
   global CHECK_DIST_INSTALL_OPTIONS 

   upvar $config_array config
   set actual_value  $config($name)
   set default_value $config($name,default)
   set description   $config($name,desc)
   set value $actual_value
   if { $actual_value == "" } {
      set value $default_value
   }
   if { $only_check == 0 } {
      # do setup  
      puts $CHECK_OUTPUT "" 
      puts $CHECK_OUTPUT "Please enter dist install options (use \"none\" for no options)"
      puts $CHECK_OUTPUT "or press >RETURN< to use the default value."
      puts $CHECK_OUTPUT "(default: $value)"
      puts -nonewline $CHECK_OUTPUT "> "
      set input [ wait_for_enter 1]
      if { [ string length $input] > 0 } {
         set value $input 
      } else {
         puts $CHECK_OUTPUT "using default value"
      }
   } 
   # set global values
   set CHECK_DIST_INSTALL_OPTIONS $value
   if { [ string compare "none" $value ] == 0  } {
      set  CHECK_DIST_INSTALL_OPTIONS ""
   }

   return $value
}

#****** check/config_qmaster_install_options() *********************************
#  NAME
#     config_qmaster_install_options() -- master install options setup
#
#  SYNOPSIS
#     config_qmaster_install_options { only_check name config_array } 
#
#  FUNCTION
#     Testsuite configuration setup - called from verify_config()
#
#  INPUTS
#     only_check   - 0: expect user input
#                    1: just verify user input
#     name         - option name (in ts_config array)
#     config_array - config array name (ts_config)
#
#  SEE ALSO
#     check/setup2()
#     check/verify_config()
#*******************************************************************************
proc config_qmaster_install_options { only_check name config_array } {
   global CHECK_OUTPUT 
   global CHECK_QMASTER_INSTALL_OPTIONS 

   upvar $config_array config
   set actual_value  $config($name)
   set default_value $config($name,default)
   set description   $config($name,desc)
   set value $actual_value
   if { $actual_value == "" } {
      set value $default_value
   }
   if { $only_check == 0 } {
      # do setup  
      puts $CHECK_OUTPUT "" 
      puts $CHECK_OUTPUT "Please enter Grid Engine qmaster install options (use \"none\" for no options)"
      puts $CHECK_OUTPUT "or press >RETURN< to use the default value."
      puts $CHECK_OUTPUT "(default: $value)"
      puts -nonewline $CHECK_OUTPUT "> "
      set input [ wait_for_enter 1]
      if { [ string length $input] > 0 } {
         set value $input 
      } else {
         puts $CHECK_OUTPUT "using default value"
      }
   } 
   # set global values
   set CHECK_QMASTER_INSTALL_OPTIONS  $value
   if { [ string compare "none" $value ] == 0  } {
      set CHECK_QMASTER_INSTALL_OPTIONS  ""
   }

   return $value
}

#****** check/config_execd_install_options() ***********************************
#  NAME
#     config_execd_install_options() -- install options setup
#
#  SYNOPSIS
#     config_execd_install_options { only_check name config_array } 
#
#  FUNCTION
#     Testsuite configuration setup - called from verify_config()
#
#  INPUTS
#     only_check   - 0: expect user input
#                    1: just verify user input
#     name         - option name (in ts_config array)
#     config_array - config array name (ts_config)
#
#  SEE ALSO
#     check/setup2()
#     check/verify_config()
#*******************************************************************************
proc config_execd_install_options { only_check name config_array } {
   global CHECK_OUTPUT 
   global CHECK_EXECD_INSTALL_OPTIONS 

   upvar $config_array config
   set actual_value  $config($name)
   set default_value $config($name,default)
   set description   $config($name,desc)
   set value $actual_value
   if { $actual_value == "" } {
      set value $default_value
   }
   if { $only_check == 0 } {
      # do setup  
      puts $CHECK_OUTPUT "" 
      puts $CHECK_OUTPUT "Please enter Grid Engine execd install options (use \"none\" for no options)"
      puts $CHECK_OUTPUT "or press >RETURN< to use the default value."
      puts $CHECK_OUTPUT "(default: $value)"
      puts -nonewline $CHECK_OUTPUT "> "
      set input [ wait_for_enter 1]
      if { [ string length $input] > 0 } {
         set value $input 
      } else {
         puts $CHECK_OUTPUT "using default value"
      }
   } 
   # set global values
   set CHECK_EXECD_INSTALL_OPTIONS   $value
   if { [ string compare "none" $value ] == 0  } {
      set CHECK_EXECD_INSTALL_OPTIONS  ""
   }

   return $value
}


#****** check/config_package_directory() ***************************************
#  NAME
#     config_package_directory() -- package optiont setup
#
#  SYNOPSIS
#     config_package_directory { only_check name config_array } 
#
#  FUNCTION
#     Testsuite configuration setup - called from verify_config()
#
#  INPUTS
#     only_check   - 0: expect user input
#                    1: just verify user input
#     name         - option name (in ts_config array)
#     config_array - config array name (ts_config)
#
#  SEE ALSO
#     check/setup2()
#     check/verify_config()
#
#*******************************************************************************
proc config_package_directory { only_check name config_array } {
   global CHECK_OUTPUT 
   global CHECK_PACKAGE_DIRECTORY CHECK_PACKAGE_TYPE

   upvar $config_array config
   set actual_value  $config($name)
   set default_value $config($name,default)
   set description   $config($name,desc)
   set value $actual_value
   if { $actual_value == "" } {
      set value $default_value
   }
   if { $only_check == 0 } {
      # do setup  
      puts $CHECK_OUTPUT "" 
      puts $CHECK_OUTPUT "Please enter directory path to Grid Engine packages (pkgadd or zip),"
      puts $CHECK_OUTPUT "(use \"none\" if there are no packages available)"
      puts $CHECK_OUTPUT "or press >RETURN< to use the default value."
      puts $CHECK_OUTPUT "(default: $value)"
      puts -nonewline $CHECK_OUTPUT "> "
      set input [ wait_for_enter 1]
      if { [ string length $input] > 0 } {
         set value $input 
      } else {
         puts $CHECK_OUTPUT "using default value"
      }
   } 

   if { [string compare "none" $value ] != 0 } {
      if { [ file isdirectory $value ] != 1  } {
         puts $CHECK_OUTPUT "Directory \"$value\" not found"
         return -1
      }
      if { [info exists CHECK_PACKAGE_TYPE] } {
         if { [string compare $CHECK_PACKAGE_TYPE "tar"] == 0 }    {
            if { [check_packages_directory $value check_tar] != 0 } {
               puts $CHECK_OUTPUT "error checking package_directory! are all package file installed?"
               return -1
            }
         } else {
            if { [check_packages_directory $value check_zip] != 0 } {
               puts $CHECK_OUTPUT "error checking package_directory! are all package file installed?"
               return -1
            }
         }

      } else {
         if { [check_packages_directory $value] != 0 } {
            puts $CHECK_OUTPUT "error checking package_directory! are all package file installed?"
            return -1
         }
      }
   }

   # set global values
   set CHECK_PACKAGE_DIRECTORY $value

   return $value
}


#****** check/config_package_type() ********************************************
#  NAME
#     config_package_type() -- package type setup
#
#  SYNOPSIS
#     config_package_type { only_check name config_array } 
#
#  FUNCTION
#     Testsuite configuration setup - called from verify_config()
#
#  INPUTS
#     only_check   - 0: expect user input
#                    1: just verify user input
#     name         - option name (in ts_config array)
#     config_array - config array name (ts_config)
#
#  SEE ALSO
#     check/setup2()
#     check/verify_config()
#*******************************************************************************
proc config_package_type { only_check name config_array } {
   global CHECK_OUTPUT 
   global CHECK_PACKAGE_TYPE 

   upvar $config_array config
   set actual_value  $config($name)
   set default_value $config($name,default)
   set description   $config($name,desc)
   set value $actual_value
   if { $actual_value == "" } {
      set value $default_value
   }
   if { $only_check == 0 } {
      # do setup  
      puts $CHECK_OUTPUT "" 
      puts $CHECK_OUTPUT "Please enter package type to test (\"tar\" or \"zip\"),"
      puts $CHECK_OUTPUT "or press >RETURN< to use the default value."
      puts $CHECK_OUTPUT "(default: $value)"
      puts -nonewline $CHECK_OUTPUT "> "
      set input [ wait_for_enter 1]
      if { [ string length $input] > 0 } {
         set value $input 
      } else {
         puts $CHECK_OUTPUT "using default value"
      }
   } 

   if { [string compare "tar" $value ] != 0 && 
        [string compare "zip" $value ] != 0  } {
      puts $CHECK_OUTPUT "unexpected package type: \"$value\" use \"zip\" or \"tar\"!"
      return -1
   }

   # set global values
   set CHECK_PACKAGE_TYPE $value

   return $value
}







#****** check/config_report_mail_to() ******************************************
#  NAME
#     config_report_mail_to() -- mail to setup
#
#  SYNOPSIS
#     config_report_mail_to { only_check name config_array } 
#
#  FUNCTION
#     Testsuite configuration setup - called from verify_config()
#
#  INPUTS
#     only_check   - 0: expect user input
#                    1: just verify user input
#     name         - option name (in ts_config array)
#     config_array - config array name (ts_config)
#
#  SEE ALSO
#     check/setup2()
#     check/verify_config()
#*******************************************************************************
proc config_report_mail_to { only_check name config_array } {
   global CHECK_OUTPUT 
   global CHECK_USER 
   global CHECK_MAILX_HOST
   global CHECK_HOST
   global CHECK_REPORT_EMAIL_TO

   upvar $config_array config
   set actual_value  $config($name)
   set default_value $config($name,default)
   set description   $config($name,desc)
   set value $actual_value
   if { $actual_value == "" } {
      set value $default_value
      if { $config(mailx_host) == "none" } {
         set value "none"
         set only_check 1
      }
   }

   if { $only_check == 0 } {
      # do setup  
      puts $CHECK_OUTPUT "" 
      puts $CHECK_OUTPUT "Please enter e-mail address where the testsuite should send report mails"
      puts $CHECK_OUTPUT "or press >RETURN< to use the default value."
      puts $CHECK_OUTPUT "Set this value to \"none\" if you don't want get e-mails from the"
      puts $CHECK_OUTPUT "testsuite."
      puts $CHECK_OUTPUT "(default: $value)"
      puts -nonewline $CHECK_OUTPUT "> "
      set input [ wait_for_enter 1]
      if { [ string length $input] > 0 } {
         set value $input 
      } else {
         puts $CHECK_OUTPUT "using default value"
      }
   } 

   # set global values
   set CHECK_REPORT_EMAIL_TO $value

   return $value
}


#****** check/config_report_mail_cc() ******************************************
#  NAME
#     config_report_mail_cc() -- mail cc setup
#
#  SYNOPSIS
#     config_report_mail_cc { only_check name config_array } 
#
#  FUNCTION
#     Testsuite configuration setup - called from verify_config()
#
#  INPUTS
#     only_check   - 0: expect user input
#                    1: just verify user input
#     name         - option name (in ts_config array)
#     config_array - config array name (ts_config)
#
#  SEE ALSO
#     check/setup2()
#     check/verify_config()
#*******************************************************************************
proc config_report_mail_cc { only_check name config_array } {
   global CHECK_OUTPUT 
   global CHECK_USER 
   global CHECK_MAILX_HOST
   global CHECK_HOST
   global CHECK_REPORT_EMAIL_CC

   upvar $config_array config
   set actual_value  $config($name)
   set default_value $config($name,default)
   set description   $config($name,desc)
   set value $actual_value
   if { $actual_value == "" } {
      set value $default_value
      if { $config(mailx_host) == "none" } {
         set value "none"
         set only_check 1
      }
   }

   if { $only_check == 0 } {
      # do setup  
      puts $CHECK_OUTPUT "" 
      puts $CHECK_OUTPUT "Please enter e-mail address where the testsuite should cc report mails"
      puts $CHECK_OUTPUT "or press >RETURN< to use the default value."
      puts $CHECK_OUTPUT "Set this value to \"none\" if you don't want to cc e-mails from the"
      puts $CHECK_OUTPUT "testsuite."
      puts $CHECK_OUTPUT "(default: $value)"
      puts -nonewline $CHECK_OUTPUT "> "
      set input [ wait_for_enter 1]
      if { [ string length $input] > 0 } {
         set value $input 
      } else {
         puts $CHECK_OUTPUT "using default value"
      }
   } 

   # set global values
   set CHECK_REPORT_EMAIL_CC $value

   return $value
}

#****** check/config_enable_error_mails() **************************************
#  NAME
#     config_enable_error_mails() -- error mail setup
#
#  SYNOPSIS
#     config_enable_error_mails { only_check name config_array } 
#
#  FUNCTION
#     Testsuite configuration setup - called from verify_config()
#
#  INPUTS
#     only_check   - 0: expect user input
#                    1: just verify user input
#     name         - option name (in ts_config array)
#     config_array - config array name (ts_config)
#
#  SEE ALSO
#     check/setup2()
#     check/verify_config()
#*******************************************************************************
proc config_enable_error_mails { only_check name config_array } {
   global CHECK_OUTPUT 
   global CHECK_USER 
   global CHECK_MAILX_HOST
   global CHECK_HOST
   global CHECK_REPORT_EMAIL_TO
   global CHECK_REPORT_EMAIL_CC
   global CHECK_SEND_ERROR_MAILS
   global CHECK_MAX_ERROR_MAILS

   upvar $config_array config
   set actual_value  $config($name)
   set default_value $config($name,default)
   set description   $config($name,desc)
   set value $actual_value
   if { $actual_value == "" } {
      set value $default_value
      if { $config(mailx_host) == "none" } {
         set value "none"
         set only_check 1
      }
   }

   if { $only_check == 0 } {
      # do setup  
      puts $CHECK_OUTPUT "" 
      puts $CHECK_OUTPUT "Please enter the maximum number of e-mails you want to get from the"
      puts $CHECK_OUTPUT "testsuite or press >RETURN< to use the default value."
      puts $CHECK_OUTPUT "Set this value to \"none\" if you don't want to get e-mails from the"
      puts $CHECK_OUTPUT "testsuite."
      puts $CHECK_OUTPUT "(default: $value)"
      puts -nonewline $CHECK_OUTPUT "> "
      set input [ wait_for_enter 1]
      if { [ string length $input] > 0 } {
         set value $input 
      } else {
         puts $CHECK_OUTPUT "using default value"
      }
   } 

   if { $value != "none" } {
      if { $CHECK_MAILX_HOST == "none" } {
         puts $CHECK_OUTPUT "mailx host not configured"
         return -1
      }
      set  CHECK_SEND_ERROR_MAILS 1
      set  CHECK_MAX_ERROR_MAILS $value
      if { $only_check == 0 } {
         send_mail $CHECK_REPORT_EMAIL_TO $CHECK_REPORT_EMAIL_CC "Welcome!" "Testsuite mail setup test mail"
         puts $CHECK_OUTPUT "Have you got the e-mail? (y/n) "
         set input [wait_for_enter 1]
         if { $input != "y" }  {
            puts $CHECK_OUTPUT "disabling e-mail ..."
            set CHECK_SEND_ERROR_MAILS 0
            set CHECK_MAX_ERROR_MAILS 0
            set value "none"
         }
      }
   } else {
      set  CHECK_SEND_ERROR_MAILS 0
      set  CHECK_MAX_ERROR_MAILS 0
   }

   return $value
}


#****** check/config_use_ssh() *************************************************
#  NAME
#     config_use_ssh() -- ssh (secure shell) setup
#
#  SYNOPSIS
#     config_use_ssh { only_check name config_array } 
#
#  FUNCTION
#     Testsuite configuration setup - called from verify_config()
#
#  INPUTS
#     only_check   - 0: expect user input
#                    1: just verify user input
#     name         - option name (in ts_config array)
#     config_array - config array name (ts_config)
#
#  SEE ALSO
#     check/setup2()
#     check/verify_config()
#*******************************************************************************
proc config_use_ssh { only_check name config_array } {
   global CHECK_OUTPUT 
   global CHECK_USE_SSH
   global CHECK_USER
   global CHECK_HOST

   upvar $config_array config
   set actual_value  $config($name)
   set default_value $config($name,default)
   set description   $config($name,desc)
   set value $actual_value
   if { $actual_value == "" } {
      set value $default_value
   }

   if { $only_check == 0 } {
      # do setup  
      puts $CHECK_OUTPUT "" 
      puts $CHECK_OUTPUT "Please enter \"yes\" if testsuite should use secure shell to connect to the"
      puts $CHECK_OUTPUT "cluster hosts or press >RETURN< to use the default value."
      puts $CHECK_OUTPUT "Set this value to \"none\" if you don't want configure ssh access to all cluster"
      puts $CHECK_OUTPUT "hosts. The root user should not get any password question when using ssh."
      puts $CHECK_OUTPUT "(default: $value)"
      puts -nonewline $CHECK_OUTPUT "> "
      set input [ wait_for_enter 1]
      if { [ string length $input] > 0 } {
         set value $input 
      } else {
         puts $CHECK_OUTPUT "using default value"
      }
   } 

   set local_host [ gethostname ]
   if { $local_host == "unknown" } {
      puts $CHECK_OUTPUT "Could not get local host name" 
      return -1
   }
   set CHECK_HOST $local_host

   if { $value == "yes" } {
      set CHECK_USE_SSH 1
   } else {
      set value "none"
      set CHECK_USE_SSH 0
   }

   set result [ start_remote_prog $CHECK_HOST $CHECK_USER "echo" "\"hello $CHECK_HOST\"" prg_exit_state 60 0 "" 1 0 ]
   if { $prg_exit_state != 0 } {
      puts $CHECK_OUTPUT "rlogin/ssh to host $CHECK_HOST doesn't work correctly"
      return -1
   }
   if { [ string first "hello $CHECK_HOST" $result ] < 0 } {
      puts $CHECK_OUTPUT "$result"
      puts $CHECK_OUTPUT "echo \"hello $CHECK_HOST\" doesn't work"
      return -1
   }
   return $value
}

#****** check/config_master_host() *********************************************
#  NAME
#     config_master_host() -- master host setup
#
#  SYNOPSIS
#     config_master_host { only_check name config_array } 
#
#  FUNCTION
#     Testsuite configuration setup - called from verify_config()
#
#  INPUTS
#     only_check   - 0: expect user input
#                    1: just verify user input
#     name         - option name (in ts_config array)
#     config_array - config array name (ts_config)
#
#  SEE ALSO
#     check/setup2()
#     check/verify_config()
#*******************************************************************************
proc config_master_host { only_check name config_array } {
   global CHECK_OUTPUT 
   global CHECK_HOST
   global CHECK_CORE_MASTER
   global ts_host_config do_nomain

   upvar $config_array config
   set actual_value  $config($name)
   set default_value $config($name,default)
   set description   $config($name,desc)
   set value $actual_value

   set local_host [ gethostname ]
   if { $local_host == "unknown" } {
      puts $CHECK_OUTPUT "Could not get local host name" 
      return -1
   }
   set CHECK_HOST $local_host

   

   if { $actual_value == "" } {
      set value $default_value
      if { $default_value == "" } {
         set value $CHECK_HOST
      }
   }

#   master host must be check_host !!!
#
   if { $only_check == 0 } {
      # do setup  
      if { [ lsearch $ts_host_config(hostlist) $value ] < 0  } {
         puts $CHECK_OUTPUT "Press enter to add host \"$CHECK_HOST\" to global host configuration ..."
         wait_for_enter
         set errors 0
         incr errors [host_config_hostlist_add_host ts_host_config  $CHECK_HOST]
         incr errors [host_config_hostlist_edit_host ts_host_config $CHECK_HOST]
         incr errors [save_host_configuration $config(host_config_file)]
         if { $errors != 0 } {
            setup_host_config $config(host_config_file) 1
         }
      }
      puts $CHECK_OUTPUT "Press enter to use host \"$CHECK_HOST\" as qmaster host"
      wait_for_enter
      set value $CHECK_HOST
       
   } 

   debug_puts "master host: $value"
   if { [ string compare $value $CHECK_HOST] != 0 && $do_nomain == 0} {
      puts $CHECK_OUTPUT "Master host must be local host"
      return -1
   }

   if { [llength $value] != 1 } {
      puts $CHECK_OUTPUT "qmaster_host has more than one hostname entry"
      return -1
   }

   if { [ lsearch $ts_host_config(hostlist) $value ] < 0  } {
      puts $CHECK_OUTPUT "Master host \"$value\" is not in host configuration file"
      return -1
   }

   set CHECK_CORE_MASTER $value

   return $value
}

#****** check/config_execd_hosts_set_compile_hosts() ***************************
#  NAME
#     config_execd_hosts_set_compile_hosts() -- set compile host array
#
#  SYNOPSIS
#     config_execd_hosts_set_compile_hosts { value } 
#
#  FUNCTION
#     This procedure is called to set the global CHECK_SOURCE_COMPILE_HOSTS
#     variable. 
#
#  INPUTS
#     value - host list, used in execd list
#
#  SEE ALSO
#     check/config_execd_hosts()
#*******************************************************************************
proc config_execd_hosts_set_compile_hosts { value } {
   global CHECK_OUTPUT do_nomain
   global CHECK_SOURCE_COMPILE_HOSTS
   global ts_host_config

   set CHECK_SOURCE_COMPILE_HOSTS ""
   foreach host $value {
      if { $ts_host_config($host,compile) == 1 } {
         # ok we can compile on this host
         lappend CHECK_SOURCE_COMPILE_HOSTS $host
      } else {
         # is other host with that arch in host list ?
         set act_host_arch $ts_host_config($host,arch)
         set found_c_host 0
         foreach tmp_host $value {
            if { [string compare $ts_host_config($tmp_host,arch) $act_host_arch] == 0 } {
               if { $ts_host_config($tmp_host,compile) == 1 } {
                  lappend CHECK_SOURCE_COMPILE_HOSTS $tmp_host
                  set found_c_host 1
                  break
               }
            }
         }
         if { $found_c_host == 0 } {
            # try to find at least one compile host
            foreach tmp_host $ts_host_config(hostlist) {
               if { [string compare $ts_host_config($tmp_host,arch) $act_host_arch] == 0 } {
                  if { $ts_host_config($tmp_host,compile) == 1 } {
                     lappend CHECK_SOURCE_COMPILE_HOSTS $tmp_host
                     set found_c_host 1
                     break
                  }
               }
            } 
         }
         if { $found_c_host == 0 } {
            puts $CHECK_OUTPUT "no compile host found for architecture $act_host_arch"
            return -1
         }
      }
   }
   # sort CHECK_SOURCE_COMPILE_HOSTS
   set new_comp_host_list ""
   foreach elem $CHECK_SOURCE_COMPILE_HOSTS {
      if { [lsearch $new_comp_host_list $elem] < 0 } {
         lappend new_comp_host_list $elem
      }
   }
   set CHECK_SOURCE_COMPILE_HOSTS [lsort $new_comp_host_list]
   return 0
}

#****** check/config_execd_hosts() *********************************************
#  NAME
#     config_execd_hosts() -- execd daemon host setup
#
#  SYNOPSIS
#     config_execd_hosts { only_check name config_array } 
#
#  FUNCTION
#     Testsuite configuration setup - called from verify_config()
#
#  INPUTS
#     only_check   - 0: expect user input
#                    1: just verify user input
#     name         - option name (in ts_config array)
#     config_array - config array name (ts_config)
#
#  SEE ALSO
#     check/setup2()
#     check/verify_config()
#*******************************************************************************
proc config_execd_hosts { only_check name config_array } {
   global CHECK_OUTPUT do_nomain
   global CHECK_HOST
   global CHECK_CORE_EXECD
   global CHECK_CORE_PROCESSORS
   global CHECK_SOURCE_COMPILE_HOSTS
   global ts_host_config

   set CHECK_CORE_EXECD ""

   upvar $config_array config
   set actual_value  $config($name)
   set default_value $config($name,default)
   set description   $config($name,desc)
   set value $actual_value

   if { $actual_value == "" } {
      set value $default_value
      if { $default_value == "" } {
         set value $CHECK_HOST
      }
   }

   if { $only_check == 0 } {
#      # do setup  
       puts $CHECK_OUTPUT "" 
       set selected $value
       while { 1 } {
          clear_screen
          puts $CHECK_OUTPUT "----------------------------------------------------------"
          puts $CHECK_OUTPUT $description
          puts $CHECK_OUTPUT "----------------------------------------------------------"
           
          set selected [lsort $selected]
          puts $CHECK_OUTPUT "\nSelected cluster hosts:"
          puts $CHECK_OUTPUT "----------------------------------------------------------"
          foreach elem $selected { puts $CHECK_OUTPUT $elem }
          puts $CHECK_OUTPUT "----------------------------------------------------------"
          host_config_hostlist_show_hosts ts_host_config
          puts $CHECK_OUTPUT "\n"
          puts $CHECK_OUTPUT "Type \"all\" to select all hosts in list"
          puts -nonewline $CHECK_OUTPUT "Please enter hostname/number or return to exit: "
         
          set host [wait_for_enter 1]
          if { [ string length $host ] == 0 } {
             break
          }
          if { [ string compare $host "all" ] == 0 } {
             set selected ""
             foreach host $ts_host_config(hostlist) {
                if { [ lsearch -exact $selected $host ] < 0 } {
                   append selected " $host"
                }
             }
             break
          }
          if { [string is integer $host] } {
             incr host -1
             set host [ lindex $ts_host_config(hostlist) $host ]
          }
          if { [ lsearch $ts_host_config(hostlist) $host ] < 0 } {
             puts $CHECK_OUTPUT "host \"$host\" not found in list"
             wait_for_enter
             continue
          }
          if { [ lsearch -exact $selected $host ] < 0 } {
             append selected " $host"
          } else {
             set index [lsearch $selected $host]
             set selected [ lreplace $selected $index $index ]
          }
       }
       
       set value [string trim $selected]

       set index [lsearch $value $CHECK_HOST]
       if { $index >= 0 } {
          set selected [ lreplace $value $index $index ]
       }
       set value $CHECK_HOST
       append value " $selected"
       set value [string trim $value]
       foreach host $value {
          if { [ lsearch $ts_host_config(hostlist) $host ] < 0  } {
             puts $CHECK_OUTPUT "host \"$host\" is not in host configuration file"
             puts $CHECK_OUTPUT "Press enter to add host \"$host\" to global host configuration ..."
             wait_for_enter
             set errors 0
             incr errors [host_config_hostlist_add_host ts_host_config  $host]
             incr errors [host_config_hostlist_edit_host ts_host_config $host]
             incr errors [save_host_configuration $config(host_config_file)]
             if { $errors != 0 } {
                setup_host_config $config(host_config_file) 1
             }
          }
       }
       if { [config_execd_hosts_set_compile_hosts $value] != 0 } {
          puts $CHECK_OUTPUT "Press enter to edit global host configuration ..."
          wait_for_enter
          setup_host_config $config(host_config_file) 1
       }
   } 

   if { [ string compare [lindex $value 0] $CHECK_HOST] != 0  && $do_nomain == 0} {
      puts $CHECK_OUTPUT "First execd host must be local host"
      return -1
   }


   foreach host $value {
      if { [ lsearch $ts_host_config(hostlist) $host ] < 0  } {
         puts $CHECK_OUTPUT "Host \"$host\" is not in host configuration file"
         return -1
      }
   }
   set CHECK_CORE_EXECD $value

   if { [config_execd_hosts_set_compile_hosts $value] != 0 } {
      return -1
   }

   set CHECK_CORE_PROCESSORS ""
   foreach host $CHECK_CORE_EXECD {
      debug_puts "setting processors of host $host to $ts_host_config($host,processors)"
      lappend CHECK_CORE_PROCESSORS $ts_host_config($host,processors)
   }



   return $value
}


#****** check/config_submit_only_hosts() ***************************************
#  NAME
#     config_submit_only_hosts() -- submit only hosts setup
#
#  SYNOPSIS
#     config_submit_only_hosts { only_check name config_array } 
#
#  FUNCTION
#     Testsuite configuration setup - called from verify_config()
#
#  INPUTS
#     only_check   - 0: expect user input
#                    1: just verify user input
#     name         - option name (in ts_config array)
#     config_array - config array name (ts_config)
#
#  SEE ALSO
#     check/setup2()
#     check/verify_config()
#*******************************************************************************
proc config_submit_only_hosts { only_check name config_array } {
   global CHECK_OUTPUT 
   global CHECK_HOST
   global CHECK_CORE_EXECD
   global CHECK_SUBMIT_ONLY_HOSTS
   global ts_host_config

   upvar $config_array config
   set actual_value  $config($name)
   set default_value $config($name,default)
   set description   $config($name,desc)
   set value $actual_value

   if { $actual_value == "" } {
      set value $default_value
   }

   if { $only_check == 0 } {
#      # do setup  
       if { $value == "none" } {
          set value ""
       }
       puts $CHECK_OUTPUT "" 
       set selected $value
       while { 1 } {
          clear_screen
          puts $CHECK_OUTPUT "----------------------------------------------------------"
          puts $CHECK_OUTPUT $description
          puts $CHECK_OUTPUT "----------------------------------------------------------"

          set selected [lsort $selected]
          puts $CHECK_OUTPUT "\nSelected submit only hosts:"

          puts $CHECK_OUTPUT "----------------------------------------------------------"
          foreach elem $selected { puts $CHECK_OUTPUT $elem }
          puts $CHECK_OUTPUT "----------------------------------------------------------"

          host_config_hostlist_show_hosts ts_host_config
          puts $CHECK_OUTPUT "\n"
          puts $CHECK_OUTPUT "Type \"all\" to select all hosts who are not in execd host list"
          puts -nonewline $CHECK_OUTPUT "Please enter hostname/number or return to exit: "
         
          set host [wait_for_enter 1]
          if { [ string length $host ] == 0 } {
             break
          }
          if { [ string compare $host "all" ] == 0 } {
             set selected ""
             foreach host $ts_host_config(hostlist) {
                if { [ lsearch -exact $CHECK_CORE_EXECD $host ] < 0 } {
                   append selected " $host"
                }
             }
             break
          }
          if { [string is integer $host] } {
             incr host -1
             set host [ lindex $ts_host_config(hostlist) $host ]
          }
          if { [ lsearch $ts_host_config(hostlist) $host ] < 0 } {
             puts $CHECK_OUTPUT "host \"$host\" not found in list"
             wait_for_enter
             continue
          }
          if { [ lsearch $CHECK_CORE_EXECD $host ] >= 0 } {
             puts $CHECK_OUTPUT "host \"$host\" is in execd list"
             wait_for_enter
             continue
          }


          if { [ lsearch -exact $selected $host ] < 0 } {
             append selected " $host"
          } else {
             set index [lsearch $selected $host]
             set selected [ lreplace $selected $index $index ]
          }
       }
       
       set value [string trim $selected]
       foreach host $value {
          if { [ lsearch $ts_host_config(hostlist) $host ] < 0  } {
             puts $CHECK_OUTPUT "host \"$host\" is not in host configuration file"
             puts $CHECK_OUTPUT "Press enter to add host \"$host\" to global host configuration ..."
             wait_for_enter
             set errors 0
             incr errors [host_config_hostlist_add_host ts_host_config  $host]
             incr errors [host_config_hostlist_edit_host ts_host_config $host]
             incr errors [save_host_configuration $config(host_config_file)]
             if { $errors != 0 } {
                setup_host_config $config(host_config_file) 1
             }
          }
       }
       if { $value == "" } {
          set value "none"
       }
   } 

   if { [string compare $value "none"] != 0 }  {
      foreach host $value {
         if { [ lsearch $ts_host_config(hostlist) $host ] < 0  } {
            puts $CHECK_OUTPUT "Host \"$host\" is not in host configuration file"
            return -1
         }
         if { [ lsearch $CHECK_CORE_EXECD $host ] >= 0  } {
            puts $CHECK_OUTPUT "Host \"$host\" is in execd host list"
            return -1
         }
      }
      set CHECK_SUBMIT_ONLY_HOSTS $value
   } else {
      set CHECK_SUBMIT_ONLY_HOSTS ""
   }
   return $value
}


#****** check/config_add_compile_archs() ***************************************
#  NAME
#     config_add_compile_archs() -- forced compilation setup
#
#  SYNOPSIS
#     config_add_compile_archs { only_check name config_array } 
#
#  FUNCTION
#     Testsuite configuration setup - called from verify_config()
#
#  INPUTS
#     only_check   - 0: expect user input
#                    1: just verify user input
#     name         - option name (in ts_config array)
#     config_array - config array name (ts_config)
#
#  SEE ALSO
#     check/setup2()
#     check/verify_config()
#*******************************************************************************
proc config_add_compile_archs { only_check name config_array } {
   global CHECK_OUTPUT 
   global CHECK_HOST CHECK_ADDITIONAL_COMPILE_HOSTS
   global ts_host_config

   upvar $config_array config
   set actual_value  $config($name)
   set default_value $config($name,default)
   set description   $config($name,desc)
   set value $actual_value

   if { $actual_value == "" } {
      set value $default_value
   }

   if { $only_check == 0 } {
#      # do setup  
       if { $value == "none" } {
          set value ""
       }
       puts $CHECK_OUTPUT "" 
       set selected $value
       while { 1 } {
          clear_screen
          puts $CHECK_OUTPUT "----------------------------------------------------------"
          puts $CHECK_OUTPUT $description
          puts $CHECK_OUTPUT "----------------------------------------------------------"

          set selected [lsort $selected]
          puts $CHECK_OUTPUT "\nSelected additional compile architectures:"

          puts $CHECK_OUTPUT "----------------------------------------------------------"
          foreach elem $selected { puts $CHECK_OUTPUT $elem }
          puts $CHECK_OUTPUT "----------------------------------------------------------"

          host_config_hostlist_show_compile_hosts ts_host_config arch_array
          puts $CHECK_OUTPUT "\n"
          puts -nonewline $CHECK_OUTPUT "Please enter architecture/number or return to exit: "
         
          set new_arch [wait_for_enter 1]
          if { [ string length $new_arch ] == 0 } {
             break
          }
          if { [string is integer $new_arch] } {
             if { $new_arch >= 1 && $new_arch <= $arch_array(count) } {
                set new_arch $arch_array($new_arch,arch)
             }
          }
          # now we have arch string in new_arch
          set found_arch 0
          foreach host $ts_host_config(hostlist) {
             if { $ts_host_config($host,compile) == 1 } {
                set compile_arch $ts_host_config($host,arch)
                if { [ string compare $compile_arch $new_arch ] == 0 } {
                   set found_arch 1
                   continue
                }
             }
          }
          if { $found_arch == 0 } {
             puts $CHECK_OUTPUT "architecture \"$new_arch\" not found in list"
             wait_for_enter
             continue
          }

          if { [ lsearch -exact $selected $new_arch ] < 0 } {
             append selected " $new_arch"
          } else {
             set index [lsearch $selected $new_arch ]
             set selected [ lreplace $selected $index $index ]
          }
       }
       
       set value [string trim $selected]
       if { $value == "" } {
          set value "none"
       }
   } 

   if { [string compare $value "none"] != 0 }  {
      set add_compile_host_list ""
      foreach arch $value {
         set found_arch 0
         foreach host $ts_host_config(hostlist) {
             if { $ts_host_config($host,compile) == 1 } {
                set compile_arch $ts_host_config($host,arch)
                if { [ string compare $compile_arch $arch ] == 0 } {
                   set found_arch 1
                   lappend add_compile_host_list $host
                   continue
                }
             }
         }
         if { $found_arch == 0 } {
            puts $CHECK_OUTPUT "could not find compile host with architecture \"$arch\""
            return -1
         }
      } 
      set CHECK_ADDITIONAL_COMPILE_HOSTS $add_compile_host_list
   } else {
      set CHECK_ADDITIONAL_COMPILE_HOSTS ""
   }

   return $value
}


#****** check/config_commd_port() **********************************************
#  NAME
#     config_commd_port() -- commd port option setup
#
#  SYNOPSIS
#     config_commd_port { only_check name config_array } 
#  FUNCTION
#     Testsuite configuration setup - called from verify_config()
#
#  INPUTS
#     only_check   - 0: expect user input
#                    1: just verify user input
#     name         - option name (in ts_config array)
#     config_array - config array name (ts_config)
#
#  SEE ALSO
#     check/setup2()
#     check/verify_config()
#
#*******************************************************************************
proc config_commd_port { only_check name config_array } {
   global CHECK_OUTPUT 
   global CHECK_COMMD_PORT
   global CHECK_USER
   global ts_user_config

   upvar $config_array config
   set actual_value  $config($name)
   set default_value $config($name,default)
   set description   $config($name,desc)
   set value $actual_value

   if { $actual_value == "" } {
      set value $default_value
   }

   if { $only_check == 0 } {
#     # do setup  
      puts $CHECK_OUTPUT "" 
      puts $CHECK_OUTPUT "Please enter the port number value the testsuite should use for COMMD_PORT,"
      puts $CHECK_OUTPUT "or press >RETURN< to use the default value."
      puts $CHECK_OUTPUT "(default: $value)"
      puts -nonewline $CHECK_OUTPUT "> "
      set input [ wait_for_enter 1]
      if { [ string length $input] > 0 } {
         set value $input 
      } else {
         puts $CHECK_OUTPUT "using default value"
      }



       set add_port 0 
       if { [ info exists ts_user_config($CHECK_USER,portlist) ] != 1 } {
          puts $CHECK_OUTPUT "No portlist defined for user $CHECK_USER in user configuration"
          puts $CHECK_OUTPUT "Press enter to add user $CHECK_USER"
          wait_for_enter
          set errors 0
          incr errors [user_config_userlist_add_user ts_user_config  $CHECK_USER]
          incr errors [user_config_userlist_edit_user ts_user_config $CHECK_USER]
          incr errors [save_user_configuration $config(user_config_file)]
          if { $errors != 0 } {
             puts $CHECK_OUTPUT "Errors press enter to edit user configuration"
             wait_for_enter
             setup_user_config $config(user_config_file) 1
          }

       }
       if { [ lsearch $ts_user_config($CHECK_USER,portlist) $value ] < 0 } {
          puts $CHECK_OUTPUT "port $value not defined for user $CHECK_USER"
          puts $CHECK_OUTPUT "Press enter to add port $value"
          wait_for_enter
          set errors 0
          set new_value "$ts_user_config($CHECK_USER,portlist) $value"
          incr errors [user_config_userlist_set_portlist ts_user_config $CHECK_USER $new_value]
          if { $errors == 0 }  {
             incr errors [save_user_configuration $config(user_config_file)]
          }
          if { $errors != 0 } {
             puts $CHECK_OUTPUT "Errors press enter to edit user configuration"
             wait_for_enter
             setup_user_config $config(user_config_file) 1
          }
       }
   } 

   if { [ info exists ts_user_config($CHECK_USER,portlist) ] != 1 } {
      puts $CHECK_OUTPUT "User $CHECK_USER has not portlist entry in user configuration"
      return -1
   }

   if { [ lsearch $ts_user_config($CHECK_USER,portlist) $value] < 0 } {
      puts $CHECK_OUTPUT "Port $value not in portlist of user $CHECK_USER" 
      return -1
   }
 
   set CHECK_COMMD_PORT $value

   return $value
}

#****** check/config_product_root() ********************************************
#  NAME
#     config_product_root() -- product root setup
#
#  SYNOPSIS
#     config_product_root { only_check name config_array } 
#
#  FUNCTION
#     Testsuite configuration setup - called from verify_config()
#
#  INPUTS
#     only_check   - 0: expect user input
#                    1: just verify user input
#     name         - option name (in ts_config array)
#     config_array - config array name (ts_config)
#
#  SEE ALSO
#     check/setup2()
#     check/verify_config()
#*******************************************************************************
proc config_product_root { only_check name config_array } {
   global CHECK_OUTPUT 
   global CHECK_PRODUCT_ROOT

   upvar $config_array config
   set actual_value  $config($name)
   set default_value $config($name,default)
   set description   $config($name,desc)
   set value $actual_value

   if { $actual_value == "" } {
      set value $default_value
   }

   if { $only_check == 0 } {
#     # do setup  
      puts $CHECK_OUTPUT "" 
      puts $CHECK_OUTPUT "Please enter the path where the testsuite should install Grid Engine,"
      puts $CHECK_OUTPUT "or press >RETURN< to use the default value."
      puts $CHECK_OUTPUT "You can also specify a current installed Grid Engine system path."
      puts $CHECK_OUTPUT "WARNING: The compile option will remove the content of this directory"
      puts $CHECK_OUTPUT "and store it to \"testsuite_trash\" directory!!!"
      puts $CHECK_OUTPUT "(default: $value)"
      puts -nonewline $CHECK_OUTPUT "> "
      set input [ wait_for_enter 1]
      if { [ string length $input] > 0 } {
         set value $input 
      } else {
         puts $CHECK_OUTPUT "using default value"
      }
   } 

   
   # is full path ?
   if { [ string first "/" $value ] != 0 } {
      puts $CHECK_OUTPUT "Path \"$value\" doesn't start with \"/\""
      return -1
   }

   if { [ file isdirectory $value ] != 1 } {
      puts $CHECK_OUTPUT "Creating directory:\n$value"
      file mkdir $value
   }

   if { [ file isdirectory $value ] != 1 } {
      puts $CHECK_OUTPUT "Directory \"$value\" not found"
      return -1
   }

   set path_length [ string length "/bin/solaris64/sge_qmaster" ]
   if { [string length "$value/bin/solaris64/sge_qmaster"] > 60 } {
        puts $CHECK_OUTPUT "path for product_root_directory is to long (must be <= [expr ( 60 - $path_length )] chars)"
        puts $CHECK_OUTPUT "The testsuite tries to find processes via ps output most ps output is truncated"
        puts $CHECK_OUTPUT "for longer lines."
        return -1
   }


   set CHECK_PRODUCT_ROOT $value

   return $value
}



#****** check/config_product_type() ********************************************
#  NAME
#     config_product_type() -- product type setup
#
#  SYNOPSIS
#     config_product_type { only_check name config_array } 
#
#  FUNCTION
#     Testsuite configuration setup - called from verify_config()
#
#  INPUTS
#     only_check   - 0: expect user input
#                    1: just verify user input
#     name         - option name (in ts_config array)
#     config_array - config array name (ts_config)
#
#  SEE ALSO
#     check/setup2()
#     check/verify_config()
#*******************************************************************************
proc config_product_type { only_check name config_array } {
   global CHECK_OUTPUT 
   global CHECK_PRODUCT_TYPE

   upvar $config_array config
   set actual_value  $config($name)
   set default_value $config($name,default)
   set description   $config($name,desc)
   set value $actual_value

   if { $actual_value == "" } {
      set value $default_value
   }

   if { $only_check == 0 } {
#     # do setup  
      puts $CHECK_OUTPUT "" 
      puts $CHECK_OUTPUT "Please specify the product type. Enter \"sge\" for Grid Engine,"
      puts $CHECK_OUTPUT "\"sgeee\" for Grid Engine Enterprise Edition"
      puts $CHECK_OUTPUT "or press >RETURN< to use the default value."
      puts $CHECK_OUTPUT "(default: $value)"
      puts -nonewline $CHECK_OUTPUT "> "
      set input [ wait_for_enter 1]
      if { [ string length $input] > 0 } {
         set value $input 
      } else {
         puts $CHECK_OUTPUT "using default value"
      }
   } 

   if {    ([string compare "sgeee" $value ] != 0) &&
           ([string compare "sge"   $value ] != 0) } {
        puts $CHECK_OUTPUT "product_type can only be \"sge\" or \"sgeee\""
        return -1
   }
  
   set CHECK_PRODUCT_TYPE $value

   return $value
}

#****** check/config_product_feature() *****************************************
#  NAME
#     config_product_feature() -- product feature setup
#
#  SYNOPSIS
#     config_product_feature { only_check name config_array } 
#
#  FUNCTION
#     Testsuite configuration setup - called from verify_config()
#
#  INPUTS
#     only_check   - 0: expect user input
#                    1: just verify user input
#     name         - option name (in ts_config array)
#     config_array - config array name (ts_config)
#
#  SEE ALSO
#     check/setup2()
#     check/verify_config()
#*******************************************************************************
proc config_product_feature { only_check name config_array } {
   global CHECK_OUTPUT 
   global CHECK_PRODUCT_FEATURE

   upvar $config_array config
   set actual_value  $config($name)
   set default_value $config($name,default)
   set description   $config($name,desc)
   set value $actual_value

   if { $actual_value == "" } {
      set value $default_value
   }

   if { $only_check == 0 } {
#     # do setup  
      puts $CHECK_OUTPUT "" 
      puts $CHECK_OUTPUT "Please specify the product feature."
      puts $CHECK_OUTPUT "Enter \"none\" for no special product features."
      puts $CHECK_OUTPUT "Enter \"csp\" for Certificate Security Protocol"
      puts $CHECK_OUTPUT "or press >RETURN< to use the default value."
      puts $CHECK_OUTPUT "(default: $value)"
      puts -nonewline $CHECK_OUTPUT "> "
      set input [ wait_for_enter 1]
      if { [ string length $input] > 0 } {
         set value $input 
      } else {
         puts $CHECK_OUTPUT "using default value"
      }
   } 

   if { ([string compare "none"   $value ] != 0) &&
        ([string compare "csp" $value ] != 0) } {
        puts $CHECK_OUTPUT "product_feature can only be \"none\" or \"csp\""
        return -1
   }

   set CHECK_PRODUCT_FEATURE $value

   return $value
}

#****** check/config_l10n_test_locale() ****************************************
#  NAME
#     config_l10n_test_locale() -- l10n option setup
#
#  SYNOPSIS
#     config_l10n_test_locale { only_check name config_array } 
#
#  FUNCTION
#     Testsuite configuration setup - called from verify_config()
#
#  INPUTS
#     only_check   - 0: expect user input
#                    1: just verify user input
#     name         - option name (in ts_config array)
#     config_array - config array name (ts_config)
#
#  SEE ALSO
#     check/setup2()
#     check/verify_config()
#*******************************************************************************
proc config_l10n_test_locale { only_check name config_array } {
   global CHECK_OUTPUT 
   global CHECK_L10N ts_host_config ts_config
   global CHECK_CORE_MASTER CHECK_CORE_EXECD CHECK_SUBMIT_ONLY_HOSTS 

   upvar $config_array config
   set actual_value  $config($name)
   set default_value $config($name,default)
   set description   $config($name,desc)
   set value $actual_value

   if { $actual_value == "" } {
      set value $default_value
   }

   if { $only_check == 0 } {
#     # do setup  
      puts $CHECK_OUTPUT "" 
      puts $CHECK_OUTPUT "Please specify the locale for localization (l10n) test."
      puts $CHECK_OUTPUT "Enter \"none\" for no l10n testing."
      puts $CHECK_OUTPUT "Enter \"fr\", \"ja\" or \"zh\" to enable french, japanese or chinese"
      puts $CHECK_OUTPUT "l10n testing or press >RETURN< to use the default value."
      puts $CHECK_OUTPUT "(default: $value)"
      puts -nonewline $CHECK_OUTPUT "> "
      set input [ wait_for_enter 1]
      if { [ string length $input] > 0 } {
         set value $input 
      } else {
         puts $CHECK_OUTPUT "using default value"
      }
   } 
   set CHECK_L10N 0
   if { ([string compare "none"   $value ] != 0) } {
        
        if { [string compare "fr" $value ] == 0 || 
             [string compare "ja" $value ] == 0 ||
             [string compare "zh" $value ] == 0 } {

           set was_error 0

           if { [ info exist ts_host_config($CHECK_CORE_MASTER,${value}_locale)] != 1 } {
              puts $CHECK_OUTPUT "can't read ts_host_config($CHECK_CORE_MASTER,${value}_locale)"
              return -1
           }

           if { $ts_host_config($CHECK_CORE_MASTER,${value}_locale) == "" } {
              puts $CHECK_OUTPUT "locale not defined for master host $CHECK_CORE_MASTER"
              incr was_error 1
           }
           foreach host $CHECK_CORE_EXECD {
              if { $ts_host_config($host,${value}_locale) == "" } {
                 puts $CHECK_OUTPUT "locale not defined for execd host $host"
                 incr was_error 1
              }
           }
           foreach host $CHECK_SUBMIT_ONLY_HOSTS {
              if { $ts_host_config($host,${value}_locale) == "" } {
                 puts $CHECK_OUTPUT "locale not defined for submit host $host"
                 incr was_error 1
              }
           }
           if { $was_error != 0 } {
              if { $only_check == 0 } {
                  puts $CHECK_OUTPUT "Press enter to edit global host configuration ..."
                  wait_for_enter
                  setup_host_config $config(host_config_file) 1
              }
              return -1
           }
           set CHECK_L10N 1
           set mem_value $ts_config(l10n_test_locale)
           set ts_config(l10n_test_locale) $value
           set test_result [perform_simple_l10n_test]
           set ts_config(l10n_test_locale) $mem_value

           if { $test_result != 0 } {
              puts $CHECK_OUTPUT "l10n errors" 
              set CHECK_L10N 0
              return -1
           }
        } else {
           puts $CHECK_OUTPUT "unexpected locale setting"
           return -1
        }
   }
   return $value
}

#****** check/perform_simple_l10n_test() ***************************************
#  NAME
#     perform_simple_l10n_test() -- check minimal l10n settings
#
#  SYNOPSIS
#     perform_simple_l10n_test { } 
#
#  FUNCTION
#     This will try to get the translated version of an message string
#
#  SEE ALSO
#     ???/???
#*******************************************************************************
proc perform_simple_l10n_test { } {

   global CHECK_CORE_MASTER CHECK_USER CHECK_L10N ts_host_config ts_config
   global CHECK_OUTPUT CHECK_HOST CHECK_ARCH l10n_raw_cache
   puts $CHECK_OUTPUT ""
   flush $CHECK_OUTPUT

   set mem_it $CHECK_L10N


   set CHECK_L10N 0
   if { [ info exists l10n_raw_cache] } {
      unset l10n_raw_cache
   }
   set no_l10n  [translate $CHECK_CORE_MASTER 1 0 0 [sge_macro SGE_INFOTEXT_TESTSTRING_S_L10N ] " $CHECK_USER " ]
   set CHECK_L10N 1
   unset l10n_raw_cache
   set with_l10n  [translate $CHECK_CORE_MASTER 1 0 0 [sge_macro SGE_INFOTEXT_TESTSTRING_S_L10N ] " $CHECK_USER " ]

#   puts $CHECK_OUTPUT [translate $CHECK_CORE_MASTER 0 0 0 [sge_macro MSG_QSUB_YOURQSUBREQUESTCOULDNOTBESCHEDULEDDTRYLATER ]]

   puts $CHECK_OUTPUT "\n------------------------------------------------------------------------\n"
   puts $CHECK_OUTPUT $with_l10n
   puts $CHECK_OUTPUT "------------------------------------------------------------------------"
   set CHECK_L10N $mem_it

   if { [ string compare $no_l10n $with_l10n ] == 0 } {
      add_proc_error "perform_simple_l10n_test" -1 "localization (l10n) error:\nIs the locale directory available?"
      return -1
   } 
   return 0
}

#****** check/update_ts_host_config_version() **********************************
#  NAME
#     update_ts_host_config_version() -- used for version update of ts_host_config
#
#  SYNOPSIS
#     update_ts_host_config_version { filename } 
#
#  FUNCTION
#     This procedure is called when the versions of the testsuite host configuration
#     are not equal.
#
#  INPUTS
#     filename - host configuration file
#
#  SEE ALSO
#     check/update_ts_config_version()
#*******************************************************************************
proc update_ts_host_config_version { filename } {
   global actual_ts_host_config_version
   global ts_host_config ts_config
   global CHECK_OUTPUT

   if { $ts_host_config(version) == "1.0" && $actual_ts_host_config_version == "1.1" } {
      puts $CHECK_OUTPUT "\ntestsuite host configuration update from 1.0 to 1.1 ..."

      foreach host $ts_host_config(hostlist) {
         set ts_host_config($host,fr_locale) ""
         set ts_host_config($host,ja_locale) ""
         set ts_host_config($host,zh_locale) ""
      }
      set ts_host_config(version) "1.1"
     
      show_config ts_host_config
      wait_for_enter
      if { [ save_host_configuration $filename] != 0} {
         puts $CHECK_OUTPUT "Could not save host configuration"
         wait_for_enter
         return
      }
      return 0
   }
   puts $CHECK_OUTPUT "\nunexpected version"
   return -1
}

#****** check/update_ts_config_version() ***************************************
#  NAME
#     update_ts_config_version() -- used for version update of ts_config
#
#  SYNOPSIS
#     update_ts_config_version { } 
#
#  FUNCTION
#     This procedure is called when the versions of the testsuite configuration
#     are not equal.
#
#  SEE ALSO
#     check/update_ts_host_config_version()
#*******************************************************************************
proc update_ts_config_version {} {
   global actual_ts_config_version 
   global ts_config
   global CHECK_OUTPUT
   
   if { $ts_config(version) == "1.0" && $actual_ts_config_version == "1.1" } {
      puts $CHECK_OUTPUT "\ntestsuite configuration update from 1.0 to 1.1 ..."
      set insert_pos $ts_config(product_feature,pos)
      incr insert_pos 1
       
      set names [array names ts_config "*,pos"]
      foreach name $names {
         if { $ts_config($name) >= $insert_pos } {
            set ts_config($name) [ expr ( $ts_config($name) + 1 ) ]
         }
      }
      set parameter "l10n_test_locale"
      set ts_config($parameter)            ""
      set ts_config($parameter,desc)       "Specify localization environment (LANG)"
      set ts_config($parameter,default)    "none"
      set ts_config($parameter,setup_func) "config_$parameter"
      set ts_config($parameter,onchange)   "install"
      set ts_config($parameter,pos) $insert_pos

      set ts_config(version) "1.1"
     

      show_config ts_config
      wait_for_enter
      return 0
   }
   if { $ts_config(version) == "1.1" && $actual_ts_config_version == "1.2" } {
      puts $CHECK_OUTPUT "\ntestsuite configuration update from 1.1 to 1.2 ..."
      set insert_pos $ts_config(submit_only_hosts,pos)   ;# new entry after submit_only_hosts
      incr insert_pos 1
       
      set names [array names ts_config "*,pos"]
      foreach name $names {
         if { $ts_config($name) >= $insert_pos } {
            set ts_config($name) [ expr ( $ts_config($name) + 1 ) ]
         }
      }
      set parameter "add_compile_archs"
      set ts_config($parameter)            ""
      set ts_config($parameter,desc)       "Forced compilation for architectures"
      set ts_config($parameter,default)    "none"
      set ts_config($parameter,setup_func) "config_$parameter"
      set ts_config($parameter,onchange)   ""
      set ts_config($parameter,pos) $insert_pos

      set ts_config(version) "1.2"
     
      show_config ts_config
      wait_for_enter
      return 0
   }
   
   puts $CHECK_OUTPUT "\nunexpected version $ts_config(version), need version $actual_ts_config_version"
   return -1
}

#****** check/host_config_hostlist() *******************************************
#  NAME
#     host_config_hostlist() -- host configuration setup
#
#  SYNOPSIS
#     host_config_hostlist { only_check name config_array } 
#
#  FUNCTION
#     Testsuite host configuration setup - called from verify_host_config()
#
#  INPUTS
#     only_check   - 0: expect user input
#                    1: just verify user input
#     name         - option name (in ts_host_config array)
#     config_array - config array name (ts_config)
#
#  SEE ALSO
#     check/setup_host_config()
#     check/verify_host_config()
#*******************************************************************************
proc host_config_hostlist { only_check name config_array } {
   global CHECK_OUTPUT CHECK_HOST CHECK_USER

   upvar $config_array config

   set description   $config($name,desc)

   if { $only_check == 0 } {
       set not_ready 1
       while { $not_ready } {
          clear_screen
          puts $CHECK_OUTPUT "----------------------------------------------------------"
          puts $CHECK_OUTPUT "Global host configuration setup"
          puts $CHECK_OUTPUT "----------------------------------------------------------"
          puts $CHECK_OUTPUT "\n    hosts configured: [llength $config(hostlist)]"
          host_config_hostlist_show_hosts config
          puts $CHECK_OUTPUT "\n\n(1)  add host"
          puts $CHECK_OUTPUT "(2)  edit host"
          puts $CHECK_OUTPUT "(3)  delete host"
          puts $CHECK_OUTPUT "(4)  try nslookup scann"
          puts $CHECK_OUTPUT "(10) exit setup"
          puts -nonewline $CHECK_OUTPUT "> "
          set input [ wait_for_enter 1]
          switch -- $input {
             1 {
                set result [host_config_hostlist_add_host config]
                if { $result != 0 } {
                   wait_for_enter
                }
             }
             2 {
                set result [host_config_hostlist_edit_host config]
                if { $result != 0 } {
                   wait_for_enter
                }
             }
             3 {
               set result [host_config_hostlist_delete_host config]
                if { $result != 0 } {
                   wait_for_enter
                }
             }
             10 {
                set not_ready 0
             }
             4 {
                set result [ start_remote_prog $CHECK_HOST $CHECK_USER "nslookup" $CHECK_HOST prg_exit_state 60 0 "" 1 0 ]
                if { $prg_exit_state == 0 } {
                   set pos1 [ string first $CHECK_HOST $result ]
                   set ip [string range $result $pos1 end]
                   set pos1 [ string first ":" $ip ]
                   incr pos1 1
                   set ip [string range $ip $pos1 end]
                   set pos1 [ string last "." $ip ]
                   incr pos1 -1
                   set ip [string range $ip 0 $pos1 ]
                   set ip [string trim $ip]
                   puts $CHECK_OUTPUT "ip: $ip"

                   for { set i 1 } { $i <= 254 } { incr i 1 } {
                       set ip_run "$ip.$i"
                       puts -nonewline $CHECK_OUTPUT "\r$ip_run"
                       set result [ start_remote_prog $CHECK_HOST $CHECK_USER "nslookup" $ip_run prg_exit_state 25 0 "" 1 0 ]
                       set pos1 [ string first "Name:" $result ]   
                       if { $pos1 >= 0 } {
                          incr pos1 5
                          set name [ string range $result $pos1 end ]
                          set pos1 [ string first "." $name ]
                          incr pos1 -1
                          set name [ string range $name 0 $pos1 ]
                          set name [ string trim $name ]
                          puts $CHECK_OUTPUT "\nHost: $name"
                          set result [host_config_hostlist_add_host config $name]
                       }
                   }
                } 

                wait_for_enter
             }
          } 
       }
   } 

   # check host configuration
   debug_puts "host_config_hostlist:"
   foreach host $config(hostlist) {
      debug_puts "      host: $host"
   }

   return $config(hostlist)
}


#****** check/user_config_first_foreign_user() *********************************
#  NAME
#     user_config_first_foreign_user() -- edit first foreign user
#
#  SYNOPSIS
#     user_config_first_foreign_user { only_check name config_array } 
#
#  FUNCTION
#     Testsuite user configuration setup - called from verify_user_config()
#
#  INPUTS
#     only_check   - 0: expect user input
#                    1: just verify user input
#     name         - option name (in ts_user_config array)
#     config_array - config array name (ts_config)
#
#  SEE ALSO
#     check/setup_user_config()
#     check/verify_user_config()
#
#*******************************************************************************
proc user_config_first_foreign_user { only_check name config_array } {
   global CHECK_OUTPUT CHECK_HOST CHECK_USER
   global CHECK_FIRST_FOREIGN_SYSTEM_USER
   global CHECK_SECOND_FOREIGN_SYSTEM_USER
   upvar $config_array config
   
   set actual_value  $config($name)
   set default_value $config($name,default)
   set description   $config($name,desc)

   set value $actual_value
   if { $actual_value == "" } {
      set value $default_value
   }

   if { $only_check == 0 } {
      # do setup
      puts $CHECK_OUTPUT "" 
      puts $CHECK_OUTPUT "Please enter name of the first testsuite user. This user must have access to the"
      puts $CHECK_OUTPUT "testsuite directory and must exist on all cluster hosts."
      puts $CHECK_OUTPUT "Press >RETURN< to accept the default value."
      puts $CHECK_OUTPUT "(default: $value)"
      puts -nonewline $CHECK_OUTPUT "> "
      set input [ wait_for_enter 1]
      if { [ string length $input] > 0 } {
         set value $input 
      } else {
         puts $CHECK_OUTPUT "using default value"
      }
   } 
   # now verify
   if { [string compare $CHECK_USER $value] == 0 } {
      puts $CHECK_OUTPUT "first testsuite user \"$value\" and actual check user are identical!"
      return -1
   }
   if { [ info exists CHECK_SECOND_FOREIGN_SYSTEM_USER ] } {
      if { $CHECK_SECOND_FOREIGN_SYSTEM_USER == $value } {
         puts $CHECK_OUTPUT "first testsuite user should not be identical with second testsuite user"
         return -1
      }
   }
   
   set result [start_remote_prog $CHECK_HOST $CHECK_USER "id" "$value" prg_exit_state 60 0 "" 1 0]
   if { $prg_exit_state != 0 } {
      puts $CHECK_OUTPUT "id $value returns error. User $value not existing?"
      return -1
   }
   

   # set global variables to value
   set CHECK_FIRST_FOREIGN_SYSTEM_USER $value

   return $value
}

#****** check/user_config_second_foreign_user() ********************************
#  NAME
#     user_config_second_foreign_user() -- setup second foreign user
#
#  SYNOPSIS
#     user_config_second_foreign_user { only_check name config_array } 
#
#  FUNCTION
#     Testsuite user configuration setup - called from verify_user_config()
#
#  INPUTS
#     only_check   - 0: expect user input
#                    1: just verify user input
#     name         - option name (in ts_user_config array)
#     config_array - config array name (ts_config)
#
#  SEE ALSO
#     check/setup_user_config()
#     check/verify_user_config()
#
#*******************************************************************************
proc user_config_second_foreign_user { only_check name config_array } {
   global CHECK_OUTPUT CHECK_HOST CHECK_USER
   global CHECK_SECOND_FOREIGN_SYSTEM_USER
   global CHECK_FIRST_FOREIGN_SYSTEM_USER
   upvar $config_array config
   
   set actual_value  $config($name)
   set default_value $config($name,default)
   set description   $config($name,desc)

   set value $actual_value
   if { $actual_value == "" } {
      set value $default_value
   }

   if { $only_check == 0 } {
      # do setup
      puts $CHECK_OUTPUT "" 
      puts $CHECK_OUTPUT "Please enter name of the second testsuite user. This user must have access to the"
      puts $CHECK_OUTPUT "testsuite directory and must exist on all cluster hosts."
      puts $CHECK_OUTPUT "Press >RETURN< to accept the default value."
      puts $CHECK_OUTPUT "(default: $value)"
      puts -nonewline $CHECK_OUTPUT "> "
      set input [ wait_for_enter 1]
      if { [ string length $input] > 0 } {
         set value $input 
      } else {
         puts $CHECK_OUTPUT "using default value"
      }
   } 
   # now verify
   if { [string compare $CHECK_USER $value] == 0 } {
      puts $CHECK_OUTPUT "second testsuite user \"$value\" and actual check user are identical!"
      return -1
   }
   if { [ info exists CHECK_FIRST_FOREIGN_SYSTEM_USER ] } {
      if { $value == $CHECK_FIRST_FOREIGN_SYSTEM_USER } {
         puts $CHECK_OUTPUT "second testsuite user should not be identical with first testsuite user"
         return -1
      }
   }
   set result [start_remote_prog $CHECK_HOST $CHECK_USER "id" "$value" prg_exit_state 60 0 "" 1 0]
   if { $prg_exit_state != 0 } {
      puts $CHECK_OUTPUT "id $value returns error. User $value not existing?"
      return -1
   }



   # set global variables to value
   set CHECK_SECOND_FOREIGN_SYSTEM_USER $value

   return $value
}
#****** check/user_config_first_foreign_group() ********************************
#  NAME
#     user_config_first_foreign_group() -- first foreign user configuration setup
#
#  SYNOPSIS
#     user_config_first_foreign_group { only_check name config_array } 
#
#  FUNCTION
#     Testsuite user configuration setup - called from verify_user_config()
#
#  INPUTS
#     only_check   - 0: expect user input
#                    1: just verify user input
#     name         - option name (in ts_user_config array)
#     config_array - config array name (ts_config)
#
#  SEE ALSO
#     check/setup_user_config()
#     check/verify_user_config()
#
#*******************************************************************************
proc user_config_first_foreign_group { only_check name config_array } {
   global CHECK_OUTPUT CHECK_HOST CHECK_USER
   global CHECK_FIRST_FOREIGN_SYSTEM_GROUP CHECK_FIRST_FOREIGN_SYSTEM_USER
   global CHECK_SECOND_FOREIGN_SYSTEM_GROUP

   upvar $config_array config
   
   set actual_value  $config($name)
   set default_value $config($name,default)
   set description   $config($name,desc)

   set value $actual_value
   if { $actual_value == "" } {
      set value $default_value
   }

   if { $only_check == 0 } {
      # do setup
      puts $CHECK_OUTPUT "" 
      puts $CHECK_OUTPUT "Please enter the name of main group where user $CHECK_FIRST_FOREIGN_SYSTEM_USER is member."
      puts $CHECK_OUTPUT "Press >RETURN< to accept the default value."
      puts $CHECK_OUTPUT "(default: [ lindex $value 0 ])"
      puts -nonewline $CHECK_OUTPUT "> "
      set input [ wait_for_enter 1]
      if { [ string length $input] > 0 } {
         set group1 $input 
      } else {
         set group1 [ lindex $value 0 ]
         puts $CHECK_OUTPUT "using default value"
      }
 
      puts $CHECK_OUTPUT "" 
      puts $CHECK_OUTPUT "Please enter the name of additional group where user $CHECK_FIRST_FOREIGN_SYSTEM_USER is member."
      puts $CHECK_OUTPUT "Press >RETURN< to accept the default value."
      puts $CHECK_OUTPUT "(default: [ lindex $value 1 ])"
      puts -nonewline $CHECK_OUTPUT "> "
      set input [ wait_for_enter 1]
      if { [ string length $input] > 0 } {
         set group2 $input 
      } else {
         set group2 [ lindex $value 1 ]
         puts $CHECK_OUTPUT "using default value"
      }

      set value "$group1 $group2" 
   } 
   # now verify

   if { [llength $value] != 2 } {
        puts $CHECK_OUTPUT "first testsuite user should belong to 2 groups"
        return -1
   }

   if { [info exists CHECK_SECOND_FOREIGN_SYSTEM_GROUP ] } {
      foreach gname $value {
         if { [ string compare $gname $CHECK_SECOND_FOREIGN_SYSTEM_GROUP] == 0 } {
             puts $CHECK_OUTPUT "first testsuite user should not have the same group as second testsuite user"
             return -1
         } 
      }
   }

   set group1 [lindex $value 0]
   set group2 [lindex $value 1]
   
   set result [start_remote_prog $CHECK_HOST $CHECK_USER "id" "$CHECK_FIRST_FOREIGN_SYSTEM_USER" prg_exit_state 60 0 "" 1 0]
   debug_puts $result
   if { [string first $group1 $result ] < 0 } {
      puts $CHECK_OUTPUT "first testsuite user ($CHECK_FIRST_FOREIGN_SYSTEM_USER) has not \"$group1\" as main group"
      return -1
   }

   set result [start_remote_prog $CHECK_HOST $CHECK_USER "groups" "$CHECK_FIRST_FOREIGN_SYSTEM_USER" prg_exit_state 60 0 "" 1 0]
   debug_puts $result
   if { $prg_exit_state == 0 } {
      if { [string first $group2 $result] < 0 } { 
         puts $CHECK_OUTPUT "first testsuite user ($CHECK_FIRST_FOREIGN_SYSTEM_USER) has not \"$group2\" as secondary group"
         return -1
      }
   }

   if { [llength $value] != 2 } {
        puts $CHECK_OUTPUT "first foreign system group must have 2 group entries"
        return -1
   }


   # set global variables to value
   set CHECK_FIRST_FOREIGN_SYSTEM_GROUP $value

   return $value

}


#****** check/user_config_second_foreign_group() *******************************
#  NAME
#     user_config_second_foreign_group() -- setup second foreign group
#
#  SYNOPSIS
#     user_config_second_foreign_group { only_check name config_array } 
#
#  FUNCTION
#     Testsuite user configuration setup - called from verify_user_config()
#
#  INPUTS
#     only_check   - 0: expect user input
#                    1: just verify user input
#     name         - option name (in ts_user_config array)
#     config_array - config array name (ts_config)
#
#  SEE ALSO
#     check/setup_user_config()
#     check/verify_user_config()
#
#*******************************************************************************
proc user_config_second_foreign_group { only_check name config_array } {
   global CHECK_OUTPUT CHECK_HOST CHECK_USER
   global CHECK_FIRST_FOREIGN_SYSTEM_GROUP CHECK_SECOND_FOREIGN_SYSTEM_USER
   global CHECK_SECOND_FOREIGN_SYSTEM_GROUP do_nomain

   upvar $config_array config
   
   set actual_value  $config($name)
   set default_value $config($name,default)
   set description   $config($name,desc)

   set value $actual_value
   if { $actual_value == "" } {
      set value $default_value
   }

   if { $only_check == 0 } {
      # do setup
      puts $CHECK_OUTPUT "" 
      puts $CHECK_OUTPUT "Please enter the name of main group where user $CHECK_SECOND_FOREIGN_SYSTEM_USER is member."
      puts $CHECK_OUTPUT "Press >RETURN< to accept the default value."
      puts $CHECK_OUTPUT "(default: $value)"
      puts -nonewline $CHECK_OUTPUT "> "
      set input [ wait_for_enter 1]
      if { [ string length $input] > 0 } {
         set value $input 
      } else {
         puts $CHECK_OUTPUT "using default value"
      }
   } 
   # now verify

   if { [llength $value] != 1 } {
        puts $CHECK_OUTPUT "second testsuite user should belong only to one group"
        return -1
   }

   if { [info exists CHECK_FIRST_FOREIGN_SYSTEM_GROUP ] } {
      foreach gname $CHECK_FIRST_FOREIGN_SYSTEM_GROUP {
         if { [ string compare $gname $value] == 0 } {
             puts $CHECK_OUTPUT "first testsuite user should not have the same group as second testsuite user"
             return -1
         } 
      }
   }

   set result [start_remote_prog $CHECK_HOST $CHECK_USER "id" "$CHECK_SECOND_FOREIGN_SYSTEM_USER" prg_exit_state 60 0 "" 1 0]
   debug_puts $result
   if { [string first $value $result ] < 0 && $do_nomain == 0 } {
      puts $CHECK_OUTPUT "second testsuite user ($CHECK_SECOND_FOREIGN_SYSTEM_USER) has not \"$value\" as main group"
      return -1
   }

   if { [llength $value] != 1 } {
        puts $CHECK_OUTPUT "second foreign system group must have 1 group entries"
        return -1
   }


   # set global variables to value
   set CHECK_SECOND_FOREIGN_SYSTEM_GROUP $value

   return $value


}


#****** check/user_config_userlist() *******************************************
#  NAME
#     user_config_userlist() -- user list setup
#
#  SYNOPSIS
#     user_config_userlist { only_check name config_array } 
#
#  FUNCTION
#     Testsuite user configuration setup - called from verify_user_config()
#
#  INPUTS
#     only_check   - 0: expect user input
#                    1: just verify user input
#     name         - option name (in ts_user_config array)
#     config_array - config array name (ts_config)
#
#  SEE ALSO
#     check/setup_user_config()
#     check/verify_user_config()
#
#*******************************************************************************
proc user_config_userlist { only_check name config_array } {
   global CHECK_OUTPUT CHECK_HOST CHECK_USER
   global CHECK_REMOTE_ENVIRONMENT
   
   upvar $config_array config

   set description   $config($name,desc)

   if { $only_check == 0 } {
       set not_ready 1
       while { $not_ready } {
          clear_screen
          puts $CHECK_OUTPUT "\nGlobal user configuration setup"
          puts $CHECK_OUTPUT "==============================="
          puts $CHECK_OUTPUT "\n\n    users configured: [llength $config(userlist)]"
          user_config_userlist_show_users config
          puts $CHECK_OUTPUT "\n\n(1)  add user"
          puts $CHECK_OUTPUT "(2)  edit user"
          puts $CHECK_OUTPUT "(3)  delete user"
          puts $CHECK_OUTPUT "(10) exit setup"
          puts -nonewline $CHECK_OUTPUT "> "
          set input [ wait_for_enter 1]
          switch -- $input {
             1 {
                set result [user_config_userlist_add_user config]
                if { $result != 0 } {
                   wait_for_enter
                }
             }
             2 {
                set result [user_config_userlist_edit_user config]
                if { $result != 0 } {
                   wait_for_enter
                }
             }
             3 {
               set result [user_config_userlist_delete_user config]
                if { $result != 0 } {
                   wait_for_enter
                }
             }
             10 {
                set not_ready 0
             }
          } 
       }
   } 

   # check user configuration
   debug_puts "user_config_userlist:"
   foreach user $config(userlist) {
      debug_puts "checking user \"$user\" ... "
   }

   if { [ info exists config($CHECK_USER,envlist) ] } {
      set CHECK_REMOTE_ENVIRONMENT $config($CHECK_USER,envlist)
   } else {
      set CHECK_REMOTE_ENVIRONMENT ""
   }

   return $config(userlist)
}


#****** check/host_config_hostlist_show_hosts() ********************************
#  NAME
#     host_config_hostlist_show_hosts() -- show host in host configuration
#
#  SYNOPSIS
#     host_config_hostlist_show_hosts { array_name } 
#
#  FUNCTION
#     Print hosts
#
#  INPUTS
#     array_name - ts_host_config
#
#  SEE ALSO
#     check/setup_host_config()
#     check/verify_host_config()
#     check/host_config_hostlist_show_compile_hosts()
#*******************************************************************************
proc host_config_hostlist_show_hosts { array_name } {
   global CHECK_OUTPUT
   upvar $array_name config

   puts $CHECK_OUTPUT "\nHost list:\n"
   if { [llength $config(hostlist)] == 0 } {
      puts $CHECK_OUTPUT "no hosts defined"
   }

   set max_length 0
   foreach host $config(hostlist) {
      if { [string length $host] > $max_length } {
         set max_length [string length $host]
      }
   }  


   set index 0
   foreach host $config(hostlist) {
      incr index 1 

      set space ""
      for { set i 0 } { $i < [ expr ( $max_length - [ string length $host ]  ) ] } { incr i 1 } {  
          append space " "
      }
      if { $config($host,compile) == 1 } {
          set comp_host "(compile host)"
      } else {
          set comp_host "              "
      }


      if { $index <= 9 } {
         puts $CHECK_OUTPUT "    $index) $host $space ($config($host,arch)) $comp_host"
      } else {
         puts $CHECK_OUTPUT "   $index) $host $space ($config($host,arch)) $comp_host"
      }
   }
}

#****** check/host_config_hostlist_show_compile_hosts() ************************
#  NAME
#     host_config_hostlist_show_compile_hosts() -- show compile hosts
#
#  SYNOPSIS
#     host_config_hostlist_show_compile_hosts { array_name save_array } 
#
#  FUNCTION
#     This procedure shows the list of compile hosts
#
#  INPUTS
#     array_name - ts_host_config array
#     save_array - array to store compile host informations
#
#  RESULT
#     save_array(count)     -> number of compile hosts (starting from 1)
#     save_array($num,arch) -> compile architecture
#     save-array($num,host) -> compile host name
#
#  SEE ALSO
#     check/host_config_hostlist_show_hosts()
#*******************************************************************************
proc host_config_hostlist_show_compile_hosts { array_name save_array } {
   global CHECK_OUTPUT
   upvar $array_name config
   upvar $save_array back

   if { [ info exists back ] } {
      unset back
   }

   puts $CHECK_OUTPUT "\nCompile architecture list:\n"
   if { [llength $config(hostlist)] == 0 } {
      puts $CHECK_OUTPUT "no hosts defined"
   }

   set index 0
  
   set max_arch_length 0
   foreach host $config(hostlist) {
      if { $config($host,compile) == 1 } {
         lappend arch_list $config($host,arch)
         set host_list($config($host,arch)) $host
         set arch_length [string length $config($host,arch) ]
         if { $max_arch_length < $arch_length } {
            set max_arch_length $arch_length
         }
      }
   }
   set arch_list [lsort $arch_list]
   foreach arch $arch_list {
      set host $host_list($arch)
      if { $config($host,compile) == 1 } {
         incr index 1 
         set back(count) $index
         set back($index,arch) $config($host,arch)
         set back($index,host) $host 

         set arch_length [string length $config($host,arch)]
         if { $index <= 9 } {
            puts $CHECK_OUTPUT "    $index) $config($host,arch) [get_spaces [expr ( $max_arch_length - $arch_length ) ]] ($host)"
         } else {
            puts $CHECK_OUTPUT "   $index) $config($host,arch) [get_spaces [expr ( $max_arch_length - $arch_length ) ]] ($host)" 
         }
      } 
   }
}


#****** check/user_config_userlist_show_users() ********************************
#  NAME
#     user_config_userlist_show_users() -- show testsuite user configuration
#
#  SYNOPSIS
#     user_config_userlist_show_users { array_name } 
#
#  FUNCTION
#     This procedure will show the current testsuite user configuration
#
#  INPUTS
#     array_name - ts_user_config
#
#  SEE ALSO
#     check/setup_user_config()
#     check/verify_user_config()
#*******************************************************************************
proc user_config_userlist_show_users { array_name } {
   global CHECK_OUTPUT
   upvar $array_name config

   puts $CHECK_OUTPUT "\nUser list:\n"
   if { [llength $config(userlist)] == 0 } {
      puts $CHECK_OUTPUT "no users defined"
   }
   set index 0
   foreach user $config(userlist) {
      incr index 1 
      puts $CHECK_OUTPUT "($index) $user (ports: $config($user,portlist))"
   }
}



#****** check/host_config_hostlist_add_host() **********************************
#  NAME
#     host_config_hostlist_add_host() -- add host to host configuration
#
#  SYNOPSIS
#     host_config_hostlist_add_host { array_name { have_host "" } } 
#
#  FUNCTION
#     This procedure is used to add an host to the testsuite host configuration 
#
#  INPUTS
#     array_name       - ts_host_config
#     { have_host "" } - if not "": add this host without questions
#
#  SEE ALSO
#     check/setup_host_config()
#     check/verify_host_config()
#*******************************************************************************
proc host_config_hostlist_add_host { array_name { have_host "" } } {
   global CHECK_OUTPUT
   upvar $array_name config
   global CHECK_USER
  
   if { $have_host == "" } {
      clear_screen
      puts $CHECK_OUTPUT "\nAdd host to global host configuration"
      puts $CHECK_OUTPUT "====================================="

   
      host_config_hostlist_show_hosts config

      puts $CHECK_OUTPUT "\n"
      puts -nonewline $CHECK_OUTPUT "Please enter new hostname: "
      set new_host [wait_for_enter 1]
   } else {
      set new_host $have_host
   }

   if { [ string length $new_host ] == 0 } {
      puts $CHECK_OUTPUT "no hostname entered"
      return -1
   }
     
   if { [ lsearch $config(hostlist) $new_host ] >= 0 } {
      puts $CHECK_OUTPUT "host \"$new_host\" is allready in list"
      return -1
   }

   set time [timestamp]
   set result [ start_remote_prog $new_host $CHECK_USER "echo" "\"hello $new_host\"" prg_exit_state 12 0 "" 1 0 ]
   if { $prg_exit_state != 0 } {
      if { $have_host == "" } {

         puts $CHECK_OUTPUT "connect timeout error\nPlease enter a timeout value > 12 or press return to abort"
         set result [ wait_for_enter 1 ]
         if { [ string length $result] == 0  || $result < 12 } {
            puts $CHECK_OUTPUT "aborting ..."
            return -1
         }
         set result [ start_remote_prog $new_host $CHECK_USER "echo" "\"hello $new_host\"" prg_exit_state $result 0 "" 1 0 ]
      }
   }

   if { $prg_exit_state != 0 } {
      puts $CHECK_OUTPUT "rlogin to host $new_host doesn't work correctly"
      return -1
   }
   if { [ string first "hello $new_host" $result ] < 0 } {
      puts $CHECK_OUTPUT "$result"
      puts $CHECK_OUTPUT "echo \"hello $new_host\" doesn't work"
      return -1
   }

   set arch [resolve_arch $new_host]
   lappend config(hostlist) $new_host

   
   set expect_bin [ start_remote_prog $new_host $CHECK_USER "which" "expect" prg_exit_state 12 0 "" 1 0 ]
   if { $prg_exit_state != 0 } {
      set expect_bin "" 
   } 
   set vim_bin [ start_remote_prog $new_host $CHECK_USER "which" "vim" prg_exit_state 12 0 "" 1 0 ]
   if { $prg_exit_state != 0 } {
      set vim_bin  "" 
   }
   set tar_bin [ start_remote_prog $new_host $CHECK_USER "which" "tar" prg_exit_state 12 0 "" 1 0 ]
   if { $prg_exit_state != 0 } {
      set tar_bin "" 
   }
   set gzip_bin [ start_remote_prog $new_host $CHECK_USER "which" "gzip" prg_exit_state 12 0 "" 1 0 ]
   if { $prg_exit_state != 0 } {
      set gzip_bin "" 
   }

   set config($new_host,expect)        [string trim $expect_bin]
   set config($new_host,vim)           [string trim $vim_bin]
   set config($new_host,tar)           [string trim $tar_bin]
   set config($new_host,gzip)          [string trim $gzip_bin]
   set config($new_host,loadsensor)    ""
   set config($new_host,processors)    1
   set config($new_host,spooldir)      ""
   set config($new_host,arch)          $arch
   set config($new_host,compile)       0
   set config($new_host,compile_time)  0
   set config($new_host,response_time) [ expr ( [timestamp] - $time ) ]
   set config($new_host,fr_locale)     ""
   set config($new_host,ja_locale)     ""
   set config($new_host,zh_locale)     ""


   if { $have_host == "" } {
      host_config_hostlist_edit_host config $new_host
   }
      
   return 0   
}

#****** check/user_config_userlist_add_user() **********************************
#  NAME
#     user_config_userlist_add_user() -- add user to user configuration
#
#  SYNOPSIS
#     user_config_userlist_add_user { array_name { have_user "" } } 
#
#  FUNCTION
#     Add user to testsuite user configuration
#
#  INPUTS
#     array_name       - ts_user_config
#     { have_user "" } - if not "": add this user
#
#  SEE ALSO
#     check/setup_user_config()
#     check/verify_user_config()
#*******************************************************************************
proc user_config_userlist_add_user { array_name { have_user "" } } {
   global CHECK_OUTPUT
   upvar $array_name config
   global CHECK_USER
  
   if { $have_user == "" } {
      clear_screen
      puts $CHECK_OUTPUT "\nAdd user to global user configuration"
      puts $CHECK_OUTPUT "====================================="

      user_config_userlist_show_users config

      puts $CHECK_OUTPUT "\n"
      puts -nonewline $CHECK_OUTPUT "Please enter new username: "
      set new_user [wait_for_enter 1]
   } else {
      set new_user $have_user
   }

   if { [ string length $new_user ] == 0 } {
      puts $CHECK_OUTPUT "no username entered"
      return -1
   }
     
   if { [ lsearch $config(userlist) $new_user ] >= 0 } {
      puts $CHECK_OUTPUT "user \"$new_user\" is allready in list"
      return -1
   }

   lappend config(userlist) $new_user
   set config($new_user,portlist) ""
   set config($new_user,envlist)  ""
   if { $have_user == "" } {
      user_config_userlist_edit_user config $new_user
   }
   return 0   
}


#****** check/host_config_hostlist_edit_host() *********************************
#  NAME
#     host_config_hostlist_edit_host() -- edit host in host configuration
#
#  SYNOPSIS
#     host_config_hostlist_edit_host { array_name { has_host "" } } 
#
#  FUNCTION
#     This procedure is used for host edition in host configuration
#
#  INPUTS
#     array_name      - ts_host_config
#     { has_host "" } - if not "": just edit this host
#
#  SEE ALSO
#     check/setup_host_config()
#     check/verify_host_config()
#*******************************************************************************
proc host_config_hostlist_edit_host { array_name { has_host "" } } {
   global CHECK_OUTPUT
   global CHECK_USER 
   global ts_config ts_host_config

   upvar $array_name config

   set goto 0

   if { $has_host != "" } {
      set goto $has_host
   } 

   while { 1 } {

      clear_screen
      puts $CHECK_OUTPUT "\nEdit host in global host configuration"
      puts $CHECK_OUTPUT "======================================"

   
      host_config_hostlist_show_hosts config

      puts $CHECK_OUTPUT "\n"
      puts -nonewline $CHECK_OUTPUT "Please enter hostname/number or return to exit: "
      if { $goto == 0 } {
         set host [wait_for_enter 1]
         set goto $host
      } else {
         set host $goto
         puts $CHECK_OUTPUT $host
      }
 
      if { [ string length $host ] == 0 } {
         break
      }
     
      if { [string is integer $host] } {
         incr host -1
         set host [ lindex $config(hostlist) $host ]
      }

      if { [ lsearch $config(hostlist) $host ] < 0 } {
         puts $CHECK_OUTPUT "host \"$host\" not found in list"
         wait_for_enter
         set goto 0
         continue
      }
      puts $CHECK_OUTPUT ""
      puts $CHECK_OUTPUT "   host          : $host"
      puts $CHECK_OUTPUT "   arch          : $config($host,arch)"
      puts $CHECK_OUTPUT "   expect        : $config($host,expect)"
      puts $CHECK_OUTPUT "   vim           : $config($host,vim)"
      puts $CHECK_OUTPUT "   tar           : $config($host,tar)"
      puts $CHECK_OUTPUT "   gzip          : $config($host,gzip)"
      puts $CHECK_OUTPUT "   loadsensor    : $config($host,loadsensor)"
      puts $CHECK_OUTPUT "   processors    : $config($host,processors)"
      puts $CHECK_OUTPUT "   spooldir      : $config($host,spooldir)"
      puts $CHECK_OUTPUT "   fr_locale     : $config($host,fr_locale)"
      puts $CHECK_OUTPUT "   ja_locale     : $config($host,ja_locale)"
      puts $CHECK_OUTPUT "   zh_locale     : $config($host,zh_locale)"

      if { $config($host,compile) == 0 } {
         puts $CHECK_OUTPUT "   compile       : not a compile host"
      } else {
         puts $CHECK_OUTPUT "   compile       : testsuite will use this host to compile \"$config($host,arch)\" binaries"
      }
      puts $CHECK_OUTPUT "   compile_time  : $config($host,compile_time)"
      puts $CHECK_OUTPUT "   response_time : $config($host,response_time)"


      puts $CHECK_OUTPUT ""
   
      puts $CHECK_OUTPUT "\n"
      puts -nonewline $CHECK_OUTPUT "Please enter category to edit or hit return to exit > "
      set input [ wait_for_enter 1]
      if { [ string length $input ] == 0 } {
         set goto 0
         continue
      }

 
      if { [ string compare $input "host"] == 0 } {
         puts $CHECK_OUTPUT "Setting \"$input\" is not allowed"
         wait_for_enter
         continue
      }

      if { [ info exists config($host,$input) ] != 1 } {
         puts $CHECK_OUTPUT "Not a valid category"
         wait_for_enter
         continue
      }

      if { [string compare $input "arch"] == 0 } {
         puts $CHECK_OUTPUT "Setting \"$input\" is not allowed"
         wait_for_enter
         continue
      }


      set isfile 0
      set isdir 0
      set extra 0
      switch -- $input {
         "expect" { set isfile 1 }
         "vim"    { set isfile 1 }
         "tar"    { set isfile 1 }
         "gzip"   { set isfile 1 }
         "loadsensor" { set isfile 1 }
         "spooldir" { set isdir 1 }
         "compile" { set extra 1 }
         "compile_time"  { set extra 2 }
         "response_time" { set extra 3 }
      }      

      set do_simple_test 0
      if { [string first "locale" $input] >= 0 } {
         puts $CHECK_OUTPUT "INFO:"
         puts $CHECK_OUTPUT "Please enter an environment list to get localized output on that host!"
         puts $CHECK_OUTPUT ""
         puts $CHECK_OUTPUT "e.g.: LANG=fr_FR.ISO8859-1 LC_MESSAGES=fr"
         set do_simple_test 1
      }

      if { $extra == 0 } {
         puts -nonewline $CHECK_OUTPUT "\nPlease enter new $input value: "
         set value [ wait_for_enter 1 ]
      }

      if { $extra == 1 } { ;# compile option
         puts -nonewline $CHECK_OUTPUT "\nShould testsuite use this host for compilation (y/n) :"
         set value [ wait_for_enter 1 ]
         if { [ string compare "y" $value ] == 0 } {
            set value 1
         } else {
            set value 0
         }
      }

      if { $extra == 2 || $extra == 3 } {
         puts $CHECK_OUTPUT "Setting \"$input\" is not allowed"
         wait_for_enter
         continue
      }

      if { $isfile } {
         set result [ start_remote_prog $host $CHECK_USER "ls" "$value" prg_exit_state 12 0 "" 1 0 ]
         if { $prg_exit_state != 0 } {
            puts $CHECK_OUTPUT $result
            puts $CHECK_OUTPUT "file $value not found on host $host"
            wait_for_enter
            continue
         }
      }
      
      if { $isdir } {
         set result [ start_remote_prog $host $CHECK_USER "cd" "$value" prg_exit_state 12 0 "" 1 0 ]
         if { $prg_exit_state != 0 } {
            puts $CHECK_OUTPUT $result
            puts $CHECK_OUTPUT "can't cd to directory $value on host $host"
            wait_for_enter
            continue
         }
      }

      if { $do_simple_test == 1 } {
         set mem_it $ts_host_config($host,$input)
         set mem_l10n $ts_config(l10n_test_locale)
       
         set ts_config(l10n_test_locale) [string range $input 0 1]
         set ts_host_config($host,$input) $value

         set test_result [perform_simple_l10n_test ]

         set ts_host_config($host,$input) $mem_it
         set ts_config(l10n_test_locale) mem_l10n

         if { $test_result != 0 } {
            puts $CHECK_OUTPUT "l10n errors" 
            wait_for_enter
            continue
         }
         puts $CHECK_OUTPUT "you have to enable l10n in testsuite setup too!"
         wait_for_enter
      }
      set config($host,$input) $value
   }
   
   return 0   
}


#****** check/user_config_userlist_edit_user() *********************************
#  NAME
#     user_config_userlist_edit_user() -- edit user configuration
#
#  SYNOPSIS
#     user_config_userlist_edit_user { array_name { has_user "" } } 
#
#  FUNCTION
#     This procedure is used to edit the testsuite user configuration
#
#  INPUTS
#     array_name      - ts_user_config
#     { has_user "" } - if not "": edit this user
#
#  SEE ALSO
#     check/setup_user_config()
#     check/verify_user_config()
#*******************************************************************************
proc user_config_userlist_edit_user { array_name { has_user "" } } {
   global CHECK_OUTPUT
   upvar $array_name config
   global CHECK_USER CHECK_HOST
   global CHECK_REMOTE_ENVIRONMENT

   set goto 0

   if { $has_user != "" } {
      set goto $has_user
   } 

   while { 1 } {

      clear_screen
      puts $CHECK_OUTPUT "\nEdit user in global user configuration"
      puts $CHECK_OUTPUT "======================================"

   
      user_config_userlist_show_users config

      puts $CHECK_OUTPUT "\n"
      puts -nonewline $CHECK_OUTPUT "Please enter username/number or return to exit: "
      if { $goto == 0 } {
         set user [wait_for_enter 1]
         set goto $user
      } else {
         set user $goto
         puts $CHECK_OUTPUT $user
      }
 
      if { [ string length $user ] == 0 } {
         break
      }
     
      if { [string is integer $user] } {
         incr user -1
         set user [ lindex $config(userlist) $user ]
      }

      if { [ lsearch $config(userlist) $user ] < 0 } {
         puts $CHECK_OUTPUT "user \"$user\" not found in list"
         wait_for_enter
         set goto 0
         continue
      }
      puts $CHECK_OUTPUT ""
      puts $CHECK_OUTPUT "   user     : $user"
      puts $CHECK_OUTPUT "   portlist : $config($user,portlist)"
      puts $CHECK_OUTPUT "   envlist  : $config($user,envlist)"
   
      puts $CHECK_OUTPUT "\n"
      puts -nonewline $CHECK_OUTPUT "Please enter category to edit or hit return to exit > "
      set input [ wait_for_enter 1]
      if { [ string length $input ] == 0 } {
         set goto 0
         continue
      }

 
      if { [ string compare $input "user"] == 0 } {
         puts $CHECK_OUTPUT "Setting \"$input\" is not allowed"
         wait_for_enter
         continue
      }

      if { [ info exists config($user,$input) ] != 1 } {
         puts $CHECK_OUTPUT "Not a valid category"
         wait_for_enter
         continue
      }

      set extra 0
      switch -- $input {
         "portlist"  { set extra 1 }
         "envlist"   { set extra 2 }
      }      

      if { $extra == 0 } {
         puts -nonewline $CHECK_OUTPUT "\nPlease enter new $input value: "
         set value [ wait_for_enter 1 ]
      }
      
      if { $extra == 1 } {
         puts -nonewline $CHECK_OUTPUT "\nPlease enter new $input value: "
         set value [ wait_for_enter 1 ]
         set errors [user_config_userlist_set_portlist config $user $value]
         if { $errors != 0 } {
            wait_for_enter
         }
         continue
      }

      if { $extra == 2 } {
         puts $CHECK_OUTPUT "The envlist has following syntax:"
         puts $CHECK_OUTPUT "variable=value \[...\] or local environment name to export e.g. DISPLAY"
         puts -nonewline $CHECK_OUTPUT "\nPlease enter new $input value: "
         set value [ wait_for_enter 1 ]
         set CHECK_REMOTE_ENVIRONMENT $value
         set back [ set_users_environment $CHECK_HOST]
         if { $back == 0 } {
            set config($user,$input) $value
         }
         wait_for_enter
         continue
      }


      set config($user,$input) $value
   }
   return 0   
}

#****** check/user_config_userlist_set_portlist() ******************************
#  NAME
#     user_config_userlist_set_portlist() -- set protlist for testsuite user
#
#  SYNOPSIS
#     user_config_userlist_set_portlist { array_name user value } 
#
#  FUNCTION
#     This procedure will set the portlist in the user configuration
#
#  INPUTS
#     array_name - ts_user_config
#     user       - user
#     value      - new portlist
#
#  SEE ALSO
#     check/setup_user_config()
#     check/verify_user_config()
#
#*******************************************************************************
proc user_config_userlist_set_portlist { array_name user value } {
   global ts_user_config
   global CHECK_OUTPUT

   upvar $array_name config


   set ok_value ""
   set value [ lsort $value ]
         
   foreach port $value { 
      set had_error 0 
      if { [string is integer $port ] != 1 } {
         puts $CHECK_OUTPUT "$port is not a valid port number"
         set had_error 1
      } 
      if { [info exists config($port)] } {
         if { [ string compare $config($port) $user ] != 0 } {
            puts $CHECK_OUTPUT "user \"$config($port)\" has allready reserved port $port"
            set had_error 1
         }
      } 
      if { [ lsearch -exact $ok_value $port ] >= 0 } {
          puts $CHECK_OUTPUT "ignoring double entry of port $port"
          set had_error 1
      }

      if { $had_error == 0 } {
         lappend ok_value $port
      } 
   }
   foreach port $config($user,portlist) {
      if { [lsearch -exact $ok_value $port] < 0 } {
         puts $CHECK_OUTPUT "removing port $port"
         unset config($port)
         unset config($port,$user) 
      }
   }
   foreach port $ok_value {
      set config($port) $user
      set config($port,$user) [user_config_userlist_create_gid_port config $port $user]
   }
   set config($user,portlist) $ok_value
   return $had_error
}

#****** check/user_config_userlist_create_gid_port() ***************************
#  NAME
#     user_config_userlist_create_gid_port() -- create gid-range for user/port
#
#  SYNOPSIS
#     user_config_userlist_create_gid_port { array_name port user } 
#
#  FUNCTION
#     Create new gid-range for user/port combination
#
#  INPUTS
#     array_name - ts_user_config
#     port       - user port
#     user       - user
#
#  SEE ALSO
#     check/setup_user_config()
#     check/verify_user_config()
#*******************************************************************************
proc user_config_userlist_create_gid_port { array_name port user } {
   global CHECK_OUTPUT
   upvar $array_name config

   if { [ info exists config($port,$user) ] } {
      puts $CHECK_OUTPUT "user $user ($port) gid_range: $config($port,$user)"
      return $config($port,$user)
   }
   
   

   set highest_gid_start 12800
   if { [info exist config(userlist)] } {
      set userlist $config(userlist)
      foreach user_loop $userlist {
         set portlist $config($user_loop,portlist)
         foreach port_loop $portlist {
            set range $config($port_loop,$user_loop)
            set start_range [split $range "-"]
            set start_range [lindex $start_range 0]
            if { $start_range > $highest_gid_start } {
               set highest_gid_start $start_range
            }
         }
      }
   }

   set gid_start $highest_gid_start
   incr gid_start 200
   set gid_end $gid_start
   incr gid_end 199
   set gid_range "$gid_start-$gid_end"
   puts $CHECK_OUTPUT "user $user ($port) gid_range: $gid_range"
   return $gid_range
}

#****** check/host_config_hostlist_delete_host() *******************************
#  NAME
#     host_config_hostlist_delete_host() -- delete host from host configuration
#
#  SYNOPSIS
#     host_config_hostlist_delete_host { array_name } 
#
#  FUNCTION
#     This procedure is called to delete a host from host configuration
#
#  INPUTS
#     array_name - ts_host_config
#
#  SEE ALSO
#     check/setup_host_config()
#     check/verify_host_config()
#*******************************************************************************
proc host_config_hostlist_delete_host { array_name } {
   global CHECK_OUTPUT
   upvar $array_name config
   global CHECK_USER

   while { 1 } {

      clear_screen
      puts $CHECK_OUTPUT "\nDelete host from global host configuration"
      puts $CHECK_OUTPUT "=========================================="

   
      host_config_hostlist_show_hosts config

      puts $CHECK_OUTPUT "\n"
      puts -nonewline $CHECK_OUTPUT "Please enter hostname/number or return to exit: "
      set host [wait_for_enter 1]
 
      if { [ string length $host ] == 0 } {
         break
      }
     
      if { [string is integer $host] } {
         incr host -1
         set host [ lindex $config(hostlist) $host ]
      }

      if { [ lsearch $config(hostlist) $host ] < 0 } {
         puts $CHECK_OUTPUT "host \"$host\" not found in list"
         wait_for_enter
         continue
      }

      puts $CHECK_OUTPUT ""
      puts $CHECK_OUTPUT "   host          : $host"
      puts $CHECK_OUTPUT "   arch          : $config($host,arch)"
      puts $CHECK_OUTPUT "   expect        : $config($host,expect)"
      puts $CHECK_OUTPUT "   vim           : $config($host,vim)"
      puts $CHECK_OUTPUT "   tar           : $config($host,tar)"
      puts $CHECK_OUTPUT "   gzip          : $config($host,gzip)"
      puts $CHECK_OUTPUT "   loadsensor    : $config($host,loadsensor)"
      puts $CHECK_OUTPUT "   processors    : $config($host,processors)"
      puts $CHECK_OUTPUT "   spooldir      : $config($host,spooldir)"
      puts $CHECK_OUTPUT "   fr_locale     : $config($host,fr_locale)"
      puts $CHECK_OUTPUT "   ja_locale     : $config($host,ja_locale)"
      puts $CHECK_OUTPUT "   zh_locale     : $config($host,zh_locale)"

      if { $config($host,compile) == 0 } {
         puts $CHECK_OUTPUT "   compile       : not a compile host"
      } else {
         puts $CHECK_OUTPUT "   compile       : testsuite will use this host to compile \"$config($host,arch)\" binaries"
      }
      puts $CHECK_OUTPUT "   compile_time  : $config($host,compile_time)"
      puts $CHECK_OUTPUT "   response_time : $config($host,response_time)"


      puts $CHECK_OUTPUT ""
   
      puts $CHECK_OUTPUT "\n"
      puts -nonewline $CHECK_OUTPUT "Delete this host? (y/n): "
      set input [ wait_for_enter 1]
      if { [ string length $input ] == 0 } {
         continue
      }

 
      if { [ string compare $input "y"] == 0 } {
         set index [lsearch $config(hostlist) $host]
         set config(hostlist) [ lreplace $config(hostlist) $index $index ]
         unset config($host,arch)
         unset config($host,expect)
         unset config($host,vim)
         unset config($host,tar)
         unset config($host,gzip)
         unset config($host,loadsensor)
         unset config($host,processors)
         unset config($host,spooldir)
         unset config($host,fr_locale)
         unset config($host,ja_locale)
         unset config($host,zh_locale)
         unset config($host,compile)
         unset config($host,compile_time)
         unset config($host,response_time)
         continue
      }
   }
   return 0   
}

#****** check/user_config_userlist_delete_user() *******************************
#  NAME
#     user_config_userlist_delete_user() -- delete user from user configuration
#
#  SYNOPSIS
#     user_config_userlist_delete_user { array_name } 
#
#  FUNCTION
#     This procedure is called to select an user from the user configuration and
#     delete it.
#
#  INPUTS
#     array_name - ts_user_config
#
#  SEE ALSO
#     check/setup_user_config()
#     check/verify_user_config()
#
#*******************************************************************************
proc user_config_userlist_delete_user { array_name } {
   global CHECK_OUTPUT
   upvar $array_name config
   global CHECK_USER

   while { 1 } {

      clear_screen
      puts $CHECK_OUTPUT "\nDelete user from global user configuration"
      puts $CHECK_OUTPUT "=========================================="

   
      user_config_userlist_show_users config

      puts $CHECK_OUTPUT "\n"
      puts -nonewline $CHECK_OUTPUT "Please enter username/number or return to exit: "
      set user [wait_for_enter 1]
 
      if { [ string length $user ] == 0 } {
         break
      }
     
      if { [string is integer $user] } {
         incr user -1
         set user [ lindex $config(userlist) $user ]
      }

      if { [ lsearch $config(userlist) $user ] < 0 } {
         puts $CHECK_OUTPUT "user \"$user\" not found in list"
         wait_for_enter
         continue
      }

      puts $CHECK_OUTPUT ""
      puts $CHECK_OUTPUT "   user          : $user"
      puts $CHECK_OUTPUT "   portlist     : $config($user,portlist)"

      puts $CHECK_OUTPUT ""


      puts $CHECK_OUTPUT ""
   
      puts $CHECK_OUTPUT "\n"
      puts -nonewline $CHECK_OUTPUT "Delete this user? (y/n): "
      set input [ wait_for_enter 1]
      if { [ string length $input ] == 0 } {
         continue
      }

 
      if { [ string compare $input "y"] == 0 } {
         set index [lsearch $config(userlist) $user]
         set config(userlist) [ lreplace $config(userlist) $index $index ]

         foreach port $config($user,portlist) {
            puts $CHECK_OUTPUT "removing port $port"
            unset config($port)
         }
         unset config($user,portlist)
         wait_for_enter
         continue
      }
   }
   return 0   
}







#****** check/verify_config() **************************************************
#  NAME
#     verify_config() -- verify testsuite configuration setup
#
#  SYNOPSIS
#     verify_config { config_array only_check parameter_error_list } 
#
#  FUNCTION
#     This procedure will verify or enter setup configuration
#
#  INPUTS
#     config_array         - array name with configuration (ts_config)
#     only_check           - if 1: don't ask user, just check
#     parameter_error_list - returned list with error information
#
#  RESULT
#     number of errors
#
#  SEE ALSO
#     check/verify_host_config()
#     check/verify_user_config()
#*******************************************************************************
proc verify_config { config_array only_check parameter_error_list } {
   
   global CHECK_OUTPUT actual_ts_config_version be_quiet
   upvar $config_array config
   upvar $parameter_error_list error_list

   set errors 0
   set error_list ""
   
   if { [ info exists config(version) ] != 1 } {
      puts $CHECK_OUTPUT "Could not find version info in configuration file"
      lappend error_list "no version info"
      incr errors 1
      return -1
   }

   if { $config(version) != $actual_ts_config_version } {
      puts $CHECK_OUTPUT "Configuration file version \"$config(version)\" not supported."
      puts $CHECK_OUTPUT "Expected version is \"$actual_ts_config_version\""
      lappend error_list "unexpected version"
      incr errors 1
      return -1
   } else {
      debug_puts "Configuration Version: $config(version)"
   }

   set max_pos [get_configuration_element_count config]
   
   set uninitalized ""
   if { $be_quiet == 0 } { 
      puts $CHECK_OUTPUT ""
   }
   for { set param 1 } { $param <= $max_pos } { incr param 1 } {
      set par [ get_configuration_element_name_on_pos config $param ]
      if { $be_quiet == 0 } { 
         puts -nonewline $CHECK_OUTPUT "   $config($par,desc) ..."
         flush $CHECK_OUTPUT
      }
      if { $config($par) == "" } {
         lappend uninitalized $param
         if { $only_check != 0 } {
            lappend error_list ">$par< configuration not initalized"
            incr errors 1
         }
      } else {
         set procedure_name  $config($par,setup_func)
         set default_value   $config($par,default)
         set description     $config($par,desc)
         if { [string length $procedure_name] == 0 } {
             debug_puts "no procedure defined"
         } else {
            if { [info procs $procedure_name ] != $procedure_name } {
               puts $CHECK_OUTPUT "error\n"
               puts $CHECK_OUTPUT "-->WARNING: unkown procedure name: \"$procedure_name\" !!!"
               puts $CHECK_OUTPUT "   ======="
               lappend uninitalized $param

               if { $only_check == 0 } { 
                  wait_for_enter 
               }
            } else {
               # call procedure only_check == 1
               debug_puts "starting >$procedure_name< (verify mode) ..."
               set value [ $procedure_name 1 $par config ]
               if { $value == -1 } {
                  incr errors 1
                  lappend error_list $par
                  lappend uninitalized $param
                  puts $CHECK_OUTPUT "error\n"
                  puts $CHECK_OUTPUT "-->WARNING: verify error in procedure \"$procedure_name\" !!!"
                  puts $CHECK_OUTPUT "   ======="

               } 
            }
         }
      }
      if { $be_quiet == 0 } { 
         puts $CHECK_OUTPUT "\r   $config($par,desc) ... ok"
      }
   } 
   if { [set count [llength $uninitalized]] != 0 && $only_check == 0} {
      puts $CHECK_OUTPUT "$count parameters are not initialized!"
      puts $CHECK_OUTPUT "Entering setup procedures ..."
      foreach pos $uninitalized {
         wait_for_enter
         clear_screen
         set p_name [get_configuration_element_name_on_pos config $pos]
         set procedure_name  $config($p_name,setup_func)
         set default_value   $config($p_name,default)
         set description     $config($p_name,desc)
       
         puts $CHECK_OUTPUT "----------------------------------------------------------"
         puts $CHECK_OUTPUT $description
         puts $CHECK_OUTPUT "----------------------------------------------------------"
         debug_puts "Starting configuration procedure for parameter \"$p_name\" ($config($p_name,pos)) ..."
         set use_default 0
         if { [string length $procedure_name] == 0 } {
            puts $CHECK_OUTPUT "no procedure defined"
            set use_default 1
         } else {
            if { [info procs $procedure_name ] != $procedure_name } {
               puts $CHECK_OUTPUT ""
               puts $CHECK_OUTPUT "-->WARNING: unkown procedure name: \"$procedure_name\" !!!"
               puts $CHECK_OUTPUT "   ======="
               if { $only_check == 0 } { wait_for_enter }
               set use_default 1
            }
         } 

         if { $use_default != 0 } {
            # we have no setup procedure
            if { $default_value != "" } {
               puts $CHECK_OUTPUT "using default value: \"$default_value\"" 
               set config($p_name) $default_value 
            } else {
               puts $CHECK_OUTPUT "No setup procedure and no default value found!!!"
               if { $only_check == 0 } {
                  puts -nonewline $CHECK_OUTPUT "Please enter value for parameter \"$p_name\": "
                  set value [wait_for_enter 1]
                  puts $CHECK_OUTPUT "using value: \"$value\"" 
                  set config($p_name) $value
               } 
            }
         } else {
            # call setup procedure ...
            debug_puts "starting >$procedure_name< (setup mode) ..."
            set value [ $procedure_name 0 $p_name config ]
            if { $value != -1 } {
               puts $CHECK_OUTPUT "using value: \"$value\"" 
               set config($p_name) $value
            }
         }
         if { $config($p_name) == "" } {
            puts $CHECK_OUTPUT "" 
            puts $CHECK_OUTPUT "-->WARNING: no value for \"$p_name\" !!!"
            puts $CHECK_OUTPUT "   ======="
            incr errors 1
            lappend error_list $p_name
         }
      } 
   } 
   return $errors
}

#****** check/verify_host_config() *********************************************
#  NAME
#     verify_host_config() -- verify testsuite host configuration setup
#
#  SYNOPSIS
#     verify_host_config { config_array only_check parameter_error_list 
#     { force 0 } } 
#
#  FUNCTION
#     This procedure will verify or enter host setup configuration
#
#  INPUTS
#     config_array         - array name with configuration (ts_host_config)
#     only_check           - if 1: don't ask user, just check
#     parameter_error_list - returned list with error information
#     { force 0 }          - force ask user 
#
#  RESULT
#     number of errors
#
#  SEE ALSO
#     check/verify_host_config()
#     check/verify_user_config()
#     check/verify_config()
#     
#*******************************************************************************
proc verify_host_config { config_array only_check parameter_error_list { force 0 }} {
   global CHECK_OUTPUT actual_ts_host_config_version be_quiet
   upvar $config_array config
   upvar $parameter_error_list error_list

   set errors 0
   set error_list ""

   if { [ info exists config(version) ] != 1 } {
      puts $CHECK_OUTPUT "Could not find version info in host configuration file"
      lappend error_list "no version info"
      incr errors 1
      return -1
   }

   if { $config(version) != $actual_ts_host_config_version } {
      puts $CHECK_OUTPUT "Host configuration file version \"$config(version)\" not supported."
      puts $CHECK_OUTPUT "Expected version is \"$actual_ts_host_config_version\""
      lappend error_list "unexpected version"
      incr errors 1
      return -1
   } else {
      debug_puts "Host Configuration Version: $config(version)"
   }

   set max_pos [get_configuration_element_count config]

   set uninitalized ""
   if { $be_quiet == 0 } { 
      puts $CHECK_OUTPUT ""
   }
   for { set param 1 } { $param <= $max_pos } { incr param 1 } {
      set par [ get_configuration_element_name_on_pos config $param ]
      if { $be_quiet == 0 } { 
         puts -nonewline $CHECK_OUTPUT "      $config($par,desc) ..."
         flush $CHECK_OUTPUT
      }
      if { $config($par) == "" || $force != 0 } {
         debug_puts "not initialized or forced!"
         lappend uninitalized $param
         if { $only_check != 0 } {
            lappend error_list ">$par< configuration not initalized"
            incr errors 1
         }
      } else {
         set procedure_name  $config($par,setup_func)
         set default_value   $config($par,default)
         set description     $config($par,desc)
         if { [string length $procedure_name] == 0 } {
             debug_puts "no procedure defined"
         } else {
            if { [info procs $procedure_name ] != $procedure_name } {
               puts $CHECK_OUTPUT "error\n"
               puts $CHECK_OUTPUT "-->WARNING: unkown procedure name: \"$procedure_name\" !!!"
               puts $CHECK_OUTPUT "   ======="
               lappend uninitalized $param

               if { $only_check == 0 } { 
                  wait_for_enter 
               }
            } else {
               # call procedure only_check == 1
               debug_puts "starting >$procedure_name< (verify mode) ..."
               set value [ $procedure_name 1 $par config ]
               if { $value == -1 } {
                  incr errors 1
                  lappend error_list $par 
                  lappend uninitalized $param

                  puts $CHECK_OUTPUT "error\n"
                  puts $CHECK_OUTPUT "-->WARNING: verify error in procedure \"$procedure_name\" !!!"
                  puts $CHECK_OUTPUT "   ======="

               } 
            }
         }
      }
      if { $be_quiet == 0 } { 
         puts $CHECK_OUTPUT "\r      $config($par,desc) ... ok"   
      }
   }
   if { [set count [llength $uninitalized]] != 0 && $only_check == 0 } {
      puts $CHECK_OUTPUT "$count parameters are not initialized!"
      puts $CHECK_OUTPUT "Entering setup procedures ..."
      
      foreach pos $uninitalized {
         set p_name [get_configuration_element_name_on_pos config $pos]
         set procedure_name  $config($p_name,setup_func)
         set default_value   $config($p_name,default)
         set description     $config($p_name,desc)
       
         puts $CHECK_OUTPUT "----------------------------------------------------------"
         puts $CHECK_OUTPUT $description
         puts $CHECK_OUTPUT "----------------------------------------------------------"
         debug_puts "Starting configuration procedure for parameter \"$p_name\" ($config($p_name,pos)) ..."
         set use_default 0
         if { [string length $procedure_name] == 0 } {
            puts $CHECK_OUTPUT "no procedure defined"
            set use_default 1
         } else {
            if { [info procs $procedure_name ] != $procedure_name } {
               puts $CHECK_OUTPUT ""
               puts $CHECK_OUTPUT "-->WARNING: unkown procedure name: \"$procedure_name\" !!!"
               puts $CHECK_OUTPUT "   ======="
               if { $only_check == 0 } { wait_for_enter }
               set use_default 1
            }
         } 

         if { $use_default != 0 } {
            # check again if we have value ( force flag) 
            if { $config($p_name) == "" } {
               # we have no setup procedure
               if { $default_value != "" } {
                  puts $CHECK_OUTPUT "using default value: \"$default_value\"" 
                  set config($p_name) $default_value 
               } else {
                  puts $CHECK_OUTPUT "No setup procedure and no default value found!!!"
                  if { $only_check == 0 } {
                     puts -nonewline $CHECK_OUTPUT "Please enter value for parameter \"$p_name\": "
                     set value [wait_for_enter 1]
                     puts $CHECK_OUTPUT "using value: \"$value\"" 
                     set config($p_name) $value
                  } 
               }
            }
         } else {
            # call setup procedure ...
            debug_puts "starting >$procedure_name< (setup mode) ..."
            set value [ $procedure_name 0 $p_name config ]
            if { $value != -1 } {
               puts $CHECK_OUTPUT "using value: \"$value\"" 
               set config($p_name) $value
            }
         }
         if { $config($p_name) == "" } {
            puts $CHECK_OUTPUT "" 
            puts $CHECK_OUTPUT "-->WARNING: no value for \"$p_name\" !!!"
            puts $CHECK_OUTPUT "   ======="
            incr errors 1
            lappend error_list $p_name
         }
      } 
   }
   return $errors
}

#****** check/verify_user_config() *********************************************
#  NAME
#     verify_user_config() -- verify testsuite user configuration setup
#
#  SYNOPSIS
#     verify_user_config { config_array only_check parameter_error_list 
#     { force 0 } } 
#
#  FUNCTION
#     This procedure will verify or enter user setup configuration
#
#  INPUTS
#     config_array         - array name with configuration (ts_user_config)
#     only_check           - if 1: don't ask user, just check
#     parameter_error_list - returned list with error information
#     { force 0 }          - force ask user 
#
#  RESULT
#     number of errors
#
#  SEE ALSO
#     check/verify_host_config()
#     check/verify_user_config()
#     check/verify_config()
#     
#*******************************************************************************
proc verify_user_config { config_array only_check parameter_error_list { force 0 }} {
   global CHECK_OUTPUT actual_ts_user_config_version be_quiet
   upvar $config_array config
   upvar $parameter_error_list error_list

   set errors 0
   set error_list ""

   if { [ info exists config(version) ] != 1 } {
      puts $CHECK_OUTPUT "Could not find version info in user configuration file"
      lappend error_list "no version info"
      incr errors 1
      return -1
   }

   if { $config(version) != $actual_ts_user_config_version } {
      puts $CHECK_OUTPUT "User configuration file version \"$config(version)\" not supported."
      puts $CHECK_OUTPUT "Expected version is \"$actual_ts_user_config_version\""
      lappend error_list "unexpected version"
      incr errors 1
      return -1
   } else {
      debug_puts "User Configuration Version: $config(version)"
   }

   set max_pos [get_configuration_element_count config]

   set uninitalized ""
   if { $be_quiet == 0 } { 
      puts $CHECK_OUTPUT ""
   }
   for { set param 1 } { $param <= $max_pos } { incr param 1 } {
      set par [ get_configuration_element_name_on_pos config $param ]
      if { $be_quiet == 0 } { 
         puts -nonewline $CHECK_OUTPUT "      $config($par,desc) ..."
         flush $CHECK_OUTPUT
      }
      if { $config($par) == "" || $force != 0 } {
         debug_puts "not initialized or forced!"
         lappend uninitalized $param
         if { $only_check != 0 } {
            lappend error_list ">$par< configuration not initalized"
            incr errors 1
         }
      } else {
         set procedure_name  $config($par,setup_func)
         set default_value   $config($par,default)
         set description     $config($par,desc)
         if { [string length $procedure_name] == 0 } {
             debug_puts "no procedure defined"
         } else {
            if { [info procs $procedure_name ] != $procedure_name } {
               puts $CHECK_OUTPUT "error\n"
               puts $CHECK_OUTPUT "-->WARNING: unkown procedure name: \"$procedure_name\" !!!"
               puts $CHECK_OUTPUT "   ======="
               lappend uninitalized $param

               if { $only_check == 0 } { 
                  wait_for_enter 
               }
            } else {
               # call procedure only_check == 1
               debug_puts "starting >$procedure_name< (verify mode) ..."
               set value [ $procedure_name 1 $par config ]
               if { $value == -1 } {
                  incr errors 1
                  lappend error_list $par
                  puts $CHECK_OUTPUT "error\n"
                  puts $CHECK_OUTPUT "-->WARNING: verify error in procedure \"$procedure_name\" !!!"
                  puts $CHECK_OUTPUT "   ======="
                  lappend uninitalized $param

               }
            }
         }
      }
      if { $be_quiet == 0 } { 
         puts $CHECK_OUTPUT "\r      $config($par,desc) ... ok"   
      }
   }
   if { [set count [llength $uninitalized]] != 0 && $only_check == 0 } {
      puts $CHECK_OUTPUT "$count parameters are not initialized!"
      puts $CHECK_OUTPUT "Entering setup procedures ..."
      
      foreach pos $uninitalized {
         set p_name [get_configuration_element_name_on_pos config $pos]
         set procedure_name  $config($p_name,setup_func)
         set default_value   $config($p_name,default)
         set description     $config($p_name,desc)
       
         puts $CHECK_OUTPUT "----------------------------------------------------------"
         puts $CHECK_OUTPUT $description
         puts $CHECK_OUTPUT "----------------------------------------------------------"
         debug_puts "Starting configuration procedure for parameter \"$p_name\" ($config($p_name,pos)) ..."
         set use_default 0
         if { [string length $procedure_name] == 0 } {
            puts $CHECK_OUTPUT "no procedure defined"
            set use_default 1
         } else {
            if { [info procs $procedure_name ] != $procedure_name } {
               puts $CHECK_OUTPUT ""
               puts $CHECK_OUTPUT "-->WARNING: unkown procedure name: \"$procedure_name\" !!!"
               puts $CHECK_OUTPUT "   ======="
               if { $only_check == 0 } { wait_for_enter }
               set use_default 1
            }
         } 

         if { $use_default != 0 } {
            # check again if we have value ( force flag) 
            if { $config($p_name) == "" } {
               # we have no setup procedure
               if { $default_value != "" } {
                  puts $CHECK_OUTPUT "using default value: \"$default_value\"" 
                  set config($p_name) $default_value 
               } else {
                  puts $CHECK_OUTPUT "No setup procedure and no default value found!!!"
                  if { $only_check == 0 } {
                     puts -nonewline $CHECK_OUTPUT "Please enter value for parameter \"$p_name\": "
                     set value [wait_for_enter 1]
                     puts $CHECK_OUTPUT "using value: \"$value\"" 
                     set config($p_name) $value
                  } 
               }
            }
         } else {
            # call setup procedure ...
            debug_puts "starting >$procedure_name< (setup mode) ..."
            set value [ $procedure_name 0 $p_name config ]
            if { $value != -1 } {
               puts $CHECK_OUTPUT "using value: \"$value\"" 
               set config($p_name) $value
            }
         }
         if { $config($p_name) == "" } {
            puts $CHECK_OUTPUT "" 
            puts $CHECK_OUTPUT "-->WARNING: no value for \"$p_name\" !!!"
            puts $CHECK_OUTPUT "   ======="
            incr errors 1
            lappend error_list $p_name
         }
      } 
   }
   return $errors
}


#****** check/setup_host_config() **********************************************
#  NAME
#     setup_host_config() -- testsuite host configuration initalization
#
#  SYNOPSIS
#     setup_host_config { file { force 0 } } 
#
#  FUNCTION
#     This procedure will initalize the testsuite host configuration
#
#  INPUTS
#     file        - host configuration file
#     { force 0 } - if 1: edit configuration setup
#
#  SEE ALSO
#     check/setup_user_config()
#*******************************************************************************
proc setup_host_config { file { force 0 }} {
   global CHECK_OUTPUT
   global ts_host_config actual_ts_host_config_version

   if { [read_array_from_file $file "testsuite host configuration" ts_host_config ] == 0 } {
      if { $ts_host_config(version) != $actual_ts_host_config_version } {
         puts $CHECK_OUTPUT "unkown host configuration file version: $ts_host_config(version)"
         while { [update_ts_host_config_version $file] != 0 } {
            wait_for_enter
         }
      }
      # got config
      if { [verify_host_config ts_host_config 1 err_list $force ] != 0 } {
         # configuration problems
         foreach elem $err_list {
            puts $CHECK_OUTPUT "$elem"
         } 
         puts $CHECK_OUTPUT "Press enter to edit host setup configurations"
         set answer [wait_for_enter 1]

         set not_ok 1
         while { $not_ok } {
            if { [verify_host_config ts_host_config 0 err_list $force ] != 0 } {
               set not_ok 1
               foreach elem $err_list {
                  puts $CHECK_OUTPUT "error in: $elem"
               } 
               puts $CHECK_OUTPUT "try again? (y/n)"
               set answer [wait_for_enter 1]
               if { $answer == "n" } {
                  puts $CHECK_OUTPUT "Do you want to save your changes? (y/n)"
                  set answer [wait_for_enter 1]
                  if { $answer == "y" } {
                     if { [ save_host_configuration $file] != 0} {
                        puts $CHECK_OUTPUT "Could not save host configuration"
                        wait_for_enter
                     }
                  }
                  return
               } else {
                  continue
               }
            } else {
              set not_ok 0
            }
         }
         if { [ save_host_configuration $file] != 0} {
            puts $CHECK_OUTPUT "Could not save host configuration"
            wait_for_enter
            return
         }
      }
      if { $force == 1 } {
         if { [ save_host_configuration $file] != 0} {
            puts $CHECK_OUTPUT "Could not save host configuration"
            wait_for_enter
         }
      }
      return
   } else {
      puts $CHECK_OUTPUT "could not open host config file \"$file\""
      puts $CHECK_OUTPUT "press return to create new host configuration file"
      wait_for_enter 1
      if { [ save_host_configuration $file] != 0} {
         exit -1
      }
      setup_host_config $file
   }
}

#****** check/setup_user_config() **********************************************
#  NAME
#     setup_user_config() -- testsuite user configuration initalization
#
#  SYNOPSIS
#     setup_user_config { file { force 0 } } 
#
#  FUNCTION
#     This procedure will initalize the testsuite user configuration
#
#  INPUTS
#     file        - user configuration file
#     { force 0 } - if 1: edit configuration setup
#
#  SEE ALSO
#     check/setup_host_config()
#*******************************************************************************
proc setup_user_config { file { force 0 }} {
   global CHECK_OUTPUT
   global ts_user_config actual_ts_user_config_version do_nomain
   

   if { [read_array_from_file $file "testsuite user configuration" ts_user_config ] == 0 } {
      if { $ts_user_config(version) != $actual_ts_user_config_version } {
         puts $CHECK_OUTPUT "unkown user configuration file version: $ts_user_config(version)"
         exit -1
      }
      # got config
     
      if { $do_nomain == 0 } {
         if { [verify_user_config ts_user_config 1 err_list $force ] != 0 } {
            # configuration problems
            foreach elem $err_list {
               puts $CHECK_OUTPUT "$elem"
            } 
            set not_ok 1
            while { $not_ok } {
               if { [verify_user_config ts_user_config 0 err_list $force ] != 0 } {
                  set not_ok 1
                  puts $CHECK_OUTPUT "User configuration error. Stop."
                  foreach elem $err_list {
                     puts $CHECK_OUTPUT "error in: $elem"
                  } 
                  puts $CHECK_OUTPUT "try again? (y/n)"
                  set answer [wait_for_enter 1]
                  if { $answer == "n" } {
                     puts $CHECK_OUTPUT "Do you want to save your changes? (y/n)"
                     set answer [wait_for_enter 1]
                     if { $answer == "y" } {
                        if { [ save_user_configuration $file] != 0} {
                           puts $CHECK_OUTPUT "Could not save user configuration"
                           wait_for_enter
                        }
                     }
                     return
                  } else {
                    continue
                  }
               } else {
                 set not_ok 0
               }
            }
            if { [ save_user_configuration $file] != 0} {
               puts $CHECK_OUTPUT "Could not save user configuration"
               wait_for_enter
               return
            }

         }
         if { $force == 1 } {
            if { [ save_user_configuration $file] != 0} {
               puts $CHECK_OUTPUT "Could not save user configuration"
               wait_for_enter
            }
         }
         return
      }
      return 
   } else {
      puts $CHECK_OUTPUT "could not open user config file \"$file\""
      puts $CHECK_OUTPUT "press return to create new user configuration file"
      wait_for_enter 1
      if { [ save_user_configuration $file] != 0} {
         exit -1
      }
      setup_user_config $file
   }
}

#****** check/edit_setup() *****************************************************
#  NAME
#     edit_setup() -- edit testsuite/host/user configuration setup
#
#  SYNOPSIS
#     edit_setup { array_name verify_func mod_string } 
#
#  FUNCTION
#     This procedure is used to change the testsuite setup configuration
#
#  INPUTS
#     array_name  - ts_config, ts_host_config or ts_user_config array name
#     verify_func - procedure used for verify changes
#     mod_string  - name of string to report changes
#
#  SEE ALSO
#     check/verify_config()
#     check/verify_host_config()
#     check/verify_user_config()
#*******************************************************************************
proc edit_setup { array_name verify_func mod_string } {
   global ts_config
   global CHECK_OUTPUT
   global CHECK_DEFAULTS_FILE 
   global env

   upvar $array_name org_config
   upvar $mod_string onchange_values

   set onchange_values ""
   set org_names [ array names org_config ]
   foreach name $org_names {
      set config($name) $org_config($name)
   }

   set no_changes 1
   while { 1 } {
      clear_screen
      puts $CHECK_OUTPUT "----------------------------------------------------------"
      puts $CHECK_OUTPUT "$config(version,desc)"
      puts $CHECK_OUTPUT "----------------------------------------------------------"

      set max_pos [get_configuration_element_count config]
      set index 1
      for { set param 1 } { $param <= $max_pos } { incr param 1 } {
         set par [ get_configuration_element_name_on_pos config $param ]
     
         set procedure_name  $config($par,setup_func)
         if { [ string compare "" $procedure_name ] == 0 } {
            continue
         }
          
         if { [info procs $procedure_name ] == $procedure_name } {
            set index_par_list($index) $par
   
            if { $index <= 9 } {
               puts $CHECK_OUTPUT "    $index) $config($par,desc)"
            } else {
               puts $CHECK_OUTPUT "   $index) $config($par,desc)"
            }
            incr index 1
         }
      }
      puts $CHECK_OUTPUT ""
      puts $CHECK_OUTPUT "Please enter the number of the configuration parameter"
      puts -nonewline $CHECK_OUTPUT "you want to change or return to exit: "
      set input [ wait_for_enter 1]
   
      if { [ info exists index_par_list($input) ] } {
         set no_changes 0
         set back [$config($index_par_list($input),setup_func) 0 $index_par_list($input) config ]
         if { $back != -1 } {
            puts $CHECK_OUTPUT "setting $index_par_list($input) to:\n\"$back\"" 
            set config($index_par_list($input)) $back
            wait_for_enter
         } else {
            puts $CHECK_OUTPUT "setup error"
            wait_for_enter
         }
      } else {
         if { [string compare $input ""] == 0 } {
            break
         }
         puts $CHECK_OUTPUT "\"$input\" is not a valid number"
      }
   }
   if { $no_changes == 1 } {
      return -1
   }

   puts $CHECK_OUTPUT ""
   # modified values
   set no_changes 0
   set org_names [ array names org_config ]
   foreach name $org_names {
      if { [ info exists config($name) ] != 1 } {
         incr no_changes 1
         break
      }
      if { [ string compare $config($name) $org_config($name)] != 0 } {
         incr no_changes 1
         break
      }
   }
   # added values
   set new_names [ array names config ]      
   foreach name $new_names {
      if { [ info exists org_config($name)] != 1 } {
         incr no_changes 1
         break
      }
   }
   if { $no_changes == 0 } {
      return -1
   }

   puts $CHECK_OUTPUT "Verify new settings ..."
   set verify_state "-1"
   lappend errors "edit_setup(): verify func not found"
   if { [info procs $verify_func ] == $verify_func } {
      set errors ""
      set verify_state [$verify_func config 1 errors ]
   }
   if { $verify_state == 0 } {
      puts $CHECK_OUTPUT ""
      # modified values
      set org_names [ array names org_config ]
      foreach name $org_names {
         if { [ info exists config($name) ] != 1 } {
            puts $CHECK_OUTPUT "removed $name:"
            puts $CHECK_OUTPUT "old value: \"$org_config($name)\""
            continue
         }
         if { [ string compare $config($name) $org_config($name)] != 0 } {
            puts $CHECK_OUTPUT "modified $name:"
            puts $CHECK_OUTPUT "old value: \"$org_config($name)\""
            puts $CHECK_OUTPUT "new value: \"$config($name)\"\n"
         }
      }
      # added values
      set new_names [ array names config ]      
      foreach name $new_names {
         if { [ info exists org_config($name)] != 1 } {
            puts $CHECK_OUTPUT "added $name:"
            puts $CHECK_OUTPUT "value: \"$config($name)\"\n"
         }
      }

      puts -nonewline $CHECK_OUTPUT "Do you want to use your changes? (y/n) > "
      set input [ wait_for_enter 1 ]
      if { [ string compare $input "y" ] == 0 } {
         # save values (modified, deleted)
         set org_names [ array names org_config ]
         foreach name $org_names {
            if { [ info exists config($name) ] != 1 } {
               unset org_config($name)
               if { [ info exists config($name,onchange)] } {
                  append onchange_values $config($name,onchange)
               }
               continue
            }
            if { [ string compare $config($name) $org_config($name)] != 0 } {
               set org_config($name) $config($name)
               if { [ info exists config($name,onchange)] } {
                  append onchange_values $config($name,onchange)
               }
            }
         }
         # save values (added)
         set new_names [ array names config ]      
         foreach name $new_names {
            if { [ info exists org_config($name)] != 1 } {
               set org_config($name) $config($name) 
               if { [ info exists config($name,onchange)] } {
                  append onchange_values $config($name,onchange)
               }
            }
         }


         return 0
      }
   } else {
      puts $CHECK_OUTPUT "Verify errros:"
      foreach elem $errors {
         puts $CHECK_OUTPUT "error in: $elem"
      }
      wait_for_enter
   }
   puts $CHECK_OUTPUT "resetting old values ..."
   $verify_func org_config 1 errors 
   return -1
}



#****** check/show_config() ****************************************************
#  NAME
#     show_config() -- show configuration settings
#
#  SYNOPSIS
#     show_config { conf_array {short 1} } 
#
#  FUNCTION
#     This procedure will print the current configuration settings for the
#     global configuration arrays: ts_config, ts_user_config or ts_host_config
#
#  INPUTS
#     conf_array - ts_config, ts_user_config or ts_host_config
#     {short 1}  - if 0: show long parameter names
#
#  SEE ALSO
#     ???/???
#*******************************************************************************
proc show_config { conf_array {short 1}} {
   global CHECK_OUTPUT

   upvar $conf_array config

   set max_pos [get_configuration_element_count config]
   set max_par_length 0
   set max_description_length 0
   for { set param 1 } { $param <= $max_pos } { incr param 1 } {
      set par [ get_configuration_element_name_on_pos config $param ]
      set description     $config($par,desc)
      
      set par_length [string length $par]
      set description_length [string length $description]
      if { $max_par_length < $par_length } {
         set max_par_length $par_length
      }
      if { $max_description_length < $description_length} {
         set  max_description_length $description_length
      }
   }
   for { set param 1 } { $param <= $max_pos } { incr param 1 } {
      set par [ get_configuration_element_name_on_pos config $param ]
      set procedure_name  $config($par,setup_func)
      set default_value   $config($par,default)
      set description     $config($par,desc)
      set value           $config($par)
      if { $short == 0 } {
         puts $CHECK_OUTPUT "$description:[get_spaces [expr ( $max_description_length - [ string length $description ] ) ]] \"$config($par)\""
      } else {
         puts $CHECK_OUTPUT "$par:[get_spaces [expr ( $max_par_length - [ string length $par ] ) ]] \"$config($par)\""
      }
   }

}
#****** check/get_spaces() *****************************************************
#  NAME
#     get_spaces() -- return string with given number of spaces 
#
#  SYNOPSIS
#     get_spaces { nr } 
#
#  FUNCTION
#     This procedure returns a string with the given number of spaces
#
#  INPUTS
#     nr - nr of spaces in string
#
#  RESULT
#     string with given number of spaces
#
#  SEE ALSO
#     ???/???
#*******************************************************************************
proc get_spaces { nr } {
   set spaces ""
   for { set i 0 } { $i < $nr } { incr i 1 } {
      append spaces " "
   }
   return $spaces
}


#****** check/modify_setup2() **************************************************
#  NAME
#     modify_setup2() -- modify testsuite setup files
#
#  SYNOPSIS
#     modify_setup2 { } 
#
#  FUNCTION
#     This procedure is called to let the user change testsuite settings
#
#  INPUTS
#
#  SEE ALSO
#     check/setup2()
#*******************************************************************************
proc modify_setup2 {} {
   global ts_config ts_host_config ts_user_config CHECK_ACT_LEVEL
   global CHECK_OUTPUT CHECK_PACKAGE_DIRECTORY check_name

   global CHECK_CORE_EXECD CHECK_CORE_MASTER CHECK_PRODUCT_ROOT CHECK_CHECKTREE_ROOT


   lock_testsuite

   set old_exed $CHECK_CORE_EXECD
   set old_master $CHECK_CORE_MASTER
   set old_root $CHECK_PRODUCT_ROOT

   set change_level ""
   
   set check_name "setup"
   set CHECK_ACT_LEVEL "0"

    while { 1 } {
      clear_screen
      puts $CHECK_OUTPUT "------------------------------------------------------------------"
      puts $CHECK_OUTPUT "Modify testsuite configuration"
      puts $CHECK_OUTPUT "------------------------------------------------------------------"
      puts $CHECK_OUTPUT "   (1) Testsuite configuration   (1s) Show testsuite configuration"
      puts $CHECK_OUTPUT "   (2) Host file configuration   (2s) Show host file configuration"
      puts $CHECK_OUTPUT "   (3) User file configuration   (3s) Show user file configuration"
      puts $CHECK_OUTPUT ""
      puts -nonewline $CHECK_OUTPUT "Please enter a number or press return to exit: "
      set input [ wait_for_enter 1]
      if { [string compare $input ""] == 0 } {
         break
      }
      set do_show 0
      if { [set pos [string first "s" $input ]] > 0 } {
         set do_show 1
         incr pos -1
         set input [string range $input 0 $pos]
      }
      if { $do_show == 0 } {
         switch -- $input {
            1 {
               set do_save [edit_setup ts_config verify_config tmp_string]
               if { $do_save == 0 } {
                  save_configuration
                  append change_level $tmp_string
               }
            }
   
            2 {
               set do_save [edit_setup ts_host_config verify_host_config tmp_string]
               if { $do_save == 0 } {
                  save_host_configuration $ts_config(host_config_file)
                  append change_level $tmp_string
               }
   
            }
            3 {
               set do_save [edit_setup ts_user_config verify_user_config tmp_string]
               if { $do_save == 0 } {
                  save_user_configuration $ts_config(user_config_file)
                  append change_level $tmp_string
               }
            }
   
            default { 
               puts $CHECK_OUTPUT "no valid number"
               wait_for_enter  
            }
         }
      } else {
         switch -- $input {
            1 {
               show_config ts_config
            }
            2 {
               show_config ts_host_config

            }
            3 {
               show_config ts_user_config
            }
   
            default { 
               puts $CHECK_OUTPUT "no valid number"
            }
         }
         wait_for_enter
      }
   }

   set new_exed $CHECK_CORE_EXECD
   set new_master $CHECK_CORE_MASTER
   set new_root $CHECK_PRODUCT_ROOT

   set CHECK_CORE_EXECD $old_exed
   set CHECK_CORE_MASTER $old_master
   set CHECK_PRODUCT_ROOT $old_root

   set CHECK_CORE_EXECD $new_exed
   set CHECK_CORE_MASTER $new_master
   set CHECK_PRODUCT_ROOT $new_root


   # onchange:   "", "compile", "install", "stop"
   debug_puts "change_level: \"$change_level\""

   if { [string length $change_level] != 0 } { 
      puts $CHECK_OUTPUT "modification needs shutdown of old grid engine system"
      set CHECK_CORE_EXECD $old_exed
      set CHECK_CORE_MASTER $old_master
      set CHECK_PRODUCT_ROOT $old_root
      shutdown_core_system
      delete_tests $CHECK_CHECKTREE_ROOT/install_core_system
      set CHECK_CORE_EXECD $new_exed
      set CHECK_CORE_MASTER $new_master
      set CHECK_PRODUCT_ROOT $new_root
   }

   if { [ string first "stop" $change_level ] >= 0 } {
      puts $CHECK_OUTPUT "modification needs restart of testsuite."
      exit 1
   }

   if { [ string first "compile" $change_level ] >= 0 } {
      if { $CHECK_PACKAGE_DIRECTORY != "none" } {
         puts $CHECK_OUTPUT "modification needs reinstallation of packages"
         prepare_packages ;# reinstall tar binaries
      } else { 
         puts $CHECK_OUTPUT "modification needs compilation of new grid engine system"
         compile_source
      }
   }
   unlock_testsuite
   return $change_level
}


#****** check/setup2() *********************************************************
#  NAME
#     setup2() -- testsuite initialization procedure
#
#  SYNOPSIS
#     setup2 { } 
#
#  FUNCTION
#     This procedure is used for testsuite initalization.
#
#  INPUTS
#
#  SEE ALSO
#     check/__setup()
#*******************************************************************************
proc setup2 { } {
   global bootstrap
   global ts_config ts_host_config ts_user_config actual_ts_config_version
   global CHECK_OUTPUT CHECK_DO_SETUP
   global CHECK_DEFAULTS_FILE do_nomain
   global env be_quiet be_quiet
   global check_name CHECK_ACT_LEVEL have_defaults
   global CHECK_USER CHECK_CURRENT_WORKING_DIR



   global CHECK_PRODUCT_TYPE
   global CHECK_PRODUCT_FEATURE
   global CHECK_PRODUCT_VERSION_NUMBER
   global CHECK_PRODUCT_ROOT
   global CHECK_COMMD_PORT
   global CHECK_TESTSUITE_ROOT
   global CHECK_CONFIG_DIR
   global CHECK_CHECKTREE_ROOT
   global CHECK_MAIN_RESULTS_DIR
   global CHECK_JOB_OUTPUT_DIR
   global CHECK_PROTOCOL_DIR
   global CHECK_CORE_MASTER
   global CHECK_CORE_EXECD
   global CHECK_CORE_PROCESSORS
   global CHECK_SUBMIT_ONLY_HOSTS
   global CHECK_USER
   global CHECK_GROUP
   global CHECK_CURRENT_WORKING_DIR
   global CHECK_SOURCE_DIR
   global CHECK_SOURCE_CVS_RELEASE
   global CHECK_SOURCE_HOSTNAME
   global CHECK_SOURCE_COMPILE_HOSTS
   global CHECK_AIMK_COMPILE_OPTIONS
   global CHECK_DIST_INSTALL_OPTIONS
   global CHECK_PACKAGE_DIRECTORY
   global CHECK_PACKAGE_TYPE
   global CHECK_QMASTER_INSTALL_OPTIONS
   global CHECK_EXECD_INSTALL_OPTIONS
   global CHECK_DNS_DOMAINNAME
   global CHECK_REMOTE_ENVIRONMENT
   global CHECK_FIRST_FOREIGN_SYSTEM_USER
   global CHECK_SECOND_FOREIGN_SYSTEM_USER
   global CHECK_FIRST_FOREIGN_SYSTEM_GROUP
   global CHECK_SECOND_FOREIGN_SYSTEM_GROUP
   global CHECK_DEFAULT_DOMAIN
   global CHECK_MAILX_HOST
   global CHECK_REPORT_EMAIL_TO
   global CHECK_REPORT_EMAIL_CC
   global CHECK_SEND_ERROR_MAILS 
   global CHECK_MAX_ERROR_MAILS
   global CHECK_USE_SSH 
 

   source_procedures
  
   # unset old system environment
   if { $be_quiet == 0 } { 
      puts "starting setup ..."
   }
   if { [info exists env(GRD_ROOT) ] } {
      if { $be_quiet == 0 } { 
         puts "unsetting GRD_ROOT"
      }
      unset env(GRD_ROOT)
   }
   if { [info exists env(CODINE_ROOT) ] } {
      if { $be_quiet == 0 } { 
         puts "unsetting CODINE_ROOT"
      }
      unset env(CODINE_ROOT)
   }
   
   # setup check information for error mails
   set check_name "setup"
   set CHECK_ACT_LEVEL "0"
   set have_defaults 0

   if { [read_array_from_file $CHECK_DEFAULTS_FILE "testsuite configuration" ts_config ] == 0 } {
      if { $ts_config(version) != $actual_ts_config_version } {
         puts $CHECK_OUTPUT "unkown configuration file version: $ts_config(version)"
         while { [update_ts_config_version] != 0 } {
            wait_for_enter
         }
      }
      # got config
      
      if { [verify_config ts_config 1 err_list] != 0 } {
       
         # configuration problems

         foreach elem $err_list {
            puts "$elem"
         } 
         puts "Press enter to edit setup configurations"
         set answer [wait_for_enter 1]
         set not_ok 1
         while { $not_ok } {
            if { [verify_config ts_config 0 err_list ] != 0 } {
               wait_for_enter
               set not_ok 1
               foreach elem $err_list {
                  puts $CHECK_OUTPUT "error in: $elem"
               } 
               puts $CHECK_OUTPUT "Try again? (y/n)"
               set answer [wait_for_enter 1]
               if { $answer == "n" } {
                  # restore old config ?
                  puts $CHECK_OUTPUT "Do you want to restore previous configuration? (y/n)"
                  set answer [ wait_for_enter 1 ]
                  if { $answer == "y" } {
                     if { [restore_configuration] != 0 } {
                        puts $CHECK_OUTPUT "error restoring configuration!"
                        exit 1
                     }
                     exit 0
                  }
                  # save anyway
                  puts $CHECK_OUTPUT "Do you want to save your changes? (y/n)"
                  set answer [ wait_for_enter 1 ]
                  if { $answer == "y" } {
                     if { [save_configuration] != 0 } {
                        puts $CHECK_OUTPUT "error saving configuration!"
                        exit 1
                     }
                  }
                  exit 1
               } 
            } else {
               set not_ok 0
               if { [save_configuration] != 0 } {
                  puts $CHECK_OUTPUT "error saving configuration!"
                  exit 1
               }
            }
         }
      }
      set CHECK_CONFIG_DIR "not supported in setup2 config file"
      if { $be_quiet == 0 } { 
         puts $CHECK_OUTPUT "\nstarting setup ... ok"
      }
#      if { $be_quiet == 0 } { 
#         puts "product type:         $CHECK_PRODUCT_TYPE";
#         puts "product feature:      $CHECK_PRODUCT_FEATURE";
#         puts "product version:      $CHECK_PRODUCT_VERSION_NUMBER";
#         puts "product root dir:     $CHECK_PRODUCT_ROOT";
#         puts "commd port:           $CHECK_COMMD_PORT";
#         puts "testsuite root:       $CHECK_TESTSUITE_ROOT";
#         puts "testsuite config dir: $CHECK_CONFIG_DIR";
#         puts "checktree is:         $CHECK_CHECKTREE_ROOT";
#         puts "check results dir:    $CHECK_MAIN_RESULTS_DIR";
#         puts "check job output dir: $CHECK_JOB_OUTPUT_DIR";
#         puts "check protocols:      $CHECK_PROTOCOL_DIR";
#         puts "master host:          $CHECK_CORE_MASTER";
#         puts "execution hosts:      $CHECK_CORE_EXECD";
#         puts "number of procs:      $CHECK_CORE_PROCESSORS";
#         puts "submit_only_hosts:    $CHECK_SUBMIT_ONLY_HOSTS";
#         puts "username:             $CHECK_USER";
#         puts "user groupname:       $CHECK_GROUP";
#         puts "current working dir:  $CHECK_CURRENT_WORKING_DIR"
#         puts "source code dir:      $CHECK_SOURCE_DIR";
#         puts "cvs release/tag:      $CHECK_SOURCE_CVS_RELEASE";
#         puts "name of cvs host:     $CHECK_SOURCE_HOSTNAME";
#         puts "compile hosts:        $CHECK_SOURCE_COMPILE_HOSTS"
#         puts "aimk compile opt.:    $CHECK_AIMK_COMPILE_OPTIONS"
#         puts "dist inst opt.:       $CHECK_DIST_INSTALL_OPTIONS"
#         puts "package_directory:    $CHECK_PACKAGE_DIRECTORY"
#         puts "package_type:         $CHECK_PACKAGE_TYPE"
#         puts "qmaster inst opt.:    $CHECK_QMASTER_INSTALL_OPTIONS"
#         puts "execd inst opt.:      $CHECK_EXECD_INSTALL_OPTIONS"
#         puts "dns_domain_name:      $CHECK_DNS_DOMAINNAME"
#         puts "user_environment:     $CHECK_REMOTE_ENVIRONMENT"
#         puts "other system users:   $CHECK_FIRST_FOREIGN_SYSTEM_USER, $CHECK_SECOND_FOREIGN_SYSTEM_USER"
#         puts "other system groups:  $CHECK_FIRST_FOREIGN_SYSTEM_GROUP, $CHECK_SECOND_FOREIGN_SYSTEM_GROUP"
#         puts "default domain:       $CHECK_DEFAULT_DOMAIN"
#         puts "mail host (mailx):    $CHECK_MAILX_HOST"
#         puts "mail report to:       $CHECK_REPORT_EMAIL_TO"
#         puts "mail cc to:           $CHECK_REPORT_EMAIL_CC"
#         if { $CHECK_SEND_ERROR_MAILS == 0 } {
#            set smail_state_text "disabled"
#         } else {
#            set smail_state_text "enabled"
#         }
#         puts "enable_error_mails:   $smail_state_text"
#         puts "max_run_all_mails:    $CHECK_MAX_ERROR_MAILS"
#         if { $CHECK_USE_SSH == 0 } {
#            set ssh_state_text "disabled"
#         } else {
#            set ssh_state_text "enabled"
#         }
#         puts "use_ssh:              $ssh_state_text"        
#      }
      enhanced_setup
      
      if { $CHECK_DO_SETUP == 1 } {
         modify_setup2
      }
      
      # fill bootstrap array
      init_bootstrap
      
      unlock_testsuite
   } else {
      puts $CHECK_OUTPUT "could not open defaults file."
      if { [ file isfile $CHECK_DEFAULTS_FILE ] } {
         puts $CHECK_OUTPUT "file exists -> assuming old configuration file!"
         convert_old_defaults_file_to_new_format
         exit -1
      }
      puts $CHECK_OUTPUT "press return to create new configuration file \"$CHECK_DEFAULTS_FILE\""
      wait_for_enter 1 
      if { [save_configuration] != 0 } {
         exit -1
      }
      setup2
   }

}

proc init_bootstrap {} {
   global bootstrap ts_config
   global CHECK_USER CHECK_DEFAULT_DOMAIN
   global CHECK_PRODUCT_ROOT CHECK_OUTPUT

   # start from scratch
   if [info exists bootstrap] {
      unset bootstrap
   }

   # we don't have bootstrapping in versions prior 6.x
   set version [resolve_version]
   if {$version >= 3} {
      # read bootstrapping info from file
      # if it does not yet exist, initialize if from configuration
      set bootstrap_file "$CHECK_PRODUCT_ROOT/default/common/bootstrap"
      if {[file exists $bootstrap_file]} {
         puts $CHECK_OUTPUT "reading bootstrap file $bootstrap_file"
         set f [open $bootstrap_file r]
         while {[gets $f line] > 0} {
            if {[string range $line 0 0] != "#"} {
               set name [lindex $line 0]
               set value [lrange $line 1 end]
               set bootstrap($name) "$value"
               #puts $CHECK_OUTPUT "read $name: $value"
            } else {
               #puts $CHECK_OUTPUT "skipping comment"
            }
         }
      } else {
         puts $CHECK_OUTPUT "initializing bootstrap from scratch"
         set bootstrap(admin_user) "$CHECK_USER"
         set bootstrap(default_domain) "$CHECK_DEFAULT_DOMAIN"
         set bootstrap(ignore_fqdn) "true"
         set bootstrap(spooling_method) "unknown"
         set bootstrap(spooling_lib) "unknown"
         set bootstrap(spooling_params) "unknown"
         set bootstrap(binary_path) "$CHECK_PRODUCT_ROOT/bin"
         set bootstrap(qmaster_spool_dir) "$CHECK_PRODUCT_ROOT/default/spool/qmaster"
         set bootstrap(product_mode) "$ts_config(product_type)"
      }
   } else {
      puts $CHECK_OUTPUT "no need to read bootstrap file for sge testsuite version $version"
   }

   #dump_bootstrap
   #sleep 10
}

proc dump_bootstrap {} {
   global bootstrap CHECK_OUTPUT

   foreach entry [array names bootstrap] {
      puts $CHECK_OUTPUT "$entry: $bootstrap($entry)"
   }
}

#****** check/convert_old_defaults_file_to_new_format() ************************
#  NAME
#     convert_old_defaults_file_to_new_format() -- configuration file converting
#
#  SYNOPSIS
#     convert_old_defaults_file_to_new_format { } 
#
#  FUNCTION
#     This procedure generates the new configuration file format used in setup2
#     from existing old configuration files.
#
#  SEE ALSO
#     check/setup2()
#*******************************************************************************
proc convert_old_defaults_file_to_new_format {} {
   global CHECK_DEFAULTS_FILE ts_config ts_host_config ts_user_config
   global CHECK_OUTPUT CHECK_DO_SETUP
   global CHECK_SETTINGS_VERSION CHECK_JOB_OUTPUT_DIR
  global CHECK_CHECKTREE_ROOT CHECK_PRODUCT_ROOT CHECK_PRODUCT_TYPE 
  global CHECK_PRODUCT_FEATURE env 
  global CHECK_CORE_MASTER CHECK_CORE_EXECD CHECK_CORE_PROCESSORS argv 
  global CHECK_SUBMIT_ONLY_HOSTS CHECK_PRODUCT_ROOT
  global CHECK_PRODUCT_VERSION_NUMBER CHECK_USER CHECK_ARCH CHECK_HOST CHECK_COMMD_PORT
  global CHECK_RESULT_DIR CHECK_BAD_RESULT_DIR CHECK_REPORT_FILE CHECK_GROUP
  global CHECK_CORE_RESULT_DIR CHECK_CORE_BAD_RESULT_DIR CHECK_MAIN_RESULTS_DIR 
  global CHECK_DEFAULTS_FILE CHECK_TESTSUITE_ROOT
  global CHECK_CURRENT_WORKING_DIR CHECK_DO_SETUP CHECK_MAX_LEVEL CHECK_GUILTY_RUNLEVELS
  global CHECK_PROTOCOL_DIR CHECK_OUTPUT CHECK_CONFIG_DIR
  global CHECK_SOURCE_DIR CHECK_SOURCE_HOSTNAME CHECK_SOURCE_COMPILE_HOSTS
  global CHECK_AIMK_COMPILE_OPTIONS CHECK_DIST_INSTALL_OPTIONS
  global CHECK_PACKAGE_DIRECTORY CHECK_PACKAGE_TYPE
  global CHECK_QMASTER_INSTALL_OPTIONS CHECK_EXECD_INSTALL_OPTIONS
  global CHECK_DNS_DOMAINNAME CHECK_REMOTE_ENVIRONMENT
  global CHECK_FIRST_FOREIGN_SYSTEM_USER CHECK_SECOND_FOREIGN_SYSTEM_USER 
  global CHECK_FIRST_FOREIGN_SYSTEM_GROUP CHECK_SECOND_FOREIGN_SYSTEM_GROUP
  global CHECK_DEFAULT_DOMAIN be_quiet
  global CHECK_MAILX_HOST do_nomain
  global CHECK_REPORT_EMAIL_TO CHECK_REPORT_EMAIL_CC  CHECK_USE_SSH CHECK_SOURCE_CVS_RELEASE
  global check_name CHECK_ACT_LEVEL CHECK_SEND_ERROR_MAILS CHECK_MAX_ERROR_MAILS
  global CHECK_GUILTY_CATEGORIES CHECK_SETUP_CHANGES


   set new_file "$CHECK_DEFAULTS_FILE.new"
   clear_screen
   puts $CHECK_OUTPUT "This testsuite version uses a new method to save settings. If you press"
   puts $CHECK_OUTPUT ">ENTER< the testsuite will try to convert the file\n"
   puts $CHECK_OUTPUT "   \"$CHECK_DEFAULTS_FILE\"\n"
   puts $CHECK_OUTPUT "into the new defaults file format and save the new configuration into the file\n"
   puts $CHECK_OUTPUT "   \"$new_file\"\n"
   puts -nonewline $CHECK_OUTPUT "> "
   wait_for_enter 1

   # read in old configuration
   set CHECK_DO_SETUP 0
   __setup
   if { [ info exist env(LANG) ] } {
      unset env(LANG)
   }
   
   set CHECK_DEFAULTS_FILE $new_file
   wait_for_enter 


   set new_host_config_file "$CHECK_CONFIG_DIR/testsuite_host.conf"
   set new_user_config_file "$CHECK_CONFIG_DIR/testsuite_user.conf"


   if { [file isfile $new_host_config_file ] != 1 } {
      while { 1 } {
         set file_exists 0
         puts $CHECK_OUTPUT "\nThe testsuite will generate a new configuration file for all hosts in your"
         puts $CHECK_OUTPUT "cluster. Do you want to create the following configuration file? (y/n)\n"
         puts $CHECK_OUTPUT "\"$new_host_config_file\"\n"
         puts -nonewline $CHECK_OUTPUT "> "
         set input [wait_for_enter 1]
         if { [string compare $input "y"] == 0 } {
            if { [file isfile $new_host_config_file ] } {
               puts $CHECK_OUTPUT "file exists"
               set file_exists 1
               break
            }
            set error [ catch { set fd [open $new_host_config_file "w"] } catch_output]
            if { $error != 0 } {
               puts $CHECK_OUTPUT $catch_output
               wait_for_enter
               continue
            }
            close $fd 
            file delete $new_host_config_file
            break  
         } else {
            puts $CHECK_OUTPUT "Please enter new host configuration file:"
            set new_host_config_file [wait_for_enter 1]
         }
      }
      puts $CHECK_OUTPUT "Using \"$new_host_config_file\" as host configuration file"
      wait_for_enter
      if { $file_exists == 0 } {
         foreach host $CHECK_CORE_EXECD {
            host_config_hostlist_add_host ts_host_config $host
         }
         foreach host $CHECK_SUBMIT_ONLY_HOSTS {
            host_config_hostlist_add_host ts_host_config $host
         }
         foreach host $CHECK_SOURCE_COMPILE_HOSTS {
            host_config_hostlist_add_host ts_host_config $host
            set ts_host_config($host,compile) 1
         }
         puts $CHECK_OUTPUT "\nnew host configuration:"
         show_config ts_host_config
         wait_for_enter
         if { [ save_host_configuration $new_host_config_file] != 0} {
            exit -1
         }
      }
   }

   setup_host_config $new_host_config_file
   foreach host $CHECK_CORE_EXECD {
      host_config_hostlist_add_host ts_host_config $host
   }
   foreach host $CHECK_SUBMIT_ONLY_HOSTS {
      host_config_hostlist_add_host ts_host_config $host
   }
   foreach host $CHECK_SOURCE_COMPILE_HOSTS {
      host_config_hostlist_add_host ts_host_config $host
   }
   save_host_configuration $new_host_config_file
   
   
   if { [file isfile $new_user_config_file ] != 1 } {
      set file_exists 0
      while { 1 } {
         puts $CHECK_OUTPUT "\nThe testsuite will generate a new configuration file for all testsuite"
         puts $CHECK_OUTPUT "users. Do you want to create the following configuration file? (y/n)\n"
         puts $CHECK_OUTPUT "\"$new_user_config_file\"\n"
         puts -nonewline $CHECK_OUTPUT "> "
         set input [wait_for_enter 1]
         if { [string compare $input "y"] == 0 } {
            if { [file isfile $new_user_config_file ] } {
               puts $CHECK_OUTPUT "file exists"
               set file_exists 1
               break
            }
            set error [ catch { set fd [open $new_user_config_file "w"] } catch_output]
            if { $error != 0 } {
               puts $CHECK_OUTPUT $catch_output
               wait_for_enter
               continue
            }
            close $fd 
            file delete $new_user_config_file
            break  
         } else {
            puts $CHECK_OUTPUT "Please enter new user configuration file:"
            set new_user_config_file [wait_for_enter 1]
         }
      }
      puts $CHECK_OUTPUT "Using \"$new_user_config_file\" as user configuration file"
      wait_for_enter

      if { $file_exists == 0 } {
   
         user_config_userlist_add_user ts_user_config  $CHECK_USER
         user_config_userlist_set_portlist ts_user_config $CHECK_USER $CHECK_COMMD_PORT
         set ts_user_config($CHECK_USER,envlist)  $CHECK_REMOTE_ENVIRONMENT
   
         set old_gid_config_file "$CHECK_CONFIG_DIR/gid-range.conf"
         if { [file exists $old_gid_config_file] } {
            set file_p [ open $old_gid_config_file r ]
            set line_no 0
            while { [gets $file_p line ] >= 0 } {
               if { [string first "#" $line ] == 0 } {
                  incr line_no 1
                  continue
               }
               if { [string first "|" $line ] > 0 } {
                  set help [split $line "|"]
                  set user  [lindex $help 0]
                  set port  [lindex $help 1]
                  set range [lindex $help 2] 
                  puts $CHECK_OUTPUT $line
                  if { [ string compare $user $CHECK_USER ] != 0 } {
                      user_config_userlist_add_user ts_user_config $user
                      user_config_userlist_set_portlist ts_user_config $user "$ts_user_config($user,portlist) $port"
                  }
                  set ts_user_config($port,$user) $range
               }
               incr line_no 1 
            }
            close $file_p
         }
         set parameter "first_foreign_user"
         set ts_user_config($parameter)      $CHECK_FIRST_FOREIGN_SYSTEM_USER
         set parameter "second_foreign_user"
         set ts_user_config($parameter)      $CHECK_SECOND_FOREIGN_SYSTEM_USER
         set parameter "first_foreign_group"
         set ts_user_config($parameter)      $CHECK_FIRST_FOREIGN_SYSTEM_GROUP
         set parameter "second_foreign_group"
         set ts_user_config($parameter)      $CHECK_SECOND_FOREIGN_SYSTEM_GROUP
   
         puts $CHECK_OUTPUT "\nnew user configuration:"
         show_config ts_user_config
         wait_for_enter 
   
         if { [ save_user_configuration $new_user_config_file] != 0} {
            exit -1
         }
      }
   }
   
   wait_for_enter
   setup_user_config $new_user_config_file

   user_config_userlist_add_user ts_user_config  $CHECK_USER
   user_config_userlist_set_portlist ts_user_config $CHECK_USER $CHECK_COMMD_PORT
   set ts_user_config($CHECK_USER,envlist)  $CHECK_REMOTE_ENVIRONMENT

   show_config ts_user_config

   wait_for_enter 

   save_user_configuration $new_user_config_file

   # now save values into new configuration file  
   set parameter "testsuite_root_dir"
   set ts_config($parameter)         $CHECK_TESTSUITE_ROOT
   set parameter "checktree_root_dir"
   set ts_config($parameter)         $CHECK_CHECKTREE_ROOT
   set parameter "results_dir"       
   set ts_config($parameter)         $CHECK_MAIN_RESULTS_DIR
   set parameter "use_ssh"
   set ts_config($parameter)         $CHECK_USE_SSH
   set parameter "source_dir"
   set ts_config($parameter)         $CHECK_SOURCE_DIR
   set parameter "source_cvs_hostname"
   set ts_config($parameter)         $CHECK_SOURCE_HOSTNAME
   set parameter "source_cvs_release"
   set ts_config($parameter)         $CHECK_SOURCE_CVS_RELEASE
   set parameter "host_config_file"
   set ts_config($parameter)         $new_host_config_file 
   set parameter "user_config_file"
   set ts_config($parameter)         $new_user_config_file
   set parameter "master_host"
   set ts_config($parameter)         $CHECK_CORE_MASTER
   set parameter "execd_hosts"
   set ts_config($parameter)         $CHECK_CORE_EXECD
   set parameter "submit_only_hosts" 
   set ts_config($parameter)         $CHECK_SUBMIT_ONLY_HOSTS
   set parameter "commd_port"
   set ts_config($parameter)         $CHECK_COMMD_PORT
   set parameter "product_root"
   set ts_config($parameter)         $CHECK_PRODUCT_ROOT
   set parameter "product_type"
   set ts_config($parameter)         $CHECK_PRODUCT_TYPE
   set parameter "product_feature"
   set ts_config($parameter)         $CHECK_PRODUCT_FEATURE
   set parameter "aimk_compile_options"
   set ts_config($parameter)         $CHECK_AIMK_COMPILE_OPTIONS
   set parameter "dist_install_options"
   set ts_config($parameter)         $CHECK_DIST_INSTALL_OPTIONS
   set parameter "qmaster_install_options"
   set ts_config($parameter)         $CHECK_QMASTER_INSTALL_OPTIONS
   if { $ts_config($parameter) == "" } { 
      set ts_config($parameter) "none" 
   }
   set parameter "execd_install_options"
   set ts_config($parameter)         $CHECK_EXECD_INSTALL_OPTIONS
   if { $ts_config($parameter) == "" } { 
      set ts_config($parameter) "none" 
   }
   set parameter "package_directory"
   set ts_config($parameter)         $CHECK_PACKAGE_DIRECTORY
   set parameter "package_type"
   set ts_config($parameter)         $CHECK_PACKAGE_TYPE
   set parameter "dns_domain"
   set ts_config($parameter)         $CHECK_DNS_DOMAINNAME
   set parameter "dns_for_install_script"
   set ts_config($parameter)         $CHECK_DEFAULT_DOMAIN
   set parameter "mailx_host"
   set ts_config($parameter)         $CHECK_MAILX_HOST
   set parameter "report_mail_to"
   set ts_config($parameter)         $CHECK_REPORT_EMAIL_TO
   set parameter "report_mail_cc"
   set ts_config($parameter)         $CHECK_REPORT_EMAIL_CC
   set parameter "enable_error_mails"
   set ts_config($parameter)         $CHECK_MAX_ERROR_MAILS


   show_config ts_config
   wait_for_enter
   save_configuration
   puts $CHECK_OUTPUT "Please restart testsuite with new configuration file"
   exit -1
}



#****** check/enhanced_setup() *************************************************
#  NAME
#     enhanced_setup() -- addition testsuite setup
#
#  SYNOPSIS
#     enhanced_setup { } 
#
#  FUNCTION
#     Procedure is called at the end of setup2(). Here some additional testsuite
#     setup calls are made.
#
#  SEE ALSO
#     check/setup2()
#*******************************************************************************
proc enhanced_setup {} {
   global CHECK_CHECKTREE_ROOT CHECK_GUILTY_RUNLEVELS
   global CHECK_GUILTY_CATEGORIES CHECK_OUTPUT check_name
   global be_quiet CHECK_PACKAGE_DIRECTORY
   global env CHECK_COMMD_PORT CHECK_PRODUCT_ROOT CHECK_ARCH CHECK_HOST

   if { $be_quiet == 0 } { 
      puts "starting enhanced setup ..."
   }
   set check_name "enhanced_setup"

   set env(COMMD_PORT) $CHECK_COMMD_PORT;
   set env(SGE_ROOT) $CHECK_PRODUCT_ROOT;

   set_users_environment $CHECK_HOST

   get_max_level_count $CHECK_CHECKTREE_ROOT

   set CHECK_GUILTY_RUNLEVELS "0" ;# 100 200 300 400" ;#$CHECK_MAX_LEVEL is 400
   set CHECK_GUILTY_CATEGORIES "SYSTEM" ;# [get_categories $CHECK_CHECKTREE_ROOT ]

   delete_tests $CHECK_CHECKTREE_ROOT 1

   setup_shared_lib_path
   check_executable_files
   
   if { $be_quiet == 0 } { 
      puts "   architecture: $CHECK_ARCH";
      puts "   local host:   $CHECK_HOST";
      puts "starting enhanced setup ... ok"
   }
   update_macro_messages_list
#
# uncomment the following line, if the unused macros should be removed from source code
# ======================================================================================  
# 
# --   check_c_source_code_files_for_macros
}

#****** check/__setup() ********************************************************
#  NAME
#     __setup() -- old setup initialization routine
#
#  SYNOPSIS
#     __setup { {do_only_hostname_resolving 0} } 
#
#  FUNCTION
#     Use setup2 
#
#  INPUTS
#     {do_only_hostname_resolving 0} - if not 0: do only host name resolving
#
#  SEE ALSO
#     check/setup2()
#*******************************************************************************
proc __setup { {do_only_hostname_resolving 0} } {


  global ts_config

  global CHECK_SETTINGS_VERSION CHECK_JOB_OUTPUT_DIR
  global CHECK_CHECKTREE_ROOT CHECK_PRODUCT_ROOT CHECK_PRODUCT_TYPE 
  global CHECK_PRODUCT_FEATURE env 
  global CHECK_CORE_MASTER CHECK_CORE_EXECD CHECK_CORE_PROCESSORS argv 
  global CHECK_SUBMIT_ONLY_HOSTS CHECK_PRODUCT_ROOT
  global CHECK_PRODUCT_VERSION_NUMBER CHECK_USER CHECK_ARCH CHECK_HOST CHECK_COMMD_PORT
  global CHECK_RESULT_DIR CHECK_BAD_RESULT_DIR CHECK_REPORT_FILE CHECK_GROUP
  global CHECK_CORE_RESULT_DIR CHECK_CORE_BAD_RESULT_DIR CHECK_MAIN_RESULTS_DIR 
  global CHECK_DEFAULTS_FILE CHECK_TESTSUITE_ROOT
  global CHECK_CURRENT_WORKING_DIR CHECK_DO_SETUP CHECK_MAX_LEVEL CHECK_GUILTY_RUNLEVELS
  global CHECK_PROTOCOL_DIR CHECK_OUTPUT CHECK_CONFIG_DIR
  global CHECK_SOURCE_DIR CHECK_SOURCE_HOSTNAME CHECK_SOURCE_COMPILE_HOSTS
  global CHECK_AIMK_COMPILE_OPTIONS CHECK_DIST_INSTALL_OPTIONS
  global CHECK_PACKAGE_DIRECTORY CHECK_PACKAGE_TYPE
  global CHECK_QMASTER_INSTALL_OPTIONS CHECK_EXECD_INSTALL_OPTIONS
  global CHECK_DNS_DOMAINNAME CHECK_REMOTE_ENVIRONMENT
  global CHECK_FIRST_FOREIGN_SYSTEM_USER CHECK_SECOND_FOREIGN_SYSTEM_USER 
  global CHECK_FIRST_FOREIGN_SYSTEM_GROUP CHECK_SECOND_FOREIGN_SYSTEM_GROUP
  global CHECK_DEFAULT_DOMAIN be_quiet
  global CHECK_MAILX_HOST do_nomain
  global CHECK_REPORT_EMAIL_TO CHECK_REPORT_EMAIL_CC  CHECK_USE_SSH CHECK_SOURCE_CVS_RELEASE
  global check_name CHECK_ACT_LEVEL CHECK_SEND_ERROR_MAILS CHECK_MAX_ERROR_MAILS
  global CHECK_GUILTY_CATEGORIES CHECK_SETUP_CHANGES

  puts "starting setup ..."
  if { [info exists env(GRD_ROOT) ] } {
     puts "unsetting GRD_ROOT"
     unset env(GRD_ROOT)
  }
  if { [info exists env(CODINE_ROOT) ] } {
     puts "unsetting CODINE_ROOT"
     unset env(CODINE_ROOT)
  }

  set check_name "setup"
  set CHECK_ACT_LEVEL "0"
  set have_defaults 0
  
  if { [load_defaults] == 0 } {
     if { $be_quiet == 0 } { 
        puts "--> using \"$CHECK_DEFAULTS_FILE\" for setup."
     }
     if { $CHECK_DO_SETUP == 0 } {
        set have_defaults 1
        #setup on --setup flag!
     }
  } else {
     show_setup_information  ;# print info 
  }

  if {[catch {set CHECK_USER [set env(USER)] }] != 0} {
     set CHECK_USER [file attributes $CHECK_TESTSUITE_ROOT/check.exp -owner]
     puts "\nNo USER is set!\n(default: $CHECK_USER)\n"
     set env(USER) $CHECK_USER
  } 

  if {[catch {set CHECK_GROUP [set env(GROUP)] }] != 0} {
     set CHECK_GROUP [file attributes $CHECK_TESTSUITE_ROOT/check.exp -group]
     puts "\nNo GROUP is set!\n(default: $CHECK_GROUP)\n"
     set env(GROUP) $CHECK_GROUP
  }


# to do to do
  if { $have_defaults == 0 && $do_only_hostname_resolving == 0 } {
      set CHECK_ARCH [ resolve_arch ]
      puts $CHECK_OUTPUT "arch is $CHECK_ARCH"
      set CHECK_HOST [ gethostname ]
      set setup_ok 0

      set edit_result [ edit_defaults ]
      if { $edit_result < 0 } {
         puts $CHECK_OUTPUT "edit defaults: error ; stop"
         set setup_ok -1
      }

      foreach host $CHECK_CORE_EXECD {
         puts $CHECK_OUTPUT "\n--> try rlogin $host and run command echo \"hello $host\" ..."


         set result [ start_remote_prog "$host" $CHECK_USER "echo" "\"hello $host\"" ]
         puts $CHECK_OUTPUT "--> echo exit state: $prg_exit_state"
         puts $CHECK_OUTPUT "--> echo result:     $result"
         if { $prg_exit_state != 0 } {
             puts $CHECK_OUTPUT "-->rlogin to host $host doesn't work correctly"
             set setup_ok -1
         }
         if { [ string first "hello $host" $result ] < 0 } {
             puts $CHECK_OUTPUT "$result"
             puts $CHECK_OUTPUT "echo \"hello $host\" doesn't work"
             set setup_ok -1
         }

         start_remote_prog "$host" "$CHECK_USER" "cd" "$CHECK_CURRENT_WORKING_DIR" 
         if { $prg_exit_state != 0 } {
             puts $CHECK_OUTPUT "directory \"$CHECK_CURRENT_WORKING_DIR\" is not available on host \"$host\""
             set setup_ok -1
         } 

         get_binary_path $host "expect"       
         get_binary_path $host "vim"
      }

      foreach host $CHECK_SOURCE_COMPILE_HOSTS {
         start_remote_prog "$host" "$CHECK_USER" "cd" "$CHECK_CURRENT_WORKING_DIR" 
         if { $prg_exit_state != 0 } {
             puts $CHECK_OUTPUT "directory \"$CHECK_CURRENT_WORKING_DIR\" is not available on compile host \"$host\""
             set setup_ok -1
         } 
      }

      if {$setup_ok == 0} {
         set CHECK_PROTOCOL_DIR $CHECK_MAIN_RESULTS_DIR/protocols
         if {[file isdirectory "$CHECK_PROTOCOL_DIR"] != 1} {
            set catch_return [ catch {  file mkdir "$CHECK_PROTOCOL_DIR" } ]
            if { $catch_return != 0 } {
               puts $CHECK_OUTPUT "could not create directory \"$CHECK_PROTOCOL_DIR\""
               exit -1
            } 
         }
         source_procedures
      } else {
         puts $CHECK_OUTPUT "edit defaults: error ; stop"
         exit -1
      } 
  
     
     set env(COMMD_PORT) $CHECK_COMMD_PORT;
     set env(SGE_ROOT) $CHECK_PRODUCT_ROOT;
     set_users_environment $CHECK_HOST
   
   # resolve now: CHECK_HOST, CHECK_CORE_EXECD, CHECK_CORE_MASTER 
   
     set result [resolve_host $CHECK_CORE_MASTER]
     set ok 1
     foreach elem $result {
        if { [string compare "unknown" $elem] == 0 } {
           set ok 0
        }
     }
     if { $ok == 1 } {
        set CHECK_CORE_MASTER $result
     }    
 
     set result ""
     foreach elem $CHECK_CORE_EXECD {
        lappend result [resolve_host $elem]
     }
     set ok 1
     foreach elem $result {
        if { [string compare "unknown" $elem] == 0 } {
           set ok 0
        }
     }
     if { $ok == 1 } {
        set CHECK_CORE_EXECD $result
     }
  }

  if { $do_only_hostname_resolving == 0 } {
     set env(COMMD_PORT) $CHECK_COMMD_PORT;
     set env(SGE_ROOT) $CHECK_PRODUCT_ROOT;
     set CHECK_ARCH [ resolve_arch ]
     set CHECK_HOST [ gethostname ]
     set_users_environment $CHECK_HOST
     if {[file isdirectory "$CHECK_MAIN_RESULTS_DIR"] != 1} {
           file mkdir "$CHECK_MAIN_RESULTS_DIR"
     }
     set CHECK_RESULT_DIR "$CHECK_MAIN_RESULTS_DIR/$CHECK_HOST.completed"
     set CHECK_BAD_RESULT_DIR "$CHECK_MAIN_RESULTS_DIR/$CHECK_HOST.uncompleted"
     set CHECK_REPORT_FILE "$CHECK_MAIN_RESULTS_DIR/$CHECK_HOST.report"
     set CHECK_CORE_RESULT_DIR "$CHECK_MAIN_RESULTS_DIR/core.completed"
     set CHECK_CORE_BAD_RESULT_DIR "$CHECK_MAIN_RESULTS_DIR/core.uncompleted"
     set CHECK_JOB_OUTPUT_DIR "$CHECK_MAIN_RESULTS_DIR/testsuite_job_outputs"
 
     if {[file isdirectory "$CHECK_CORE_RESULT_DIR"] != 1} {
        file mkdir "$CHECK_CORE_RESULT_DIR"
     }
     if {[file isdirectory "$CHECK_CORE_BAD_RESULT_DIR"] != 1} {
        file mkdir "$CHECK_CORE_BAD_RESULT_DIR"
     }
     if {[file isdirectory "$CHECK_RESULT_DIR"] != 1} {
        file mkdir "$CHECK_RESULT_DIR"
     }
     if {[file isdirectory "$CHECK_BAD_RESULT_DIR"] != 1} {
        file mkdir "$CHECK_BAD_RESULT_DIR"
     }
     if {[file isdirectory "$CHECK_JOB_OUTPUT_DIR"] != 1} {
        file mkdir "$CHECK_JOB_OUTPUT_DIR"
     }
     if {[file isdirectory "$CHECK_PRODUCT_ROOT"] != 1} {
        file mkdir "$CHECK_PRODUCT_ROOT"
     }
  }
  get_version_info

  if {[file isdirectory "$CHECK_CONFIG_DIR"] != 1} {
         puts $CHECK_OUTPUT "could not open config directory \"$CHECK_CONFIG_DIR\""
         exit -1 
  }

  if { $be_quiet == 0 } { 
     puts "       product type:         $CHECK_PRODUCT_TYPE";
     puts "       product feature:      $CHECK_PRODUCT_FEATURE";
     puts "       product version:      $CHECK_PRODUCT_VERSION_NUMBER";
     puts "       product root dir:     $CHECK_PRODUCT_ROOT";
     puts "       commd port:           $CHECK_COMMD_PORT";
     puts "       testsuite root:       $CHECK_TESTSUITE_ROOT";
     puts "       testsuite config dir: $CHECK_CONFIG_DIR";
     puts "       checktree is:         $CHECK_CHECKTREE_ROOT";
     puts "       check results dir:    $CHECK_MAIN_RESULTS_DIR";
     puts "       check job output dir: $CHECK_JOB_OUTPUT_DIR";
     puts "       check protocols:      $CHECK_PROTOCOL_DIR";
     puts "       master host:          $CHECK_CORE_MASTER";
     puts "       execution hosts:      $CHECK_CORE_EXECD";
     puts "       number of procs:      $CHECK_CORE_PROCESSORS";
     puts "       submit_only_hosts:    $CHECK_SUBMIT_ONLY_HOSTS";
     puts "       username:             $CHECK_USER";
     puts "       user groupname:       $CHECK_GROUP";
     puts "       current working dir:  $CHECK_CURRENT_WORKING_DIR"
     puts "       source code dir:      $CHECK_SOURCE_DIR";
     puts "       cvs release/tag:      $CHECK_SOURCE_CVS_RELEASE";
     puts "       name of cvs host:     $CHECK_SOURCE_HOSTNAME";
     puts "       compile hosts:        $CHECK_SOURCE_COMPILE_HOSTS"
     puts "       aimk compile opt.:    $CHECK_AIMK_COMPILE_OPTIONS"
     puts "       dist inst opt.:       $CHECK_DIST_INSTALL_OPTIONS"
     puts "       package_directory:    $CHECK_PACKAGE_DIRECTORY"
     puts "       package_type:         $CHECK_PACKAGE_TYPE"
     puts "       qmaster inst opt.:    $CHECK_QMASTER_INSTALL_OPTIONS"
     puts "       execd inst opt.:      $CHECK_EXECD_INSTALL_OPTIONS"
     puts "       dns_domain_name:      $CHECK_DNS_DOMAINNAME"
     puts "       user_environment:     $CHECK_REMOTE_ENVIRONMENT"
     puts "       other system users:   $CHECK_FIRST_FOREIGN_SYSTEM_USER, $CHECK_SECOND_FOREIGN_SYSTEM_USER"
     puts "       other system groups:  $CHECK_FIRST_FOREIGN_SYSTEM_GROUP, $CHECK_SECOND_FOREIGN_SYSTEM_GROUP"
     puts "       default domain:       $CHECK_DEFAULT_DOMAIN"
     puts "       mail host (mailx):    $CHECK_MAILX_HOST"
     puts "       mail report to:       $CHECK_REPORT_EMAIL_TO"
     puts "       mail cc to:           $CHECK_REPORT_EMAIL_CC"
     if { $CHECK_SEND_ERROR_MAILS == 0 } {
        set smail_state_text "disabled"
     } else {
        set smail_state_text "enabled"
     }
     puts "       enable_error_mails:   $smail_state_text"
     puts "       max_run_all_mails:    $CHECK_MAX_ERROR_MAILS"
     if { $CHECK_USE_SSH == 0 } {
        set ssh_state_text "disabled"
     } else {
        set ssh_state_text "enabled"
     }
     puts "       use_ssh:              $ssh_state_text"        
  }

  if {$have_defaults == 0 && $do_only_hostname_resolving == 0 && $do_nomain == 0} {
     puts "is this correct (y/n)"
     set enter [wait_for_enter 1]
     if {$enter != "y" } {
        return [__setup]
     } else {
        save_defaults
     }
  }


  if {[catch {set CHECK_USER [set env(USER)] }] != 0} {
     set CHECK_USER [file attributes $CHECK_TESTSUITE_ROOT/check.exp -owner]
     puts "\nNo USER is set!\n(default: $CHECK_USER)\n"
     set env(USER) $CHECK_USER
  } 

  if {[catch {set CHECK_GROUP [set env(GROUP)] }] != 0} {
     set CHECK_GROUP [file attributes $CHECK_TESTSUITE_ROOT/check.exp -group]
     puts "\nNo GROUP is set!\n(default: $CHECK_GROUP)\n"
     set env(GROUP) $CHECK_GROUP
  }


  if {$do_only_hostname_resolving == 1} {
      # resolve now: CHECK_HOST, CHECK_CORE_EXECD, CHECK_CORE_MASTER 
      
        set result [resolve_host $CHECK_CORE_MASTER]
        set ok 1
        foreach elem $result {
           if { [string compare "unknown" $elem] == 0 } {
              set ok 0
           }
        }
        if { $ok == 1 } {
           set CHECK_CORE_MASTER $result
        }    
    
        set result ""
        foreach elem $CHECK_CORE_EXECD {
           lappend result [resolve_host $elem]
        }
        set ok 1
        foreach elem $result {
           if { [string compare "unknown" $elem] == 0 } {
              set ok 0
           }
        }
        if { $ok == 1 } {
           set CHECK_CORE_EXECD $result
        }
        save_defaults
  }

  get_max_level_count $CHECK_CHECKTREE_ROOT
  set CHECK_GUILTY_RUNLEVELS "0" ;# 100 200 300 400" ;#$CHECK_MAX_LEVEL is 400
  set CHECK_GUILTY_CATEGORIES "SYSTEM" ;# [get_categories $CHECK_CHECKTREE_ROOT ]
  delete_tests $CHECK_CHECKTREE_ROOT 1

  setup_shared_lib_path

  set CHECK_ARCH [ resolve_arch ]
  set CHECK_HOST [ gethostname ]

  check_executable_files

  if { $be_quiet == 0 } { 
     puts "       architecture:         $CHECK_ARCH";
     puts "       local host:           $CHECK_HOST";
     puts "--> Setup complete"
  }
  set check_name "no check running"



  foreach elem $CHECK_CORE_EXECD {
     set found 0
     set hostname ""
     foreach host $CHECK_CORE_EXECD {
        if { [ string first $host $elem ] >= 0 }  {
           incr found 1
           set hostname $host
        }
     }
     if { $found != 1 } {
        puts "checking list_of_execution_hosts"
        puts "error -> found duplicate entry of host $hostname"
        exit 1
     }
  }

  foreach elem $CHECK_CORE_MASTER {
     set found 0
     set hostname ""
     foreach host $CHECK_CORE_MASTER {
        if { [ string first $host $elem ] >= 0 }  {
           incr found 1
           set hostname $host
        }
     }
     if { $found != 1 } {
        puts "checking qmaster_host"
        puts "error -> found duplicate entry of host $hostname"
        exit 1
     }
  }


  foreach elem $CHECK_SUBMIT_ONLY_HOSTS {
     set found 0
     set hostname ""
     foreach host $CHECK_SUBMIT_ONLY_HOSTS {
        if { [ string first $host $elem ] >= 0 }  {
           incr found 1
           set hostname $host
        }
     }
     if { $found != 1 } {
        puts "checking list_of_submit_only_hosts"
        puts "error -> found duplicate entry of host $hostname"
        exit 1
     }
  }


  foreach elem $CHECK_SOURCE_COMPILE_HOSTS {
     set found 0
     set hostname ""
     foreach host $CHECK_SOURCE_COMPILE_HOSTS {
        if { [ string first $host $elem ] >= 0 }  {
           incr found 1
           set hostname $host
        }
     }
     if { $found != 1 } {
        puts "checking list_of_compile_hosts"
        puts "error -> found duplicate entry of host $hostname"
        exit 1
     }
  }

  set result [get_setup_change_state]
  if { $result == 1 } {
     if { $CHECK_PACKAGE_DIRECTORY != "none" } {
        prepare_packages ;# reinstall tar binaries
     } else { 
        compile_source 1  ;# only install binaries
     }
  }
  if { $result == 2 } {
     shutdown_core_system
  }
}



# get directories with checkprog
#                                                             max. column:     |
#****** check/get_check_dirs() ******
# 
#  NAME
#     get_check_dirs -- ??? 
#
#  SYNOPSIS
#     get_check_dirs { path } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#     path - ??? 
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc get_check_dirs { path } {
  global CHECK_DIRECTORIES CHECK_INFORMATION_FILE

  set files [get_file_names $path] 
  set dirs [get_dir_names $path]
  
  if { [lsearch $files $CHECK_INFORMATION_FILE] >= 0 }  {
     lappend CHECK_DIRECTORIES $path;
  } 
  foreach element $dirs {
     get_check_dirs "$path/$element"
  }
}


# check dependencies
#                                                             max. column:     |
#****** check/validate_needs() ******
# 
#  NAME
#     validate_needs -- ??? 
#
#  SYNOPSIS
#     validate_needs { needs } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#     needs - ??? 
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc validate_needs {needs} {
  global CHECK_RESULT_DIR CHECK_CORE_RESULT_DIR CHECK_OUTPUT

  if {$needs == ""} {
     return 0;
  } 

  set uncomplete 0;

  foreach elem $needs {

    set result_files ""
    set core_result_files ""
    catch { set result_files [glob "$CHECK_RESULT_DIR/$elem.res.*"] }
    catch { set core_result_files [glob "$CHECK_CORE_RESULT_DIR/$elem.res.*"] }

    debug_puts $result_files $core_result_files

    debug_puts " validate_needs: matching files in $CHECK_RESULT_DIR: $result_files"
    debug_puts " validate_needs: matching files in $CHECK_CORE_RESULT_DIR: $core_result_files"

    if {([file isfile [lindex $result_files 0]] != 1) && ([file isfile [lindex $core_result_files 0]] != 1 )} {
       debug_puts " validate_needs: need to run check $elem.";
       incr uncomplete 1; 
    }
  }

  if {$uncomplete == 0} {
    return 0;
  }
  return -1;
}

# delete result in CHECK_RESULT_DIR
#                                                             max. column:     |
#****** check/delete_result() ******
# 
#  NAME
#     delete_result -- ??? 
#
#  SYNOPSIS
#     delete_result { path runtime level } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#     path    - ??? 
#     runtime - ??? 
#     level   - ??? 
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc delete_result {path runtime level} {
  global check_name check_description check_needs check_functions check_errno check_errstr CHECK_RESULT_DIR CHECK_BAD_RESULT_DIR
  global CHECK_CORE_RESULT_DIR CHECK_CORE_BAD_RESULT_DIR CHECK_OUTPUT check_highest_level

  if { [is_level_enabled $level] == -1 } { 
     debug_puts "\n--> delete_result - info: test level $level not activated, aborting\n"
     return   ;# level not enabled
  }

  if { [is_category_enabled $path] == -1 } { 
     debug_puts "\n--> delete_result - info: category not activated, aborting\n"
     return  
  }
  
  

  set good_dir $CHECK_CORE_RESULT_DIR
  set bad_dir $CHECK_CORE_BAD_RESULT_DIR

  if {[string compare $check_name "init_core_system"] != 0} {
    set good_dir $CHECK_RESULT_DIR
    set bad_dir $CHECK_BAD_RESULT_DIR
  }

  debug_puts "saving results for $check_name (level $level)..."
  debug_puts $good_dir
  debug_puts $bad_dir

  set myfile "$good_dir/$check_name.res.$level" 
  if {[file isfile $myfile] == 1} {
    delete_file $myfile
  }

  set data ""

  lappend data $path
  lappend data $check_name;
  lappend data $check_description($level)
 
  lappend data $check_needs



  if { [ info exists check_functions ] } {
     if { [ string length $check_functions ] < 1 } {
        lappend data "{-> no check_function name <-}"
     } else {
        lappend data $check_functions
     } 
  } else {
     lappend data "{-> no check_function name <-}"
  }
  

  lappend data $check_errno
 
  lappend data $check_errstr
  lappend data $runtime
  lappend data [exec date]
  lappend data $check_highest_level

  set output [open "$bad_dir/$check_name.res.$level" "w"]  
  puts $output "$data"
  close $output 
}



# save results in CHECK_RESULT_DIR
#                                                             max. column:     |
#****** check/save_result() ******
# 
#  NAME
#     save_result -- ??? 
#
#  SYNOPSIS
#     save_result { path runtime level } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#     path    - ??? 
#     runtime - ??? 
#     level   - ??? 
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc save_result {path runtime level} {
  global check_name check_description check_needs check_functions check_errno check_errstr CHECK_RESULT_DIR CHECK_BAD_RESULT_DIR
 
  global CHECK_CORE_RESULT_DIR CHECK_CORE_BAD_RESULT_DIR CHECK_OUTPUT check_highest_level

  if { [is_level_enabled $level] == -1 } { 
     puts $CHECK_OUTPUT "\n--> save_result - error: test level $level not activated\n"
     return   ;# level not enabled
  }


  set good_dir $CHECK_CORE_RESULT_DIR
  set bad_dir $CHECK_CORE_BAD_RESULT_DIR

  if {[string compare $check_name "init_core_system"] != 0} {
    set good_dir $CHECK_RESULT_DIR
    set bad_dir $CHECK_BAD_RESULT_DIR
  } 

  puts "saving results for $check_name (level $level) ..."
  puts $good_dir
  puts $bad_dir
  
  set data ""
  lappend data $path
  lappend data $check_name;
  lappend data $check_description($level)
 
  lappend data $check_needs
  lappend data $check_functions
  lappend data $check_errno
 
  lappend data $check_errstr
  lappend data $runtime
  lappend data [exec date]
  lappend data $check_highest_level

  set output [open "$good_dir/$check_name.res.$level" "w"]  
  puts $output "$data"
  close $output

  if {[file isfile "$bad_dir/$check_name.res.$level"] == 1} {
    delete_file "$bad_dir/$check_name.res.$level"
    puts $CHECK_OUTPUT "\nset state of \"$check_name\" for level $level to completed !"
  }

} 

# get_check_name
#                                                             max. column:     |
#****** check/get_check_name() ******
# 
#  NAME
#     get_check_name -- ??? 
#
#  SYNOPSIS
#     get_check_name { path } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#     path - ??? 
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc get_check_name {path} {
   global CHECK_INFORMATION_FILE check_name
   set check_name ""
   source $path/$CHECK_INFORMATION_FILE
  
   return $check_name
}

proc get_check_levels { path } {
   global CHECK_INFORMATION_FILE check_highest_level
   global CHECK_ACT_LEVEL check_highest_level

   set saved_level $CHECK_ACT_LEVEL
   set check_highest_level 0
   set check_init_level_procedure "blub"
   unset check_init_level_procedure

   set levels ""
   source $path/$CHECK_INFORMATION_FILE
   if { $check_highest_level > 0 && [info exists check_init_level_procedure] == 1} {
      for {set i 0} {$i <= $check_highest_level} {incr i 1} {
         set CHECK_ACT_LEVEL $i
         if { [$check_init_level_procedure ]  != 0 } { 
            continue 
         }
         lappend levels $CHECK_ACT_LEVEL
      }
   } else {
      lappend levels 0
   }
   set CHECK_ACT_LEVEL $saved_level
   return $levels
}

# get test result
#                                                             max. column:     |
#****** check/get_test_result() ******
# 
#  NAME
#     get_test_result -- ??? 
#
#  SYNOPSIS
#     get_test_result { filename } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#     filename - ??? 
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc get_test_result {filename} {
   if {[file isfile $filename] != 1} {
      return {"file not found"}
   }
   if {[file readable $filename] != 1} {
      return {"file not readable"}
   }
   set input [open $filename "r"]
   gets $input data
   close $input
   return $data
}

# create report
#                                                             max. column:     |
#****** check/create_report() ******
# 
#  NAME
#     create_report -- ??? 
#
#  SYNOPSIS
#     create_report { file goodbad } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#     file    - ??? 
#     goodbad - ??? 
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc create_report {file goodbad} {
  global CHECK_RESULT_DIR CHECK_BAD_RESULT_DIR CHECK_CORE_RESULT_DIR
  global CHECK_CORE_BAD_RESULT_DIR CHECK_PRODUCT_VERSION_NUMBER CHECK_PRODUCT_ROOT


  set output [open $file "WRONLY APPEND CREAT"]
  puts $output "\n checksystem report"
  puts $output " ==================\n"
  puts $output " Date: [exec date]\n\n"
  puts $output " Version: $CHECK_PRODUCT_VERSION_NUMBER"
  puts $output " Installed in: $CHECK_PRODUCT_ROOT"
  if {$goodbad == 0} { 
     set total1 [ print_results $CHECK_CORE_RESULT_DIR $output ]
     set total2 [ print_results $CHECK_RESULT_DIR $output ]
     puts $output "\nTotal number of test functions: [expr ($total1 + $total2) ]"
  } else {
     print_results $CHECK_CORE_BAD_RESULT_DIR $output
     print_results $CHECK_BAD_RESULT_DIR $output
  }

  flush $output  
  close $output
 
  puts "report was written to $file"
}

# formatted output
#                                                             max. column:     |
#****** check/format_output() ******
# 
#  NAME
#     format_output -- ??? 
#
#  SYNOPSIS
#     format_output { prefix size text } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#     prefix - ??? 
#     size   - ??? 
#     text   - ??? 
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc format_output { prefix size text} {

  if {[string length $text] <= $size } {
     return $text;
  }

  set otext $text
  set buffer ""

  while { 1 == 1 } {
     set buffer "$buffer[string range $otext 0 $size]"
     set otext [string range $otext [expr ($size+1)] [string length $otext] ]
     set buffer "$buffer\n$prefix"
     if {[string length $otext] <= $size} {
        set buffer "$buffer$otext"
        return $buffer
     }
  }

}

# print results
#                                                             max. column:     |
#****** check/print_results() ******
# 
#  NAME
#     print_results -- ??? 
#
#  SYNOPSIS
#     print_results { ckpath where } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#     ckpath - ??? 
#     where  - ??? 
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc print_results {ckpath where} {

   set numb_of_check_functions 0 
   set filenames [get_file_names $ckpath]
   set catch_return [ catch {
      foreach elem $filenames {
         clear_screen
         set data [get_test_result "$ckpath/$elem"]
   
         set path [lindex $data 0]
         set check_name [lindex $data 1]
         set check_descrip [lindex $data 2]
         set check_needs [lindex $data 3]
         set check_functions [lindex $data 4]
         set check_errno [lindex $data 5]
         set check_errstr [lindex $data 6]
         set check_clock [lindex $data 7]
         set check_date  [lindex $data 8]
         set high_level [lindex $data 9]
         set file_level [split $elem "."]
         set file_level [lindex $file_level 2]
   
         set check_description($file_level) $check_descrip
   
         puts $where "############################################################################"
         puts $where "check: $check_name (level $file_level)"
         puts $where "############################################################################"
         puts $where "----------------------------------------------------------------------------"
         puts $where "results:"
      
         set index 0
         puts $where "----------------------------------------------------------------------------"
         puts $where "run time:       [format_output "                " 59 $check_clock]"
         puts $where "----------------------------------------------------------------------------"
         puts $where "date (end):     [format_output "                " 59 $check_date]" 
         puts $where "----------------------------------------------------------------------------"
         set leveltext $check_description($file_level)
         puts $where "description:    [format_output "                " 59 $leveltext]"
         puts $where "----------------------------------------------------------------------------"
         puts $where "dependencies:   [format_output "                " 59 $check_needs]"
         puts $where "----------------------------------------------------------------------------"
         puts $where "functions:      [format_output "                " 59 $check_functions]"
         puts $where "----------------------------------------------------------------------------"
         puts $where "function count: [format_output "                " 59 [llength $check_functions]]"
         puts $where "----------------------------------------------------------------------------"
         puts $where "directory:      [format_output "                " 59 $path]"
         puts $where "----------------------------------------------------------------------------\n"
   
         set numb_of_check_functions [ expr ($numb_of_check_functions + [llength $check_functions]) ]
         if {[string compare $where "stdout" ] == 0 } {
            puts $where "please press RETURN"
            set pressed [wait_for_enter 1]
         }
      }
   } my_error ]
   if { $catch_return != 0 } {
       add_proc_error "print_results" -1 "error creating test report:\n$my_error"
   }
   


   puts $where "\nTotal number of check functions in\n\"$ckpath\":\n$numb_of_check_functions\n"
   return $numb_of_check_functions
}
#                                                             max. column:     |
#****** check/is_level_enabled() ******
# 
#  NAME
#     is_level_enabled -- ??? 
#
#  SYNOPSIS
#     is_level_enabled { level_nr } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#     level_nr - ??? 
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc is_level_enabled { level_nr } {

    global CHECK_GUILTY_RUNLEVELS

    foreach level_start $CHECK_GUILTY_RUNLEVELS {
       set level_end [ expr ( $level_start + 99 ) ]

       if { ( $level_start <= $level_nr ) && ( $level_nr <= $level_end ) } {
          return 0
       }
    }

    return -1
}

proc get_check_category { path } {
   global CHECK_INFORMATION_FILE check_category
   source $path/$CHECK_INFORMATION_FILE
   return $check_category
}

proc is_category_enabled { path } {
   global CHECK_GUILTY_CATEGORIES CHECK_OUTPUT
   set checks_cat [get_check_category $path]

   foreach elem $checks_cat {
      if { [ lsearch $CHECK_GUILTY_CATEGORIES $elem] != -1 } {
         return 0
      }
   }

   return -1
}

# delete tests
#                                                             max. column:     |
#****** check/delete_tests() ******
# 
#  NAME
#     delete_tests -- ??? 
#
#  SYNOPSIS
#     delete_tests { path { only_if_not_there 0 } } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#     path                    - ??? 
#     { only_if_not_there 0 } - ??? 
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc delete_tests {path { only_if_not_there 0 } } {
  global CHECK_DIRECTORIES check_errno check_errstr check_functions validate_needs check_name
  global CHECK_INFORMATION_FILE CHECK_OUTPUT check_highest_level check_name check_description
  global check_init_level_procedure CHECK_ACT_LEVEL CHECK_OUTPUT


  set old_check_name $check_name

  set CHECK_DIRECTORIES ""
  get_check_dirs $path 

  if { [info exists CHECK_DIRECTORIES] == 1 } {
    foreach elem $CHECK_DIRECTORIES {
#       puts "--"
       set check_highest_level 0
       set check_errstr ""
       set check_errno ""
       set check_name ""
       set check_init_level_procedure "--"
       source $elem/$CHECK_INFORMATION_FILE
       set check_errstr ""
       set check_errno ""
       if { [ info exists check_functions ] } {
          foreach element $check_functions {
             lappend check_errstr "was never running" 
             lappend check_errno "-1"
          }
       } else {
          puts $CHECK_OUTPUT "no check_functions variable available!!"
          sleep 5
       }
       debug_puts "sourced \"$elem/$CHECK_INFORMATION_FILE\""

       set do_delete 1
       if {$only_if_not_there == 1 } { 
          set result [ validate_needs $check_name ]
          if { $result == 0 } {
             set do_delete 0
          }
       }

       if {$do_delete == 1} {
          for {set i 0} {$i <= $check_highest_level} {incr i 1} {
             if { [string compare $check_init_level_procedure "--" ] != 0 } { 
                set CHECK_ACT_LEVEL $i
                if { [$check_init_level_procedure ]  == 0 } { 
                   delete_result $elem 0 $i
                } 
             } else {
               delete_result $elem 0 $i
             }
          }
       }

    }
  }
  set check_name $old_check_name
}


#                                                             max. column:     |
#****** check/run_tests() ******
# 
#  NAME
#     run_tests -- ??? 
#
#  SYNOPSIS
#     run_tests { path runcompleted } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#     path         - ??? 
#     runcompleted - ??? 
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc run_tests { path runcompleted } {
    global CHECK_DIRECTORIES CHECK_OUTPUT CHECK_HOST check_errstr CHECK_RESULT_DIR
    global CHECK_MAILS_SENT CHECK_ENABLE_MAIL CHECK_MAX_ERROR_MAILS CHECK_CORE_RESULT_DIR
    global CHECK_CHECKTREE_ROOT CHECK_ACT_PATH check_use_installed_system
    global check_reinit_on_tcl_error CHECK_CORE_MASTER CHECK_PRODUCT_ROOT CHECK_ARCH

    set CHECK_DIRECTORIES ""
    get_check_dirs $path 

    set CHECK_MAILS_SENT 0  ;# clear mail counter

    if { [info exists CHECK_DIRECTORIES] == 1 } {
       
        set checks_to_do ""
        foreach elem $CHECK_DIRECTORIES {
           if { [is_category_enabled $elem ] == 0 } {
               set test_name [get_check_name $elem] 
               set tests_runlevels [get_check_levels $elem]
               foreach tests_runlevel $tests_runlevels {
                  if { ( [file isfile "$CHECK_RESULT_DIR/$test_name.res.$tests_runlevel"] == 1) } {
                     continue
                  }
                  if { ( [file isfile "$CHECK_CORE_RESULT_DIR/$test_name.res.$tests_runlevel"] == 1) } {
                     continue
                  }
                  lappend checks_to_do $elem
                  break
               }
           }
        }
        set checks_to_do [lsort $checks_to_do]
        if {[llength $checks_to_do] == 0} {
           return
        }

        # check if root password is needed
        foreach elem $checks_to_do {
            debug_puts "checking whether test in directory $elem needs root access ..."
            if { ([check_root_access $elem ] == 0) && ([have_root_passwd] == -1 ) } {
                puts $CHECK_OUTPUT "test in directory $elem needs root access ..."
                set_root_passwd
            }
        }

        set stop 0
        set pass_no 1
        set last_to_do -1
        set check_ok_name     ""
        set check_ok_state    "" 
        set check_ok_date     ""
        set check_ok_pass     ""
#        set check_ok_text     ""
        set check_error_name  ""
        set check_error_state ""
        set check_error_date  ""
        set check_error_pass  ""
#        set check_error_text  ""
        set check_missing_dep ""
        set check_warning_name ""
        set check_warning_state ""
        set check_warning_date ""
        set check_warning_pass ""
        set check_missing_dep ""
#        set check_warning_text ""

        while { $stop == 0 } {
           set todo [ llength $checks_to_do ]
           puts $CHECK_OUTPUT "---PASS${pass_no}----------------------------------------"
           puts $CHECK_OUTPUT "   Nr. of tests remaining: $todo"
           puts $CHECK_OUTPUT "------------------------------------------------" 

           # start tests
           foreach check $checks_to_do {
              set test_result [ run_test $check $runcompleted ]

              switch -- $test_result {
                       0 { 
                            # test OK
                            lappend check_ok_name  $check
                            lappend check_ok_state $test_result
                            lappend check_ok_date  [ exec date ]
                            lappend check_ok_pass  $pass_no 
#                            foreach err_message $check_errstr {
#                               lappend check_ok_text("$check") "{$err_message}"
#                            }

                         }
                      -2 { 
                            # dependencies - try again
                            lappend check_missing_dep  $check
                         }
                      -3 {
                            # impossible / unusefull to run this test
                            lappend check_warning_name $check 
                            lappend check_warning_state $test_result
                            lappend check_warning_date [ exec date ]
                            lappend check_warning_pass  $pass_no 
                            foreach err_message $check_errstr {
                               if { [info exists check_warning_text("$check") ] } {
                                  lappend check_warning_text("$check") "{$err_message}"
                               } else {
                                  set check_warning_text("$check") "{$err_message}"
                               }
                            }
                         }
                       1 { 
                            # test was allready done in an earlier run
                            # no action
                            puts $CHECK_OUTPUT "run_tests - check allready done"
                         }
                    -101 {
                            # check failed due to tcl error
                            lappend check_error_name  $check
                            lappend check_error_state $test_result
                            lappend check_error_date  [ exec date ]
                            lappend check_error_pass  $pass_no 
                                    
                            foreach err_message $check_errstr {
                               if { [info exists check_error_text("$check") ] } {
                                  lappend check_error_text("$check") "{$err_message}"
                               } else {
                                  set check_error_text("$check") "{$err_message}"
                               }
                            }
     
                            if { $check_reinit_on_tcl_error == 1 } {
                               # reinit system
                               puts $CHECK_OUTPUT "deleting all jobs"
                               catch {  eval exec "$CHECK_PRODUCT_ROOT/bin/$CHECK_ARCH/qdel" "-uall" } catch_result
                               puts $CHECK_OUTPUT $catch_result
                               wait_for_end_of_all_jobs 60

                               set save_installed_value $check_use_installed_system
                               set save_CHECK_ACT_PATH $CHECK_ACT_PATH
                               set check_use_installed_system 1
                               set CHECK_ACT_PATH "$CHECK_CHECKTREE_ROOT/install_core_system"  
                               close_open_rlogin_sessions  ;# session reset
                               if { [run_test $CHECK_ACT_PATH 1] != 0 } {
                                  set CHECK_ACT_PATH "$CHECK_CHECKTREE_ROOT/install_core_system" 
                                  run_test $CHECK_ACT_PATH 1
                               }
                               set CHECK_ACT_PATH $save_CHECK_ACT_PATH
                               set check_use_installed_system $save_installed_value
                            }
                         }

                 default {
                            # check failed
                            lappend check_error_name  $check
                            lappend check_error_state $test_result
                            lappend check_error_date  [ exec date ]
                            lappend check_error_pass  $pass_no 
                                    
                            foreach err_message $check_errstr {
                               if { [info exists check_error_text("$check") ] } {
                                  lappend check_error_text("$check") "{$err_message}"
                               } else {
                                  set check_error_text("$check") "{$err_message}"
                               }
                            }
                            if { $check_reinit_on_tcl_error == 1 } {
                               # reinit system
                               # reinit system
                               puts $CHECK_OUTPUT "deleting all jobs"
                               catch {  eval exec "$CHECK_PRODUCT_ROOT/bin/$CHECK_ARCH/qdel" "-uall" } catch_result
                               puts $CHECK_OUTPUT $catch_result
                               wait_for_end_of_all_jobs 60

                               set save_installed_value $check_use_installed_system
                               set save_CHECK_ACT_PATH $CHECK_ACT_PATH
                               set check_use_installed_system 1
                               set CHECK_ACT_PATH "$CHECK_CHECKTREE_ROOT/install_core_system"  
                               close_open_rlogin_sessions  ;# session reset
                               if { [run_test $CHECK_ACT_PATH 1] != 0 } {
                                  set CHECK_ACT_PATH "$CHECK_CHECKTREE_ROOT/install_core_system" 
                                  run_test $CHECK_ACT_PATH 1
                               }
                               set CHECK_ACT_PATH $save_CHECK_ACT_PATH
                               set check_use_installed_system $save_installed_value
                           }
                         }
              }
           }
   
           if { [llength $check_missing_dep] > 0 } {
              # missing dependencies , run again
              set checks_to_do $check_missing_dep
              incr pass_no 1
              if { $todo == $last_to_do } {
                 set stop 1
              } else {
                 puts $CHECK_OUTPUT "restarting test with missing dependencies ..."
                 set check_missing_dep ""
              } 
              set last_to_do $todo
           } else {
              # all done
              set stop 1
           } 
        }  ;# while stop == 0

        puts $CHECK_OUTPUT "Number of completed tests     : [llength $check_ok_name]"  
        puts $CHECK_OUTPUT "Number of failed tests        : [llength $check_error_name]"  
        puts $CHECK_OUTPUT "Number of unsupported tests   : [llength $check_warning_name]"
        puts $CHECK_OUTPUT "Number of dependencies errors : [llength $check_missing_dep]"
 

        set mail_body "Testsuite run on host $CHECK_HOST complete\n\n"


        # dependencies errors
        if { [llength $check_missing_dep ] > 0 } { 
           append mail_body "missing dependencies:\n"
           append mail_body "=====================\n\n"
           foreach elem $check_missing_dep {
              append mail_body "check [get_check_name $elem] in directory\n$elem\n" 
           } 
           append mail_body "\n"
        }
        # tests ok

        append mail_body "completed tests:\n"
        append mail_body "================\n\n"
        for {set index 0} {$index < [llength $check_ok_name]} {incr index 1} {
            append mail_body "Date: [ lindex $check_ok_date $index ]\n" 
            append mail_body "Test: [ lindex $check_ok_name $index ]\n"
            append mail_body "Info: Pass[lindex $check_ok_pass $index], State: [lindex $check_ok_state $index]\n\n"
#            foreach err_message $check_ok_text("[ lindex $check_ok_name $index ]") {
#                foreach sm $err_message {
#                   set error_output [ create_error_message $sm ]
#                   puts $CHECK_OUTPUT $error_output 
#                   append mail_body $error_output
#                }
#            }
        }
        set nr_complete [llength $check_ok_name] 
        append mail_body "Number of completed tests: $nr_complete"        

        # tests failed
        append mail_body "\n\nfailed tests:\n"
        append mail_body "=============\n"
        for {set index 0} {$index < [llength $check_error_name]} {incr index 1} {
            append mail_body "Date: [ lindex $check_error_date $index ]\n" 
            append mail_body "Test: [ lindex $check_error_name $index ]\n"
            append mail_body "Info: Pass[lindex $check_error_pass $index], State: [lindex $check_error_state $index]\n\n"
            foreach err_message $check_error_text("[ lindex $check_error_name $index ]") {
                foreach sm $err_message {
                   set error_output [ create_error_message $sm ]
                   append mail_body $error_output
                }
            }
        }
        set nr_failed [llength $check_error_name]
        append mail_body "Number of failed tests: $nr_failed"  

        # test run not usefull (warning)
        append mail_body "\n\nunsupported tests:\n"
        append mail_body "==================\n"
        for {set index 0} {$index < [llength $check_warning_name]} {incr index 1} {
            append mail_body "Date: [ lindex $check_warning_date $index ]\n" 
            append mail_body "Test: [ lindex $check_warning_name $index ]\n"
            append mail_body "Info: Pass[lindex $check_warning_pass $index], State: [lindex $check_warning_state $index]\n\n"
            if { [info exists check_warning_text("[ lindex $check_warning_name $index ]")] } {
               foreach err_message $check_warning_text("[ lindex $check_warning_name $index ]") {
                  foreach sm $err_message {
                     set error_output [ create_error_message $sm ]
                     append mail_body $error_output
                  }
               }
            }
        }
        set nr_unsupported [llength $check_warning_name]
        append mail_body "Number of unsupported tests: $nr_unsupported"  
        if { [llength $check_missing_dep ] > 0 } {
           set mail_subject "testsuite run complete - ok:$nr_complete;failed:$nr_failed;unsup.:$nr_unsupported;depend:[llength $check_missing_dep]"
        } else {
           set mail_subject "testsuite run complete - ok:$nr_complete;failed:$nr_failed;unsup.:$nr_unsupported"
        }
        mail_report "$mail_subject" $mail_body
      
 
    } else {
       puts $CHECK_OUTPUT "check directories not found"
    }

}


#                                                             max. column:     |
#****** check/lock_testsuite() ******
# 
#  NAME
#     lock_testsuite -- ??? 
#
#  SYNOPSIS
#     lock_testsuite { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc lock_testsuite {} {
    global CHECK_TESTSUITE_ROOT CHECK_OUTPUT CHECK_HOST CHECK_USER CHECK_MAIN_RESULTS_DIR
    global CHECK_SCRIPT_FILE_DIR CHECK_TESTSUITE_LOCKFILE

    set pid [getpid]
    
    debug_puts "-> lock_testsuite: pid=$pid host=$CHECK_HOST user=$CHECK_USER"

    set result 0
    set time [ expr ( [timestamp] + 60 ) ] 
    while { $result  != 10 } {
       puts $CHECK_OUTPUT "waiting for lock ..."
       set result [ catch {  
           eval exec "$CHECK_TESTSUITE_ROOT/$CHECK_SCRIPT_FILE_DIR/lock.sh $CHECK_TESTSUITE_LOCKFILE $pid $CHECK_HOST $CHECK_USER"
       } ]
       puts $CHECK_OUTPUT "lock.sh returned $result"
       set file_size 0
       catch { set file_size [file size $CHECK_TESTSUITE_LOCKFILE]}
       if { $file_size == 0 } {
           puts $CHECK_OUTPUT "file size is 0, deleteing lockfile..."
           sleep 60  ;# wait for NFS to update file
           unlock_testsuite
           sleep 60  ;# wait for NFS to update file
           return [ lock_testsuite ]  
       }
       if { $result != 10 } {
          puts $CHECK_OUTPUT "checking lockfile owner process ..."
          set data ""
          catch {
              set input [ open "$CHECK_TESTSUITE_LOCKFILE" "r" ]
              gets $input data 
              close $input
          }
          set owner_pid  [lindex $data 0]
          set owner_host [lindex $data 1]
          set owner_user [lindex $data 2]

          debug_puts "testsuite is locked by user $owner_user, process $owner_pid on host $owner_host!"
          if { ([lindex $data 0] == $pid ) && ([lindex $data 1] == $CHECK_HOST ) && ([lindex $data 2] == $CHECK_USER) } {
              debug_puts "thats me, so we have the lock"
              set result 10
              continue
          }
          debug_puts "checking whether process is still alive ..."
           
          get_ps_info $owner_pid $owner_host
          if { $ps_info($owner_pid,error) == 0 } {
             puts $CHECK_OUTPUT "process exists, command is \n-----\n\"$ps_info($owner_pid,string)\"\n-----"
          } else {
             puts $CHECK_OUTPUT "process doesn't exist -> unlock_testsuite ..." 
             unlock_testsuite 
          }
       }
    }
    debug_puts "new lockfile written! Testing for correct lock ..."

    set time [ expr ( [timestamp] + 60 ) ] 
    set tries 0 
    set ok 0
    set failed 0
    set file_size 0
    while {$ok != 1} {
       sleep 1
       catch { set input [ open $CHECK_TESTSUITE_LOCKFILE "r" ]
               gets $input data 
               close $input } 
 
       debug_puts "pid  [lindex $data 0] == $pid"
       debug_puts "host [lindex $data 1] == $CHECK_HOST"
       debug_puts "user [lindex $data 2] == $CHECK_USER"
 
       if { ([lindex $data 0] == $pid ) && ([lindex $data 1] == $CHECK_HOST ) && ([lindex $data 2] == $CHECK_USER) } {
          incr tries 1
          if {$tries >= 2} {
             set ok 1
          }
       }
       debug_puts "waiting to get lock"

       catch { set file_size [file size $CHECK_TESTSUITE_LOCKFILE]}
       debug_puts "file size is: $file_size"

       if { [timestamp] > $time } {
          set failed 1
          set ok 1
       }      
    }

    if {$failed == 1} {
        puts $CHECK_OUTPUT "no success! Try again ..."
        if { $file_size == 0 } {
           debug_puts "file size is zero, deleteing lockfile..."
           unlock_testsuite
        }
        return [ lock_testsuite ] 
    } 

    debug_puts "lock success!" 

}

#                                                             max. column:     |
#****** check/unlock_testsuite() ******
# 
#  NAME
#     unlock_testsuite -- ??? 
#
#  SYNOPSIS
#     unlock_testsuite { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc unlock_testsuite {} {
    global CHECK_TESTSUITE_ROOT CHECK_OUTPUT CHECK_MAIN_RESULTS_DIR CHECK_TESTSUITE_LOCKFILE

    if {[file isfile $CHECK_TESTSUITE_LOCKFILE] == 1 } {
        puts $CHECK_OUTPUT "removing lockfile \"$CHECK_TESTSUITE_LOCKFILE\"" 

       set catch_return [ catch {exec rm "$CHECK_TESTSUITE_LOCKFILE"} ]
       if { $catch_return != 0 } {
          puts $CHECK_OUTPUT "unlock_testsuite - could not unlock testsuite"
          return
       } 
       while { [ file isfile $CHECK_TESTSUITE_LOCKFILE ] == 1 } {
          puts $CHECK_OUTPUT "file still existing" 
          sleep 1
       }
    }
    puts $CHECK_OUTPUT "testsuite unlocked!" 
}



# run_test_level: returns
# -1 on error, 
# -2 check can not run
#  0 if ok, 
#  1 allready done
#
#                                                             max. column:     |
#****** check/run_test_level() ******
# 
#  NAME
#     run_test_level -- ??? 
#
#  SYNOPSIS
#     run_test_level { path runcompleted level {do_save 1} } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#     path         - ??? 
#     runcompleted - ??? 
#     level        - ??? 
#     {do_save 1}  - ??? 
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc run_test_level {path runcompleted level {do_save 1}} {
   global CHECK_INFORMATION_FILE check_needs CHECK_RESULT_DIR check_name CHECK_ACTUAL_TEST_PATH
   global CHECK_CORE_RESULT_DIR check_errstr CHECK_OUTPUT check_description check_functions check_errno 
   global CHECK_CUR_PROC_NAME CHECK_CUR_PROC_RESULTS CHECK_CUR_PROC_ERRORS
   global CHECK_CURRENT_WORKING_DIR check_init_level_procedure CHECK_ACT_LEVEL
   global set_error_proc_called errorInfo CHECK_CORE_MASTER
   
   # do not run allready completed tests
   debug_puts "runcompleted is $runcompleted"
   if { $runcompleted == 0 } {
     if { ( [file isfile "$CHECK_RESULT_DIR/$check_name.res.$level"] == 1) } {
        return 1 
     }
     if { ( [file isfile "$CHECK_CORE_RESULT_DIR/$check_name.res.$level"] == 1) } {
        return 1 
     }
   }  


   # get lock  
   delete_temp_script_files
   lock_testsuite

 
   set CHECK_ACT_LEVEL $level
   puts $CHECK_OUTPUT "starting test functions (runlevel is $CHECK_ACT_LEVEL)..."
 
   # call init_check_level procedure!
   if {[info exists check_init_level_procedure] == 1 } {
       if {[ string compare $check_init_level_procedure "--"] != 0 } {
          puts $CHECK_OUTPUT "\ncalling init level function \"$check_init_level_procedure\" ..."
          $check_init_level_procedure
       }
   }

 
   # call all check functions 
   set check_errno "-1"
   set check_errstr "was never running"
   set start_time [clock seconds]
   set was_error 0
   set was_unsupported 0
   set complete_errstr ""
   set complete_errno ""

   if { [ string compare $check_name "init_core_system" ] != 0 } {
      if { [is_scheduler_alive $CHECK_CORE_MASTER [get_qmaster_spool_dir]] != 1 } {
         add_proc_error "run_test_level" -1 "scheduler is not alive"
      }
   }

   if { [info exists check_functions] == 1 } {
      foreach elem $check_functions {
         
         puts $CHECK_OUTPUT "\n>>>>>>>>>>>>>>>>>>>>>>"
         puts $CHECK_OUTPUT "$elem"    
         puts $CHECK_OUTPUT "runlevel: [get_run_level_name $level]($level)"
         puts $CHECK_OUTPUT ">>>>>>>>>>>>>>>>>>>>>>"

         set check_errno "-1"
         set check_errstr "was never running"
         set was_empty 0
 
         # set public procedure error state to "no error"
         set check_cur_proc_result "0"
         set check_cur_proc_error "ok"
         set CHECK_CUR_PROC_ERRORS ""
         set CHECK_CUR_PROC_RESULTS "" 
         set CHECK_CUR_PROC_NAME $elem
         set set_error_proc_called 0  

         

         # this starts the test procedure
         set catch_return [ catch { $elem } errMsg ]
         if { $catch_return != 0 } {
            puts $CHECK_OUTPUT $errMsg
            add_proc_error "run_test_level" "-2" "catch returns not 0\n${errMsg}\n${errorInfo}" 
            set_error -2 "tcl error"
         } 
         
         # examine public procedure error states
         set myindex 0
         set procedure_error_text ""
         set procedure_errno ""
         foreach element $CHECK_CUR_PROC_RESULTS {
            if { $element != 0 } {
               # we got an error: append it to the check_xxx lists
               lappend procedure_error_text [lindex $CHECK_CUR_PROC_ERRORS $myindex]
               lappend procedure_errno $element 
            }
            incr myindex 1
         }        

         if { $set_error_proc_called == 0 } {
             lappend procedure_error_text "{$elem|no \"set_error\" call on procedure return|$check_name|run_test_level}"
             lappend procedure_errno "-1"
             set was_empty 1
         }



 
         # flush output file
         flush $CHECK_OUTPUT  
      
         set stop 0 
         if { [ llength $procedure_errno ] == 0 } {
            lappend procedure_error_text "{$elem|$check_errstr|$check_name|run_test_level}"
            lappend procedure_errno $check_errno
            set was_empty 1
         }
         set cur_check_errno [ lindex $procedure_errno [ expr ( [ llength $procedure_errno] - 1 ) ] ]
         debug_puts "cur_check_errno = \"$cur_check_errno\""
         set cur_check_err_text  [ lindex $procedure_error_text [ expr ( [ llength $procedure_error_text] - 1 ) ] ]


         if {$cur_check_errno != 0} {
            incr was_error 1

            debug_puts "DEBUG: cur_errno = $cur_check_errno"           
 
            if { $was_empty == 1  } { 
               show_proc_error $cur_check_errno $cur_check_err_text
            }

            if {$cur_check_errno == -2 } {    ;# hard error dedected run no more test functions
              set stop 1   ;# stop with this test or not ?
            }

            if {$cur_check_errno == -3 } {    ;# test not possible for this host (no error)
              set was_unsupported 1
              incr was_error -1

#              set myindex 0
#              foreach element $procedure_errno {
#                 if { $element != 0 } {
#                    lappend complete_errstr [lindex $procedure_error_text $myindex]
#                    lappend complete_errno  $element
#                 }
#                 incr myindex 1
#              }
#              set check_errstr $complete_errstr
#              set check_errno $complete_errno
              puts $CHECK_OUTPUT "U N S U P P O R T E D   test \"$check_name\" in run level $level, procedure $elem !"
#              set end_time [clock seconds]
#              if { $do_save == 1 } {  
#                  delete_result $path [expr ($end_time - $start_time)] $level
#              }
#              unlock_testsuite
#              return -2


            }
         } else {
            debug_puts "status: $check_errstr"
         }

         set myindex 0
         foreach element $procedure_errno {
            if { $element != 0 } {
               lappend complete_errstr [lindex $procedure_error_text $myindex]
               lappend complete_errno  $element
            }
            incr myindex 1
         }
         if {$stop == 1} {
           break;
         }

      } 
      
      if { [llength $check_functions] == 0 } {   
         set no_func_error "{none|check_functions list has length 0 ( level: $level)|$check_name|run_test_level}"
         lappend complete_errstr "$no_func_error"
         lappend complete_errno -1
         show_proc_error -1 "$no_func_error"
         set was_error 1
      }

      
      if { $catch_return != 0 } {
         set check_errstr $complete_errstr
         set check_errno $complete_errno
         puts $CHECK_OUTPUT "T C L   E R R O R   running test \"$check_name\" in run level $level !"
         set end_time [clock seconds]
         unlock_testsuite
         return -101 
      }

      if { $was_unsupported == 1 && $was_error == 0 } {
         set check_errstr $complete_errstr
         set check_errno $complete_errno
         puts $CHECK_OUTPUT "U N S U P P O R T E D   test \"$check_name\" in run level $level !"
         set end_time [clock seconds]
         if { $do_save == 1 } {  
             save_result $path [expr ($end_time - $start_time)] $level
         }
         unlock_testsuite
         return -2
      }


      if {$was_error == 0} {
         set check_errstr $complete_errstr
         set check_errno $complete_errno
         puts $CHECK_OUTPUT "S U C C E S S F U L L Y performed \"$check_name\" in run level $level !"
         set end_time [clock seconds]
         if { $do_save == 1 } {      
            save_result $path [expr ($end_time - $start_time)] $level
         }
         unlock_testsuite
         return 0
      } 
   } else {
     set no_func_error "{none|check_functions variable not found (level: $level)|$check_name|run_test_level}"
     lappend complete_errstr "$no_func_error"
     lappend complete_errno -1
     show_proc_error -1 "$no_func_error"

   }
 
   # check function does not exist or had an error
   
   set check_errstr $complete_errstr
   set check_errno $complete_errno


   set end_time [clock seconds]
   if { $do_save == 1 } {   
      delete_result $path [expr ($end_time - $start_time)] $level
   }
   puts $CHECK_OUTPUT "\ncheck \"$check_name\" F A I L E D  in run level $level !"
   unlock_testsuite
   return -1
}


#                                                             max. column:     |
#****** check/check_root_access() ******
# 
#  NAME
#     check_root_access -- ??? 
#
#  SYNOPSIS
#     check_root_access { path } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#     path - ??? 
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc check_root_access {path} {

  global check_root_access_needs CHECK_INFORMATION_FILE

  set check_root_access_needs ""  
  source $path/$CHECK_INFORMATION_FILE

  if { [string compare "" $check_root_access_needs ] != 0 } {
     return 0
  } 

  return -1
}

proc delete_temp_script_files { } {
  global CHECK_TESTSUITE_ROOT CHECK_OUTPUT

  set del_file_name "$CHECK_TESTSUITE_ROOT/.testsuite_delete"
  if { [ file isfile $del_file_name ] == 1 } {
     set del_file [ open $del_file_name "r" ]
     while { [gets $del_file line] >= 0 } {
        if { [ file isfile $line ] == 1 } {
           file delete $line
        }
     }
     close $del_file
     file delete $del_file_name     
  } 
}
# run test
#                                                             max. column:     |
#****** check/run_test() ******
# 
#  NAME
#     run_test -- ??? 
#
#  SYNOPSIS
#     run_test { path runcompleted {run_single_test "all"} } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#     path                    - ??? 
#     runcompleted            - ??? 
#     {run_single_test "all"} - ??? 
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc run_test {path runcompleted {run_single_test "all"} { send_mail_report 1 } } {
  

  global CHECK_INFORMATION_FILE check_needs CHECK_RESULT_DIR check_name CHECK_ACTUAL_TEST_PATH
  global CHECK_CORE_RESULT_DIR check_errstr CHECK_OUTPUT check_description check_functions check_errno 
  global CHECK_CUR_PROC_NAME CHECK_CUR_PROC_RESULTS CHECK_CUR_PROC_ERRORS check_root_access_needs
  global CHECK_CURRENT_WORKING_DIR check_highest_level check_init_level_procedure CHECK_ACT_LEVEL
  global CHECK_PRODUCT_TYPE CHECK_PRODUCT_VERSION_NUMBER CHECK_PRODUCT_ROOT CHECK_TESTSUITE_ROOT
  global CHECK_PRODUCT_FEATURE check_category CHECK_GROUP

  cd $CHECK_CURRENT_WORKING_DIR

  set do_only_one_test 0

  set CHECK_ACTUAL_TEST_PATH $path

  set check_name          ""
  set check_category      ""
  set check_needs         ""
  set check_functions     ""
  set check_highest_level 0
  set check_init_level_procedure "--"
  set check_root_access_needs   "" 
  source_procedures 
  source $path/$CHECK_INFORMATION_FILE
  if { [string compare $run_single_test "all"] != 0 } {
     set do_only_one_test 1
     puts $CHECK_OUTPUT "running only test \"$run_single_test\""
     set check_functions "$run_single_test"
  }

  if { ( [string compare "" $check_root_access_needs] != 0) && ([have_root_passwd] == -1 ) } {
     set_root_passwd
  }

  # first check the dependencies
  
  puts $CHECK_OUTPUT ">>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>"
  puts $CHECK_OUTPUT ">>> $check_name"
  puts $CHECK_OUTPUT ">>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>"
  debug_puts "file: $path/check.exp"


  set result [validate_needs $check_needs]

  debug_puts "needs returned $result"
  debug_puts "highest level of test is $check_highest_level"

  if { $result != 0 } {
     puts $CHECK_OUTPUT "dependencies ($check_needs) not fulfilled! Stop!"
     set check_errstr ""
     set check_errno ""
     foreach elem $check_functions {
        lappend check_errstr "{run_test|dependencies not fulfilled!|$check_name|run_test}"
        lappend check_errno "-1"
     }

     for {set level 0} {$level <= $check_highest_level} {incr level 1} {
       if { [string compare $check_init_level_procedure "--" ] != 0 } { 
         set CHECK_ACT_LEVEL $level
         if { [$check_init_level_procedure ]  == 0 } { 
            delete_result $path 0 $level 
         }
       } else { 
         delete_result $path 0 $level
       }
     }
     return -2  ;# dependencies not fulfilled
  }

  set nr_errors 0
  set nr_warnings 0
  set nr_allready_done 0
  set nr_new_done 0
  set my_current_runlevel 0
  set do_send_mail 0
  set no_level_calls 0 


  for {set level 0} { $level <= $check_highest_level} {incr level 1} {

     if {[is_level_enabled $level] == -1 } {
        continue
     } 
     set my_current_runlevel $level
     if { [string compare $check_init_level_procedure "--" ] != 0 } { 
         set CHECK_ACT_LEVEL $level
         if { [$check_init_level_procedure ]  != 0 } { 
            continue 
         }
     }
     puts $CHECK_OUTPUT "\n----------------------------------------------"
     puts $CHECK_OUTPUT "-> enter check level $level"

     if { $do_only_one_test == 0 } {
        set back [run_test_level $path $runcompleted $level]
        debug_puts "level $level return value: $back"
        incr no_level_calls 1
     } else {
        set back [run_test_level $path $runcompleted $level 0 ]
        debug_puts "level $level return value of test $run_single_test: $back"
        incr no_level_calls 1
     }

     if { [string first "unknown" $CHECK_GROUP] >= 0 } {
         add_proc_error "run_test" -1 "CHECK_GROUP set to unknown, test was $path in level $level"
     }

     if {$back == -101  } { 
        incr nr_errors 1
        debug_puts "--> TCL ERROR in check $path in level $level <--"
        return -101
     }
     if {$back == -1} {
        incr nr_errors 1     ;# we had an error
        debug_puts "--> ERROR in check $path in level $level <--"
        return -1
     }
     if {$back == -2} {
        incr nr_warnings 1     ;# check can not run
        debug_puts "--> check $path in level $level: can't start test <--"
        
#        return -3
     }
     if {$back == 0} {
        set do_send_mail 1  ;# a successfull test run
        incr nr_new_done 1
        debug_puts "no errors"
     } 

     if {$back == 1} {
        debug_puts "check allready done"
        incr nr_allready_done 1
     }
     debug_puts "calls=$no_level_calls, allready done=$nr_allready_done"
  }

#  if { $nr_warnings != 0 } {
#     return -3 ;# warning
#  }

  if { $nr_allready_done == $no_level_calls } {
     return 1  ;# was done time before
  }
  
  if { $send_mail_report != 1 } {
     set do_send_mail 0
  }

  if { $nr_errors == 0 && $nr_warnings == 0 } {
     if { $do_send_mail == 1 } {
        set mail_body "Successfully performed check $check_name in directory\n$path\n"
        set mail_body "${mail_body}Date: [ exec date ]\n\n"
        set mail_body "${mail_body}product type:     $CHECK_PRODUCT_TYPE\n"
        set mail_body "${mail_body}product feature:  $CHECK_PRODUCT_FEATURE\n"
        set mail_body "${mail_body}product version:  $CHECK_PRODUCT_VERSION_NUMBER\n"
        set mail_body "${mail_body}product root:     $CHECK_PRODUCT_ROOT\n"
        set mail_body "${mail_body}runlevel:         [get_run_level_name $my_current_runlevel]\n"
        set mail_body "${mail_body}max. runlevel:    [get_run_level_name $check_highest_level]\n"
        set mail_body "${mail_body}dependencies:     $check_needs\n"
        set mail_body "${mail_body}check functions:  \n"
        foreach elem $check_functions {
           set mail_body "${mail_body}                   $elem\n"
        } 
        set mail_body "${mail_body}init level proc:  $check_init_level_procedure\n"
        mail_report "testsuite success - $check_name" $mail_body
     }
     return 0
  } else {
     if { $nr_errors == 0 } {
        return -3 ;# we had warnings
     }
     return -1
  }
}

#                                                             max. column:     |
#****** check/clean_up_globals() ******
# 
#  NAME
#     clean_up_globals -- ??? 
#
#  SYNOPSIS
#     clean_up_globals { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc clean_up_globals {} {
  global check_init_level_procedure check_name check_description check_highest_level
  global check_needs check_functions check_errno check_errstr check_category
 
  if { [ info exists check_category ] } {
     unset check_category 
  }

  if { [ info exists check_description] } {
     unset check_description 
  }


  set check_name        ""                 ;# name of actual check module 
  set check_needs       ""          ;# dependencies of this check (name of other check)
  set check_functions   ""          ;# functions to call (in order)
  set check_init_level_procedure "--"   ;# name of procedure to call before starting level run
  set check_errno      -1          ;# 0 -> OK , != 0 means error (-2 = break test , -1 failure )
  set check_errstr       ""          ;# short error description in text form  
  set check_highest_level 0        ;# here a check can define his check levels count 0 ... 
}

# show test description
#                                                             max. column:     |
#****** check/show_test() ******
# 
#  NAME
#     show_test -- ??? 
#
#  SYNOPSIS
#     show_test { path full } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#     path - ??? 
#     full - ??? 
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc show_test {path full} {
  global CHECK_INFORMATION_FILE check_errno check_needs check_highest_level 
  global check_init_level_procedure CHECK_ACT_LEVEL check_category

  clean_up_globals  
  source $path/$CHECK_INFORMATION_FILE
  puts "===============================================================================" 
  puts "name:         | $check_name"
  puts -nonewline "categories:   | "
  foreach cat $check_category {
     puts -nonewline "$cat "
  }
  puts ""
  puts "===============================================================================" 

  if { $full == 1} {
    puts "filename:     | [ format_output "              | " 61 $path/$CHECK_INFORMATION_FILE ]"

    puts "===============================================================================" 
    for {set i 0} {$i <= $check_highest_level} {incr i 1} {
       set blank ""
       if { $i <= 99} {
         set blank " "
       }
       if { $i <= 9 } {
         set blank "  "
       } 

       set do_print 0
       if { [string compare $check_init_level_procedure "--" ] != 0 } { 
          set CHECK_ACT_LEVEL $i
          if { [$check_init_level_procedure ]  == 0 } { 
             set do_print 1
          } 
       } else {
          set do_print 1
       }
       if { $do_print == 1 } { 
          puts "run level ${blank}$i |"
          puts "description:  | [ format_output "              | " 61 $check_description($i)]"
          puts "==============================================================================="
       }
      

    }

    puts "dependencies: |"
    foreach element $check_needs {
      puts "              | [ format_output "              | " 61 $element]"
    }
    puts "==============================================================================="
  }
}

#                                                             max. column:     |
#****** check/select_runlevel() ******
# 
#  NAME
#     select_runlevel -- ??? 
#
#  SYNOPSIS
#     select_runlevel { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc select_runlevel {} {
     global CHECK_GUILTY_RUNLEVELS CHECK_GUILTY_CATEGORIES CHECK_CHECKTREE_ROOT

     set data ""
     set my_cats [get_categories $CHECK_CHECKTREE_ROOT]

     while { $data != 0 } {
       
        clear_screen
        print_menu_header
        set selected_levels ""
        foreach elem $CHECK_GUILTY_RUNLEVELS {
           set a_level [ get_run_level_name $elem ] 
  
           if { [string first $a_level $selected_levels ] < 0 } {
              set selected_levels "$selected_levels $a_level"
           } 
        }

        puts "\nplease select/unselect new runlevels/categories: \n"
        puts "(0) return to previous menu\n"

        puts "runlevels:\n"
        puts "(1) short  (   0 min - 15 min / run level   0 -  99 )"
        puts "(2) medium (  16 min -  1 h   / run level 100 - 199 )"
        puts "(3) long   (   1 h   -  4 h   / run level 200 - 299 )"
        puts "(4) day    ( > 4 h   - 24 h   / run level 300 - 399 )"
        puts "(5) week   ( >24 h            / run level 400 - 499 )\n"
        puts "categories:\n"
        set numbs 6
        foreach elem $my_cats {
           puts "($numbs) $elem"
           incr numbs 1
        }

        set data [wait_for_enter 1]
        if { $data <= 5 && $data > 0 } {
           incr data -1
           set in 0
           if { $data <= 4 && $data >= 0 } {
              foreach x $CHECK_GUILTY_RUNLEVELS {
                 if { $x == [ expr ( $data * 100 ) ] } {
                    set in 1
                 }      
              }
           }
   
           if { $data <= 4 && $data >= 0 } {
             if {$in == 0} {
               lappend CHECK_GUILTY_RUNLEVELS [ expr ( $data * 100 )] 
             } else {
               set new_guilty_runlevels ""
               foreach x $CHECK_GUILTY_RUNLEVELS {
                  if { $x != [ expr ( $data * 100 ) ] } { 
                     lappend new_guilty_runlevels $x
                  }
               }
               set CHECK_GUILTY_RUNLEVELS $new_guilty_runlevels
             } 
           }
           incr data 1
        } else {
           # categories
           set max_number [llength $my_cats]
           incr max_number 5
           if { $data > $max_number || $data <= 5  } {
              continue
           }   
           set my_cat [ expr ( $data - 6 ) ]   
           set new_cat [ lindex $my_cats $my_cat ]
           set cat_pos [ lsearch $CHECK_GUILTY_CATEGORIES  $new_cat ]
           if { $cat_pos != -1 } {
              set CHECK_GUILTY_CATEGORIES [ lreplace $CHECK_GUILTY_CATEGORIES $cat_pos $cat_pos ]
           } else {
              lappend CHECK_GUILTY_CATEGORIES $new_cat
           }
        }
     } 
}
proc check_display {} {
     global CHECK_DISPLAY_OUTPUT CHECK_CORE_MASTER CHECK_USER 

     if { [ string compare $CHECK_DISPLAY_OUTPUT "undefined" ] == 0 } {
        puts "no debug x display set"
        return -1
     } 
     start_remote_prog "$CHECK_CORE_MASTER" "$CHECK_USER" "/usr/openwin/bin/xterm" "-bg darkolivegreen -fg navajowhite -sl 5000 -sb -j -display $CHECK_DISPLAY_OUTPUT -e sleep 1"
     if { $prg_exit_state != 0 } {
         puts "can't open display $CHECK_DISPLAY_OUTPUT as user $CHECK_USER from host $CHECK_CORE_MASTER"    
         return -1
     }

     if { [ have_root_passwd ] != 0 } {
         set_root_passwd
     }
     start_remote_prog "$CHECK_CORE_MASTER" "root" "/usr/openwin/bin/xterm" "-bg darkolivegreen -fg navajowhite -sl 5000 -sb -j -display $CHECK_DISPLAY_OUTPUT -e sleep 1"
     if { $prg_exit_state != 0 } {
         puts "can't open display $CHECK_DISPLAY_OUTPUT as user root from host $CHECK_CORE_MASTER"    
         return -1
     }
     return 0
}


proc set_command_line_options {} {
     global CHECK_GUILTY_RUNLEVELS CHECK_GUILTY_CATEGORIES CHECK_CHECKTREE_ROOT 
     global CHECK_SGE_DEBUG_LEVEL
     global master_debug schedd_debug do_not_update CHECK_DISPLAY_OUTPUT daemon_debug
     set data ""
     while { $data != 0 } {
        clear_screen
        print_menu_header
        puts "\nplease select/unselect command line options: \n"
        puts "(0) return to previous menu\n"

        puts "options:\n"


        if { $master_debug == 0 } {
           set md_flag "off"
        } else {
           set md_flag "on"
        }
        if { $schedd_debug == 0 } {
           set sd_flag "off"
        } else {
           set sd_flag "on"
        }
        if { $do_not_update == 0 } {
           set nu_flag "off"
        } else {
           set nu_flag "on"
        }


        puts "(1) master_debug    : $md_flag"
        puts "(2) schedd_debug    : $sd_flag"
        puts "(3) SGE_DEBUG_LEVEL : $CHECK_SGE_DEBUG_LEVEL"
        puts "(4) no_update       : $nu_flag"

        set data [wait_for_enter 1]
        if { $data <= 2 && $data > 0 } {
        }
        switch $data {
           "1" { 
              puts "master_debug" 
              if { $master_debug == 0 } {
                 set result [check_display]
                 if { $result != 0 } {
                    puts "current display \"$CHECK_DISPLAY_OUTPUT\" does not work,\nplease enter correct display: "
                    set CHECK_DISPLAY_OUTPUT [wait_for_enter 1]
                    set result [check_display]
                    if { $result != 0 } { 
                       puts "still errors"
                       wait_for_enter
                       continue
                    }
                 }
                 set master_debug 1
              } else {
                 set master_debug 0
              }
           }
           "2" {
              puts "schedd_debug" 
              if { $schedd_debug == 0 } {
                 set result [check_display]
                 if { $result != 0 } {
                    puts "current display \"$CHECK_DISPLAY_OUTPUT\" does not work,\nplease enter correct display: "
                    set CHECK_DISPLAY_OUTPUT [wait_for_enter 1]
                    set result [check_display]
                    if { $result != 0 } { 
                       puts "still errors"
                       wait_for_enter
                       continue
                    }
                 }
                 set schedd_debug 1
              } else {
                 set schedd_debug 0
              }
           }
           "3" {
               puts "enter new SGE_DEBUG_LEVEL: "
               set CHECK_SGE_DEBUG_LEVEL [wait_for_enter 1]
           }
           "4" {
               if { $do_not_update == 0 } {
                  set do_not_update 1
               } else { 
                  set do_not_update 0
               }
           }
        }

        if { $schedd_debug == 0 && $master_debug == 0 } {
           set daemon_debug 1
        } else {
           set daemon_debug 0
        }
     } 
}

#                                                             max. column:     |
#****** check/get_max_level_count() ******
# 
#  NAME
#     get_max_level_count -- ??? 
#
#  SYNOPSIS
#     get_max_level_count { path } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#     path - ??? 
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc get_max_level_count {path} {
  global CHECK_DIRECTORIES CHECK_INFORMATION_FILE check_highest_level 
  global CHECK_MAX_LEVEL check_init_level_procedure CHECK_ACT_LEVEL check_name
 
  set old_check_name $check_name

  set CHECK_DIRECTORIES ""
  set CHECK_MAX_LEVEL "0"
  get_check_dirs $path  
  if { [info exists CHECK_DIRECTORIES] == 1 } {
    foreach elem $CHECK_DIRECTORIES {
       
       if { [file isfile $elem/$CHECK_INFORMATION_FILE] == 1 } {
          set check_highest_level 0 
          set check_init_level_procedure "--"
          source $elem/$CHECK_INFORMATION_FILE
          if { [string compare $check_init_level_procedure "--" ] != 0 } {
             for {set x 0 } {$x <= $check_highest_level} {incr x 1 } {
                set CHECK_ACT_LEVEL $x
                if { [$check_init_level_procedure ]  == 0 } {
                   if { [lsearch $CHECK_MAX_LEVEL $x] < 0 } {
                      lappend CHECK_MAX_LEVEL $x
                   }
                }
             } 
          }
       }
    }  
  }
  set check_name $old_check_name
  return $CHECK_MAX_LEVEL
}

proc get_categories {path} {
  global CHECK_DIRECTORIES CHECK_INFORMATION_FILE check_highest_level 
  global CHECK_MAX_LEVEL check_init_level_procedure CHECK_ACT_LEVEL
  global check_category
 
  set CHECK_DIRECTORIES ""
  set CHECK_MAX_LEVEL "0"
  set back ""
  get_check_dirs $path  
  if { [info exists CHECK_DIRECTORIES] == 1 } {
    foreach elem $CHECK_DIRECTORIES {
       if { [file isfile $elem/$CHECK_INFORMATION_FILE] == 1 } {
          clean_up_globals
          source $elem/$CHECK_INFORMATION_FILE
          if { [info exists check_category] } {
             foreach elem $check_category {
                if { [ lsearch -exact $back $elem ] == -1 } {
                   lappend back $elem
                }
             }
          }
       }
    }  
  }
  set back [lsort $back]
  return $back
}




# show test descriptons (of all subtests)
#                                                             max. column:     |
#****** check/show_tests() ******
# 
#  NAME
#     show_tests -- ??? 
#
#  SYNOPSIS
#     show_tests { path full } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#     path - ??? 
#     full - ??? 
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc show_tests {path full} {
  global CHECK_DIRECTORIES

  set CHECK_DIRECTORIES ""
  get_check_dirs $path 

  if { [info exists CHECK_DIRECTORIES] == 1 } {
    foreach elem $CHECK_DIRECTORIES {
      clear_screen
      show_test $elem $full
      wait_for_enter
    }  
  }
}

# change directory
#                                                             max. column:     |
#****** check/change_dir() ******
# 
#  NAME
#     change_dir -- ??? 
#
#  SYNOPSIS
#     change_dir { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc change_dir { } {
  global CHECK_ACT_PATH CHECK_CHECKTREE_ROOT 

  print_menu_header

  set dirs [ get_dir_names $CHECK_ACT_PATH ]

  set count 1 

  if {[string compare $CHECK_ACT_PATH $CHECK_CHECKTREE_ROOT] != 0 } {
    puts "($count) - up"
    incr count 1
  }
  puts "($count) - stay"
  incr count 1
  foreach elem $dirs {
     puts "($count) - go to \"$elem\""
     set newdir($count) $elem
     incr count 1
  }

  set input [wait_for_enter 1] 
  
  if { ($input == 1) && ([string compare $CHECK_ACT_PATH $CHECK_CHECKTREE_ROOT] != 0)}  {
     puts "go to upper dir ..."
     set test [split $CHECK_ACT_PATH "/\/"] 
     set CHECK_ACT_PATH [lrange $test 0 [expr [llength $test] - 2] ]
     set CHECK_ACT_PATH [ join $CHECK_ACT_PATH "/"]  
     return
  }

  if { [info exists newdir($input)] == 1 } {
     puts "go to dir $newdir($input) ..."
     set CHECK_ACT_PATH "$CHECK_ACT_PATH/$newdir($input)"
     return
  }
}


#                                                             max. column:     |
#****** check/get_run_level_name() ******
# 
#  NAME
#     get_run_level_name -- ??? 
#
#  SYNOPSIS
#     get_run_level_name { level } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#     level - ??? 
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc get_run_level_name { level } {
  
  if { $level >= 400 } {
     return "week"
  }

  if { $level >= 300 } {
     return "day"
  }

  if { $level >= 200 } {
     return "long"
  }

  if { $level >= 100 } {
     return "medium"
  }

  if { $level >= 00 } {
     return "short"
  }
  return ""
}
# time in minutes
proc get_run_level_time { level } {
  
  if { $level >= 400 } {
     return [expr (48 * 60)]
  }

  if { $level >= 300 } {
     return [expr (14 * 60)]
  }

  if { $level >= 200 } {
     return [expr (2 * 60)]
  }

  if { $level >= 100 } {
     return 30
  }

  if { $level >= 00 } {
     return 10
  }
  return 0
}


#                                                             max. column:     |
#****** check/clear_screen() ******
# 
#  NAME
#     clear_screen -- ??? 
#
#  SYNOPSIS
#     clear_screen { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc clear_screen {} {
 
  set clear_sequence [ format "%c%c%c%c%c%c%c" 0x1b 0x5b 0x48 0x1b 0x5b 0x32 0x4a 0x00 ]
  puts -nonewline $clear_sequence
}

#                                                             max. column:     |
#****** check/print_menu_header() ******
# 
#  NAME
#     print_menu_header -- ??? 
#
#  SYNOPSIS
#     print_menu_header { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc print_menu_header {} {
  global CHECK_ACT_PATH CHECK_DIRECTORIES CHECK_INFORMATION_FILE CHECK_RESULT_DIR 
  global CHECK_USER CHECK_REPORT_FILE CHECK_OUTPUT CHECK_HOST CHECK_BAD_RESULT_DIR 
  global CHECK_CORE_RESULT_DIR CHECK_CORE_BAD_RESULT_DIR CHECK_MAIN_RESULTS_DIR 
  global CHECK_GUILTY_RUNLEVELS CHECK_MAX_LEVEL CHECK_PRODUCT_VERSION_NUMBER
  global CHECK_PRODUCT_FEATURE CHECK_GUILTY_CATEGORIES CHECK_USER CHECK_GROUP

  clear_screen
  set_users_environment $CHECK_HOST env 1
  get_version_info
  puts "===============================================================================" 

  puts " system version     :  $CHECK_PRODUCT_VERSION_NUMBER ([resolve_version])"
  puts " feature            :  $CHECK_PRODUCT_FEATURE"
  puts " current dir        :  [ format_output "                       " 54 $CHECK_ACT_PATH ]"
#  puts " user group         :  $CHECK_GROUP"
#  puts " user name          :  $CHECK_USER"
  set dirs [ get_dir_names $CHECK_ACT_PATH ]
  set files [get_file_names $CHECK_ACT_PATH ]
  if { [ llength $dirs ] == 0 } {
     lappend dirs "."
  }
  set test_counts ""
  set test_text ""
  set time_count 0
  foreach elem $dirs {
     set test_name ""
     set CHECK_DIRECTORIES ""
     get_check_dirs "$CHECK_ACT_PATH/$elem"
     set count 0
     foreach test $CHECK_DIRECTORIES {
        if { [is_category_enabled $test] == 0 } {
           set run_test_ok 0
           set tests_runlevels [get_check_levels $test]
            
           foreach tests_runlevel $tests_runlevels {
              if { [ is_level_enabled $tests_runlevel ] == 0 } {
                 set test_name [get_check_name $test]
                 if { ( [file isfile "$CHECK_RESULT_DIR/$test_name.res.$tests_runlevel"] == 1) } {
                    continue
                 }
                 if { ( [file isfile "$CHECK_CORE_RESULT_DIR/$test_name.res.$tests_runlevel"] == 1) } {
                    continue
                 }
                 set run_test_ok 1
                 incr time_count [get_run_level_time $tests_runlevel] 
              }
           }
           if { $run_test_ok == 1 } {
              incr count 1  
           }
        }
     }
     if { $count > 9 } {
        set blank " "
     } else {
        set blank "  "
     }
     lappend test_counts "$count"
     if { ${elem} == "." } {
        lappend test_text   " test name: $test_name"
     } else {
        lappend test_text   "${blank}${count} test(s) available in subdir: ${elem}"
     }
  }
  set test_count 0
  foreach elem $test_counts {
     incr test_count $elem 
  }

  get_max_level_count $CHECK_ACT_PATH
  set possible_levels ""

  foreach elem $CHECK_MAX_LEVEL {
     set a_level [ get_run_level_name $elem ] 
     if { [string first $a_level $possible_levels ] < 0 } {
        set possible_levels "$possible_levels $a_level"
     } 
  }
  set possible_levels [lsort $possible_levels]
  puts " max. runlevel      :  $possible_levels"  

  set selected_levels ""
  set CHECK_GUILTY_RUNLEVELS [ lsort $CHECK_GUILTY_RUNLEVELS  ]
  foreach elem $CHECK_GUILTY_RUNLEVELS {
     set a_level [ get_run_level_name $elem ] 

     if { [string first $a_level $selected_levels ] < 0 } {
        set selected_levels "$selected_levels $a_level"
     } 
  } 

  set selected_levels [ lsort $selected_levels ]
  puts " selected runlevels :  $selected_levels"
  set my_cats [get_categories $CHECK_ACT_PATH]
  puts -nonewline " categories         :  "
  foreach elem $my_cats {
     puts -nonewline "$elem "
  }
  puts ""

  puts -nonewline " selected categories:  "
  set CHECK_GUILTY_CATEGORIES [ lsort $CHECK_GUILTY_CATEGORIES]
  foreach elem $CHECK_GUILTY_CATEGORIES {
     puts -nonewline "$elem "
  }
  puts ""
  set hours [ expr ( $time_count / 60 ) ]
  set minutes [ expr (  $time_count % 60 ) ]
  puts " est. run time      :  $hours h $minutes m"
  puts "===============================================================================" 
  foreach elem $test_text {
     puts $elem
  }
#  puts "===============================================================================" 
#  set blank "  "
#  if { $test_count > 9 } {
#     set blank " "
#  }  
#  puts "${blank}$test_count test(s) available in current subdirs"
  puts "===============================================================================" 
  return $files
}

#                                                             max. column:     |
#****** check/wait_for_enter() ******
# 
#  NAME
#     wait_for_enter -- ??? 
#
#  SYNOPSIS
#     wait_for_enter { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc wait_for_enter { {no_text 0} } {
   global CHECK_OUTPUT CHECK_TESTSUITE_ROOT CHECK_SCRIPT_FILE_DIR
   flush $CHECK_OUTPUT

   if { $no_text == 0 } {
      puts "\npress enter..."
   }
   set output ""
   set en_result [ catch {
      set output [eval exec "$CHECK_TESTSUITE_ROOT/$CHECK_SCRIPT_FILE_DIR/wait_for_enter.sh"]
   } catch_output ]
   return [string trim $output]
}

#                                                             max. column:     |
#****** check/wait_for_start_time() ******
# 
#  NAME
#     wait_for_start_time -- ??? 
#
#  SYNOPSIS
#     wait_for_start_time { substring } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#     substring - ??? 
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc wait_for_start_time { substring } {
   puts "wait for start time: \"$substring\""
   while { 1 } {
      set date_output [ exec date "+%D %H:%M" ]
      puts -nonewline "\r$date_output"
      flush stdout
      if { [string compare $date_output $substring] == 0 } {
         break; 
      }
      sleep 30
   }
   puts ""
}

# returns -1: error
# returns 0 : no error
proc prepare_packages { } {

   global CHECK_PACKAGE_DIRECTORY CHECK_OUTPUT CHECK_DEFAULTS_FILE
   global CHECK_PRODUCT_ROOT CHECK_JOB_OUTPUT_DIR CHECK_HOST CHECK_PACKAGE_TYPE
   global CHECK_USER CHECK_PRODUCT_TYPE CHECK_CORE_EXECD CHECK_PROTOCOL_DIR
   global CHECK_GROUP check_name CHECK_CUR_PROC_NAME

   set check_name "prepare_packages"
   set CHECK_CUR_PROC_NAME "prepare_packages"


   #do pre checks like in compile
   if {[file isdirectory "$CHECK_PROTOCOL_DIR"] != 1} {
      set catch_return [ catch {  file mkdir "$CHECK_PROTOCOL_DIR" } ]
      if { $catch_return != 0 } {
           puts $CHECK_OUTPUT "could not create directory \"$CHECK_PROTOCOL_DIR\""
           return -1
      } 
   }

   set have_tar 0
   set have_zip 0
   if { [ check_packages_directory $CHECK_PACKAGE_DIRECTORY check_tar ] == 0 } {
      puts $CHECK_OUTPUT "found tar files"
      set have_tar 1
   }

   if { [ check_packages_directory $CHECK_PACKAGE_DIRECTORY check_zip ] == 0 } {
      puts $CHECK_OUTPUT "found zip files"
      set have_zip 1
   }

   if { $have_tar == 0 && $CHECK_PACKAGE_TYPE == "tar" } {
      add_proc_error "prepare_packages" -1 "not all tar files available"
      return -1
   }

   if { $have_zip == 0 && $CHECK_PACKAGE_TYPE == "zip" } {
      add_proc_error "prepare_packages" -1 "not all zip files available"
      return -1
   }


   if { $have_tar == 1 && $CHECK_PACKAGE_TYPE == "tar" } {

      # shutdown eventually running system
      shutdown_core_system

      set tar_files [ check_packages_directory $CHECK_PACKAGE_DIRECTORY check_both tar ]

      set restore_host_aliases_file 0
      # copy pos. host_aliases file 
      if { [ file isfile "$CHECK_PRODUCT_ROOT/default/common/host_aliases"] == 1 } {
         puts $CHECK_OUTPUT "saving host_aliases file ..."
         set restore_host_aliases_file 1
         catch { exec "cp" "$CHECK_PRODUCT_ROOT/default/common/host_aliases" "$CHECK_JOB_OUTPUT_DIR/host_aliases"  } result
         puts $result
      } 
      # now delete install directory
      puts $CHECK_OUTPUT "moving directory \"$CHECK_PRODUCT_ROOT\" to testsuite_trash"
      if { [delete_directory "$CHECK_PRODUCT_ROOT"] != 0 } {
         add_proc_error "prepare_packages" -2 "could not delete $CHECK_PRODUCT_ROOT directory, critical error - stop"
         return -1
      }
      # checking permissions
      catch { exec "mkdir" "$CHECK_PRODUCT_ROOT"  } result
      puts $result
      catch { exec "chmod" "755" "$CHECK_PRODUCT_ROOT"  } result
      puts $result

      catch { file mkdir "$CHECK_PRODUCT_ROOT/default" } 
      catch { file mkdir "$CHECK_PRODUCT_ROOT/default/common" } 

      # copy pos. host_aliases file to new product root /default/common
      if { [ file isfile "$CHECK_JOB_OUTPUT_DIR/host_aliases"] == 1 && 
           $restore_host_aliases_file == 1 } {
         puts $CHECK_OUTPUT "restoring host_aliases file ..."
         catch { exec "cp" "$CHECK_JOB_OUTPUT_DIR/host_aliases" "$CHECK_PRODUCT_ROOT/default/common/host_aliases" } result
         puts $result
      }

      # copy package files to product root directory
      puts $CHECK_OUTPUT "copy package files to product root directory ..."
      set i 0
      foreach file $tar_files { 
         puts -nonewline $CHECK_OUTPUT [washing_machine $i]
         flush $CHECK_OUTPUT
         incr i 1
         file copy $CHECK_PACKAGE_DIRECTORY/$file $CHECK_PRODUCT_ROOT
      } 
      puts $CHECK_OUTPUT ""

      # gunzip package files
      puts $CHECK_OUTPUT "gunzip package files ..."
      set i 0
      foreach file $tar_files { 
         puts -nonewline $CHECK_OUTPUT [washing_machine $i]
         flush $CHECK_OUTPUT
         incr i 1
         set catch_out [catch { exec "gunzip" "$CHECK_PRODUCT_ROOT/$file"  } result]
         if { $catch_out != 0 } {
            puts $CHECK_OUTPUT $result
         }
      } 
      puts $CHECK_OUTPUT ""

      # extract package files
      puts $CHECK_OUTPUT "extract package files ..."
      set i 0
      foreach file $tar_files { 
         puts -nonewline $CHECK_OUTPUT [washing_machine $i]
         flush $CHECK_OUTPUT
         incr i 1
         set help [ string first ".gz" $file ]
         incr help -1
         set file_no_gz [string range $file 0 $help]
         set result [ start_remote_prog $CHECK_HOST $CHECK_USER "cd" "$CHECK_PRODUCT_ROOT ; tar -xvf $CHECK_PRODUCT_ROOT/$file_no_gz" ]
         if { $prg_exit_state != 0 } {
            puts $CHECK_OUTPUT $result
         }
      } 
      puts $CHECK_OUTPUT ""
     
      # delete untared package files
      puts $CHECK_OUTPUT "delete untared package files ..."
      foreach file $tar_files { 
         set help [ string first ".gz" $file ]
         incr help -1
         set file_no_gz [string range $file 0 $help]
         delete_file $CHECK_PRODUCT_ROOT/$file_no_gz
      } 
      puts $CHECK_OUTPUT ""

      # checking for correct system 
      set sys_info "unkown"
      if { [ file isfile $CHECK_PRODUCT_ROOT/inst_sge ] } {
         set sys_info "sge"
      }
      if { [ file isfile $CHECK_PRODUCT_ROOT/inst_sgeee ] } {
         set sys_info "sgeee"
      }

      puts $CHECK_OUTPUT "system       : $sys_info"      

      # checking for installed archs
      set sys_archs [get_dir_names $CHECK_PRODUCT_ROOT/utilbin ]
      
      set local_host_arch [ resolve_arch $CHECK_HOST ]
      set local_arch_ok 0
      puts -nonewline $CHECK_OUTPUT "architectures:"
     
      foreach arch $sys_archs {
         puts -nonewline $CHECK_OUTPUT " $arch"
         if { [ string compare $arch $local_host_arch ] == 0 } {
            set local_arch_ok 1
         }
      }
      puts $CHECK_OUTPUT ""
      
      # check for testsuite host binaries
      if { $local_arch_ok != 1 } {
         add_proc_error "prepare_packages" -1 "host architecture for host $CHECK_HOST not installed"
         return -1
      }

      # check if settings file is correct for the system
      if { $CHECK_PRODUCT_TYPE != $sys_info } {
         add_proc_error "prepare_packages" -1 "setup entry for product_type is \"$CHECK_PRODUCT_TYPE\", but system is \"$sys_info\""
         return -1
      }

      # check all archs to appear in execd host list and vice versa
      set execd_archs ""
      foreach elem $CHECK_CORE_EXECD {
         set host_arch [ resolve_arch $elem ]
         if { [string compare $host_arch "unkown" ] == 0 } {
            add_proc_error "prepare_packages" -1 "could not resolve host \"$elem\"!"
            return -1
         }
         lappend execd_archs $host_arch
         set found_arch 0
         foreach sarch $sys_archs {
            if { [ string compare $sarch $host_arch] == 0 } {
               set found_arch 1
            }
         }
         if { $found_arch != 1 } {
            add_proc_error "prepare_packages" -1 "binaries for host \"$elem\" not in tar files, please add tar file"
            return -1
         }
      }

      foreach elem $sys_archs {
         set found_arch 0
         foreach execd $execd_archs {
            if { [ string compare $elem $execd] == 0 } {
               set found_arch 1
            }
         }
         if { $found_arch != 1 } {
            add_proc_error "prepare_packages" -1 "found no host for tar architecture \"$elem\""
            return -1
         }
      } 

      # try to resolve hostnames in settings file
      set catch_return [ catch { eval exec "cp ${CHECK_DEFAULTS_FILE} ${CHECK_DEFAULTS_FILE}.[timestamp]" } ]
      if { $catch_return != 0 } { 
         puts "could not copy defaults file"
         return -1
      }
      return 0
   }

   if { $have_zip == 1 && $CHECK_PACKAGE_TYPE == "zip" } {

      # shutdown eventually running system
      shutdown_core_system

      set zip_files [ check_packages_directory $CHECK_PACKAGE_DIRECTORY check_both zip ]

      set restore_host_aliases_file 0
      # copy pos. host_aliases file 
      if { [ file isfile "$CHECK_PRODUCT_ROOT/default/common/host_aliases"] == 1 } {
         puts $CHECK_OUTPUT "saving host_aliases file ..."
         set restore_host_aliases_file 1
         catch { exec "cp" "$CHECK_PRODUCT_ROOT/default/common/host_aliases" "$CHECK_JOB_OUTPUT_DIR/host_aliases"  } result
         puts $result
      } 
      # now delete install directory
      puts $CHECK_OUTPUT "moving directory \"$CHECK_PRODUCT_ROOT\" to testsuite_trash"
      if { [delete_directory "$CHECK_PRODUCT_ROOT"] != 0 } {
         add_proc_error "prepare_packages" -2 "could not delete $CHECK_PRODUCT_ROOT directory, critical error - stop"
         return -1
      }
      # checking permissions
      catch { exec "mkdir" "$CHECK_PRODUCT_ROOT"  } result
      puts $result
      catch { exec "chmod" "755" "$CHECK_PRODUCT_ROOT"  } result
      puts $result

      catch { file mkdir "$CHECK_PRODUCT_ROOT/default" } 
      catch { file mkdir "$CHECK_PRODUCT_ROOT/default/common" } 

      # copy pos. host_aliases file to new product root /default/common
      if { [ file isfile "$CHECK_JOB_OUTPUT_DIR/host_aliases"] == 1 && 
           $restore_host_aliases_file == 1 } {
         puts $CHECK_OUTPUT "restoring host_aliases file ..."
         catch { exec "cp" "$CHECK_JOB_OUTPUT_DIR/host_aliases" "$CHECK_PRODUCT_ROOT/default/common/host_aliases" } result
         puts $result
      }

      # copy package files to product root directory
      puts $CHECK_OUTPUT "copy package files to product root directory ..."
      set i 0
      if { [catch { file mkdir "$CHECK_PRODUCT_ROOT/tmp_zip_copy" }] != 0 } {
         puts $CHECK_OUTPUT "could not create directory \"$CHECK_PRODUCT_ROOT/tmp_zip_copy\""
         return -1    
      }
      foreach file $zip_files { 
         puts -nonewline $CHECK_OUTPUT [washing_machine $i]
         flush $CHECK_OUTPUT
         incr i 1
         file copy $CHECK_PACKAGE_DIRECTORY/$file $CHECK_PRODUCT_ROOT/tmp_zip_copy
      } 
      puts $CHECK_OUTPUT ""

      
      # unzip package files
      puts $CHECK_OUTPUT "unzip package files ..."
      set i 0
      foreach file $zip_files { 
         puts -nonewline $CHECK_OUTPUT [washing_machine $i]
         flush $CHECK_OUTPUT
         incr i 1
         set catch_out [catch { exec "unzip" "$CHECK_PRODUCT_ROOT/tmp_zip_copy/$file" "-d" "$CHECK_PRODUCT_ROOT/tmp_zip_copy"  } result]
         if { $catch_out != 0 } {
            puts $CHECK_OUTPUT $result
         }
      } 
      puts $CHECK_OUTPUT ""

      # delete untared package files
      puts $CHECK_OUTPUT "delete untared package files ..."
      foreach file $zip_files { 
         delete_file $CHECK_PRODUCT_ROOT/tmp_zip_copy/$file
      } 
      puts $CHECK_OUTPUT ""


      # now check if packages are allready installed and remove installed ones
      set package_names [ get_dir_names $CHECK_PRODUCT_ROOT/tmp_zip_copy ]
      puts -nonewline $CHECK_OUTPUT "Found following packages:"
      foreach pkg $package_names {
         puts -nonewline $CHECK_OUTPUT " $pkg" 
      }
      puts $CHECK_OUTPUT "\n"
      set user_key "unknown"
      foreach pkg $package_names {
         puts -nonewline $CHECK_OUTPUT "Checking if package \"$pkg\" is allready installed on host \"$CHECK_HOST\" ... "
         set output [ start_remote_prog $CHECK_HOST "root" "pkginfo" "$pkg" ]
         if { $prg_exit_state != 0 } {
            puts $CHECK_OUTPUT "not installed"
         } else {
            puts $CHECK_OUTPUT "allready installed."
            puts $CHECK_OUTPUT "\n$output\n"
            puts $CHECK_OUTPUT "Press \"yes\" to uninstall ALL packages listed above or \"no\" to continue ..."
            if { $user_key == "unknown" } {
               set user_key [ wait_for_enter 1 ]
            }
            if { $user_key == "yes" } {
               puts $CHECK_OUTPUT "removing package \"$pkg\" ..."
               set output [ start_remote_prog $CHECK_HOST "root" "pkgrm" "-n $pkg" ]
               puts $CHECK_OUTPUT $output
               if { $prg_exit_state != 0 } {
                  puts $CHECK_OUTPUT "error uninstalling package \"$pkg\""
                   puts $CHECK_OUTPUT "stop package installation"
                   return -1
               }
            } else {
               puts $CHECK_OUTPUT "will NOT remove package \"\""
               puts $CHECK_OUTPUT "stop package installation"
               return -1
            }
         }
      }
      
      # now install the packages ...
      set send_speed .1
      set send_slow "1 $send_speed"
      foreach pkg $package_names {
         set id [open_remote_spawn_process "$CHECK_HOST" "root" "pkgadd" "-d $CHECK_PRODUCT_ROOT/tmp_zip_copy $pkg" ]
         log_user 1
         set sp_id [ lindex $id 1 ]
         set timeout 60
         set do_stop 0
         set exit_state 1
         while { $do_stop == 0 } {
            flush $CHECK_OUTPUT
            expect {
               -i $sp_id full_buffer { 
                  add_proc_error "prepare_packages" -1 "buffer overflow please increment CHECK_EXPECT_MATCH_MAX_BUFFER value"
                  close_spawn_process $id
                  return -1
               }
               -i $sp_id timeout {
                  add_proc_error "prepare_packages" -1 "unexpected timeout"
                  close_spawn_process $id
                  return -1
               } 
               -i $sp_id eof {
                  set exit_state [close_spawn_process $id]
                  set do_stop 1
               } 
               -i $sp_id "_exit_status_:*\n" {
                  set buf $expect_out(buffer)
                  set s_start [ string first "(" $buf ]
                  set s_end [ string first ")" $buf ]
                  incr s_start 1
                  incr s_end -1
                  set exit_state [ string range $buf $s_start $s_end ]
                  puts $CHECK_OUTPUT "exit state is: \"$exit_state\""
                  close_spawn_process $id
                  set do_stop 1
               }
               -i $sp_id "default /gridware/sge*]" {
                  flush $CHECK_OUTPUT
                  if { [ string length $CHECK_PRODUCT_ROOT ] >= 5  } {
                     send -s -i $sp_id "$CHECK_PRODUCT_ROOT\n"
                  } else {
                     add_proc_error "prepare_packages" -1 "can't use product root directory (shorter than 5 chars)"
                     close_spawn_process $id
                     return -1
                  }
                  flush $CHECK_OUTPUT
               } 
               -i $sp_id "default sgeadmin*]" {
                  flush $CHECK_OUTPUT
                  send -s -i $sp_id "$CHECK_USER\n"   
                  flush $CHECK_OUTPUT
               } 
               -i $sp_id "Do you want to install these as setuid/setgid files*]" {
                  flush $CHECK_OUTPUT
                  send -s -i $sp_id "y\n"   
                  flush $CHECK_OUTPUT
               }


               -i $sp_id "default adm*]" {
                  send -s -i $sp_id "$CHECK_GROUP\n"
                  flush $CHECK_OUTPUT
               } 
               -i $sp_id "Waiting for pkgadd of*" {
                  add_proc_error "prepare_packages" -1 "$CHECK_HOST: another pkgadd session is running...\n$expect_out(buffer)"
                  close_spawn_process $id
                  return -1
               }
               -i $sp_id "*\n" { 
                  flush $CHECK_OUTPUT
               } 
               -i $sp_id default {
                  add_proc_error "prepare_packages" -1 "undefined behaviour: $expect_out(buffer)"
                  close_spawn_process $id
                  return -1
               } 
            }
         }
         if { $exit_state != 0 } {
            add_proc_error "prepare_packages" -1 "exit state of pgkadd \"$pkg\" is $exit_state -> error"
            return -1
         }
      }
           



      # checking for correct system 
      set sys_info "unkown"
      if { [ file isfile $CHECK_PRODUCT_ROOT/inst_sge ] } {
         set sys_info "sge"
      }
      if { [ file isfile $CHECK_PRODUCT_ROOT/inst_sgeee ] } {
         set sys_info "sgeee"
      }

      puts $CHECK_OUTPUT "system       : $sys_info"      

      # checking for installed archs
      set sys_archs [get_dir_names $CHECK_PRODUCT_ROOT/utilbin ]
      
      set local_host_arch [ resolve_arch $CHECK_HOST ]
      set local_arch_ok 0
      puts -nonewline $CHECK_OUTPUT "architectures:"
     
      foreach arch $sys_archs {
         puts -nonewline $CHECK_OUTPUT " $arch"
         if { [ string compare $arch $local_host_arch ] == 0 } {
            set local_arch_ok 1
         }
      }
      puts $CHECK_OUTPUT ""
      
      # check for testsuite host binaries
      if { $local_arch_ok != 1 } {
         add_proc_error "prepare_packages" -1 "host architecture for host $CHECK_HOST not installed"
         return -1
      }

      # check if settings file is correct for the system
      if { $CHECK_PRODUCT_TYPE != $sys_info } {
         add_proc_error "prepare_packages" -1 "setup entry for product_type is \"$CHECK_PRODUCT_TYPE\", but system is \"$sys_info\""
         return -1
      }

      # check all archs to appear in execd host list and vice versa
      set execd_archs ""
      foreach elem $CHECK_CORE_EXECD {
         set host_arch [ resolve_arch $elem ]
         if { [string compare $host_arch "unkown" ] == 0 } {
            add_proc_error "prepare_packages" -1 "could not resolve host \"$elem\"!"
            return -1
         }
         lappend execd_archs $host_arch
         set found_arch 0
         foreach sarch $sys_archs {
            if { [ string compare $sarch $host_arch] == 0 } {
               set found_arch 1
            }
         }
         if { $found_arch != 1 } {
            add_proc_error "prepare_packages" -1 "binaries for host \"$elem\" not in zip files, please add zip file"
            return -1
         }
      }

      foreach elem $sys_archs {
         set found_arch 0
         foreach execd $execd_archs {
            if { [ string compare $elem $execd] == 0 } {
               set found_arch 1
            }
         }
         if { $found_arch != 1 } {
            add_proc_error "prepare_packages" -1 "found no host for zip architecture \"$elem\""
            return -1
         }
      } 

      # try to resolve hostnames in settings file
      set catch_return [ catch { eval exec "cp ${CHECK_DEFAULTS_FILE} ${CHECK_DEFAULTS_FILE}.[timestamp]" } ]
      if { $catch_return != 0 } { 
         puts "could not copy defaults file"
         return -1
      }
      return 0
   }

   return -1
}
# mode : check_both, check_tar, check_zip
# get_files : no, tar, zip
proc check_packages_directory { path { mode "check_both" } { get_files "no" } } {

   global CHECK_OUTPUT CHECK_PACKAGE_TYPE

   set tar_bin_files [ get_file_names $path "sge*-bin-*.tar.gz" ] 
   set zip_bin_files [ get_file_names $path "sge*-bin-*.zip" ]      
   set tar_common_files [ get_file_names $path "sge*-common*.tar.gz" ] 
   set zip_common_files [ get_file_names $path "sge*-common*.zip" ]   
   set tar_doc_files [ get_file_names $path "sge*-doc*.tar.gz" ] 
   set zip_doc_files [ get_file_names $path "sge*-doc*.zip" ]    

   set tar_list "$tar_bin_files $tar_common_files $tar_doc_files"
   set zip_list "$zip_bin_files $zip_common_files $zip_doc_files"
     

   set nr_tar_bin_files [ llength $tar_bin_files ]
   set nr_zip_bin_files [ llength $zip_bin_files ] 
   set nr_tar_common_files [ llength $tar_common_files ]
   set nr_zip_common_files [ llength $zip_common_files ] 
   set nr_tar_doc_files [ llength $tar_doc_files ]
   set nr_zip_doc_files [ llength $zip_doc_files ] 

   set tar_complete 0
   set zip_complete 0

   if { $tar_bin_files  > 0 && $tar_common_files > 0 && $tar_doc_files > 0 } {
      set tar_complete 1
   }
   if { $zip_bin_files  > 0 && $zip_common_files > 0 && $zip_doc_files > 0 } {
      set zip_complete 1
   }

   if { $get_files == "no" } {
      puts $CHECK_OUTPUT "nr. of binary tar files: $nr_tar_bin_files"
      puts $CHECK_OUTPUT "nr. of binary zip files: $nr_zip_bin_files"
      puts $CHECK_OUTPUT "nr. of common tar files: $nr_tar_common_files"
      puts $CHECK_OUTPUT "nr. of common zip files: $nr_zip_common_files"
      puts $CHECK_OUTPUT "nr. of doc tar files: $nr_tar_doc_files"
      puts $CHECK_OUTPUT "nr. of doc zip files: $nr_zip_doc_files"
      if { $tar_complete == 1 } {
         puts $CHECK_OUTPUT "tar files complete"
      } else {
         puts $CHECK_OUTPUT "tar files INCOMPLETE"
      }
      if { $zip_complete == 1 } {
         puts $CHECK_OUTPUT "zip files complete"
      } else {
         puts $CHECK_OUTPUT "zip files INCOMPLETE"
      }
      
      if { $tar_complete == 1 && $zip_complete == 1 && $mode == "check_both" } {
         return 0
      }
      if { $tar_complete == 1 && $mode == "check_tar" } {
         return 0
      }
      if { $zip_complete == 1 && $mode == "check_zip" } {
         return 0
      }
      return -1
   } else {
      switch -- $get_files {
         "tar" {
             if { $tar_complete == 0 } {
                add_proc_error "check_packages_directory" -1 "tar files incomplete error"
                return ""
             }
             return $tar_list
         }
         "zip" {
             if { $tar_complete == 0 } {
                add_proc_error "check_packages_directory" -1 "zip files incomplete error"
                return ""
             }
             return $zip_list
         } 
      }
   }
   return -1
}
#
#                                                             max. column:     |
#
#****** check/compile_source() ******
#  NAME
#     compile_source() -- ??? 
#
#  SYNOPSIS
#     compile_source { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
#
proc compile_source { { do_only_install 0 } } {

   global CHECK_SOURCE_DIR CHECK_OUTPUT CHECK_SOURCE_HOSTNAME CHECK_SOURCE_COMPILE_HOSTS
   global CHECK_TESTSUITE_ROOT CHECK_SCRIPT_FILE_DIR CHECK_PRODUCT_TYPE CHECK_PRODUCT_ROOT
   global CHECK_PRODUCT_FEATURE CHECK_ADDITIONAL_COMPILE_HOSTS
   global CHECK_DEFAULTS_FILE CHECK_SOURCE_CVS_RELEASE do_not_update check_name
   global CHECK_AIMK_COMPILE_OPTIONS CHECK_DIST_INSTALL_OPTIONS CHECK_JOB_OUTPUT_DIR
   global CHECK_PACKAGE_DIRECTORY CHECK_PACKAGE_DIRECTORY CHECK_PACKAGE_TYPE
   global CHECK_CORE_EXECD CHECK_PROTOCOL_DIR CHECK_PRODUCT_FEATURE CHECK_USER


   set check_name "compile_source"
   set CHECK_CUR_PROC_NAME "compile_source"
   set mail_subject "testsuite error - compile_source"
   set mail_body    "date: [exec date]\n"


   set html_body [ create_html_text "date: [exec date]" 1 ]
   append html_body [ create_html_text "compiling ..." 1 ]
   update_compile_html_output $html_body
   set html_body [ create_html_text "date: [exec date]" 1 ]

 
   set was_error 0
   set cvs_change_log ""

   foreach host $CHECK_ADDITIONAL_COMPILE_HOSTS {
      if { [ lsearch -exact $CHECK_SOURCE_COMPILE_HOSTS $host ] < 0 } {
         lappend CHECK_SOURCE_COMPILE_HOSTS $host
         puts $CHECK_OUTPUT "adding additional compile host $host"
      }
   }

   if { $CHECK_PACKAGE_DIRECTORY != "none" } {
       puts $CHECK_OUTPUT "can not compile -> using product packages"
       puts $CHECK_OUTPUT "edit settings file and set package_directory to \"none\" if comilation should be possible"
       mail_report $mail_subject "$mail_body can not compile -> using product packages\nedit settings file and set package_directory to \"none\"" 
       append html_body [ create_html_text "can not compile -> using product packages\nedit settings file and set package_directory to \"none\"" ]
       update_compile_html_output $html_body
       return -1
   }


   if { ( [ string compare $CHECK_SOURCE_DIR "unknown" ] == 0 ) || ( [ string compare $CHECK_SOURCE_DIR "" ] == 0 ) } {
       puts $CHECK_OUTPUT "source directory unknown - check defaults file"
       mail_report $mail_subject "$mail_body source directory unknown - check defaults file" 
       append html_body [ create_html_text "source directory unknown - check defaults file" ]
       update_compile_html_output $html_body
       return -1
   }
   if { ( [ string compare $CHECK_SOURCE_HOSTNAME "unknown" ] == 0 ) || ( [ string compare $CHECK_SOURCE_HOSTNAME "" ] == 0  ) } {
       puts $CHECK_OUTPUT "host for cvs checkout unknown - check defaults file"
       mail_report $mail_subject "$mail_body host for cvs checkout unknown - check defaults file"
       append html_body [ create_html_text "host for cvs checkout unknown - check defaults file" ]
       update_compile_html_output $html_body
       return -1
   }
   if { ( [ string compare $CHECK_SOURCE_COMPILE_HOSTS "unknown" ] == 0 ) || ([ string compare $CHECK_SOURCE_COMPILE_HOSTS "" ] == 0) } {
       puts $CHECK_OUTPUT "host list to compile for unknown - check defaults file"
       mail_report $mail_subject "$mail_body host list to compile for unknown - check defaults file"
       append html_body [ create_html_text "host list to compile for unknown - check defaults file" ]
       update_compile_html_output $html_body
       return -1
   }

   set compile_arch_list ""
   foreach chost $CHECK_SOURCE_COMPILE_HOSTS {
      puts $CHECK_OUTPUT "\n-> checking architecture for host $chost ..."
      set output [ start_remote_prog $chost $CHECK_USER "cd" "$CHECK_SOURCE_DIR ; ./aimk -no-mk" prg_exit_state 60 0 "" 1 0 ]
      puts $CHECK_OUTPUT "return state: $prg_exit_state"
      if { $prg_exit_state != 0 } {
         puts $CHECK_OUTPUT "error starting \"aimk -no-mk\" on host $chost"
         append html_body [ create_html_text "error starting \"aimk -no-mk\" on host $chost" ]
         update_compile_html_output $html_body
         return -1
      }
      puts $CHECK_OUTPUT "output:\n$output"
      lappend compile_arch_list $output
   }

   foreach elem $compile_arch_list {
     set found 0
     set hostarch ""
     foreach host $compile_arch_list {
        if { [ string compare $host $elem ] == 0 }  {
           incr found 1
           set hostarch $host
        }
     }
     if { $found != 1 } {
        puts $CHECK_OUTPUT "two compile hosts have the same architecture -> error"
        append html_body [ create_html_text "two compile hosts have the same architecture -> error" ]
        update_compile_html_output $html_body
        return -1
     }
   }

   if {[file isdirectory "$CHECK_PROTOCOL_DIR"] != 1} {
      set catch_return [ catch {  file mkdir "$CHECK_PROTOCOL_DIR" } ]
      if { $catch_return != 0 } {
           puts $CHECK_OUTPUT "could not create directory \"$CHECK_PROTOCOL_DIR\""
           append html_body [ create_html_text "could not create directory \"$CHECK_PROTOCOL_DIR\"" ]
           update_compile_html_output $html_body
           return -1
      } 
   }


   # shutdown eventually running system
   shutdown_core_system


   if { $do_only_install != 1 } {

   # update source 
   if { $do_not_update == 0 } {

      set tries 1

      set output ""
      set update_ok 0
      while { $tries <= 3 && $update_ok == 0 } {
         puts $CHECK_OUTPUT "------------------------------------------"
         puts $CHECK_OUTPUT "$tries. cvs update try ..."
         puts $CHECK_OUTPUT "updating gridengine directory $CHECK_SOURCE_DIR/.. on host $CHECK_SOURCE_HOSTNAME ..."
         append output [ start_remote_prog $CHECK_SOURCE_HOSTNAME $CHECK_USER "cd" "$CHECK_SOURCE_DIR/.. ; cvs -z 9 update -dP" ]
         append output "\n"
         if { $prg_exit_state != 0 } {
            set update_ok 0
            sleep 60
         } else {
            set update_ok 1
         }
         incr tries 1
      }
      if { $update_ok != 1 } {
         add_proc_error "compile_source" -2 "cvs update -dP error:\n$output" 
         append html_body [ create_html_text "cvs update -dP error:\n$output" ]
         update_compile_html_output $html_body
         return -1
      }

      puts $CHECK_OUTPUT "------------------------------------------"
      set cvs_output [ open "$CHECK_SOURCE_DIR/cvs_update.log.[timestamp]" "w" ]
      puts $cvs_output $output
      close $cvs_output
      set update_output [split $output "\n"] 
      set frame_work_script_update 0
      set testsuite_update 0
      foreach elem $update_output {
         if { ([string range $elem 0 2 ] != "cvs") && ([string range $elem 0 0] != "?") } {
            puts $CHECK_OUTPUT $elem
            append cvs_change_log "$elem\n"
            if { [ string first "testsuite/check.exp" $elem ] >= 0 && [string range $elem 0 0] != "M" } {
               set frame_work_script_update 1
            }
            if { [ string first "testsuite/tcl_files" $elem ] >= 0 && [string range $elem 0 0] != "M" } {
               set testsuite_update 1
            }
         } 
      }
      if { $frame_work_script_update == 1 } {
         puts $CHECK_OUTPUT "TESTSUITE FRAMEWORK SCRIPT was updated!!! Stop !!!"
         flush $CHECK_OUTPUT
         mail_report $mail_subject "$mail_body TESTSUITE FRAMEWORK SCRIPT was updated!!! Stop !!!" 
         append html_body [ create_html_text "TESTSUITE FRAMEWORK SCRIPT was updated!!! Stop !!!" ]
         exit 1 
      }
      if { $testsuite_update == 1 } {
         puts $CHECK_OUTPUT "testsuite source procedures were updated!!! resourcing it !!!"
         source_procedures
      }
      puts $CHECK_OUTPUT "------------------------------------------"

      foreach chost $CHECK_SOURCE_COMPILE_HOSTS {
         puts $CHECK_OUTPUT "------------------------------------------"
         puts $CHECK_OUTPUT "-> starting aimk clean on host $chost ..."
         set output [ start_remote_prog $chost $CHECK_USER "cd" "$CHECK_SOURCE_DIR ; ./aimk clean" prg_exit_state 60 0 "" 1 0 ]
         puts $CHECK_OUTPUT "------------------------------------------"
         puts $CHECK_OUTPUT "return state: $prg_exit_state"
         puts $CHECK_OUTPUT "------------------------------------------"
         puts $CHECK_OUTPUT "output:\n$output"
         puts $CHECK_OUTPUT "------------------------------------------"
      }
      set macro_messages_file [get_macro_messages_file_name]
      puts $CHECK_OUTPUT "deleting macro messages file after update!"
      puts $CHECK_OUTPUT "file: $macro_messages_file"
      if { [ file isfile $macro_messages_file] } {
         file delete $macro_messages_file
      }
      update_macro_messages_list
   }
   }
   

   if { $do_only_install != 1 } {


   set depend_host_name [lindex $CHECK_SOURCE_COMPILE_HOSTS 0] 

   puts $CHECK_OUTPUT "------------------------------------------"
   puts $CHECK_OUTPUT "-> starting scripts/zerodepend on host $depend_host_name ..."
   set output [ start_remote_prog $depend_host_name $CHECK_USER "cd" "$CHECK_SOURCE_DIR ; scripts/zerodepend" prg_exit_state 60 0 "" 1 0 ]
   puts $CHECK_OUTPUT "------------------------------------------"
   puts $CHECK_OUTPUT "return state: $prg_exit_state"
   puts $CHECK_OUTPUT "------------------------------------------"
   puts $CHECK_OUTPUT "output:\n$output"
   puts $CHECK_OUTPUT "------------------------------------------"

   puts $CHECK_OUTPUT "------------------------------------------"


   set my_compile_options $CHECK_AIMK_COMPILE_OPTIONS
   if { [ string compare "csp" $CHECK_PRODUCT_FEATURE ] == 0 } {
      append my_compile_options " -secure"
      puts $CHECK_OUTPUT "-> adding compile option -csp"
   }
   puts $CHECK_OUTPUT "-> starting aimk -only-depend on host $depend_host_name ..."
   set output [ start_remote_prog $depend_host_name $CHECK_USER "cd" "$CHECK_SOURCE_DIR ; ./aimk -only-depend" prg_exit_state 60 0 "" 1 0 ]
   puts $CHECK_OUTPUT "------------------------------------------"
   puts $CHECK_OUTPUT "return state: $prg_exit_state"
   puts $CHECK_OUTPUT "------------------------------------------"
   puts $CHECK_OUTPUT "output:\n$output"
   puts $CHECK_OUTPUT "------------------------------------------"
   if { $prg_exit_state != 0 } {
      mail_report $mail_subject "$mail_body aimk -only-depend on host $depend_host_name returned:\n$output"
      append html_body [ create_html_text "aimk -only-depend on host $depend_host_name returned:\n$output" ]
      update_compile_html_output $html_body

      return -1
   }


   puts $CHECK_OUTPUT "------------------------------------------"
   puts $CHECK_OUTPUT "-> starting aimk $my_compile_options depend on host $depend_host_name ..."
   set output [ start_remote_prog $depend_host_name $CHECK_USER "cd" "$CHECK_SOURCE_DIR ; ./aimk $my_compile_options depend" prg_exit_state 60 0 "" 1 0 ]
   puts $CHECK_OUTPUT "------------------------------------------"
   puts $CHECK_OUTPUT "return state: $prg_exit_state"
   puts $CHECK_OUTPUT "------------------------------------------"
   puts $CHECK_OUTPUT "output:\n$output"
   puts $CHECK_OUTPUT "------------------------------------------"

   if { $prg_exit_state != 0 } {
      mail_report $mail_subject "$mail_body aimk $my_compile_options depend on host $depend_host_name returned:\n$output"
      append html_body [ create_html_text "aimk $my_compile_options depend on host $depend_host_name returned:\n$output" ]
      update_compile_html_output $html_body

      return -1
   }

   }

   set host_list $CHECK_SOURCE_COMPILE_HOSTS
   if { $do_only_install != 1 } {
   
   set num 0
   set spawn_list {} 
   set remote_spawn_list {}
   set file_list {}
   set file_name_list {}
 
   set cvs_tag "maintrunc"
   if { [ file isfile "${CHECK_SOURCE_DIR}/CVS/Tag" ] } {
      set cvs_tag "no_tag_dir" 
      set tag_state [ catch { eval exec "cat ${CHECK_SOURCE_DIR}/CVS/Tag" } cvs_tag ]
   }

   set table_row 2
   foreach elem $host_list {
      # compile the staff
      puts $CHECK_OUTPUT "-> starting compiling on host $elem ..."

      set html_table($table_row,BGCOLOR) "#009900"
      set html_table($table_row,FNCOLOR) "#FFFFFF"
      set html_table($table_row,1) $elem
      set html_table($table_row,2) [resolve_arch $elem]

      set html_table($table_row,3) "ok"    ;# error is set later
      set html_table($table_row) "$elem"   ;# not neccessary for html table


      set prog "$CHECK_TESTSUITE_ROOT/$CHECK_SCRIPT_FILE_DIR/remotecompile.sh"
      set par1 "$CHECK_SOURCE_DIR"
      set par2 "$my_compile_options"
      
      puts $CHECK_OUTPUT "$prog $par1 '$par2'"
      set open_spawn [ open_remote_spawn_process $elem $CHECK_USER $prog "$par1 '$par2'" 0 "" 0 ] 

      lappend spawn_list [ lindex $open_spawn 1 ]
      lappend remote_spawn_list $open_spawn
      
      set myfilename "$CHECK_PROTOCOL_DIR/${elem}_compile_${cvs_tag}.out"

      set html_table($table_row,4) [create_html_link "view" $myfilename]
  
      lappend file_name_list $myfilename
      catch { file delete $myfilename }
      lappend file_list [open $myfilename w]
      incr table_row 1    
      incr num 
   }  
   incr table_row -1
  
   append mail_body "\n\ncompile output saved in the files:"
   foreach elem $file_name_list {
      append mail_body "\n$elem"
#      eval exec "/usr/openwin/bin/xterm -sl 5000 -sb -j -e tail -f $elem &"
   }
   append mail_body "\n"
   
   
   }

   if { $do_only_install != 1 } {

   puts $CHECK_OUTPUT "now waiting for end of compile ..." 
   set timeout 300
   set done_count 0
   set compile_bad {}
   log_user 0

   set original_spawn_list $spawn_list  
   set show_info 1
   set output_buff ""
   while { [llength $spawn_list] > 0   } {
      if {[info exists spawn_id]} {
            unset spawn_id
      }
      if { $show_info == 1 } {
         clear_screen
         puts $CHECK_OUTPUT "============================================"
         puts $CHECK_OUTPUT "open compile connections: "
         foreach id $spawn_list {
            set host_nr 0
            set host_index 0
            foreach el $original_spawn_list {
               if { [string compare $el $id] == 0 } {
                    set host_index $host_nr
               }
               incr host_nr 1
            }
            puts -nonewline $CHECK_OUTPUT "[lindex $host_list $host_index] "
         }
         puts $CHECK_OUTPUT "\n============================================"
         puts $CHECK_OUTPUT $output_buff
         set show_info 1
      }

      expect {
         -i $spawn_list full_buffer {
         }
         -i $spawn_list timeout {
              set spawn_id [lindex $spawn_list 0]   ;# declare first connection as fault
              set host_index 0
              set host_nr 0
              foreach el $original_spawn_list {
                 if { [string compare $el $spawn_id] == 0 } {
                    set host_index $host_nr
                 }
                 incr host_nr 1
              }
              lappend compile_bad [lindex $host_list $host_index]
              puts $CHECK_OUTPUT "got timeout for host \"[lindex $host_list $host_index]\""
              foreach spawn_object $remote_spawn_list {
                 if { [ lindex $spawn_object 1 ] == $spawn_id } {
                    puts $CHECK_OUTPUT "found spawn object: $spawn_object"
                    close_spawn_process $spawn_object
                 }
              }
              set index [lsearch -exact $spawn_list $spawn_id]
              set spawn_list [lreplace $spawn_list $index $index]
              set show_info 1
         }
         -i $spawn_list eof {
              set spawn_id $expect_out(spawn_id)
              set host_index 0
              set host_nr 0
              foreach el $original_spawn_list {
                 if { [string compare $el $spawn_id] == 0 } {
                    set host_index $host_nr
                 }
                 incr host_nr 1
              }
              lappend compile_bad [lindex $host_list $host_index]
              puts $CHECK_OUTPUT $expect_out(0,string)
              foreach spawn_object $remote_spawn_list {
                 if { [ lindex $spawn_object 1 ] == $spawn_id } {
                    puts $CHECK_OUTPUT "found spawn object: $spawn_object"
                    close_spawn_process $spawn_object
                 }
              }

              set index [lsearch -exact $spawn_list $spawn_id]
              set spawn_list [lreplace $spawn_list $index $index]
              set show_info 1

         }
         -i $spawn_list "remotecompile * aimk compile error" {
              set spawn_id $expect_out(spawn_id)
              set host_index 0
              set host_nr 0
              foreach el $original_spawn_list {
                 if { [string compare $el $spawn_id] == 0 } {
                    set host_index $host_nr
                 }
                 incr host_nr 1
              }
              lappend compile_bad [lindex $host_list $host_index]
              puts $CHECK_OUTPUT $expect_out(0,string)
              foreach spawn_object $remote_spawn_list {
                 if { [ lindex $spawn_object 1 ] == $spawn_id } {
                    puts $CHECK_OUTPUT "found spawn object: $spawn_object"
                    close_spawn_process $spawn_object
                 }
              }

              set index [lsearch -exact $spawn_list $spawn_id]
              set spawn_list [lreplace $spawn_list $index $index]
              set show_info 1

         }
         -i $spawn_list "remotecompile * aimk no errors" {
              set spawn_id $expect_out(spawn_id)
              puts $CHECK_OUTPUT $expect_out(0,string)
              foreach spawn_object $remote_spawn_list {
                 if { [ lindex $spawn_object 1 ] == $spawn_id } {
                    puts $CHECK_OUTPUT "found spawn object: $spawn_object"
                    close_spawn_process $spawn_object
                 }
              }

              set index [lsearch -exact $spawn_list $spawn_id]
              set spawn_list [lreplace $spawn_list $index $index]
              set show_info 1
         }
         -i $spawn_list "*\n" {
              set spawn_id $expect_out(spawn_id)
              set index 0
              set nr 0
              foreach elem $original_spawn_list {
                 if { [string compare $elem $spawn_id] == 0 } {
                    set index $nr
                 }
                 incr nr 1
              }
              puts [lindex $file_list $index] "$expect_out(0,string)"
              flush [lindex $file_list $index]
              set output_buff ""
              append output_buff "\n[lindex $host_list $index]:\n"
              append output_buff "$expect_out(0,string)"
         }
      }
   }
   log_user 1
   foreach elem $file_list {
      flush $elem
      close $elem
   } 

   set compile_error 0
   foreach elem $compile_bad {
      set compile_error 1

      for { set html_c 2 } { $html_c <= $table_row }  { incr html_c 1 } {
          if { [ string compare $html_table($html_c) $elem ] == 0 } {
             set html_table($html_c,BGCOLOR) "#CC0000"
             set html_table($html_c,FNCOLOR) "#FFFFFF"
             set html_table($html_c,3) "compile error"
          }
      }


      puts $CHECK_OUTPUT "\n=============\ncompile error on host $elem:\n=============\n"
      append mail_body "\n=============\ncompile error on host $elem:\n=============\n"
      foreach file $file_name_list {
         if { [string first $elem $file] >= 0 } {
             catch { eval exec "touch $file"  }
             set fp [open $file r]
             while { [gets $fp line] >= 0 } {
                append mail_body "\n$line"
                puts $CHECK_OUTPUT $line
             }
             close $fp
         } 
      }
   }

   set html_table(1,BGCOLOR) "#3366FF"
   set html_table(1,FNCOLOR) "#66FFFF"

   set html_table(COLS) 4
   set html_table(1,1) "Host"
   set html_table(1,2) "Arch"
   set html_table(1,3) "State"
   set html_table(1,4) "Compile output"

   set html_table(ROWS) $table_row

   
   if { $compile_error != 0 } {
      mail_report $mail_subject $mail_body
      append html_body [ create_html_table html_table ]
      update_compile_html_output $html_body
      return -1
   } 

   } 

   # install to $CHECK_PRODUCT_ROOT
   set var_name "SGE_ROOT"
   if {[string compare $CHECK_PRODUCT_TYPE "sgeee"] == 0 } {
      set link_name "myinst"
      set sgeee_param "-sgeee"
   } else {
      set link_name "myinst"
      set sgeee_param ""
   }
   puts $CHECK_OUTPUT "\nusing environment variable \"$var_name\""

   # copy pos. host_aliases file to trash_
   if { [ file isfile "$CHECK_PRODUCT_ROOT/default/common/host_aliases"] == 1 } {
      puts $CHECK_OUTPUT "saving host_aliases file ..."
      catch { exec "cp" "$CHECK_PRODUCT_ROOT/default/common/host_aliases" "$CHECK_JOB_OUTPUT_DIR/host_aliases"  } result
      puts $result
   } 

   # now delete install directory
   puts $CHECK_OUTPUT "moving directory \"$CHECK_PRODUCT_ROOT\" to testsuite_trash"
   if { [delete_directory "$CHECK_PRODUCT_ROOT"] != 0 } {
      add_proc_error "compile_source" -2 "could not delete $CHECK_PRODUCT_ROOT directory, critical error - stop"
      return -1
   }
  

   catch { exec "mkdir" "$CHECK_PRODUCT_ROOT"  } result
   puts $result
   catch { exec "chmod" "755" "$CHECK_PRODUCT_ROOT"  } result
   puts $result
 

   puts $CHECK_OUTPUT "\ncreating link \"$link_name\""
   set return_state [ catch { eval exec ln -s $CHECK_SOURCE_DIR/scripts/distinst $CHECK_SOURCE_DIR/$link_name } output ]


   set arch_list {}
   set compiled_mail_architectures ""
   puts -nonewline $CHECK_OUTPUT "\narchitectures: "
   foreach elem $host_list {
      set output [resolve_arch $elem]
      lappend arch_list $output 
      puts -nonewline $CHECK_OUTPUT "$output "
      append compiled_mail_architectures "\n$elem ($output)"
   }

     

 
   puts $CHECK_OUTPUT "\ninstalling product binaries"
   set open_spawn [ open_remote_spawn_process [lindex $host_list 0] $CHECK_USER "cd" "$CHECK_SOURCE_DIR ; $var_name=$CHECK_PRODUCT_ROOT ; export $var_name ; ./$link_name $sgeee_param $CHECK_DIST_INSTALL_OPTIONS $arch_list" ]
   set sp_id [ lindex $open_spawn 1 ]
   set timeout -1
   set done 0
   while { $done != 1 } {
      expect {
         -i $sp_id full_buffer {
            puts $CHECK_OUTPUT "testsuite - compile_source buffer overflow please increment CHECK_EXPECT_MATCH_MAX_BUFFER value"
         }
         -i $sp_id "Base directory:" {
             send -i $sp_id "y\n"
         }
         -i $sp_id "overriding mode" {
             send -i $sp_id "y\n"
         }
         -i $sp_id "_exit_status_" {
            set done 1
         }
         -i $sp_id eof {
            set done 1
         }
      }
   }
   close_spawn_process $open_spawn
   puts $CHECK_OUTPUT ""

   foreach elem $CHECK_CORE_EXECD {
      set host_arch [ resolve_arch $elem ]
      if { ([string compare $host_arch ""] != 0) && ([string compare $host_arch "unknown" ] != 0) } {
         puts $CHECK_OUTPUT " arch on host $elem is $host_arch - successfully installed binaries"
      } else {
         puts $CHECK_OUTPUT " error installing binaries for host $elem"
         set found 0
         for { set html_c 2 } { $html_c <= $table_row }  { incr html_c 1 } {
            if { [ string compare $html_table($html_c) $elem ] == 0 } {
               set html_table($html_c,BGCOLOR) "#CC0000"
               set html_table($html_c,FNCOLOR) "#FFFFFF"
               set html_table($html_c,3) "error installing binaries"
               set found 1
               break
            }
         }
         if {$found != 1} {
            append html_body [ create_html_text "ERROR installing binaries for host $elem !!!" ]
         }
         set was_error 1
      }
   }
   if { $do_only_install != 1 } {
      append html_body [ create_html_table html_table ]
   }
 
   catch { file mkdir "$CHECK_PRODUCT_ROOT/man" } 
   catch { file mkdir "$CHECK_PRODUCT_ROOT/catman" } 
   catch { file mkdir "$CHECK_PRODUCT_ROOT/default" } 
   catch { file mkdir "$CHECK_PRODUCT_ROOT/default/common" } 

  
   # copy pos. host_aliases file to new product root /default/common
   if { [ file isfile "$CHECK_JOB_OUTPUT_DIR/host_aliases"] == 1 } {
        puts $CHECK_OUTPUT "restoring host_aliases file ..."
        catch { exec "cp" "$CHECK_JOB_OUTPUT_DIR/host_aliases" "$CHECK_PRODUCT_ROOT/default/common/host_aliases" } result
        puts $result
   }


   if { $was_error != 0 } {
      mail_report $mail_subject "$mail_body - compile error(s)"
      update_compile_html_output $html_body
      return -1
   }
   
   append mail_body "\nSuccessfully compiled and pre-installed following architectures:"
   append mail_body "\n${compiled_mail_architectures}\n"
   
   append mail_body "\ninit_core_system check will install the $CHECK_PRODUCT_TYPE execd at:"
   foreach elem $CHECK_CORE_EXECD {
      set host_arch [ resolve_arch $elem ]
      append mail_body "\n$elem ($host_arch)"
   }
   if { [string compare $cvs_change_log "" ] != 0 } {
      set mail_body "$mail_body \n\n Update output:\n$cvs_change_log\n\n"
   }
   set mail_subject "testsuite success - compile"
   mail_report $mail_subject $mail_body

   update_compile_html_output $html_body

   # try to resolve hostnames in settings file
   set catch_return [ catch { eval exec "cp ${CHECK_DEFAULTS_FILE} ${CHECK_DEFAULTS_FILE}.[timestamp]" } ]
   if { $catch_return != 0 } { 
        puts "could not copy defaults file"
        return -1
   }
   return 0
}

#                                                             max. column:     |
#****** check/run_all_at_starttime() ******
# 
#  NAME
#     run_all_at_starttime -- ??? 
#
#  SYNOPSIS
#     run_all_at_starttime { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc run_all_at_starttime {} {

   global CHECK_ACT_PATH CHECK_REPORT_FILE CHECK_CHECKTREE_ROOT

   set start_time 0
   set should_we_compile 0

   print_menu_header
   if { [ ask_user_yes_or_no " Do you want to enter a special starttime (y/N) ? " ] } {
      puts "\n now it is: [exec date "+%D %H:%M" ]"
      set start_time [ get_user_input "    Please enter start time : " ]
      puts "\n testsuite will start at \"$start_time\""
   } else {
      
      puts "\n testsuite will run continuously"
   }

   if { [ ask_user_yes_or_no "\n\n Should the testsuite update, compile and install before testing (y/N) ? " ] } {
      set should_we_compile 1
      puts "\n testsuite will update, compile and install the latest source code"
   } else {
      puts "\n testsuite will use the current installation"
   }

   if { [ ask_user_yes_or_no "\n\n Are this settings correct (y/N) ? " ] == 0 } {
      puts "\n testsuite will return to the main menue, please"
      return
   }

   set_root_passwd
 

   if { $start_time != 0 } {
      wait_for_start_time $start_time
   }
   delete_tests $CHECK_ACT_PATH
   if { $should_we_compile == 1 } {
#     remove_old_cvs_tree
      set back [ compile_source ]
      if { $back != 0 } {
         puts "error in compile_source - stop"
         exit -1
      }
      set saved_path $CHECK_ACT_PATH
      set CHECK_ACT_PATH "$CHECK_CHECKTREE_ROOT/install_core_system"
      set back [ run_test $CHECK_ACT_PATH 1 ]
      if { $back != 0 } {
         puts "error in test install_core_system - stop"
         exit -1
      }
      set CHECK_ACT_PATH $saved_path
   }
   run_tests $CHECK_ACT_PATH 0
   create_report ${CHECK_REPORT_FILE}.ok 0
   create_report ${CHECK_REPORT_FILE}.failed 1

   wait_for_enter
}

#****** check/do_wait() ********************************************************
#  NAME
#     do_wait() -- wait for x seconds (and print .)
#
#  SYNOPSIS
#     do_wait { time } 
#
#  INPUTS
#     time - time in seconds
#
#*******************************************************************************
proc do_wait { time } {

   set timestart [ timestamp ]
   while { 1 } {
       if { [ expr ( [ timestamp  ] - $timestart ) ] >= $time } {
         puts ""
         return
       }
       puts -nonewline "."
       flush stdout
       sleep 1
   }
}

#                                                             max. column:     |
#****** check/get_user_input() ******
# 
#  NAME
#     get_user_input -- ??? 
#
#  SYNOPSIS
#     get_user_input { what } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#     what - ??? 
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc get_user_input { what } {
   puts -nonewline $what
   flush stdout 
   set myinput [wait_for_enter 1]
   return $myinput
}


#****** check/restart_debug_daemons() ******************************************
#  NAME
#     restart_debug_daemons() -- used for menu point 20/21
#
#  SYNOPSIS
#     restart_debug_daemons { { shutdown 0 } } 
#
#  FUNCTION
#     This procedure will shutdown and restart the qmaster and scheduler
#
#  INPUTS
#     { shutdown 0 } - 0 -> do shutdown (otherwise only do starup)
#
#*******************************************************************************
proc restart_debug_daemons { { shutdown 0 } } {
   global daemon_debug master_debug schedd_debug
   global CHECK_CORE_MASTER

   if { [ have_root_passwd ] != 0 } {
      set_root_passwd
   }
   if { $shutdown == 0 } {
      get_config config_tmp
      if { [info exists config_tmp(qmaster_spool_dir) ] != 1 } { 
         return 
      }
      shutdown_master_and_scheduler $CHECK_CORE_MASTER $config_tmp(qmaster_spool_dir) 
   }
   startup_qmaster 
   wait_for_load_from_all_queues 300 
}

proc got_command {  } {

  fconfigure stdin -blocking FALSE
  set data [wait_for_enter 1]
  if { [string length $data] > 0 } {
     return $data
  }  
  fconfigure stdin -blocking TRUE

  return 0
}

#                                                             max. column:     |
#****** check/ask_user_yes_or_no() ******
# 
#  NAME
#     ask_user_yes_or_no -- ??? 
#
#  SYNOPSIS
#     ask_user_yes_or_no { question } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#     question - ??? 
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc ask_user_yes_or_no { question } {
  
   puts -nonewline $question
   flush stdout 
   set myinput [wait_for_enter 1]

   if { [ string compare -nocase $myinput "yes" ] == 0 } {
       return 1
   }
   if { [ string compare -nocase $myinput "y" ] == 0 } {
       return 1
   }
   return 0
}

# select action
#                                                             max. column:     |
#****** check/menu() ******
# 
#  NAME
#     menu -- ??? 
#
#  SYNOPSIS
#     menu { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc menu {} {
  global CHECK_ACT_PATH CHECK_DIRECTORIES CHECK_INFORMATION_FILE CHECK_RESULT_DIR 
  global CHECK_USER CHECK_REPORT_FILE CHECK_OUTPUT CHECK_HOST CHECK_BAD_RESULT_DIR 
  global CHECK_CORE_RESULT_DIR CHECK_CORE_BAD_RESULT_DIR CHECK_MAIN_RESULTS_DIR 
  global CHECK_GUILTY_RUNLEVELS CHECK_MAX_LEVEL CHECK_PRODUCT_VERSION_NUMBER CHECK_SETUP_NAMES
  global daemon_debug CHECK_DEBUG_LEVEL CHECK_DEFAULTS_FILE CHECK_DO_SETUP
  global CHECK_PACKAGE_DIRECTORY CHECK_SETUP_CHANGES CHECK_PACKAGE_TYPE
  global check_reinit_on_tcl_error

  delete_temp_script_files

  set files [  print_menu_header ]
 
  puts "  (0) select runlevels/categories"
  puts "  (1) change dir"
  puts "  (2) run not completed tests (including subdirectories)"
  puts "  (3) show test descriptions"
  puts "  (4) exit (press ^C to exit without shutdown of the cluster)"
  puts "  (5) show completed test list"
  puts "  (6) show not completed test list"
  puts "  (7) reset completed test list (for all subdirectories)"
  puts "  (8) create check report"
  puts "  (9) run all tests at a special starttime"
  if { [ string compare "stdout" $CHECK_OUTPUT ] == 0 } {
     puts " (10) use file \"${CHECK_HOST}.checklog\" for output" 
  } else {
     puts " (10) use \"stdout\" for output"
  }

  set localtest [lsearch $files $CHECK_INFORMATION_FILE]
  if { $localtest >= 0 } {
    puts " (11) show test descriptions of local test"
    puts " (12) run local test"
    puts " (13) run local test continously"
  }
    puts "===============================================================================" 
    puts " (20) shutdown and restart master and scheduler"
    puts " (21) only start master and scheduler daemons"
    puts " (22) check messages files of execds and qmaster"
    if { $CHECK_PACKAGE_DIRECTORY == "none" } {
       puts " (23) compile source code and pre install binaries"
    } else {
       puts " (23) install product packages"
    }
    puts " (24) do (23), then (2)"
    puts " (25) set testsuite debug level (current value: $CHECK_DEBUG_LEVEL)"
    puts " (26) enter testsuite setup" 
    puts " (27) set command line options"

  set input [wait_for_enter 1]; 

  clear_screen

  switch -- $input {
    "20" { restart_debug_daemons } 
    "21" { restart_debug_daemons 1 }
    "22" { set output [check_messages_files]
           puts $CHECK_OUTPUT $output
           wait_for_enter
         }
    "23" { 
            if { $CHECK_PACKAGE_DIRECTORY == "none"  } {
               # we compile the source and do a myinst
               if { [have_root_passwd] == -1 } {
                     puts $CHECK_OUTPUT "need root access ..."
                     set_root_passwd
                }
                set back [compile_source]
                if { $back != 0 } {
                   puts "--> error compiling and pre installing source code"
                } else {
                   puts "--> source code compiled and pre installed"
                }
                wait_for_enter
            } else {
               # we have product packages
               if { [have_root_passwd] == -1 } {
                     puts $CHECK_OUTPUT "need root access ..."
                     set_root_passwd
                }
                set back [prepare_packages]
                if { $back != 0 } {
                   puts "--> error installing product packages"
                } else {
                   puts "--> product packages pre installed"
                }
                wait_for_enter
            }
         }
    "24" {
          if { [have_root_passwd] == -1 } {
                puts $CHECK_OUTPUT "need root access ..."
                set_root_passwd
           }
           set back [compile_source]
           if { $back != 0 } {
              puts "--> error compiling and pre installing source code"
              wait_for_enter
           } else {
              puts "--> source code compiled and pre installed"
              run_tests $CHECK_ACT_PATH 0
              wait_for_enter
           }
         }
    "25" {  incr CHECK_DEBUG_LEVEL 1 
            if  { $CHECK_DEBUG_LEVEL > 2 } {
                set CHECK_DEBUG_LEVEL 0
            } 
         }
    "26" {  
            modify_setup2
            wait_for_enter
         }
    "27" {
         set_command_line_options
    }
    "0" { select_runlevel }
    "1" { change_dir; }
    "2" { set saved_check_reinit_on_tcl_error $check_reinit_on_tcl_error 
          set check_reinit_on_tcl_error 1
          run_tests $CHECK_ACT_PATH 0
          set check_reinit_on_tcl_error $saved_check_reinit_on_tcl_error
          wait_for_enter
        }
    "3" { show_tests $CHECK_ACT_PATH 1
        }
    "4" { puts "bye!\n"; 
          shutdown_core_system;
          if { [string compare "stdout" $CHECK_OUTPUT ] != 0 } {
             close $CHECK_OUTPUT
          } 
          exit 0; 
        }
    "5" { set total1 [print_results $CHECK_CORE_RESULT_DIR stdout]
          set total2 [print_results $CHECK_RESULT_DIR stdout]
          puts stdout "Total number of test functions: [expr ($total1 + $total2) ]"
          wait_for_enter
        }
    "6" { print_results $CHECK_CORE_BAD_RESULT_DIR stdout
          print_results $CHECK_BAD_RESULT_DIR stdout
          wait_for_enter
        }
    "7" { delete_tests $CHECK_ACT_PATH
          wait_for_enter
        }
    "8" { 
          if {[ file isfile "${CHECK_REPORT_FILE}.ok" ] == 1 } {
             delete_file "${CHECK_REPORT_FILE}.ok"
          }
          if {[ file isfile "${CHECK_REPORT_FILE}.failed" ] == 1 } {
             delete_file "${CHECK_REPORT_FILE}.failed"
          }
          create_report "${CHECK_REPORT_FILE}.ok" 0
          create_report "${CHECK_REPORT_FILE}.failed"  1
          wait_for_enter
        }
    "9" {
          run_all_at_starttime
          wait_for_enter
        }
    "10" {
           if { [ string compare "stdout" $CHECK_OUTPUT ] == 0 } {
              set CHECK_OUTPUT [open "$CHECK_MAIN_RESULTS_DIR/$CHECK_HOST.checklog" "w"]  
           } else {
              close $CHECK_OUTPUT
              set CHECK_OUTPUT stdout
           }
           

         }
    "11" {
          if {$localtest >= 0} {
            puts "local test description ..."
            show_test $CHECK_ACT_PATH 1
            wait_for_enter
          }
        }
    "12" {
          if {$localtest >= 0} {
            puts "running local test ..."
            run_test $CHECK_ACT_PATH 1
            wait_for_enter
          }
         }
    "13" {
            if {$localtest >= 0} {
               while { 1 == 1 } {
                  puts "running local test ..."
                  run_test $CHECK_ACT_PATH 1
                  create_report ${CHECK_REPORT_FILE}.ok 0
                  create_report ${CHECK_REPORT_FILE}.failed 1
               } 
            }
         }

   }
  menu
}

proc update_compile_html_output { content } {
   global CHECK_HTML_DIRECTORY CHECK_OUTPUT
   if { $CHECK_HTML_DIRECTORY != "" } { 
      puts $CHECK_OUTPUT "-> UPDATING HTML FILES IN DIRECTORY: \"$CHECK_HTML_DIRECTORY\""
      puts $CHECK_OUTPUT "-> UPDATING file index.html"
      generate_html_file $CHECK_HTML_DIRECTORY/index.html "Nightly Build Compile Results" $content
   }
}

proc get_shared_lib_path { host name path } {

   global CHECK_PRODUCT_ROOT
   upvar $name var_name
   upvar $path var_value

   set host_arch [resolve_arch $host ]
   set var_name [get_shared_lib_path_variable_name $host_arch]
   if { [info exists CHECK_PRODUCT_ROOT ] } {
      set var_value $CHECK_PRODUCT_ROOT/lib/$host_arch
   } else {
      set var_value ""
   }
}


proc get_shared_lib_path_variable_name { arch } {
   set name ""
   switch -exact $arch {
      aix41 -
      aix42 -
      aix43 {
         set name LIBPATH
      }
      hp10 -
      hp11 {
         set name SHLIB_PATH
      }
      default {
         set name LD_LIBRARY_PATH
      }
   }
   return $name
}

proc setup_shared_lib_path {} {
   global env CHECK_PRODUCT_ROOT CHECK_ARCH CHECK_OUTPUT
   global be_quiet

   set name [get_shared_lib_path_variable_name $CHECK_ARCH]
   if { [info exists env($name)] } {
      set env($name) "$env($name):$CHECK_PRODUCT_ROOT/lib/$CHECK_ARCH"
   } else {
      set env($name) "$CHECK_PRODUCT_ROOT/lib/$CHECK_ARCH"
   }
   if { $be_quiet == 0 } { 
      puts $CHECK_OUTPUT "   set environment variable $name to $env($name)"
   }
}

# Main programm:




set do_kill           0
set do_install        0
set do_compile        0
set do_not_update     0
set do_all            0
set do_one_test       0
set do_category       0
set do_nomain         0
set do_prog_start     0
set do_only_reset_config 0
set be_quiet          0
set CHECK_CUR_PROC_NAME "main"
set check_name "main"
set CHECK_ACTUAL_TEST_PATH "not in testmode"
set mail_subject "testsuite error - main"
set mail_body    "date: [exec date]\n:\n"

for { set i 0 } { $i < $argc } { incr i } {
   
   if {([string compare [lindex $argv $i] "--setup"] == 0) || ([string compare [lindex $argv $i] "setup"] == 0) } {
      set catch_return [ catch { eval exec "cp ${CHECK_DEFAULTS_FILE} ${CHECK_DEFAULTS_FILE}.[timestamp]" } ]
      if { $catch_return == 0 } { 
        set CHECK_DO_SETUP 1 
      } else {
        puts "could not copy defaults file"
      }
      continue
   }
   
   if {([string compare [lindex $argv $i] "--quiet"] == 0) || ([string compare [lindex $argv $i] "quiet"] == 0) } {
      set be_quiet 1
      continue
   }
   if {([string compare [lindex $argv $i] "--close_rlogin"] == 0) || ([string compare [lindex $argv $i] "close_rlogin"] == 0) } {
      set do_close_rlogin 1
      continue
   }
   

   if {([string compare [lindex $argv $i] "--help"] == 0) || ([string compare [lindex $argv $i] "help"] == 0) } {
      puts "usage: expect check.exp \[options\]"
      puts "\noptions are:"
      puts "help                  show this"
      puts ""
      puts "setup_help            show setup informations"
      puts ""
      puts "install               just install core system and exit"
      puts ""
      puts "kill                  shutdown cluster"
      puts ""
      puts "setup                 run setup"
      puts ""
      puts "file FILE             use FILE as defaults file"
      puts ""
      puts "re_init               use allready installed system (will only shutdown/reconfigure the cluster!)"
      puts "                      when test install_core_system is called or install option is set"
      puts ""
      puts "re_init_on_tcl_error  reinitialize cluster when tcl error occurs"
      puts ""
      puts "compile               checkout source code and recompile"
      puts ""
      puts "no_update             do not update source when compile option is used"
      puts ""
      puts "all RUNLEVEL          run every test automatically up to runlevel RUNLEVEL"
      puts "                      (RUNLEVEL is a value from 0=short tests, up to 4=week tests)"
      puts ""
      puts "check PATH RUNLEVEL   run test in checktree sub-path automatically up to runlevel"
      puts "                      RUNLEVEL. PATH is as check sub-path, relative to checktree."
      puts "                      (RUNLEVEL is a value from 0=short tests, up to 4=week tests)"
      puts ""
      puts "execute_func ARGS     just run this procedure with given arguments"
      puts "                      (all arguments after this keyword are used as function call)"
      puts "                      e.g.: .. no_update execute_func compare_dump_data_file arg1 arg2"
      puts ""
      puts "category CAT_LIST     set users category list (COMPATIBILITY SYSTEM \[...\])"
      puts "                      (CAT_LIST must be 1 single parameter, must be quoted"
      puts "                       when using more than one category)"
      puts "" 
      puts "no_main               don't run main part (usefull for sourceing this file)"
      puts ""
      puts "no_main2              don't run main part and don't do setup"
      puts "                      (usefull for sourceing this file)"
      puts ""
      puts "reset_conf            reset test cluster"
      puts ""
      puts "debug LEVEL           run testsuite in debuglevel 0,1 or 2"
      puts "                      0=no debug, 1=more output, 2=1+user response"
      puts ""
      puts "quiet                 no output on setup"
      puts ""
      puts "mfile FILE            write all mails into file FILE (when mail is enabled)"
      puts ""
      puts "html_dir              write testsuite html files into that directory"
      puts ""
      puts "close_rlogin          don't let rlogin connections open for next command (per default the testsuite"
      puts "                      not close a rlogin connection. The testsuite will reuse the open connection"
      puts "                      for a later remote command. Use close_rlogin if the number of open file "
      puts "                      descriptors is low on your system)"
      puts ""
      puts "master_debug          procedure startup_qmaster will startup qmaster"
      puts "                      in debug mode (using x host from DISPLAY,"
      puts "                      please enable xhost display for all users)"
      puts ""
      puts "schedd_debug          procedure startup_qmaster will startup schedduler"
      puts "                      in debug mode (using x host from DISPLAY,"
      puts "                      please enable xhost display for all users)"
      puts ""
      puts "display DISPLAY       set display for daemon debug windows"

      exit 1
   }

   if {([string compare [lindex $argv $i] "--setup_help"] == 0) || ([string compare [lindex $argv $i] "setup_help"] == 0) } {
      show_setup_information
      exit 1
   }
   

   if { ( [string compare [lindex $argv $i] "--re_init"] == 0 ) || ([string compare [lindex $argv $i] "re_init"] == 0) } {
      set check_use_installed_system 1
      continue
   }

   if { ( [string compare [lindex $argv $i] "--re_init_on_tcl_error"] == 0 ) || ([string compare [lindex $argv $i] "re_init_on_tcl_error"] == 0) } {
      set check_reinit_on_tcl_error 1
      continue
   }


   if { ( [string compare [lindex $argv $i] "--master_debug"] == 0 ) || ([string compare [lindex $argv $i] "master_debug"] == 0) } {
      set master_debug 1
      set daemon_debug 1
      continue
   }
   if { ( [string compare [lindex $argv $i] "--schedd_debug"] == 0 ) || ([string compare [lindex $argv $i] "schedd_debug"] == 0) } {
      set schedd_debug 1
      set daemon_debug 1
      continue
   }
   if { ( [string compare [lindex $argv $i] "--display"] == 0 ) || ([string compare [lindex $argv $i] "display"] == 0) } {
      incr i
      set CHECK_DISPLAY_OUTPUT [lindex $argv $i]
      continue
   }

   


   if { ( [string compare [lindex $argv $i] "--kill"] == 0 ) || ([string compare [lindex $argv $i] "kill"] == 0) } {
      set do_kill 1
      continue
   }
   
   if { ( [string compare [lindex $argv $i] "--mfile"] == 0 ) || ([string compare [lindex $argv $i] "mfile"] == 0) } {
      incr i
      set CHECK_MAIL_OUTPUT_FILE [lindex $argv $i]
      if { [llength $CHECK_MAIL_OUTPUT_FILE] != 1 } {
         puts $CHECK_OUTPUT "can't use \"mfile\" option without filename!"
         exit -1 
      }
      if { ([ string first "/" $CHECK_MAIL_OUTPUT_FILE ] < 0) && ([ string first "\/" $CHECK_MAIL_OUTPUT_FILE ] < 0)} {
          set CHECK_MAIL_OUTPUT_FILE "$CHECK_CURRENT_WORKING_DIR/$CHECK_MAIL_OUTPUT_FILE"
      }
      set write_mail_to_file 1
      puts $CHECK_OUTPUT " ---> writing all mails into \"$CHECK_MAIL_OUTPUT_FILE\" ! <---"
      continue
   }
 
   if { ( [string compare [lindex $argv $i] "--file"] == 0 ) || ([string compare [lindex $argv $i] "file"] == 0) } {
      incr i
      set help_var [lindex $argv $i]
      set CHECK_DEFAULTS_FILE [ string trim $help_var ]

      if { [llength $CHECK_DEFAULTS_FILE] != 1 } {
         puts $CHECK_OUTPUT "can't use \"file\" option without filename!"
         exit -1 
      }
      puts $CHECK_OUTPUT "\"$CHECK_DEFAULTS_FILE\""
      if { ([ string first "/" $CHECK_DEFAULTS_FILE ] != 0) } {
          set CHECK_DEFAULTS_FILE "$CHECK_CURRENT_WORKING_DIR/$CHECK_DEFAULTS_FILE"
      }
      
      puts $CHECK_OUTPUT " ---> using \"$CHECK_DEFAULTS_FILE\" for setup! <---"
      continue
   }

   if { ( [string compare [lindex $argv $i] "--html_dir"] == 0 ) || ([string compare [lindex $argv $i] "html_dir"] == 0) } {
      incr i
      set help_var [lindex $argv $i]
      set CHECK_HTML_DIRECTORY [ string trim $help_var ]

      if { [llength $CHECK_HTML_DIRECTORY] != 1 } {
         puts $CHECK_OUTPUT "can't use \"html_dir\" option without filename!"
         exit -1 
      }
      puts $CHECK_OUTPUT " ---> using \"$CHECK_HTML_DIRECTORY\" for HTML output <---"
      continue
   }

  
   

   if { ( [string compare [lindex $argv $i] "--install"] == 0 ) || ([string compare [lindex $argv $i] "install"] == 0 ) } {
      set do_install 1
      continue
   }

   if { ( [string compare [lindex $argv $i] "--compile"] == 0 ) || ([string compare [lindex $argv $i] "compile"] == 0 ) } {
      set do_compile 1
      continue
   }

   if { ( [string compare [lindex $argv $i] "--no_update"] == 0 ) || ([string compare [lindex $argv $i] "no_update"] == 0 ) } {
      set do_not_update 1
      continue
   }

   
   
   if { ( [string compare [lindex $argv $i] "--reset_conf"] == 0 ) || ([string compare [lindex $argv $i] "reset_conf"] == 0 ) } {
      set do_only_reset_config 1
      set check_use_installed_system 1
      continue
   }
  
   if { ( [string compare [lindex $argv $i] "--check"] == 0 ) || ([string compare [lindex $argv $i] "check"] == 0 ) } {
      set do_one_test 1
      set ru_lev [ expr ( 1 + $i ) ]
      set do_one_test_name [ lindex $argv $ru_lev ]
      set ru_lev [ expr ( 2 + $i ) ] 
      set do_one_test_level [lindex $argv $ru_lev]
      puts $CHECK_OUTPUT "path: $do_one_test_name"
      puts $CHECK_OUTPUT "level: $do_one_test_level"
      if { [ llength $do_one_test_level ] != 1 || [ llength $do_one_test_name ] != 1} {
         puts $CHECK_OUTPUT "used check parameter without runlevel or checkname"
         setup2
         set mail_body "$mail_body product version is [get_version_info]\n"
         set mail_body "$mail_body testsuite root directory is \"$CHECK_TESTSUITE_ROOT\"\n"
         set mail_body "$mail_body check is running on host \"$CHECK_HOST\" architecture is \"$CHECK_ARCH\"\n"
         set mail_body "$mail_body product root directory is \"$CHECK_PRODUCT_ROOT\"\n-------\n"
         mail_report $mail_subject "$mail_body used check parameter without runlevel or checkname" 
         exit -1
      }
      incr i
      continue
   } 
   if { ( [string compare [lindex $argv $i] "--all"] == 0 ) || ([string compare [lindex $argv $i] "all"] == 0 ) } {
      set do_all 1
      set ru_lev [ expr (1 + $i) ] 
      set do_all_runlevel [lindex $argv $ru_lev]
      if { [ llength $do_all_runlevel ] != 1 } {
         puts $CHECK_OUTPUT "used all parameter without runlevel"
         setup2
         set mail_body "$mail_body product version is [get_version_info]\n"
         set mail_body "$mail_body testsuite root directory is \"$CHECK_TESTSUITE_ROOT\"\n"
         set mail_body "$mail_body check is running on host \"$CHECK_HOST\" architecture is \"$CHECK_ARCH\"\n"
         set mail_body "$mail_body product root directory is \"$CHECK_PRODUCT_ROOT\"\n-------\n"
         mail_report $mail_subject "$mail_body used all parameter without runlevel" 
         exit -1
      }
      incr i
      continue
   }
   
   if { ( [string compare [lindex $argv $i] "--category"] == 0 ) || ([string compare [lindex $argv $i] "category"] == 0 ) } {
      set do_category 1
      set ru_lev [ expr (1 + $i) ] 
      set do_category_list [lindex $argv $ru_lev]
      if { [ llength $do_category_list ] == 0 } {
         puts $CHECK_OUTPUT "used category parameter without category list"
         setup2
         set mail_body "$mail_body product version is [get_version_info]\n"
         set mail_body "$mail_body testsuite root directory is \"$CHECK_TESTSUITE_ROOT\"\n"
         set mail_body "$mail_body check is running on host \"$CHECK_HOST\" architecture is \"$CHECK_ARCH\"\n"
         set mail_body "$mail_body product root directory is \"$CHECK_PRODUCT_ROOT\"\n-------\n"
         mail_report $mail_subject "$mail_body used category parameter without category list" 
         exit -1
      }
      incr i
      continue
   }


   if { ( [string compare [lindex $argv $i] "--debug"] == 0 ) || ([string compare [lindex $argv $i] "debug"] == 0 ) } {
      set deb_lev [ expr (1 + $i) ] 
      set CHECK_DEBUG_LEVEL [lindex $argv $deb_lev]

      debug_puts "debuglevel is $CHECK_DEBUG_LEVEL"
      incr i
      continue
   }
   if { ( [string compare [lindex $argv $i] "--execute_func"] == 0 ) || ([string compare [lindex $argv $i] "execute_func"] == 0 ) } {
      set exec_args ""
      for { incr i 1 } { $i < $argc } { incr i } {
         lappend exec_args [lindex $argv $i]
      }
      set do_prog_start 1
      break
   }

   

   if { ( [string compare [lindex $argv $i] "--no_main"] == 0 ) || ([string compare [lindex $argv $i] "no_main"] == 0 ) } {
      set do_nomain 1
      set no_action 0
      continue
   }
   if { ( [string compare [lindex $argv $i] "--no_main2"] == 0 ) || ([string compare [lindex $argv $i] "no_main2"] == 0 ) } {
      set do_nomain 1
      set no_action 0
      puts "no_main2 active"
      return
   }
}   

# load defaults file
#__setup   ;# old setup

setup2
if { $do_category == 1 } {
   set CHECK_GUILTY_CATEGORIES $do_category_list
}
set CHECK_ACT_PATH $CHECK_CHECKTREE_ROOT


set mail_body "$mail_body product version is [get_version_info]\n"
set mail_body "$mail_body testsuite root directory is \"$CHECK_TESTSUITE_ROOT\"\n"
set mail_body "$mail_body check is running on host \"$CHECK_HOST\" architecture is \"$CHECK_ARCH\"\n"
set mail_body "$mail_body product root directory is \"$CHECK_PRODUCT_ROOT\"\n-------\n"


if { $no_action == 1 } {
  puts $CHECK_OUTPUT "CHECK_GROUP=$CHECK_GROUP"
  puts "No action flag is set -> exit 1"
  exit 1
}

if { $do_prog_start == 1 } {
   puts $CHECK_OUTPUT "starting $exec_args ..."

   set exit_value [ eval $exec_args  ]

   if { $exit_value == "" || [string is integer $exit_value] != 1 } {
      exit 0
   } else {
      exit [ eval $exec_args  ]
   }
}

if { $check_reinit_on_tcl_error == 1 } {
   set_root_passwd   
}

if { $do_compile } {
   if { [ compile_source ] != 0 } {
      exit -1
   } else {
      exit 0
   }
}
if { $do_one_test } {
   set CHECK_ACT_PATH "$CHECK_CHECKTREE_ROOT/$do_one_test_name"
   set dirs [ get_dir_names $CHECK_ACT_PATH ]
   set files [get_file_names $CHECK_ACT_PATH ]
   
   get_max_level_count $CHECK_ACT_PATH
   set selected_levels ""
   set CHECK_GUILTY_RUNLEVELS ""
   for {set i 0} {$i<= $do_one_test_level} {incr i 1} {
      lappend CHECK_GUILTY_RUNLEVELS [ expr ( $i * 100 )  ]
   }
 
   delete_tests $CHECK_ACT_PATH
   # print_menu_header
   puts $CHECK_OUTPUT "run all tests ..."

   run_tests $CHECK_ACT_PATH 0

   exit 0

}

if { $do_all } {
   set CHECK_ACT_PATH "$CHECK_CHECKTREE_ROOT"
   delete_tests $CHECK_ACT_PATH

   set CHECK_ACT_PATH "$CHECK_CHECKTREE_ROOT"
   set dirs [ get_dir_names $CHECK_ACT_PATH ]
   set files [get_file_names $CHECK_ACT_PATH ]
   
   get_max_level_count $CHECK_ACT_PATH
   set selected_levels ""
   set CHECK_GUILTY_RUNLEVELS ""
   for {set i 0} {$i<= $do_all_runlevel} {incr i 1} {
      lappend CHECK_GUILTY_RUNLEVELS [ expr ( $i * 100 )  ]
   }

   print_menu_header
   puts $CHECK_OUTPUT "run all tests ..."

   run_tests $CHECK_ACT_PATH 0

   exit 0
} 

if { $do_install } {
   puts "installing core system on host $CHECK_HOST ..."
   set CHECK_ACT_PATH "$CHECK_ACT_PATH/install_core_system"  
   run_test $CHECK_ACT_PATH 1
   exit 0 
}

if { $do_kill } {
   shutdown_core_system
   exit 0   
}

if { $do_only_reset_config == 1 } {
  set result 1
 
  set CHECK_ACT_PATH "$CHECK_ACT_PATH/install_core_system"
  run_test $CHECK_ACT_PATH 1 "setup_queues" 0
  run_test $CHECK_ACT_PATH 1 "setup_testcheckpointobject" 0
  run_test $CHECK_ACT_PATH 1 "setup_conf" 0
  run_test $CHECK_ACT_PATH 1 "setup_execd_conf" 0
  run_test $CHECK_ACT_PATH 1 "setup_mytestproject" 0
  run_test $CHECK_ACT_PATH 1 "setup_mytestpe" 0
  run_test $CHECK_ACT_PATH 1 "setup_deadlineuser" 0
  run_test $CHECK_ACT_PATH 1 "setup_schedconf" 0
  run_test $CHECK_ACT_PATH 1 "setup_default_calendars" 0
  run_test $CHECK_ACT_PATH 1 "setup_inhouse_cluster" 0
 
  puts "configuration reset done" 
  exit $result
}


 
if {$do_nomain == 0} {
  if { $daemon_debug != 0 } {
     if { [check_display] != 0 } {
        exit 1
     }
  }
#  puts "please press <RETURN>"
#  wait_for_enter 1
  menu 
}

