#!/vol2/TCL_TK/glinux/bin/expect
# expect script 
# test SGE/SGEEE System
#___INFO__MARK_BEGIN__
##########################################################################
#
#  The Contents of this file are made available subject to the terms of
#  the Sun Industry Standards Source License Version 1.2
#
#  Sun Microsystems Inc., March, 2001
#
#
#  Sun Industry Standards Source License Version 1.2
#  =================================================
#  The contents of this file are subject to the Sun Industry Standards
#  Source License Version 1.2 (the "License"); You may not use this file
#  except in compliance with the License. You may obtain a copy of the
#  License at http://gridengine.sunsource.net/Gridengine_SISSL_license.html
#
#  Software provided under this License is provided on an "AS IS" basis,
#  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
#  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
#  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
#  See the License for the specific provisions governing your rights and
#  obligations concerning the Software.
#
#  The Initial Developer of the Original Code is: Sun Microsystems, Inc.
#
#  Copyright: 2001 by Sun Microsystems, Inc.
#
#  All Rights Reserved.
#
##########################################################################
#___INFO__MARK_END__


global daemon_debug 
set daemon_debug 0
global master_debug
set master_debug 0
global schedd_debug
set schedd_debug 0

global no_action                   ;# just used for testing/debug  procedures
set no_action 0
global be_quiet
set be_quiet 0
global write_mail_to_file
set write_mail_to_file 0
global do_close_rlogin
set do_close_rlogin 0

global do_compile


# path/file variables
global CHECK_TESTSUITE_ROOT        ;# path to TESTSUITE directory
global CHECK_CHECKTREE_ROOT        ;# path where checktree lies

# never touch these dirs: begin
global CHECK_RESULT_DIR            ;# check result directory            
global CHECK_BAD_RESULT_DIR        ;# check rusult directory for failed checkes
global CHECK_CORE_RESULT_DIR       ;# check result core system directory
global CHECK_CORE_BAD_RESULT_DIR   ;# check result directory for failed core system checkes
# never touch these dirs : end

# this is for new tests:
global CHECK_PROTOCOL_DIR          ;# directory for test protocols, logs etc.
global CHECK_JOB_OUTPUT_DIR        ;# directory for qsub job outputs
############################################################################

global CHECK_ACTUAL_TEST_PATH      ;# directory of current running test
global CHECK_PRODUCT_ROOT          ;# path to sge system
global CHECK_OUTPUT                ;# output from testsuite 
global CHECK_CURRENT_WORKING_DIR   ;# current work directory

# globals for source code specific staff
global CHECK_SOURCE_DIR            ;# path to source code directory (c4)
global CHECK_SOURCE_CVS_RELEASE    ;# release name to check out e.g. V52_BRANCH
set CHECK_SOURCE_CVS_RELEASE "maintrunc"    ;# default is "maintrunc"
global CHECK_SOURCE_HOSTNAME       ;# name of host with cvs installed on (e.g. fangorn)
global CHECK_SOURCE_COMPILE_HOSTS  ;# list of hostnames on which the source should be compiled
global CHECK_AIMK_COMPILE_OPTIONS     ;# optional: aimk options
global CHECK_DIST_INSTALL_OPTIONS     ;# optional: mydistinst options
global CHECK_QMASTER_INSTALL_OPTIONS  ;# optional: qmaster install parameter
global CHECK_EXECD_INSTALL_OPTIONS    ;# optional: execd install parameter 
set CHECK_AIMK_COMPILE_OPTIONS ""
set CHECK_DIST_INSTALL_OPTIONS "-allall"
set CHECK_QMASTER_INSTALL_OPTIONS ""
set CHECK_EXECD_INSTALL_OPTIONS   ""

# test system specific 
global CHECK_DNS_DOMAINNAME
set CHECK_DNS_DOMAINNAME ""
global CHECK_REMOTE_ENVIRONMENT
set CHECK_REMOTE_ENVIRONMENT ""
global CHECK_DISPLAY_OUTPUT 
set CHECK_DISPLAY_OUTPUT "undefined"
global CHECK_SETTINGS_VERSION    ;# settings file version number
set CHECK_SETTINGS_VERSION "undefined"
global CHECK_PRODUCT_VERSION_NUMBER ;# version string of qstat -help of tested system
set CHECK_PRODUCT_VERSION_NUMBER "unknown"
global CHECK_PRODUCT_TYPE           ;# "sgeee" or "sge" 
global CHECK_PRODUCT_FEATURE       ;# product feature e.g. secure
set CHECK_PRODUCT_FEATURE "none"
global CHECK_START_SCRIPT_NAME     ;# rcsge
set CHECK_START_SCRIPT_NAME "rcsge"
global CHECK_COMMD_PORT            ;# commd port
global CHECK_ARCH                  ;# architecture of this system (e.g. irix6)
set CHECK_ARCH "unknown"
global CHECK_USER                  ;# user who start test
global CHECK_GROUP                 ;# group of user who start test
global CHECK_HOST                  ;# hostname of this system (e.g. DWAIN)
global CHECK_CORE_EXECD            ;# known execd hostnames
global CHECK_SUBMIT_ONLY_HOSTS     ;# list of submithosts (no execd/commd running)
set CHECK_SUBMIT_ONLY_HOSTS ""
global CHECK_CORE_MASTER           ;# qmaster hostname
global CHECK_CORE_PROCESSORS       ;# real number of processors (in order of CHECK_CORE_EXECD)
global CHECK_ACT_LEVEL             ;# actual check level ( value from 0 up to xxx )
global CHECK_ROOT_PASSWORD         ;# stored root password ( only stored in a variable )
global CHECK_SPOOL_DIR_CONFIG_FILE ;# file for local spooldirs in $CHECK_CONFIG_DIR path
set CHECK_SPOOL_DIR_CONFIG_FILE "local-spool.conf"
global CHECK_BINARY_DIR_CONFIG_FILE ;# file for binary directories in $CHECK_CONFIG_DIR
set CHECK_BINARY_DIR_CONFIG_FILE "binary-path.conf"
global CHECK_LOADSENSOR_DIR_CONFIG_FILE ;# file for architecture specific loadsensor binaries in
set CHECK_LOADSENSOR_DIR_CONFIG_FILE "loadsensor.conf" ;# $CHECK_CONFIG_DIR
global CHECK_MAIL_OUTPUT_FILE
set CHECK_MAIL_OUTPUT_FILE "all_test_mails.txt"

global check_use_installed_system   ;# used only for install_core_system test (noinst parameter)
set check_use_installed_system 0    ;# set to 1 when installed system parameter is set

global check_reinit_on_tcl_error
set check_reinit_on_tcl_error 0

global CHECK_FIRST_FOREIGN_SYSTEM_USER       ;# other system user for e.g. submitting jobs 
set CHECK_FIRST_FOREIGN_SYSTEM_USER "nobody"

global CHECK_SECOND_FOREIGN_SYSTEM_USER      ;# other system user for e.g. submitting jobs 
set CHECK_SECOND_FOREIGN_SYSTEM_USER "nobody"

global CHECK_FIRST_FOREIGN_SYSTEM_GROUP      ;# other system group for e.g. submitting jobs
set CHECK_FIRST_FOREIGN_SYSTEM_GROUP "nogroup" 

global CHECK_SECOND_FOREIGN_SYSTEM_GROUP      ;# other system group for e.g. submitting jobs
set CHECK_SECOND_FOREIGN_SYSTEM_GROUP "nogroup" 

global CHECK_DEFAULT_DOMAIN                ;# default domain for install test
set CHECK_DEFAULT_DOMAIN "none"

global CHECK_MAILX_HOST                    ;# host where the mailx binary is available
set CHECK_MAILX_HOST "none"

global CHECK_REPORT_EMAIL_TO               ;# mail reports/errors to this email-account
set CHECK_REPORT_EMAIL_TO "none"

global CHECK_REPORT_EMAIL_CC               ;# cc reports/errors to this email-accounts
set CHECK_REPORT_EMAIL_CC "none"                 

global CHECK_SEND_ERROR_MAILS              ;# flag 0 off  1 on
set CHECK_SEND_ERROR_MAILS "1"

global CHECK_MAX_ERROR_MAILS              ;# max mails on run all test
set CHECK_MAX_ERROR_MAILS 400

global CHECK_USE_SSH                             ;# enable/disable use of ssh (o means disable)     
set CHECK_USE_SSH 0

global CHECK_TCL_SCRIPTFILE_DIR   ;# testsuite's subdir for tcl files
set CHECK_TCL_SCRIPTFILE_DIR "tcl_files"

global CHECK_SCRIPT_FILE_DIR  ;# testsuite's subdir for script files
set CHECK_SCRIPT_FILE_DIR "scripts"

global CHECK_EXPECT_MATCH_MAX_BUFFER   ;# read buffer for expect
set CHECK_EXPECT_MATCH_MAX_BUFFER 640000

# to redefine in checks:
global check_name                  ;# name of actual check module 
global check_description           ;# description of actual check module (append more levels as list)
global check_needs                 ;# dependencies of this check (name of other check)
global check_functions             ;# functions to call (in order)
global check_init_level_procedure   ;# name of procedure to call before starting level run
global check_errno                ;# 0 -> OK , != 0 means error (-2 = break test , -1 failure )
global check_errstr                 ;# short error description in text form   
global check_highest_level         ;# here a check can define his check levels count 0 ...

# for global procedures
global check_cur_proc_error        ;# short error description in text form ( in public procedures )
global check_cur_proc_result       ;# 0 -> OK , != 0 means error (-2 = break test , -1 failure )    


# testsuite intern
global CHECK_INFORMATION_FILE      ;# filename of check information (check.exp)
global CHECK_DIRECTORIES           ;# all sub directories with check's in actual checkpath
global CHECK_REPORT_FILE           ;# filename (with path) for report
global CHECK_MAIN_RESULTS_DIR      ;# check result root directory for all RESULTS
global CHECK_CONFIG_DIR            ;# global configuration testsuite directory
global CHECK_DEFAULTS_FILE         ;# default settings save file
global CHECK_DO_SETUP              ;# flag: do setup option called ?
global CHECK_CUR_PROC_NAME         ;# name of current running test procedure
global CHECK_CUR_PROC_ERRORS       ;# list of procedure errors   ({error text} {error text} ... )
global CHECK_CUR_PROC_RESULTS      ;# list of procedure results  (0 -1 -2 0 ...)
global CHECK_GUILTY_RUNLEVELS      ;# enabled runlevels
global CHECK_MAX_LEVEL             ;# highest level number of all subtests
global CHECK_ACT_PATH              ;# actual checkpath (while switching in menu mode)
global arch_cache                  ;# cache for architecture names (lower case) e.g. solaris64
global upper_arch_cache            ;# cache for architecture names (upper case) e.g. SOLARIS64
global set_error_proc_called       ;# flag
global open_spawn_buffer           ;# buffer for open_spawn_process arguments
global have_ssh_access_state       ;# global variable for have_ssh_access procedure (remember state)
global check_timestamp             ;# for use in is_job_running
global CHECK_MAILS_SENT            ;# counter for send mails
set CHECK_MAILS_SENT 0
global CHECK_ENABLE_MAIL           ;# is mail sending enabled
set CHECK_ENABLE_MAIL 1
global CHECK_ADMIN_USER_SYSTEM     ;# if no root account is possible
set CHECK_ADMIN_USER_SYSTEM 0
set check_timestamp [timestamp]
set have_ssh_access_state -1

set CHECK_ROOT_PASSWORD    "none"
set CHECK_GUILTY_RUNLEVELS "0"
set CHECK_DO_SETUP         0
set CHECK_INFORMATION_FILE "check.exp"   ;# this is the filename of each check in different
                                         ;# subdirectories of "checktree"
                                         ;# every file with this name is interpreded as check routine


# debuglevel 0 - none
# debuglevel 1 - more output
# debuglevel 2 - wait for user response (sometimes!)

global CHECK_DEBUG_LEVEL
set CHECK_DEBUG_LEVEL 0 

#
#                                                             max. column:     |
#****** check/debug_puts() ******
#  NAME
#     debug_puts -- ??? 
#
#  SYNOPSIS
#     debug_puts { args } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#     args - ??? 
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
#
proc debug_puts { args } {
   global CHECK_OUTPUT CHECK_DEBUG_LEVEL
   global CHECK_CUR_PROC_NAME CHECK_HOST
   if { $CHECK_DEBUG_LEVEL == 0 } {
      return
   }
   set output ""
   foreach elem $args {
      set output "$output $elem"
   }   

   if { [info exists CHECK_HOST ] == 0 } {
      set CHECK_HOST "unknown"
   }

   puts $CHECK_OUTPUT "\[host: $CHECK_HOST, debug/$CHECK_CUR_PROC_NAME\] $output" 
}


#                                                             max. column:     |
#****** check/get_current_working_dir() ******
# 
#  NAME
#     get_current_working_dir -- ??? 
#
#  SYNOPSIS
#     get_current_working_dir { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc get_current_working_dir { } {

  set work_dir [pwd]
  debug_puts "working dir is $work_dir"
  set help0 $work_dir
  while  { 1 } {
     set help [ split $help0 "/" ]
     set help2 [ lreplace $help 0 1 ]
     set new_work_dir "/[ join $help2 "/" ]"
     set help0 $new_work_dir
     set catch_return_1 [ catch { 
         eval exec "ls $work_dir"
     } result_1 ] 

     set catch_return_2 [ catch { 
         eval exec "ls $new_work_dir" 
     } result_2 ]
     if { $catch_return_1 == 0 && $catch_return_2 == 0} {
        if { [ string compare $result_1 $result_2 ] == 0 } {
           # possibly mounted directory try to create a file
           set f_name "testsuite_test_[timestamp]"
           set catch_return_3 [ catch { 
              eval exec "touch $work_dir/$f_name" 
           } result_3 ]
           if { [ file isfile "$new_work_dir/$f_name" ] } {
              puts "--> mount prefix found, using $new_work_dir"
              set work_dir $new_work_dir
           }
           set catch_return_4 [ catch { 
              eval exec "rm $work_dir/$f_name" 
           } result_4 ]
        }
     }
     if { [string compare $help0 "/" ] == 0 } {
        break;
     }
  }
  return $work_dir 
}

set CHECK_CURRENT_WORKING_DIR [get_current_working_dir]
set CHECK_DEFAULTS_FILE    "$CHECK_CURRENT_WORKING_DIR/defaults.sav"

set CHECK_TESTSUITE_ROOT "$CHECK_CURRENT_WORKING_DIR"
set CHECK_CHECKTREE_ROOT "$CHECK_CURRENT_WORKING_DIR/checktree"
set CHECK_MAIN_RESULTS_DIR "$CHECK_CURRENT_WORKING_DIR/results"

#set CHECK_OUTPUT [open /dev/null "w"]
set CHECK_OUTPUT stdout 


# setup_names  (for edit setup file)
global CHECK_SETUP_NAMES


global CHECK_CURRENT_SETTINGS_VERSION
set CHECK_CURRENT_SETTINGS_VERSION "6"
set CHECK_SETTINGS_VERSION $CHECK_CURRENT_SETTINGS_VERSION

set CHECK_SETUP_NAMES(index) "settings_version"
set CHECK_SETUP_NAMES(settings_version) "CHECK_SETTINGS_VERSION"

lappend CHECK_SETUP_NAMES(index) "testsuite_root_directory"
set CHECK_SETUP_NAMES(testsuite_root_directory) "CHECK_TESTSUITE_ROOT"

lappend CHECK_SETUP_NAMES(index) "testsuite_config_dir"
set CHECK_SETUP_NAMES(testsuite_config_dir) "CHECK_CONFIG_DIR"

lappend CHECK_SETUP_NAMES(index) "checktree_root_directory"
set CHECK_SETUP_NAMES(checktree_root_directory) "CHECK_CHECKTREE_ROOT"

lappend CHECK_SETUP_NAMES(index) "results_root_directory"
set CHECK_SETUP_NAMES(results_root_directory) "CHECK_MAIN_RESULTS_DIR"

lappend CHECK_SETUP_NAMES(index) "qmaster_host"
set CHECK_SETUP_NAMES(qmaster_host) "CHECK_CORE_MASTER"

lappend CHECK_SETUP_NAMES(index) "list_of_execution_hosts"
set CHECK_SETUP_NAMES(list_of_execution_hosts) "CHECK_CORE_EXECD"

lappend CHECK_SETUP_NAMES(index) "processors_on_each_execution_host"
set CHECK_SETUP_NAMES(processors_on_each_execution_host) "CHECK_CORE_PROCESSORS"

lappend CHECK_SETUP_NAMES(index) "list_of_submit_only_hosts"
set CHECK_SETUP_NAMES(list_of_submit_only_hosts) "CHECK_SUBMIT_ONLY_HOSTS"

lappend CHECK_SETUP_NAMES(index) "commd_portnumber"
set CHECK_SETUP_NAMES(commd_portnumber) "CHECK_COMMD_PORT"

lappend CHECK_SETUP_NAMES(index) "product_type"
set CHECK_SETUP_NAMES(product_type) "CHECK_PRODUCT_TYPE"

lappend CHECK_SETUP_NAMES(index) "product_feature"
set CHECK_SETUP_NAMES(product_feature) "CHECK_PRODUCT_FEATURE"

lappend CHECK_SETUP_NAMES(index) "product_root_directory"
set CHECK_SETUP_NAMES(product_root_directory) "CHECK_PRODUCT_ROOT"

lappend CHECK_SETUP_NAMES(index) "source_root_directory"
set CHECK_SETUP_NAMES(source_root_directory) "CHECK_SOURCE_DIR"

lappend CHECK_SETUP_NAMES(index) "cvs_hostname"
set CHECK_SETUP_NAMES(cvs_hostname) "CHECK_SOURCE_HOSTNAME"

lappend CHECK_SETUP_NAMES(index) "cvs_release_tag"
set CHECK_SETUP_NAMES(cvs_release_tag) "CHECK_SOURCE_CVS_RELEASE"

lappend CHECK_SETUP_NAMES(index) "list_of_compile_hosts"
set CHECK_SETUP_NAMES(list_of_compile_hosts) "CHECK_SOURCE_COMPILE_HOSTS"

lappend CHECK_SETUP_NAMES(index) "aimk_compile_options"
set CHECK_SETUP_NAMES(aimk_compile_options) "CHECK_AIMK_COMPILE_OPTIONS"

lappend CHECK_SETUP_NAMES(index) "dist_install_options"
set CHECK_SETUP_NAMES(dist_install_options) "CHECK_DIST_INSTALL_OPTIONS"

lappend CHECK_SETUP_NAMES(index) "qmaster_install_options"
set CHECK_SETUP_NAMES(qmaster_install_options) "CHECK_QMASTER_INSTALL_OPTIONS"

lappend CHECK_SETUP_NAMES(index) "execd_install_options"
set CHECK_SETUP_NAMES(execd_install_options) "CHECK_EXECD_INSTALL_OPTIONS"

lappend CHECK_SETUP_NAMES(index) "dns_domain_name"
set CHECK_SETUP_NAMES(dns_domain_name) "CHECK_DNS_DOMAINNAME"

lappend CHECK_SETUP_NAMES(index) "user_environment"
set CHECK_SETUP_NAMES(user_environment) "CHECK_REMOTE_ENVIRONMENT"

lappend CHECK_SETUP_NAMES(index) "first_foreign_system_username"
set CHECK_SETUP_NAMES(first_foreign_system_username) "CHECK_FIRST_FOREIGN_SYSTEM_USER"

lappend CHECK_SETUP_NAMES(index) "second_foreign_system_username"
set CHECK_SETUP_NAMES(second_foreign_system_username) "CHECK_SECOND_FOREIGN_SYSTEM_USER"

lappend CHECK_SETUP_NAMES(index) "first_foreign_system_groupname"
set CHECK_SETUP_NAMES(first_foreign_system_groupname) "CHECK_FIRST_FOREIGN_SYSTEM_GROUP"

lappend CHECK_SETUP_NAMES(index) "second_foreign_system_groupname"
set CHECK_SETUP_NAMES(second_foreign_system_groupname) "CHECK_SECOND_FOREIGN_SYSTEM_GROUP"

lappend CHECK_SETUP_NAMES(index) "default_domain"
set CHECK_SETUP_NAMES(default_domain) "CHECK_DEFAULT_DOMAIN"

lappend CHECK_SETUP_NAMES(index) "mailx_hostname"
set CHECK_SETUP_NAMES(mailx_hostname) "CHECK_MAILX_HOST"

lappend CHECK_SETUP_NAMES(index) "mail_to"
set CHECK_SETUP_NAMES(mail_to) "CHECK_REPORT_EMAIL_TO"

lappend CHECK_SETUP_NAMES(index) "mail_cc"
set CHECK_SETUP_NAMES(mail_cc) "CHECK_REPORT_EMAIL_CC"

lappend CHECK_SETUP_NAMES(index) "enable_error_mails"
set CHECK_SETUP_NAMES(enable_error_mails) "CHECK_SEND_ERROR_MAILS"

lappend CHECK_SETUP_NAMES(index) "max_run_all_mails"
set CHECK_SETUP_NAMES(max_run_all_mails) "CHECK_MAX_ERROR_MAILS"


lappend CHECK_SETUP_NAMES(index) "use_ssh"
set CHECK_SETUP_NAMES(use_ssh) "CHECK_USE_SSH"


# some useful functions for test implementation



# 
#                                                             max. column:     |
#****** check/add_proc_error() ******
# 
#  NAME
#     add_proc_error -- append testsuite error message
#
#  SYNOPSIS
#     add_proc_error { proc_name result text } 
#
#  FUNCTION
#     This procedure adds a new error to the global error arrays for the global 
#     procedures.  
#
#     So a test programmer doesn't have to set the error states after calling 
#     a global procedure which uses add_proc_error. Each global procedure 
#     set the error state by itself. 
#
#     The test run will report ALL global errors and doesn't set the test run 
#     to a correct state if such an error is reported. 
#
#     Some global procedures have an optional flag to switch off the global 
#     error report. For some cases it is necessary to turn off the error 
#     reporting. (e.g. forced timeout test)
#
#  INPUTS
#     proc_name - name of the calling procedure
#     result    - error state (e.g. -1)
#     text      - error text (e.g. "open file xxx failed)
#
#  RESULT
#     no result
#
#  SEE ALSO
#     check/set_error
#*******************************
proc add_proc_error { proc_name result text } {
   global CHECK_CUR_PROC_ERRORS CHECK_CUR_PROC_RESULTS CHECK_CUR_PROC_NAME CHECK_OUTPUT check_name CHECK_TESTSUITE_ROOT
   global CHECK_ARCH CHECK_HOST CHECK_PRODUCT_ROOT CHECK_ACT_LEVEL CHECK_CORE_MASTER CHECK_CORE_EXECD

   lappend CHECK_CUR_PROC_RESULTS $result
   set new_error ""
   lappend new_error "$proc_name|$text|$check_name|$CHECK_CUR_PROC_NAME"
   lappend CHECK_CUR_PROC_ERRORS $new_error

   show_proc_error $result $new_error
}

#                                                             max. column:     |
#****** check/show_proc_error() ******
# 
#  NAME
#     show_proc_error -- ??? 
#
#  SYNOPSIS
#     show_proc_error { result new_error } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#     result    - ??? 
#     new_error - ??? 
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc show_proc_error { result new_error } {
   global CHECK_CUR_PROC_ERRORS CHECK_CUR_PROC_RESULTS CHECK_CUR_PROC_NAME CHECK_OUTPUT check_name CHECK_TESTSUITE_ROOT
   global CHECK_ARCH CHECK_HOST CHECK_PRODUCT_ROOT CHECK_ACT_LEVEL CHECK_CORE_MASTER CHECK_CORE_EXECD
   global CHECK_SEND_ERROR_MAILS

   if { $result != 0 } {
      set category "error"
      if { $result == -3 } {
         set category "unsupported test warning"
      }
      puts $CHECK_OUTPUT ">>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>"
      puts $CHECK_OUTPUT ">>> $category"
      puts $CHECK_OUTPUT ">>> runlevel    : \"[get_run_level_name $CHECK_ACT_LEVEL]\", ($CHECK_ACT_LEVEL)"
      puts $CHECK_OUTPUT ">>> "
      set error_output [ create_error_message $new_error ]
      puts $CHECK_OUTPUT $error_output 


      flush $CHECK_OUTPUT

      if { $CHECK_SEND_ERROR_MAILS == 1 } {
         append mail_body "\nDate                     : [exec date]\n"
         append mail_body "testsuite root directory : \"$CHECK_TESTSUITE_ROOT\"\n"
         append mail_body "check host               : \"$CHECK_HOST\"\n"
         append mail_body "architecture             : \"$CHECK_ARCH\"\n"
         append mail_body "product version          : \"[get_version_info]\"\n"
         append mail_body "product root directory   : \"$CHECK_PRODUCT_ROOT\"\n"
         append mail_body "master host              : \"$CHECK_CORE_MASTER\"\n"
         append mail_body "execution hosts          : \"$CHECK_CORE_EXECD\"\n\n"
         append mail_body "-----------------------------------------------------\n\n"
         append mail_body "check_name  : \"$check_name\"\n"
         append mail_body "category    : \"$category\"\n"
         append mail_body "runlevel    : \"[get_run_level_name $CHECK_ACT_LEVEL]\", ($CHECK_ACT_LEVEL)\n"
         append mail_body $error_output
         catch {
            foreach level "1 2 3 4" {
               upvar $level expect_out out
               if {[info exists out]} {
                  append mail_body "----- expect buffer in upper level $level --------\n"
                  foreach i [array names out] {
                     append mail_body "$i:\t$out($i)\n"
                  }
               }
            }
         }
         mail_report "testsuite $category - $check_name" $mail_body
      }
    }
}

#                                                             max. column:     |
#****** check/create_error_message() ******
# 
#  NAME
#     create_error_message -- ??? 
#
#  SYNOPSIS
#     create_error_message { error_array } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#     error_array - ??? 
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc create_error_message { error_array} {

  set err_string [lindex $error_array 0]
  set err_complete [ split $err_string "|" ]
  set err_procedure [ lindex $err_complete 0 ]
  set err_text      [ lindex $err_complete 1 ]
  set err_checkname [ lindex $err_complete 2 ]
  set err_calledby  [ lindex $err_complete 3 ]

  set output ">>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>\n"
  append output ">>> check \"$err_checkname\", procedure \"$err_procedure\"\n"
  if { [ string compare $err_calledby $err_procedure ] != 0 } {
     append output ">>> called from \"$err_calledby\":\n"
  }
  append output "\"$err_text\"\n"
  append output ">>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>\n\n"

  return $output
}

# This procedure tries to get a ssh (secure shell) connection to each execd host
# from the cluster. The result of this test is stored in a global variable so
# the next call will not cause the connection test again.
# It returns 1 if ssh access is given, if not 0.
#                                                             max. column:     |
#****** check/have_ssh_access() ******
# 
#  NAME
#     have_ssh_access -- is ssh accessable ?
#
#  SYNOPSIS
#     have_ssh_access { } 
#
#  FUNCTION
#     This procedure tries to get a ssh (secure shell) connection to each execd 
#     host from the cluster. The result of this test is stored in a global 
#     variable so the next call will not cause the connection test again.
#
#  INPUTS
#
#  RESULT
#     0: no ssh access
#     1: ok
#
#  SEE ALSO
#     ???/???
#*******************************
proc have_ssh_access {} {
  global CHECK_CORE_EXECD open_spawn_buffer CHECK_OUTPUT have_ssh_access_state CHECK_USE_SSH

  if { $have_ssh_access_state != -1 } {
     return $have_ssh_access_state
  }

  if { $CHECK_USE_SSH == 0 } {
     set have_ssh_access_state 0
     return $have_ssh_access_state
  }

  log_user 0
  set have_complete_access 1
  foreach elem $CHECK_CORE_EXECD { 
 
     set catch_state [ catch {

        set id [ open_spawn_process "ssh" "-l" "root" "$elem" "id"]
        set sp_id [ lindex $id 1 ] 
 
        set timeout 30
        set end_val 0
        set have_access 0
        while { $end_val == 0} {
           log_user 0
           expect {
               -i $sp_id full_buffer {
                  add_proc_error "have_ssh_access" "-1" "buffer overflow please increment CHECK_EXPECT_MATCH_MAX_BUFFER value"
               }

               -i $sp_id "uid*0*root" {
                  log_user 1 
                  puts $CHECK_OUTPUT "--> having ssh access to host $elem"
                  set end_val 1
                  set have_access 1
               }
               -i $sp_id "assword" {
                  set end_val 1
               }
               -i $sp_id timeout {
                  log_user 1 
                  puts $CHECK_OUTPUT "--> timeout waiting to get root access"
                  set end_val 1
               }
               -i $sp_id eof {
                  log_user 1 
                  puts $CHECK_OUTPUT "--> end of file dedected"
                  set end_val 1
               }
           }
        }
        set log_user 0
        close_spawn_process $id 1
        if { $have_access != 1 } {
            log_user 1
            set have_complete_access 0
            puts $CHECK_OUTPUT "--> no ssh access to host $elem"
        }
     } ] ;# end of chatch
     if { $catch_state != 0} {
        puts $CHECK_OUTPUT "--> no ssh access to host $elem (maybe no ssh installed)"
        set have_complete_access 0
     }
  }
  log_user 1
  set have_ssh_access_state $have_complete_access
  return $have_complete_access
}

# This procedure reads in the root password from stdin. If the root
# password is not used ( ssh access garanted) the procedure returns
# immediately.
#                                                             max. column:     |
#****** check/set_root_passwd() ******
# 
#  NAME
#     set_root_passwd -- ask user for root password
#
#  SYNOPSIS
#     set_root_passwd { } 
#
#  FUNCTION
#     This procedure reads in the root password from stdin. If the root password 
#     is not used ( ssh access garanted) the procedure returns immediately.
#     The root password is tested with an id call as root on the local machine.
#
#  INPUTS
#
#  SEE ALSO
#     check/have_root_passwd
#     check/get_root_passwd
#*******************************
proc set_root_passwd {} {
  global CHECK_ROOT_PASSWORD CHECK_OUTPUT CHECK_HOST CHECK_ADMIN_USER_SYSTEM

  if { $CHECK_ADMIN_USER_SYSTEM != 0 } {
     puts $CHECK_OUTPUT "--> running without root access"
     set CHECK_ROOT_PASSWORD "none"
     return
  }
  set result "no password" 
  puts "root access needed, please enter root password: "
  if { [have_ssh_access] == 0 } {
     stty -echo
     gets stdin CHECK_ROOT_PASSWORD
     stty echo
     if { [ string compare "" $CHECK_ROOT_PASSWORD ] == 0 } {
        set CHECK_ROOT_PASSWORD "none"
        puts $CHECK_OUTPUT "--> root password not set!"
     } else {
        puts $CHECK_OUTPUT "--> testing root access ..."
        set result [ start_remote_prog $CHECK_HOST "root" "id" "" ]
     }
  }
  
  if {[string first "root" $result] < 0 } {
     puts $CHECK_OUTPUT "--> id as root output:\n$result"
     puts $CHECK_OUTPUT "--> no root access"
     puts $CHECK_OUTPUT "enter \"noroot\" to start testsuite without root access\nOR\npress >ENTER< to type in the root password again"
     gets stdin user_input
     if { [ string compare "noroot" $user_input ] != 0 } {
         set_root_passwd
         return
     } else { 
         set CHECK_ADMIN_USER_SYSTEM 1

     }
  } else {
     puts $CHECK_OUTPUT "--> id as root output:\n$result"
  }
 

  puts $CHECK_OUTPUT "starting now ..."
  flush $CHECK_OUTPUT
}


#                                                             max. column:     |
#****** check/have_root_passwd() ******
# 
#  NAME
#     have_root_passwd -- is root password available ?
#
#  SYNOPSIS
#     have_root_passwd { } 
#
#  FUNCTION
#     test if root password was typed in 
#
#  INPUTS
#     0  : root password should be ok
#     -1 : no root access
#  RESULT
#     
#
#  SEE ALSO
#     check/set_root_passwd
#     check/get_root_passwd
#*******************************
proc have_root_passwd {} {
  global CHECK_ROOT_PASSWORD

  if { [have_ssh_access] == 1 } {
     puts "--> ssh access ok" 
     return 0
  }

  if { [string compare "none" $CHECK_ROOT_PASSWORD ] == 0 } {
     puts "you have no ssh access and no root password"
     return -1
  }
  return 0
}

# This procedure returns the root password, typed in by the user.
#                                                             max. column:     |
#****** check/get_root_passwd() ******
# 
#  NAME
#     get_root_passwd -- return root password 
#
#  SYNOPSIS
#     get_root_passwd { } 
#
#  FUNCTION
#     This procedure returns the root password, typed in by the user.
#
#  INPUTS
#
#  RESULT
#     string with root password
#
#  SEE ALSO
#     check/have_root_passwd
#     check/set_root_passwd
#*******************************
proc get_root_passwd {} {
  global CHECK_ROOT_PASSWORD
  
  if { [ string compare "none" $CHECK_ROOT_PASSWORD ] == 0 } {
     add_proc_error "get_root_passwd" "-2" "root password not set"
  }

  return $CHECK_ROOT_PASSWORD    
}





#                                                  max. column:     |
#****** check/mail_report() ******
# 
#  NAME
#     mail_report -- send mail
#
#  SYNOPSIS
#     mail_report { subject body } 
#
#  FUNCTION
#     This procedure sends an e-mail to the e-mail-address configured
#     with the global variables CHECK_REPORT_EMAIL_CC  and 
#     CHECK_REPORT_EMAIL_TO. Subject and body of the mail is taken 
#     from the parameters subject and body.
#
#  INPUTS
#     subject - e-mail subject text
#     body    - e-mail body text
#
#  SEE ALSO
#     check/send_mail
#*******************************
proc mail_report { subject body } {
  global CHECK_REPORT_EMAIL_TO CHECK_REPORT_EMAIL_CC CHECK_OUTPUT

  if { [string compare $CHECK_REPORT_EMAIL_TO "none"] == 0 } {
     puts $CHECK_OUTPUT "--> mail_report - no mail address"
     return
  }

  set mail_cc ""
  if { [string compare $CHECK_REPORT_EMAIL_CC "none"] != 0 } {
      set mail_cc $CHECK_REPORT_EMAIL_CC
  }

  send_mail $CHECK_REPORT_EMAIL_TO $mail_cc $subject $body 
}



#                                                             max. column:     |
#****** check/send_mail() ******
# 
#  NAME
#     send_mail -- send mail  
#
#  SYNOPSIS
#     send_mail { address cc subject body } 
#
#  FUNCTION
#     This procedure calls the mailx binary by using remote shell to 
#     send an e-mail. 
#
#  INPUTS
#     address - e-mail address
#     cc      - e-mail CC address
#     subject - e-mail subject text  
#     body    - e-mail body text 
#
#  SEE ALSO
#     check/mail_report
#*******************************
proc send_mail { address cc subject body } {

  global CHECK_TESTSUITE_ROOT CHECK_MAILX_HOST CHECK_OUTPUT
  global CHECK_MAILS_SENT CHECK_ENABLE_MAIL
  global write_mail_to_file CHECK_MAIL_OUTPUT_FILE


  if { $write_mail_to_file != 0 } {
     set fd [ open $CHECK_MAIL_OUTPUT_FILE "a" ]
     puts $fd "-=*************************************************************=-"
     puts $fd "Grid Engine Version: [get_version_info]"
     puts $fd "Subject            : $subject"
     puts $fd "-=*************************************************************=-"
     puts $fd "$body"
     puts $fd "-=*=-"
     flush $fd
     close $fd 
     puts $CHECK_OUTPUT "Added entry in mail output file $CHECK_MAIL_OUTPUT_FILE"
     return
  }

  set new_subject "[get_version_info] - $subject"

  if { $CHECK_ENABLE_MAIL != 1 } {
     puts $CHECK_OUTPUT "mail sending disabled, mails sent: $CHECK_MAILS_SENT"
     puts $CHECK_OUTPUT "mail new_subject: $new_subject"
     puts $CHECK_OUTPUT "mail body:"
     puts $CHECK_OUTPUT "$body"
     return
  }


  file delete "$CHECK_TESTSUITE_ROOT/mailbody_testsuite_tmp" 

  set output_file [ open "$CHECK_TESTSUITE_ROOT/mailbody_testsuite_tmp" "w"]
  puts $output_file $body
  flush $output_file
  close $output_file

  set file_size 0
   while { $file_size == 0 } {
      catch { set file_size [file size "$CHECK_TESTSUITE_ROOT/mailbody_testsuite_tmp"]}
      if { $file_size == 0 } { 
         puts $CHECK_OUTPUT "--> file size of \"$CHECK_TESTSUITE_ROOT/mailbody_testsuite_tmp\": $file_size ; waiting for filesize > 0"
         sleep 1
      }
   }



  catch { exec "touch" "$CHECK_TESTSUITE_ROOT/mailbody_testsuite_tmp" } result
  catch { exec "chmod" "0755" "$CHECK_TESTSUITE_ROOT/mailbody_testsuite_tmp" } result

  if { [string compare $cc "none"] != 0 } {
     set mail_command "mailx -s \"$new_subject\" -c \"$cc\" \"$address\" < \"$CHECK_TESTSUITE_ROOT/mailbody_testsuite_tmp\""
  } else {
     set mail_command "mailx -s \"$new_subject\" \"$address\" < \"$CHECK_TESTSUITE_ROOT/mailbody_testsuite_tmp\""
  }
  set catch_result [ catch { 
    exec rsh $CHECK_MAILX_HOST "$mail_command" 
  } mail_output ]

  file delete "$CHECK_TESTSUITE_ROOT/mailbody_testsuite_tmp" 

  if { $catch_result != 0 } {
     puts $CHECK_OUTPUT "--> send_mail - could not send mail:\n$mail_output"
  } else {
     puts $CHECK_OUTPUT "--> send_mail - mail sent to $address"
     incr CHECK_MAILS_SENT 1
  }

}




# This procedure simply sets the global variables check_errno 
# and check_errstr to the given parameters. It 
#                                                             max. column:     |
#****** check/set_error() ******
# 
#  NAME
#     set_error -- set error for current check 
#
#  SYNOPSIS
#     set_error { erno errtext } 
#
#  FUNCTION
#     This procedure simply sets the global variables check_errno and 
#     check_errstr to the given parameters. Beyond it the procedure 
#     add_proc_error is called in order to append the errors to the global error 
#     list.
#
#  INPUTS
#     erno    - integer
#               0  = no error
#               -1 = error, but the check will run till end
#               -2 = error, the current check will stop (no further check function
#                    is called)
#               -3 = warning, (e.g. test can not run on this host)
#
#     errtext - short error description
#
#
#  EXAMPLE
#     set_error 0 "ok"  ;# Test is "OK"
#
#  SEE ALSO
#     check/add_proc_error
#*******************************
proc set_error {erno errtext} {
  global check_errno 
  global check_errstr CHECK_CUR_PROC_RESULTS
  global set_error_proc_called

  set set_error_proc_called 1
  set check_errno $erno
  set check_errstr $errtext

  add_proc_error "set_error" $erno $errtext

  if { $check_errno == 0 } {
    foreach element $CHECK_CUR_PROC_RESULTS {
      if { $element != 0 && $element != -3 } {   ;# there was a former error in this test !!
         set check_errno -1
         set check_errstr "error!"
      }
    }
  }
}


#                                                             max. column:     |
#****** check/save_defaults() ******
# 
#  NAME
#     save_defaults -- ??? 
#
#  SYNOPSIS
#     save_defaults { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc save_defaults {} {
  global CHECK_SETTINGS_VERSION
  global CHECK_CHECKTREE_ROOT CHECK_CORE_MASTER CHECK_CORE_EXECD 
  global CHECK_CORE_PROCESSORS CHECK_SUBMIT_ONLY_HOSTS 
  global CHECK_COMMD_PORT CHECK_TESTSUITE_ROOT
  global CHECK_MAIN_RESULTS_DIR CHECK_PRODUCT_TYPE 
  global CHECK_PRODUCT_FEATURE CHECK_PRODUCT_ROOT CHECK_DEFAULTS_FILE
  global CHECK_SOURCE_DIR CHECK_SOURCE_HOSTNAME CHECK_SOURCE_COMPILE_HOSTS
  global CHECK_AIMK_COMPILE_OPTIONS CHECK_DIST_INSTALL_OPTIONS
  global CHECK_QMASTER_INSTALL_OPTIONS CHECK_EXECD_INSTALL_OPTIONS
  global CHECK_DNS_DOMAINNAME CHECK_REMOTE_ENVIRONMENT
  global CHECK_FIRST_FOREIGN_SYSTEM_USER CHECK_SECOND_FOREIGN_SYSTEM_USER 
  global CHECK_FIRST_FOREIGN_SYSTEM_GROUP CHECK_SECOND_FOREIGN_SYSTEM_GROUP
  global CHECK_DEFAULT_DOMAIN
  global CHECK_MAILX_HOST 
  global CHECK_REPORT_EMAIL_TO CHECK_REPORT_EMAIL_CC  CHECK_USE_SSH CHECK_SOURCE_CVS_RELEASE
  global CHECK_CONFIG_DIR CHECK_SEND_ERROR_MAILS CHECK_MAX_ERROR_MAILS

  set data ""
  lappend data $CHECK_SETTINGS_VERSION
  lappend data $CHECK_TESTSUITE_ROOT
  lappend data $CHECK_CHECKTREE_ROOT
  lappend data $CHECK_CORE_MASTER
  lappend data $CHECK_CORE_EXECD
  lappend data $CHECK_CORE_PROCESSORS
  lappend data $CHECK_SUBMIT_ONLY_HOSTS
  lappend data $CHECK_COMMD_PORT
  lappend data $CHECK_MAIN_RESULTS_DIR
  lappend data $CHECK_PRODUCT_TYPE
  lappend data $CHECK_PRODUCT_FEATURE
  lappend data $CHECK_PRODUCT_ROOT 
  lappend data $CHECK_SOURCE_DIR 
  lappend data $CHECK_SOURCE_HOSTNAME
  lappend data $CHECK_SOURCE_COMPILE_HOSTS
  lappend data $CHECK_AIMK_COMPILE_OPTIONS
  lappend data $CHECK_DIST_INSTALL_OPTIONS
  lappend data $CHECK_QMASTER_INSTALL_OPTIONS
  lappend data $CHECK_EXECD_INSTALL_OPTIONS 
  lappend data $CHECK_DNS_DOMAINNAME
  lappend data $CHECK_REMOTE_ENVIRONMENT
  lappend data $CHECK_FIRST_FOREIGN_SYSTEM_USER
  lappend data $CHECK_SECOND_FOREIGN_SYSTEM_USER
  lappend data $CHECK_FIRST_FOREIGN_SYSTEM_GROUP
  lappend data $CHECK_SECOND_FOREIGN_SYSTEM_GROUP
  lappend data $CHECK_DEFAULT_DOMAIN
  lappend data $CHECK_MAILX_HOST
  lappend data $CHECK_REPORT_EMAIL_TO
  lappend data $CHECK_REPORT_EMAIL_CC
  lappend data $CHECK_SEND_ERROR_MAILS
  lappend data $CHECK_MAX_ERROR_MAILS
  lappend data $CHECK_USE_SSH
  lappend data $CHECK_SOURCE_CVS_RELEASE 
  lappend data $CHECK_CONFIG_DIR

  set output [open "$CHECK_DEFAULTS_FILE" "w"]  
  puts $output "$data"
  close $output
  get_version_info
  debug_puts "saved $data"
}

#                                                             max. column:     |
#****** check/source_procedures() ******
# 
#  NAME
#     source_procedures -- ??? 
#
#  SYNOPSIS
#     source_procedures { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc source_procedures {} {
  global CHECK_TESTSUITE_ROOT CHECK_OUTPUT CHECK_TCL_SCRIPTFILE_DIR be_quiet
  puts $CHECK_OUTPUT "------ SOURCEING TCL SCRIPT FILES --------------"
  source $CHECK_TESTSUITE_ROOT/$CHECK_TCL_SCRIPTFILE_DIR/file_procedures.tcl
  set tcl_files [ get_file_names "$CHECK_TESTSUITE_ROOT/$CHECK_TCL_SCRIPTFILE_DIR" "*.tcl" ]
  foreach elem $tcl_files {
     if { $be_quiet == 0 } { 
        puts $CHECK_OUTPUT "--> source tcl file \"$elem\""
     }
     source $CHECK_TESTSUITE_ROOT/$CHECK_TCL_SCRIPTFILE_DIR/$elem
  }   
  puts $CHECK_OUTPUT "------ SOURCEING TCL SCRIPT FILES DONE ---------"
}

#                                                             max. column:     |
#****** check/edit_defaults() ******
# 
#  NAME
#     edit_defaults -- ??? 
#
#  SYNOPSIS
#     edit_defaults { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc edit_defaults {} {
  global CHECK_OUTPUT CHECK_DEFAULTS_FILE CHECK_HOST 


  load_defaults
  set return_value -1
  if { [ write_edit_defaults_file "/tmp/testsuite_tmp_defaults_file" ] != 0 } {
     puts $CHECK_OUTPUT "error open file \"$def_edit_file\" for writing"
     return -1
  }

  puts $def_edit_file
  set exit_edit_loop 0
  while { $exit_edit_loop == 0 } {
     set env(EDITOR) [get_binary_path "$CHECK_HOST" "vim"]
     set id [ open_spawn_process [get_binary_path "$CHECK_HOST" "vim"] "$def_edit_file" ]
     
     interact
     set exit_state [ close_spawn_process $id ]
     if { $exit_state == 0 } {
        set read_return [ read_edit_defaults_file "$def_edit_file" ] 
        if { $read_return >= 0 } { 
           if { $read_return == 0 } {
              puts $CHECK_OUTPUT "no changes"
              set return_value 1
              set exit_edit_loop 1
           } else {
              puts $CHECK_OUTPUT "$read_return changes in defaults file \"$CHECK_DEFAULTS_FILE\""
              set return_value 0
              set exit_edit_loop 1
           }
        } else {
           puts $CHECK_OUTPUT "error reading file \"$def_edit_file\""
           puts $CHECK_OUTPUT ">> restarting vi in 10 seconds!"
           puts $CHECK_OUTPUT "\n>> press CTRL-C to abort setup configuration!"
           sleep 10
        }
     }
  }
  if { [ string first "/tmp/testsuite_tmp_defaults_file" $def_edit_file ] >= 0 } {
     file delete $def_edit_file
     puts $CHECK_OUTPUT "file \"$def_edit_file\" deleted!" 
  }
  return $return_value 
}

#                                                             max. column:     |
#****** check/read_edit_defaults_file() ******
# 
#  NAME
#     read_edit_defaults_file -- ??? 
#
#  SYNOPSIS
#     read_edit_defaults_file { filename } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#     filename - ??? 
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc read_edit_defaults_file { filename } {
   global CHECK_SETTINGS_VERSION CHECK_CURRENT_SETTINGS_VERSION
   global CHECK_CHECKTREE_ROOT CHECK_CORE_MASTER CHECK_CORE_EXECD CHECK_CORE_PROCESSORS
   global CHECK_SUBMIT_ONLY_HOSTS CHECK_COMMD_PORT CHECK_TESTSUITE_ROOT
   global CHECK_MAIN_RESULTS_DIR CHECK_PRODUCT_TYPE 
   global CHECK_PRODUCT_FEATURE CHECK_PRODUCT_ROOT CHECK_DEFAULTS_FILE
   global CHECK_SOURCE_DIR CHECK_SOURCE_HOSTNAME CHECK_SOURCE_COMPILE_HOSTS
   global CHECK_AIMK_COMPILE_OPTIONS CHECK_DIST_INSTALL_OPTIONS
   global CHECK_QMASTER_INSTALL_OPTIONS CHECK_EXECD_INSTALL_OPTIONS
   global CHECK_DNS_DOMAINNAME CHECK_REMOTE_ENVIRONMENT
   global CHECK_FIRST_FOREIGN_SYSTEM_USER CHECK_SECOND_FOREIGN_SYSTEM_USER 
   global CHECK_FIRST_FOREIGN_SYSTEM_GROUP CHECK_SECOND_FOREIGN_SYSTEM_GROUP
   global CHECK_DEFAULT_DOMAIN
   global CHECK_MAILX_HOST 
   global CHECK_REPORT_EMAIL_TO CHECK_REPORT_EMAIL_CC  CHECK_USE_SSH CHECK_SOURCE_CVS_RELEASE
   global CHECK_OUTPUT CHECK_SETUP_NAMES CHECK_CONFIG_DIR CHECK_SEND_ERROR_MAILS
   global CHECK_MAX_ERROR_MAILS CHECK_HOST CHECK_USER

   set return_value -1

   set catch_return [ catch {
      set input [open "$filename" "r"]
      while { [gets $input data ] >= 0 } {
        set input_data([lindex $data 0]) [lrange $data 1 end]
      }
      close $input 
      set nr_of_changes 0
      foreach elem $CHECK_SETUP_NAMES(index) {
         if { [info exists input_data($elem)] == 1 } {
            set var_name $CHECK_SETUP_NAMES($elem)
            set old_value [ set $var_name]
            set new_value $input_data($elem)
            if {[ string compare $old_value $new_value ] != 0 } {
               puts $CHECK_OUTPUT "\n$elem old value: \"$old_value\"" 
               puts $CHECK_OUTPUT "$elem new value: \"$new_value\""
               set $var_name $new_value
               incr nr_of_changes 1
            }
         } else {
            puts $CHECK_OUTPUT "\"$elem\" doesn't exist in file \"$filename\" - config error"
            return -1
         }
      }
      set return_value $nr_of_changes
      
   } ]

   
   if { $CHECK_FIRST_FOREIGN_SYSTEM_USER == $CHECK_USER } {
        puts $CHECK_OUTPUT "first_foreign_system_user should not be testsuite user"
        return -1
   }
   if { $CHECK_SECOND_FOREIGN_SYSTEM_USER == $CHECK_USER } {
        puts $CHECK_OUTPUT "second_foreign_system_user should not be testsuite user"
        return -1
   }

   if { $CHECK_SECOND_FOREIGN_SYSTEM_USER == $CHECK_FIRST_FOREIGN_SYSTEM_USER } {
        puts $CHECK_OUTPUT "second_foreign_system_user should not be first_foreign_system_user"
        return -1
   }
 
   if { [string length "$CHECK_PRODUCT_ROOT/bin/solaris64/sge_qmaster"] > 79 } {
        puts $CHECK_OUTPUT "path for product_root_directory is to long"
        return -1
   }

   if { $CHECK_FIRST_FOREIGN_SYSTEM_USER == "" || 
        $CHECK_SECOND_FOREIGN_SYSTEM_USER == "" ||
        $CHECK_FIRST_FOREIGN_SYSTEM_GROUP == "" ||
        $CHECK_SECOND_FOREIGN_SYSTEM_GROUP == "" } {
        puts $CHECK_OUTPUT "no value for foreign system users/groups"
        return -1
   }
   if { [llength $CHECK_FIRST_FOREIGN_SYSTEM_GROUP] != 2 } {
        puts $CHECK_OUTPUT "syntax of \"first_foreign_system_groupname\":"
        puts $CHECK_OUTPUT "main group name[SPACE]secondary group name, e.g. \"users projectA\""  
        return -1
   }

   if { [llength $CHECK_SECOND_FOREIGN_SYSTEM_GROUP] != 1 } {
        puts $CHECK_OUTPUT "syntax of \"second_foreign_system_groupname\":"
        puts $CHECK_OUTPUT "main group name \"projectB\""  
        return -1
   }



   foreach gname $CHECK_FIRST_FOREIGN_SYSTEM_GROUP {
      if { [ string compare $gname $CHECK_SECOND_FOREIGN_SYSTEM_GROUP] == 0 } {
          puts $CHECK_OUTPUT "\"second_foreign_system_groupname\" should not be member of \"first_foreign_system_groupname\""
          return -1
      } 
   }

    

   



   if { [ string compare $CHECK_SETTINGS_VERSION $CHECK_CURRENT_SETTINGS_VERSION ] != 0 } {
        puts $CHECK_OUTPUT "you should not edit the settings_version - config error"
        puts $CHECK_OUTPUT "version should be \"$CHECK_CURRENT_SETTINGS_VERSION\""
        return -1 
   }


   if { ([string compare "sgeee" $CHECK_PRODUCT_TYPE ] != 0) &&
           ([string compare "sge" $CHECK_PRODUCT_TYPE ] != 0) } {
        puts $CHECK_OUTPUT "product_type can only be \"sge\" or \"sgeee\""
        return -1
   }

   if { ([string compare "none"   $CHECK_PRODUCT_FEATURE ] != 0) &&
        ([string compare "secure" $CHECK_PRODUCT_FEATURE ] != 0) } {
        puts $CHECK_OUTPUT "product_feature can only be \"none\" or \"secure\""
        return -1
   }
 
   if { [set_users_environment] == -1 } {
        puts $CHECK_OUTPUT "error setting users environment"
        return -1
   }

   
 
   if { [ string compare $CHECK_CORE_MASTER [lindex $CHECK_CORE_EXECD 0] ] != 0 } {
         set new_core_execd "$CHECK_CORE_MASTER"
         puts $CHECK_OUTPUT "setting qmaster host $CHECK_CORE_MASTER on top of execd list"
         foreach elem $CHECK_CORE_EXECD {
            if {[ string compare -nocase $CHECK_CORE_MASTER $elem ] != 0 } {
               lappend new_core_execd $elem
            }
         }
         set new_proc_numb ""
         foreach elem $new_core_execd {
            set myind 0
            foreach oldname $CHECK_CORE_EXECD {
               if { [ string compare $oldname $elem ] == 0  } {
                  lappend new_proc_numb [lindex $CHECK_CORE_PROCESSORS $myind]
               }
               incr myind 1
            }
         }

         set CHECK_CORE_EXECD $new_core_execd
         set CHECK_CORE_PROCESSORS $new_proc_numb
         puts $CHECK_OUTPUT "new value for execd_list: \"$CHECK_CORE_EXECD\""
         puts $CHECK_OUTPUT "new value for processors_on_each_execution_host: \"$CHECK_CORE_PROCESSORS\""
   }

   if { [llength $CHECK_CORE_EXECD] != [llength $CHECK_CORE_PROCESSORS] } {
         puts $CHECK_OUTPUT "length of \"list_of_execution_hosts\" doesn't match length of \"processors_on_each_execution_host\""
         return -1
   } 

   if {[file isdirectory "$CHECK_MAIN_RESULTS_DIR"] != 1} {
         set catch_return [ catch {  file mkdir "$CHECK_MAIN_RESULTS_DIR" } ]
         if { $catch_return != 0 } {
             puts $CHECK_OUTPUT "could not create directory \"$CHECK_MAIN_RESULTS_DIR\""
             return -1
         } 
   }
   if {[file isdirectory "$CHECK_CONFIG_DIR"] != 1} {
         puts $CHECK_OUTPUT "could not open config directory \"$CHECK_CONFIG_DIR\""
         return -1
   }

   set group1 [lindex $CHECK_FIRST_FOREIGN_SYSTEM_GROUP 0]
   set group2 [lindex $CHECK_FIRST_FOREIGN_SYSTEM_GROUP 1]

   set result [start_remote_prog $CHECK_HOST $CHECK_USER "id" "$CHECK_FIRST_FOREIGN_SYSTEM_USER"]
   puts $CHECK_OUTPUT $result
   if { [string first $group1 $result ] < 0 } {
      puts $CHECK_OUTPUT "first_foreign_system_username ($CHECK_FIRST_FOREIGN_SYSTEM_USER) has not \"$group1\" as main group"
      return -1
   }
   
   set result [start_remote_prog $CHECK_HOST $CHECK_USER "groups" "$CHECK_FIRST_FOREIGN_SYSTEM_USER"]
   puts $CHECK_OUTPUT $result
   if { $prg_exit_state == 0 } {
      if { [string first $group2 $result] < 0 } { 
         puts $CHECK_OUTPUT "first_foreign_system_username ($CHECK_FIRST_FOREIGN_SYSTEM_USER) has not \"$group2\" as secondary group"
         return -1
      }
   }
   set result [start_remote_prog $CHECK_HOST $CHECK_USER "id" "$CHECK_SECOND_FOREIGN_SYSTEM_USER"]
   puts $CHECK_OUTPUT $result
   if { [string first $CHECK_SECOND_FOREIGN_SYSTEM_GROUP $result ] < 0 } {
      puts $CHECK_OUTPUT "first_foreign_system_username ($CHECK_SECOND_FOREIGN_SYSTEM_USER) has not \"$CHECK_SECOND_FOREIGN_SYSTEM_GROUP\" as main group"
      return -1
   }
   

   return $return_value ;# $catch_return
}

#                                                             max. column:     |
#****** check/calc_space() ******
# 
#  NAME
#     calc_space -- ??? 
#
#  SYNOPSIS
#     calc_space { space name } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#     space - ??? 
#     name  - ??? 
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc calc_space {space name} {

  set length [ string length $name ]
  set spaces [ expr ( $space - $length )  ]
  set back ""
  for {set i 0} { $i < $spaces} { incr i 1} {
     set back "$back "
  }
  return $back
}

#                                                             max. column:     |
#****** check/write_edit_defaults_file() ******
# 
#  NAME
#     write_edit_defaults_file -- ??? 
#
#  SYNOPSIS
#     write_edit_defaults_file { filename { unique_file def_edit_file } } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#     filename                      - ??? 
#     { unique_file def_edit_file } - ??? 
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc write_edit_defaults_file { filename { unique_file def_edit_file } } {
  global CHECK_SETTINGS_VERSION
  global CHECK_CHECKTREE_ROOT CHECK_CORE_MASTER CHECK_CORE_EXECD CHECK_CORE_PROCESSORS 
  global CHECK_SUBMIT_ONLY_HOSTS CHECK_COMMD_PORT CHECK_TESTSUITE_ROOT
  global CHECK_MAIN_RESULTS_DIR CHECK_PRODUCT_TYPE 
  global CHECK_PRODUCT_FEATURE  CHECK_PRODUCT_ROOT CHECK_DEFAULTS_FILE
  global CHECK_SOURCE_DIR CHECK_SOURCE_HOSTNAME CHECK_SOURCE_COMPILE_HOSTS
  global CHECK_AIMK_COMPILE_OPTIONS CHECK_DIST_INSTALL_OPTIONS
  global CHECK_QMASTER_INSTALL_OPTIONS CHECK_EXECD_INSTALL_OPTIONS
  global CHECK_DNS_DOMAINNAME CHECK_REMOTE_ENVIRONMENT
  global CHECK_FIRST_FOREIGN_SYSTEM_USER CHECK_SECOND_FOREIGN_SYSTEM_USER 
  global CHECK_FIRST_FOREIGN_SYSTEM_GROUP CHECK_SECOND_FOREIGN_SYSTEM_GROUP
  global CHECK_DEFAULT_DOMAIN
  global CHECK_MAILX_HOST CHECK_CONFIG_DIR CHECK_OUTPUT
  global CHECK_REPORT_EMAIL_TO CHECK_REPORT_EMAIL_CC  CHECK_USE_SSH CHECK_SOURCE_CVS_RELEASE CHECK_SETUP_NAMES
  global CHECK_SEND_ERROR_MAILS CHECK_MAX_ERROR_MAILS

  upvar $unique_file newfilename 
  sleep 2   ;# extra timestamp
  set newfilename "$filename.[timestamp]"
  puts $CHECK_OUTPUT "*write_edit_defaults_file*\nwriting/creating defaults file \"$filename\""
  set c 35
  set catch_return [ catch {
     set fout [ open "$newfilename" "w" ] 
     puts $CHECK_OUTPUT "open file \"$newfilename\" ..."
     foreach elem $CHECK_SETUP_NAMES(index) { 
        puts $CHECK_OUTPUT "writing $elem ..."
        set var_name $CHECK_SETUP_NAMES($elem)
        puts $fout "$elem [calc_space $c $elem] [set $var_name]"
     }
     flush $fout
     close $fout
     puts $CHECK_OUTPUT "closing file"
  } ]

  return $catch_return
}

#                                                             max. column:     |
#****** check/load_defaults() ******
# 
#  NAME
#     load_defaults -- ??? 
#
#  SYNOPSIS
#     load_defaults { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc load_defaults {} {
  global CHECK_SETTINGS_VERSION CHECK_CURRENT_SETTINGS_VERSION CHECK_OUTPUT
  global CHECK_CHECKTREE_ROOT CHECK_CORE_MASTER CHECK_CORE_EXECD 
  global CHECK_CORE_PROCESSORS CHECK_SUBMIT_ONLY_HOSTS CHECK_COMMD_PORT
  global CHECK_MAIN_RESULTS_DIR env CHECK_PRODUCT_TYPE 
  global CHECK_PRODUCT_FEATURE CHECK_PRODUCT_ROOT CHECK_DEFAULTS_FILE CHECK_TESTSUITE_ROOT
  global CHECK_PROTOCOL_DIR CHECK_CURRENT_WORKING_DIR
  global CHECK_SOURCE_DIR CHECK_SOURCE_HOSTNAME CHECK_SOURCE_COMPILE_HOSTS
  global CHECK_AIMK_COMPILE_OPTIONS CHECK_DIST_INSTALL_OPTIONS
  global CHECK_QMASTER_INSTALL_OPTIONS CHECK_EXECD_INSTALL_OPTIONS
  global CHECK_DNS_DOMAINNAME CHECK_REMOTE_ENVIRONMENT
  global CHECK_FIRST_FOREIGN_SYSTEM_USER CHECK_SECOND_FOREIGN_SYSTEM_USER 
  global CHECK_FIRST_FOREIGN_SYSTEM_GROUP CHECK_SECOND_FOREIGN_SYSTEM_GROUP
  global CHECK_DEFAULT_DOMAIN CHECK_DO_SETUP
  global CHECK_MAILX_HOST CHECK_HOST env
  global CHECK_REPORT_EMAIL_TO CHECK_REPORT_EMAIL_CC  CHECK_USE_SSH CHECK_SOURCE_CVS_RELEASE
  global CHECK_PRODUCT_VERSION_NUMBER CHECK_CONFIG_DIR CHECK_GROUP
  global CHECK_SEND_ERROR_MAILS CHECK_MAX_ERROR_MAILS CHECK_JOB_OUTPUT_DIR
  
  set CHECK_TESTSUITE_ROOT "$CHECK_CURRENT_WORKING_DIR"
  set CHECK_CHECKTREE_ROOT "$CHECK_CURRENT_WORKING_DIR/checktree"
  set CHECK_MAIN_RESULTS_DIR "$CHECK_CURRENT_WORKING_DIR/results"
  if { [info exists env(HOST)] } {
     set CHECK_CORE_MASTER     "[set env(HOST)]"
  } else {
     set CHECK_CORE_MASTER "unknown"
  }
  set CHECK_CORE_EXECD      "$CHECK_CORE_MASTER"  
  set CHECK_CORE_PROCESSORS "1"
  set CHECK_SUBMIT_ONLY_HOSTS ""
  set CHECK_COMMD_PORT "7776";
  set CHECK_USER "unknown";
  set CHECK_GROUP "unknown";
  set CHECK_ARCH "unknown";
  if { [info exists env(HOST)] } {
     set CHECK_HOST "[set env(HOST)]";
  } else {
     set CHECK_HOST "unknown"
  }
  set CHECK_PROTOCOL_DIR ""
  set CHECK_PRODUCT_TYPE "sge"
  set CHECK_PRODUCT_FEATURE "none"
  set CHECK_PRODUCT_ROOT "unknown"

  set old_dir [pwd]
  cd ..
  catch { cd source }
  set CHECK_SOURCE_DIR [ get_current_working_dir ]
  cd $old_dir

  if { [info exists env(HOST)] } {
     set CHECK_SOURCE_HOSTNAME "[set env(HOST)]"
  } else {
     set CHECK_SOURCE_HOSTNAME "unknown"
  }
  set CHECK_SOURCE_COMPILE_HOSTS "unknown"
  set CHECK_AIMK_COMPILE_OPTIONS ""
  set CHECK_DIST_INSTALL_OPTIONS "-allall"
  set CHECK_QMASTER_INSTALL_OPTIONS ""
  set CHECK_EXECD_INSTALL_OPTIONS ""
  set CHECK_DNS_DOMAINNAME ""
  set CHECK_REMOTE_ENVIRONMENT ""
  set CHECK_SOURCE_CVS_RELEASE "maintrunc"  
  set CHECK_CONFIG_DIR "$CHECK_CURRENT_WORKING_DIR/demo_config_dir"
  if { [info exists env(HOST)] } {
     set CHECK_MAILX_HOST "[set env(HOST)]"
  } else {
     set CHECK_MAILX_HOST "unknown"
  }
  if {[file isfile "$CHECK_DEFAULTS_FILE"] != 1} {
     source_procedures
     return -1
  }

  set input [open "$CHECK_DEFAULTS_FILE" "r"]
  gets $input data
  close $input 
  set CHECK_SETTINGS_VERSION                 [lindex $data 0]

  if { [ string compare $CHECK_CURRENT_SETTINGS_VERSION $CHECK_SETTINGS_VERSION] != 0  } {
     puts $CHECK_OUTPUT "wrong settings file version: $CHECK_SETTINGS_VERSION"
     puts $CHECK_OUTPUT "expected version: $CHECK_CURRENT_SETTINGS_VERSION"
     set catch_return [ catch { eval exec "cp ${CHECK_DEFAULTS_FILE} ${CHECK_DEFAULTS_FILE}.[timestamp]" } ]
      if { $catch_return == 0 } { 
        if { [ string first "/" $CHECK_SETTINGS_VERSION ] >= 0 } {
            puts $CHECK_OUTPUT "this settings file has no version number -> inserting version number"
            set CHECK_SETTINGS_VERSION "1"
            set CHECK_TESTSUITE_ROOT                   [lindex $data 0]
            set CHECK_CHECKTREE_ROOT                   [lindex $data 1]
            set CHECK_CORE_MASTER                      [lindex $data 2]
            set CHECK_CORE_EXECD                       [lindex $data 3]
            set CHECK_CORE_PROCESSORS                  [lindex $data 4]
            set CHECK_COMMD_PORT                       [lindex $data 5]
            set CHECK_MAIN_RESULTS_DIR                 [lindex $data 6]
            set CHECK_PROTOCOL_DIR $CHECK_MAIN_RESULTS_DIR/protocols
            set CHECK_JOB_OUTPUT_DIR "$CHECK_MAIN_RESULTS_DIR/testsuite_job_outputs"
          
            set CHECK_PRODUCT_TYPE                     [lindex $data 7]
            set CHECK_PRODUCT_ROOT                     [lindex $data 8]
            set CHECK_SOURCE_DIR                       [lindex $data 9]
            set CHECK_SOURCE_HOSTNAME                  [lindex $data 10]
            set CHECK_SOURCE_COMPILE_HOSTS             [lindex $data 11]
            set CHECK_AIMK_COMPILE_OPTIONS             [lindex $data 12]
            set CHECK_DIST_INSTALL_OPTIONS             [lindex $data 13] 
            set CHECK_FIRST_FOREIGN_SYSTEM_USER        [lindex $data 14]
            set CHECK_SECOND_FOREIGN_SYSTEM_USER       [lindex $data 15]
            set CHECK_FIRST_FOREIGN_SYSTEM_GROUP       [lindex $data 16]
            set CHECK_SECOND_FOREIGN_SYSTEM_GROUP      [lindex $data 17]
            set CHECK_DEFAULT_DOMAIN                   [lindex $data 18]
            set CHECK_MAILX_HOST                       [lindex $data 19]
            set CHECK_REPORT_EMAIL_TO                  [lindex $data 20]
            set CHECK_REPORT_EMAIL_CC                  [lindex $data 21]
            set CHECK_SEND_ERROR_MAILS                 [lindex $data 22]
            set CHECK_MAX_ERROR_MAILS                  [lindex $data 23]
            set CHECK_USE_SSH                          [lindex $data 24]
            set CHECK_SOURCE_CVS_RELEASE               [lindex $data 25]
            set CHECK_CONFIG_DIR                       [lindex $data 26]
            wait_for_enter
            source_procedures
            save_defaults 
            set CHECK_DO_SETUP 1 
            setup 
            puts $CHECK_OUTPUT "defaults file updated, please restart the testsuite!"
            exit -1
        }
        if { $CHECK_SETTINGS_VERSION == 1 } {
            puts $CHECK_OUTPUT "this settings file has version number 1 -> upgrading to version 2"
            set CHECK_SETTINGS_VERSION "2"
            set CHECK_TESTSUITE_ROOT                   [lindex $data 1]
            set CHECK_CHECKTREE_ROOT                   [lindex $data 2]
            set CHECK_CORE_MASTER                      [lindex $data 3]
            set CHECK_CORE_EXECD                       [lindex $data 4]
            set CHECK_CORE_PROCESSORS                  [lindex $data 5]
            set CHECK_COMMD_PORT                       [lindex $data 6]
            set CHECK_MAIN_RESULTS_DIR                 [lindex $data 7]
            set CHECK_PROTOCOL_DIR $CHECK_MAIN_RESULTS_DIR/protocols
            set CHECK_JOB_OUTPUT_DIR "$CHECK_MAIN_RESULTS_DIR/testsuite_job_outputs"
          
            set CHECK_PRODUCT_TYPE                     [lindex $data 8]
            set CHECK_PRODUCT_ROOT                     [lindex $data 9]
            set CHECK_SOURCE_DIR                       [lindex $data 10]
            set CHECK_SOURCE_HOSTNAME                  [lindex $data 11]
            set CHECK_SOURCE_COMPILE_HOSTS             [lindex $data 12]
            set CHECK_AIMK_COMPILE_OPTIONS             [lindex $data 13]
            set CHECK_DIST_INSTALL_OPTIONS             [lindex $data 14]
            set CHECK_FIRST_FOREIGN_SYSTEM_USER        [lindex $data 15]
            set CHECK_SECOND_FOREIGN_SYSTEM_USER       [lindex $data 16]
            set CHECK_FIRST_FOREIGN_SYSTEM_GROUP       [lindex $data 17]
            set CHECK_SECOND_FOREIGN_SYSTEM_GROUP      [lindex $data 18]
            set CHECK_DEFAULT_DOMAIN                   [lindex $data 19]
            set CHECK_MAILX_HOST                       [lindex $data 20]
            set CHECK_REPORT_EMAIL_TO                  [lindex $data 21]
            set CHECK_REPORT_EMAIL_CC                  [lindex $data 22]
            set CHECK_SEND_ERROR_MAILS                 [lindex $data 23]
            set CHECK_MAX_ERROR_MAILS                  [lindex $data 24]
            set CHECK_USE_SSH                          [lindex $data 25]
            set CHECK_SOURCE_CVS_RELEASE               [lindex $data 26]
            set CHECK_CONFIG_DIR                       [lindex $data 27]
            
            set CHECK_QMASTER_INSTALL_OPTIONS          ""
            set CHECK_EXECD_INSTALL_OPTIONS            ""
            puts $CHECK_OUTPUT "added qmaster_install_options"
            puts $CHECK_OUTPUT "added execd_install_options"
            wait_for_enter
            source_procedures
            save_defaults 
            set CHECK_DO_SETUP 1 
            setup 
            puts $CHECK_OUTPUT "defaults file updated, please restart the testsuite!"
            exit -1
        }
        if { $CHECK_SETTINGS_VERSION == 2 } {
            puts $CHECK_OUTPUT "this settings file has version number 2 -> upgrading to version 3"
            set CHECK_SETTINGS_VERSION "3"
            set CHECK_TESTSUITE_ROOT                   [lindex $data 1]
            set CHECK_CHECKTREE_ROOT                   [lindex $data 2]
            set CHECK_CORE_MASTER                      [lindex $data 3]
            set CHECK_CORE_EXECD                       [lindex $data 4]
            set CHECK_CORE_PROCESSORS                  [lindex $data 5]
            set CHECK_COMMD_PORT                       [lindex $data 6]
            set CHECK_MAIN_RESULTS_DIR                 [lindex $data 7]
            set CHECK_PROTOCOL_DIR $CHECK_MAIN_RESULTS_DIR/protocols
            set CHECK_JOB_OUTPUT_DIR "$CHECK_MAIN_RESULTS_DIR/testsuite_job_outputs"
           
            set CHECK_PRODUCT_TYPE                     [lindex $data 8]
            set CHECK_PRODUCT_ROOT                     [lindex $data 9]
            set CHECK_SOURCE_DIR                       [lindex $data 10]
            set CHECK_SOURCE_HOSTNAME                  [lindex $data 11]
            set CHECK_SOURCE_COMPILE_HOSTS             [lindex $data 12]
            set CHECK_AIMK_COMPILE_OPTIONS             [lindex $data 13]
            set CHECK_DIST_INSTALL_OPTIONS             [lindex $data 14]
            set CHECK_QMASTER_INSTALL_OPTIONS          [lindex $data 15]      ;# added for version 2
            set CHECK_EXECD_INSTALL_OPTIONS            [lindex $data 16]      ;# added for version 2
            set CHECK_FIRST_FOREIGN_SYSTEM_USER        [lindex $data 17]
            set CHECK_SECOND_FOREIGN_SYSTEM_USER       [lindex $data 18]
            set CHECK_FIRST_FOREIGN_SYSTEM_GROUP       [lindex $data 19]
            set CHECK_SECOND_FOREIGN_SYSTEM_GROUP      [lindex $data 20]
            set CHECK_DEFAULT_DOMAIN                   [lindex $data 21]
            set CHECK_MAILX_HOST                       [lindex $data 22]
            set CHECK_REPORT_EMAIL_TO                  [lindex $data 23]
            set CHECK_REPORT_EMAIL_CC                  [lindex $data 24]
            set CHECK_SEND_ERROR_MAILS                 [lindex $data 25]
            set CHECK_MAX_ERROR_MAILS                  [lindex $data 26]
            set CHECK_USE_SSH                          [lindex $data 27]
            set CHECK_SOURCE_CVS_RELEASE               [lindex $data 28]
            set CHECK_CONFIG_DIR                       [lindex $data 29]
                        
            set CHECK_SUBMIT_ONLY_HOSTS                ""
            puts $CHECK_OUTPUT "added list_of_submit_only_hosts"
            wait_for_enter
            source_procedures
            save_defaults 
            set CHECK_DO_SETUP 1 
            setup 
            puts $CHECK_OUTPUT "defaults file updated, please restart the testsuite!"
            exit -1
        }
        if { $CHECK_SETTINGS_VERSION == 3 } {
            puts $CHECK_OUTPUT "this settings file has version number 3 -> upgrading to version 4"
            set CHECK_SETTINGS_VERSION "4"
            set CHECK_TESTSUITE_ROOT                   [lindex $data 1]
            set CHECK_CHECKTREE_ROOT                   [lindex $data 2]
            set CHECK_CORE_MASTER                      [lindex $data 3]
            set CHECK_CORE_EXECD                       [lindex $data 4]
            set CHECK_CORE_PROCESSORS                  [lindex $data 5]
            set CHECK_SUBMIT_ONLY_HOSTS                [lindex $data 6]      ;# added for version 3
            set CHECK_COMMD_PORT                       [lindex $data 7]
            set CHECK_MAIN_RESULTS_DIR                 [lindex $data 8]
            set CHECK_PROTOCOL_DIR $CHECK_MAIN_RESULTS_DIR/protocols
            set CHECK_JOB_OUTPUT_DIR "$CHECK_MAIN_RESULTS_DIR/testsuite_job_outputs"
          
            set CHECK_PRODUCT_TYPE                     [lindex $data 9]
            set CHECK_PRODUCT_ROOT                     [lindex $data 10]
            set CHECK_SOURCE_DIR                       [lindex $data 11]
            set CHECK_SOURCE_HOSTNAME                  [lindex $data 12]
            set CHECK_SOURCE_COMPILE_HOSTS             [lindex $data 13]
            set CHECK_AIMK_COMPILE_OPTIONS             [lindex $data 14]
            set CHECK_DIST_INSTALL_OPTIONS             [lindex $data 15]
            set CHECK_QMASTER_INSTALL_OPTIONS          [lindex $data 16]      ;# added for version 2
            set CHECK_EXECD_INSTALL_OPTIONS            [lindex $data 17]      ;# added for version 2
            set CHECK_FIRST_FOREIGN_SYSTEM_USER        [lindex $data 18]
            set CHECK_SECOND_FOREIGN_SYSTEM_USER       [lindex $data 19]
            set CHECK_FIRST_FOREIGN_SYSTEM_GROUP       [lindex $data 20]
            set CHECK_SECOND_FOREIGN_SYSTEM_GROUP      [lindex $data 21]
            set CHECK_DEFAULT_DOMAIN                   [lindex $data 22]
            set CHECK_MAILX_HOST                       [lindex $data 23]
            set CHECK_REPORT_EMAIL_TO                  [lindex $data 24]
            set CHECK_REPORT_EMAIL_CC                  [lindex $data 25]
            set CHECK_SEND_ERROR_MAILS                 [lindex $data 26]
            set CHECK_MAX_ERROR_MAILS                  [lindex $data 27]
            set CHECK_USE_SSH                          [lindex $data 28]
            set CHECK_SOURCE_CVS_RELEASE               [lindex $data 29]
            set CHECK_CONFIG_DIR                       [lindex $data 30]

            set CHECK_DNS_DOMAINNAME                   ""
            set CHECK_REMOTE_ENVIRONMENT               ""
            
            puts $CHECK_OUTPUT "added dns_domain_name" 
            puts $CHECK_OUTPUT "added user_environment"
            wait_for_enter
            source_procedures
            save_defaults 
            set CHECK_DO_SETUP 1 
            setup 
            puts $CHECK_OUTPUT "defaults file updated, please restart the testsuite!"
            exit -1
        }
        if { $CHECK_SETTINGS_VERSION == 4 } {
            puts $CHECK_OUTPUT "this settings file has version number 4 -> upgrading to version 5"
            set CHECK_SETTINGS_VERSION "5"
            set CHECK_TESTSUITE_ROOT                   [lindex $data 1]
            set CHECK_CHECKTREE_ROOT                   [lindex $data 2]
            set CHECK_CORE_MASTER                      [lindex $data 3]
            set CHECK_CORE_EXECD                       [lindex $data 4]
            set CHECK_CORE_PROCESSORS                  [lindex $data 5]
            set CHECK_SUBMIT_ONLY_HOSTS                [lindex $data 6]      ;# added for version 3
            set CHECK_COMMD_PORT                       [lindex $data 7]
            set CHECK_MAIN_RESULTS_DIR                 [lindex $data 8]
            set CHECK_PROTOCOL_DIR $CHECK_MAIN_RESULTS_DIR/protocols
            set CHECK_JOB_OUTPUT_DIR "$CHECK_MAIN_RESULTS_DIR/testsuite_job_outputs"
           
            set CHECK_PRODUCT_TYPE                     [lindex $data 9]
            set CHECK_PRODUCT_ROOT                     [lindex $data 10]
            set CHECK_SOURCE_DIR                       [lindex $data 11]
            set CHECK_SOURCE_HOSTNAME                  [lindex $data 12]
            set CHECK_SOURCE_COMPILE_HOSTS             [lindex $data 13]
            set CHECK_AIMK_COMPILE_OPTIONS             [lindex $data 14]
            set CHECK_DIST_INSTALL_OPTIONS             [lindex $data 15]
            set CHECK_QMASTER_INSTALL_OPTIONS          [lindex $data 16]      ;# added for version 2
            set CHECK_EXECD_INSTALL_OPTIONS            [lindex $data 17]      ;# added for version 2
            set CHECK_DNS_DOMAINNAME                   [lindex $data 18]      ;# added for version 4
            set CHECK_REMOTE_ENVIRONMENT               [lindex $data 19]      ;# added for version 4
            set CHECK_FIRST_FOREIGN_SYSTEM_USER        [lindex $data 20]
            set CHECK_SECOND_FOREIGN_SYSTEM_USER       [lindex $data 21]
            set CHECK_FIRST_FOREIGN_SYSTEM_GROUP       [lindex $data 22]
            set CHECK_SECOND_FOREIGN_SYSTEM_GROUP      [lindex $data 23]
            set CHECK_DEFAULT_DOMAIN                   [lindex $data 24]
            set CHECK_MAILX_HOST                       [lindex $data 25]
            set CHECK_REPORT_EMAIL_TO                  [lindex $data 26]
            set CHECK_REPORT_EMAIL_CC                  [lindex $data 27]
            set CHECK_SEND_ERROR_MAILS                 [lindex $data 28]
            set CHECK_MAX_ERROR_MAILS                  [lindex $data 29]
            set CHECK_USE_SSH                          [lindex $data 30]
            set CHECK_SOURCE_CVS_RELEASE               [lindex $data 31]
            set CHECK_CONFIG_DIR                       [lindex $data 32]
           
            puts $CHECK_OUTPUT "updating second_foreign_system_groupname, first_foreign_system_groupname"
            set CHECK_FIRST_FOREIGN_SYSTEM_GROUP  "$CHECK_FIRST_FOREIGN_SYSTEM_GROUP $CHECK_SECOND_FOREIGN_SYSTEM_GROUP"
            set CHECK_SECOND_FOREIGN_SYSTEM_GROUP ""
            wait_for_enter
            source_procedures
            save_defaults 
            set CHECK_DO_SETUP 1
            setup 
            puts $CHECK_OUTPUT "defaults file updated, please restart the testsuite!"
            exit -1
        }
        if { $CHECK_SETTINGS_VERSION == 5 } {
            puts $CHECK_OUTPUT "this settings file has version number 5 -> upgrading to version 6"
            set CHECK_SETTINGS_VERSION "6"
            set CHECK_TESTSUITE_ROOT                   [lindex $data 1]
            set CHECK_CHECKTREE_ROOT                   [lindex $data 2]
            set CHECK_CORE_MASTER                      [lindex $data 3]
            set CHECK_CORE_EXECD                       [lindex $data 4]
            set CHECK_CORE_PROCESSORS                  [lindex $data 5]
            set CHECK_SUBMIT_ONLY_HOSTS                [lindex $data 6]      ;# added for version 3
            set CHECK_COMMD_PORT                       [lindex $data 7]
            set CHECK_MAIN_RESULTS_DIR                 [lindex $data 8]
            set CHECK_PROTOCOL_DIR $CHECK_MAIN_RESULTS_DIR/protocols
            set CHECK_JOB_OUTPUT_DIR "$CHECK_MAIN_RESULTS_DIR/testsuite_job_outputs"
          
            set CHECK_PRODUCT_TYPE                     [lindex $data 9]
            set CHECK_PRODUCT_ROOT                     [lindex $data 10]
            set CHECK_SOURCE_DIR                       [lindex $data 11]
            set CHECK_SOURCE_HOSTNAME                  [lindex $data 12]
            set CHECK_SOURCE_COMPILE_HOSTS             [lindex $data 13]
            set CHECK_AIMK_COMPILE_OPTIONS             [lindex $data 14]
            set CHECK_DIST_INSTALL_OPTIONS             [lindex $data 15]
            set CHECK_QMASTER_INSTALL_OPTIONS          [lindex $data 16]      ;# added for version 2
            set CHECK_EXECD_INSTALL_OPTIONS            [lindex $data 17]      ;# added for version 2
            set CHECK_DNS_DOMAINNAME                   [lindex $data 18]      ;# added for version 4
            set CHECK_REMOTE_ENVIRONMENT               [lindex $data 19]      ;# added for version 4
            set CHECK_FIRST_FOREIGN_SYSTEM_USER        [lindex $data 20]
            set CHECK_SECOND_FOREIGN_SYSTEM_USER       [lindex $data 21]
            set CHECK_FIRST_FOREIGN_SYSTEM_GROUP       [lindex $data 22]
            set CHECK_SECOND_FOREIGN_SYSTEM_GROUP      [lindex $data 23]
            set CHECK_DEFAULT_DOMAIN                   [lindex $data 24]
            set CHECK_MAILX_HOST                       [lindex $data 25]
            set CHECK_REPORT_EMAIL_TO                  [lindex $data 26]
            set CHECK_REPORT_EMAIL_CC                  [lindex $data 27]
            set CHECK_SEND_ERROR_MAILS                 [lindex $data 28]
            set CHECK_MAX_ERROR_MAILS                  [lindex $data 29]
            set CHECK_USE_SSH                          [lindex $data 30]
            set CHECK_SOURCE_CVS_RELEASE               [lindex $data 31]
            set CHECK_CONFIG_DIR                       [lindex $data 32]
                      
            puts $CHECK_OUTPUT "updating new configuration parameter \"product_feature\" ..."
            set CHECK_PRODUCT_FEATURE "none"
            wait_for_enter
            source_procedures
            save_defaults 
            set CHECK_DO_SETUP 1
            setup 
            puts $CHECK_OUTPUT "defaults file updated, please restart the testsuite!"
            exit -1
        }
        
        
        exit -1
      } else {
        puts "could not copy defaults file"
        exit -1 
      }
  }


# latest version:

  set CHECK_TESTSUITE_ROOT                   [lindex $data 1]
  set CHECK_CHECKTREE_ROOT                   [lindex $data 2]
  set CHECK_CORE_MASTER                      [lindex $data 3]
  set CHECK_CORE_EXECD                       [lindex $data 4]
  set CHECK_CORE_PROCESSORS                  [lindex $data 5]
  set CHECK_SUBMIT_ONLY_HOSTS                [lindex $data 6]      ;# added for version 3
  set CHECK_COMMD_PORT                       [lindex $data 7]
  set CHECK_MAIN_RESULTS_DIR                 [lindex $data 8]
  set CHECK_PROTOCOL_DIR $CHECK_MAIN_RESULTS_DIR/protocols
  set CHECK_JOB_OUTPUT_DIR "$CHECK_MAIN_RESULTS_DIR/testsuite_job_outputs"

  set CHECK_PRODUCT_TYPE                     [lindex $data 9]
  set CHECK_PRODUCT_FEATURE                  [lindex $data 10]      ;# added for version 6
  set CHECK_PRODUCT_ROOT                     [lindex $data 11]
  set CHECK_SOURCE_DIR                       [lindex $data 12]
  set CHECK_SOURCE_HOSTNAME                  [lindex $data 13]
  set CHECK_SOURCE_COMPILE_HOSTS             [lindex $data 14]
  set CHECK_AIMK_COMPILE_OPTIONS             [lindex $data 15]
  set CHECK_DIST_INSTALL_OPTIONS             [lindex $data 16]
  set CHECK_QMASTER_INSTALL_OPTIONS          [lindex $data 17]      ;# added for version 2
  set CHECK_EXECD_INSTALL_OPTIONS            [lindex $data 18]      ;# added for version 2
  set CHECK_DNS_DOMAINNAME                   [lindex $data 19]      ;# added for version 4
  set CHECK_REMOTE_ENVIRONMENT               [lindex $data 20]      ;# added for version 4
  set CHECK_FIRST_FOREIGN_SYSTEM_USER        [lindex $data 21]
  set CHECK_SECOND_FOREIGN_SYSTEM_USER       [lindex $data 22]
  set CHECK_FIRST_FOREIGN_SYSTEM_GROUP       [lindex $data 23]
  set CHECK_SECOND_FOREIGN_SYSTEM_GROUP      [lindex $data 24]
  set CHECK_DEFAULT_DOMAIN                   [lindex $data 25]
  set CHECK_MAILX_HOST                       [lindex $data 26]
  set CHECK_REPORT_EMAIL_TO                  [lindex $data 27]
  set CHECK_REPORT_EMAIL_CC                  [lindex $data 28]
  set CHECK_SEND_ERROR_MAILS                 [lindex $data 29]
  set CHECK_MAX_ERROR_MAILS                  [lindex $data 30]
  set CHECK_USE_SSH                          [lindex $data 31]
  set CHECK_SOURCE_CVS_RELEASE               [lindex $data 32]
  set CHECK_CONFIG_DIR                       [lindex $data 33]


  source_procedures
  get_version_info

  return 0
}


proc check_executable_files {  } {

   global CHECK_TESTSUITE_ROOT CHECK_OUTPUT CHECK_SOURCE_DIR

   set filelist ""
   lappend filelist "$CHECK_TESTSUITE_ROOT/scripts/lock.sh"
   lappend filelist "$CHECK_TESTSUITE_ROOT/scripts/remote_submit.sh"
   lappend filelist "$CHECK_TESTSUITE_ROOT/scripts/remote_submit_log.sh"
   lappend filelist "$CHECK_TESTSUITE_ROOT/scripts/remote_tcl_command.sh"
   lappend filelist "$CHECK_TESTSUITE_ROOT/scripts/remotecompile.sh"
   lappend filelist "$CHECK_TESTSUITE_ROOT/scripts/sleeper.sh"
   lappend filelist "$CHECK_TESTSUITE_ROOT/scripts/ssh_progstarter.csh"
   lappend filelist "$CHECK_TESTSUITE_ROOT/checktree/functional/migration/checkpt_job.sh"
   lappend filelist "$CHECK_TESTSUITE_ROOT/checktree/functional/migration/migrate.sh"
   lappend filelist "$CHECK_TESTSUITE_ROOT/checktree/system_tests/clients/qmod/general/qmod_job.sh"
   lappend filelist "$CHECK_TESTSUITE_ROOT/checktree/system_tests/clients/qrsh/qsub_gid.sh"
   lappend filelist "$CHECK_TESTSUITE_ROOT/checktree/system_tests/clients/qrsh/remote_qrsh.sh"
   lappend filelist "$CHECK_TESTSUITE_ROOT/checktree/system_tests/clients/qrsh/sleep_pid.sh"
   lappend filelist "$CHECK_TESTSUITE_ROOT/checktree/system_tests/clients/qrsh/terminate.sh"
   lappend filelist "$CHECK_TESTSUITE_ROOT/checktree/system_tests/clients/qrsh/trap.sh" 
   lappend filelist "$CHECK_TESTSUITE_ROOT/checktree/system_tests/clients/qrsh/ulimit.sh"
   lappend filelist "$CHECK_TESTSUITE_ROOT/checktree/system_tests/qmaster/size/pminiworm.sh"
   lappend filelist "$CHECK_TESTSUITE_ROOT/checktree/system_tests/qmaster/size/flood_sleeper.sh"
   lappend filelist "$CHECK_TESTSUITE_ROOT/checktree/system_tests/qmaster/size/qstat.sh"
   lappend filelist "$CHECK_TESTSUITE_ROOT/checktree/system_tests/qmaster/size/redir_stderr.sh"
   lappend filelist "$CHECK_TESTSUITE_ROOT/checktree/system_tests/qmaster/size/sge_start.sh"
   lappend filelist "$CHECK_SOURCE_DIR/aimk"
   lappend filelist "$CHECK_SOURCE_DIR/dist/examples/jobs/array_submitter.sh"
   lappend filelist "$CHECK_SOURCE_DIR/dist/examples/jobs/env-tester.csh"
   lappend filelist "$CHECK_SOURCE_DIR/dist/examples/jobs/jobnet_submitter.sh"
   lappend filelist "$CHECK_SOURCE_DIR/dist/examples/jobs/pminiworm.sh"
   lappend filelist "$CHECK_SOURCE_DIR/dist/examples/jobs/simple.sh"
   lappend filelist "$CHECK_SOURCE_DIR/dist/examples/jobs/sleeper.sh"
   lappend filelist "$CHECK_SOURCE_DIR/dist/examples/jobs/step_A_array_submitter.sh"
   lappend filelist "$CHECK_SOURCE_DIR/dist/examples/jobs/step_B_array_submitter.sh"
   lappend filelist "$CHECK_SOURCE_DIR/dist/examples/jobs/worker.sh"
   

   set change_files ""


   set file_error 0
   foreach elem $filelist {
      set filename $elem
      if { [ file isfile $filename ] != 1  } {
         puts $CHECK_OUTPUT "file not found: $filename"
         set file_error 1
         continue
      }
      set attribs [ file attributes $filename -permissions] 
      if { [ string compare $attribs "00755" ] != 0 } {
         puts $CHECK_OUTPUT "file not executable (attributes: $attribs):\n $filename"
         lappend change_files $filename
         set file_error 1
         continue
      }
   }

   if { $file_error != 0 } {
      while { 1 } {
         puts $CHECK_OUTPUT "should I set the file permissons to 00755? (yes/no)"
         gets stdin answer
         if { [ string compare $answer "yes" ] == 0 } {
            foreach elem $change_files {
                catch { file attributes $elem -permissions 00755 }
                set attribs [ file attributes $elem -permissions] 
                if { [ string compare $attribs "00755" ] != 0  } {
                   puts $CHECK_OUTPUT "check_executable_files - error setting file permissions: $elem"
                   exit -1
                }
            }  
            break
         } 
         if { [ string compare $answer "no" ] == 0 } {
            puts $CHECK_OUTPUT "check_executable_files - file errors. exit."
            exit -1
         } 
         puts $CHECK_OUTPUT "please enter \"yes\" or \"no\"!"
      }
   }
}

proc set_users_environment {{variable_name env}} {
   global CHECK_REMOTE_ENVIRONMENT CHECK_OUTPUT env

   upvar $variable_name environment

   foreach u_env $CHECK_REMOTE_ENVIRONMENT {
      debug_puts "environment: $u_env"
      set help [split $u_env "="]
      set env_name  [lindex $help 0]
      set env_value [lindex $help 1]
      debug_puts "env_name: $env_name"
      if { [string compare $env_name ""] == 0 } {
         puts $CHECK_OUTPUT "error setting users environment (setup parameter user_environment)"
         return -1
      }
      debug_puts "env_value: $env_value"
      if { [string compare $env_value ""] == 0 } {
         if { [info exists env($env_name)] } {
            set env_value $env($env_name)
         } else {
            puts $CHECK_OUTPUT "error setting users environment (setup parameter user_environment)"
            return -1
         }
      }
      if { [string compare $variable_name "env"] == 0 } {
         puts $CHECK_OUTPUT "setting local user environment variable $env_name to \"$env_value\""
      } else {
         puts $CHECK_OUTPUT "setting remote user environment variable $env_name to \"$env_value\""
      }
      set environment($env_name) $env_value 
   } 
   return 0
}

#                                                             max. column:     |
#****** check/setup() ******
# 
#  NAME
#     setup -- ??? 
#
#  SYNOPSIS
#     setup { {do_only_hostname_resolving 0} } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#     {do_only_hostname_resolving 0} - ??? 
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc setup { {do_only_hostname_resolving 0} } {

  global CHECK_SETTINGS_VERSION CHECK_JOB_OUTPUT_DIR
  global CHECK_CHECKTREE_ROOT CHECK_PRODUCT_ROOT CHECK_PRODUCT_TYPE 
  global CHECK_PRODUCT_FEATURE env 
  global CHECK_CORE_MASTER CHECK_CORE_EXECD CHECK_CORE_PROCESSORS argv 
  global CHECK_SUBMIT_ONLY_HOSTS
  global CHECK_PRODUCT_VERSION_NUMBER CHECK_USER CHECK_ARCH CHECK_HOST CHECK_COMMD_PORT
  global CHECK_RESULT_DIR CHECK_BAD_RESULT_DIR CHECK_REPORT_FILE CHECK_GROUP
  global CHECK_CORE_RESULT_DIR CHECK_CORE_BAD_RESULT_DIR CHECK_MAIN_RESULTS_DIR 
  global CHECK_DEFAULTS_FILE CHECK_TESTSUITE_ROOT
  global CHECK_CURRENT_WORKING_DIR CHECK_DO_SETUP CHECK_MAX_LEVEL CHECK_GUILTY_RUNLEVELS
  global CHECK_PROTOCOL_DIR CHECK_OUTPUT CHECK_CONFIG_DIR
  global CHECK_SOURCE_DIR CHECK_SOURCE_HOSTNAME CHECK_SOURCE_COMPILE_HOSTS
  global CHECK_AIMK_COMPILE_OPTIONS CHECK_DIST_INSTALL_OPTIONS
  global CHECK_QMASTER_INSTALL_OPTIONS CHECK_EXECD_INSTALL_OPTIONS
  global CHECK_DNS_DOMAINNAME CHECK_REMOTE_ENVIRONMENT
  global CHECK_FIRST_FOREIGN_SYSTEM_USER CHECK_SECOND_FOREIGN_SYSTEM_USER 
  global CHECK_FIRST_FOREIGN_SYSTEM_GROUP CHECK_SECOND_FOREIGN_SYSTEM_GROUP
  global CHECK_DEFAULT_DOMAIN be_quiet
  global CHECK_MAILX_HOST do_nomain
  global CHECK_REPORT_EMAIL_TO CHECK_REPORT_EMAIL_CC  CHECK_USE_SSH CHECK_SOURCE_CVS_RELEASE
  global check_name CHECK_ACT_LEVEL CHECK_SEND_ERROR_MAILS CHECK_MAX_ERROR_MAILS

  puts "starting setup ..."

  if { [info exists env(GRD_ROOT) ] } {
     puts "unsetting GRD_ROOT"
     unset env(GRD_ROOT)
  }
  if { [info exists env(CODINE_ROOT) ] } {
     puts "unsetting CODINE_ROOT"
     unset env(CODINE_ROOT)
  }

  set check_name "setup"
  set CHECK_ACT_LEVEL "0"
  set have_defaults 0
  if { [load_defaults] == 0 } {
     if { $be_quiet == 0 } { 
        puts "--> using \"$CHECK_DEFAULTS_FILE\" for setup."
     }
     if { $CHECK_DO_SETUP == 0 } {
        set have_defaults 1
        #setup on --setup flag!
     }
  }

  if { $have_defaults == 0 && $do_only_hostname_resolving == 0 } {

      if {[catch {set CHECK_USER [set env(USER)] }] != 0} {
        set CHECK_USER [file attributes $CHECK_TESTSUITE_ROOT/check.exp -owner]
        puts "\nNo USER is set!\n(default: $CHECK_USER)\n"
        set env(USER) $CHECK_USER
      } 

      set CHECK_ARCH [ resolve_arch ]
      puts $CHECK_OUTPUT "arch is $CHECK_ARCH"
      set CHECK_HOST [ gethostname ]
      set setup_ok 0
      set edit_result [ edit_defaults ]
      if { $edit_result < 0 } {
         puts $CHECK_OUTPUT "edit defaults: error ; stop"
         set setup_ok -1
      }
      if {[catch {set CHECK_USER [set env(USER)] }] != 0} {
        set CHECK_USER [file attributes $CHECK_TESTSUITE_ROOT/check.exp -owner]
        puts "\nNo USER is set!\n(default: $CHECK_USER)\n"
        set env(USER) $CHECK_USER
      } 

      if {[catch {set CHECK_GROUP [set env(GROUP)] }] != 0} {
        set CHECK_GROUP [file attributes $CHECK_TESTSUITE_ROOT/check.exp -group]
        puts "\nNo GROUP is set!\n(default: $CHECK_GROUP)\n"
        set env(GROUP) $CHECK_GROUP
      } 


      foreach host $CHECK_CORE_EXECD {
         start_remote_prog "$host" "$CHECK_USER" "cd" "$CHECK_CURRENT_WORKING_DIR" 
         if { $prg_exit_state != 0 } {
             puts $CHECK_OUTPUT "directory \"$CHECK_CURRENT_WORKING_DIR\" is not available on host \"$host\""
             set setup_ok -1
         } 
            
         puts $CHECK_OUTPUT "\n--> try rsh $host echo \"hello $host\" ..."
         set exit_state [ catch { exec rsh $host "echo \"hello $host\"" } result ]
         puts $CHECK_OUTPUT "--> rsh exit state: $exit_state"
         puts $CHECK_OUTPUT "--> rsh result:     $result"
         if { $exit_state != 0 } {
             puts $CHECK_OUTPUT "-->rsh to host $host doesn't work correctly"
             set setup_ok -1
         }
         if { [ string first "hello $host" $result ] < 0 } {
             puts $CHECK_OUTPUT "$result"
             puts $CHECK_OUTPUT "echo \"hello $host\" doesn't work"
             set setup_ok -1
         }
      }


      if {$setup_ok == 0} {
         set CHECK_PROTOCOL_DIR $CHECK_MAIN_RESULTS_DIR/protocols
         if {[file isdirectory "$CHECK_PROTOCOL_DIR"] != 1} {
            set catch_return [ catch {  file mkdir "$CHECK_PROTOCOL_DIR" } ]
            if { $catch_return != 0 } {
               puts $CHECK_OUTPUT "could not create directory \"$CHECK_PROTOCOL_DIR\""
               exit -1
            } 
         }
         source_procedures
      } else {
         puts $CHECK_OUTPUT "edit defaults: error ; stop"
         exit -1
      } 
  
     
     set env(COMMD_PORT) $CHECK_COMMD_PORT;
     set env(SGE_ROOT) $CHECK_PRODUCT_ROOT;
     set_users_environment
   
     if {[catch {set CHECK_USER [set env(USER)] }] != 0} {
        set CHECK_USER [file attributes $CHECK_TESTSUITE_ROOT/check.exp -owner]
        puts "\nNo USER is set!\n(default: $CHECK_USER)\n"
        set env(USER) $CHECK_USER
     }
     if {[catch {set CHECK_GROUP [set env(GROUP)] }] != 0} {
        set CHECK_GROUP [file attributes $CHECK_TESTSUITE_ROOT/check.exp -group]

        puts "\nNo GROUP is set!\n(default: $CHECK_GROUP)\n"
        set env(GROUP) $CHECK_GROUP
      } 
 
     
   # resolve now: CHECK_HOST, CHECK_CORE_EXECD, CHECK_CORE_MASTER 
   
     set result [resolve_host $CHECK_CORE_MASTER]
     set ok 1
     foreach elem $result {
        if { [string compare "unknown" $elem] == 0 } {
           set ok 0
        }
     }
     if { $ok == 1 } {
        set CHECK_CORE_MASTER $result
     }    
 
     set result ""
     foreach elem $CHECK_CORE_EXECD {
        lappend result [resolve_host $elem]
     }
     set ok 1
     foreach elem $result {
        if { [string compare "unknown" $elem] == 0 } {
           set ok 0
        }
     }
     if { $ok == 1 } {
        set CHECK_CORE_EXECD $result
     }
  }

  if { $do_only_hostname_resolving == 0 } {

     set env(COMMD_PORT) $CHECK_COMMD_PORT;
     set env(SGE_ROOT) $CHECK_PRODUCT_ROOT;
     set_users_environment
   
     if {[catch {set CHECK_USER [set env(USER)] }] != 0} {
        set CHECK_USER [file attributes $CHECK_TESTSUITE_ROOT/check.exp -owner]
        puts "\nNo USER is set!\n(default: $CHECK_USER)\n"
        set env(USER) $CHECK_USER
     } 
     if {[catch {set CHECK_GROUP [set env(GROUP)] }] != 0} {
        set CHECK_GROUP [file attributes $CHECK_TESTSUITE_ROOT/check.exp -group]
        puts "\nNo GROUP is set!\n(default: $CHECK_GROUP)\n"
        set env(GROUP) $CHECK_GROUP
     } 
     set CHECK_ARCH [ resolve_arch ]
     set CHECK_HOST [ gethostname ]

   
     if {[file isdirectory "$CHECK_MAIN_RESULTS_DIR"] != 1} {
           file mkdir "$CHECK_MAIN_RESULTS_DIR"
     }
   
     set CHECK_RESULT_DIR "$CHECK_MAIN_RESULTS_DIR/$CHECK_HOST.completed"
     set CHECK_BAD_RESULT_DIR "$CHECK_MAIN_RESULTS_DIR/$CHECK_HOST.uncompleted"
     set CHECK_REPORT_FILE "$CHECK_MAIN_RESULTS_DIR/$CHECK_HOST.report"
   
     set CHECK_CORE_RESULT_DIR "$CHECK_MAIN_RESULTS_DIR/core.completed"
     set CHECK_CORE_BAD_RESULT_DIR "$CHECK_MAIN_RESULTS_DIR/core.uncompleted"
  
     set CHECK_JOB_OUTPUT_DIR "$CHECK_MAIN_RESULTS_DIR/testsuite_job_outputs"
 
   
     if {[file isdirectory "$CHECK_CORE_RESULT_DIR"] != 1} {
        file mkdir "$CHECK_CORE_RESULT_DIR"
     }
     if {[file isdirectory "$CHECK_CORE_BAD_RESULT_DIR"] != 1} {
        file mkdir "$CHECK_CORE_BAD_RESULT_DIR"
     }
   
     if {[file isdirectory "$CHECK_RESULT_DIR"] != 1} {
        file mkdir "$CHECK_RESULT_DIR"
     }
   
     if {[file isdirectory "$CHECK_BAD_RESULT_DIR"] != 1} {
        file mkdir "$CHECK_BAD_RESULT_DIR"
     }
   
     if {[file isdirectory "$CHECK_JOB_OUTPUT_DIR"] != 1} {
        file mkdir "$CHECK_JOB_OUTPUT_DIR"
     }
  } 
  get_version_info

  if {[file isdirectory "$CHECK_CONFIG_DIR"] != 1} {
         puts $CHECK_OUTPUT "could not open config directory \"$CHECK_CONFIG_DIR\""
         exit -1 
  }

  if { $be_quiet == 0 } { 
     puts "       product type:         $CHECK_PRODUCT_TYPE";
     puts "       product feature:      $CHECK_PRODUCT_FEATURE";
     puts "       product version:      $CHECK_PRODUCT_VERSION_NUMBER";
     puts "       product root dir:     $CHECK_PRODUCT_ROOT";
     puts "       commd port:           $CHECK_COMMD_PORT";
     puts "       testsuite root:       $CHECK_TESTSUITE_ROOT";
     puts "       testsuite config dir: $CHECK_CONFIG_DIR";
     puts "       checktree is:         $CHECK_CHECKTREE_ROOT";
     puts "       check results dir:    $CHECK_MAIN_RESULTS_DIR";
     puts "       check job output dir: $CHECK_JOB_OUTPUT_DIR";
     puts "       check protocols:      $CHECK_PROTOCOL_DIR";
     puts "       master host:          $CHECK_CORE_MASTER";
     puts "       execution hosts:      $CHECK_CORE_EXECD";
     puts "       number of procs:      $CHECK_CORE_PROCESSORS";
     puts "       submit_only_hosts:    $CHECK_SUBMIT_ONLY_HOSTS";
     puts "       username:             $CHECK_USER";
     puts "       user groupname:       $CHECK_GROUP";
     puts "       current working dir:  $CHECK_CURRENT_WORKING_DIR"
     puts "       source code dir:      $CHECK_SOURCE_DIR";
     puts "       cvs release/tag:      $CHECK_SOURCE_CVS_RELEASE";
     puts "       name of cvs host:     $CHECK_SOURCE_HOSTNAME";
     puts "       compile hosts:        $CHECK_SOURCE_COMPILE_HOSTS"
     puts "       aimk compile opt.:    $CHECK_AIMK_COMPILE_OPTIONS"
     puts "       dist inst opt.:       $CHECK_DIST_INSTALL_OPTIONS"
     puts "       qmaster inst opt.:    $CHECK_QMASTER_INSTALL_OPTIONS"
     puts "       execd inst opt.:      $CHECK_EXECD_INSTALL_OPTIONS"
     puts "       dns_domain_name:      $CHECK_DNS_DOMAINNAME"
     puts "       user_environment:     $CHECK_REMOTE_ENVIRONMENT"
     puts "       other system users:   $CHECK_FIRST_FOREIGN_SYSTEM_USER, $CHECK_SECOND_FOREIGN_SYSTEM_USER"
     puts "       other system groups:  $CHECK_FIRST_FOREIGN_SYSTEM_GROUP, $CHECK_SECOND_FOREIGN_SYSTEM_GROUP"
     puts "       default domain:       $CHECK_DEFAULT_DOMAIN"
     puts "       mail host (mailx):    $CHECK_MAILX_HOST"
     puts "       mail report to:       $CHECK_REPORT_EMAIL_TO"
     puts "       mail cc to:           $CHECK_REPORT_EMAIL_CC"
     if { $CHECK_SEND_ERROR_MAILS == 0 } {
        set smail_state_text "disabled"
     } else {
        set smail_state_text "enabled"
     }
     puts "       enable_error_mails:   $smail_state_text"
     puts "       max_run_all_mails:    $CHECK_MAX_ERROR_MAILS"
     if { $CHECK_USE_SSH == 0 } {
        set ssh_state_text "disabled"
     } else {
        set ssh_state_text "enabled"
     }
     puts "       use_ssh:              $ssh_state_text"        
  }

  if {$have_defaults == 0 && $do_only_hostname_resolving == 0 && $do_nomain == 0} {
     puts "is this correct (y/n)"
     gets stdin enter

     if {$enter != "y" } { exit -1 }
     save_defaults
  }

  if {$do_only_hostname_resolving == 1} {
      # resolve now: CHECK_HOST, CHECK_CORE_EXECD, CHECK_CORE_MASTER 
      
        set result [resolve_host $CHECK_CORE_MASTER]
        set ok 1
        foreach elem $result {
           if { [string compare "unknown" $elem] == 0 } {
              set ok 0
           }
        }
        if { $ok == 1 } {
           set CHECK_CORE_MASTER $result
        }    
    
        set result ""
        foreach elem $CHECK_CORE_EXECD {
           lappend result [resolve_host $elem]
        }
        set ok 1
        foreach elem $result {
           if { [string compare "unknown" $elem] == 0 } {
              set ok 0
           }
        }
        if { $ok == 1 } {
           set CHECK_CORE_EXECD $result
        }
        save_defaults
  }

  get_max_level_count $CHECK_CHECKTREE_ROOT
  set CHECK_GUILTY_RUNLEVELS "0" ;# 100 200 300 400" ;#$CHECK_MAX_LEVEL is 400
  delete_tests $CHECK_CHECKTREE_ROOT 1

  setup_shared_lib_path

  set CHECK_ARCH [ resolve_arch ]
  set CHECK_HOST [ gethostname ]

  check_executable_files

 
  if { $be_quiet == 0 } { 
     puts "       architecture:         $CHECK_ARCH";
     puts "       local host:           $CHECK_HOST";
     puts "--> Setup complete"
  }
  set check_name "no check running"
}



# get directories with checkprog
#                                                             max. column:     |
#****** check/get_check_dirs() ******
# 
#  NAME
#     get_check_dirs -- ??? 
#
#  SYNOPSIS
#     get_check_dirs { path } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#     path - ??? 
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc get_check_dirs { path } {
  global CHECK_DIRECTORIES CHECK_INFORMATION_FILE

  set files [get_file_names $path] 
  set dirs [get_dir_names $path]
  
  if { [lsearch $files $CHECK_INFORMATION_FILE] >= 0 }  {
     lappend CHECK_DIRECTORIES $path;
  } 
  foreach element $dirs {
     get_check_dirs "$path/$element"
  }
}

# check dependencies
#                                                             max. column:     |
#****** check/validate_needs() ******
# 
#  NAME
#     validate_needs -- ??? 
#
#  SYNOPSIS
#     validate_needs { needs } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#     needs - ??? 
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc validate_needs {needs} {
  global CHECK_RESULT_DIR CHECK_CORE_RESULT_DIR CHECK_OUTPUT

  if {$needs == ""} {
     return 0;
  } 

  set uncomplete 0;

  foreach elem $needs {

    set result_files ""
    set core_result_files ""
    catch { set result_files [glob "$CHECK_RESULT_DIR/$elem.res.*"] }
    catch { set core_result_files [glob "$CHECK_CORE_RESULT_DIR/$elem.res.*"] }

    debug_puts $result_files $core_result_files

    debug_puts " validate_needs: matching files in $CHECK_RESULT_DIR: $result_files"
    debug_puts " validate_needs: matching files in $CHECK_CORE_RESULT_DIR: $core_result_files"

    if {([file isfile [lindex $result_files 0]] != 1) && ([file isfile [lindex $core_result_files 0]] != 1 )} {
       debug_puts " validate_needs: need to run check $elem.";
       incr uncomplete 1; 
    }
  }

  if {$uncomplete == 0} {
    return 0;
  }
  return -1;
}

# delete result in CHECK_RESULT_DIR
#                                                             max. column:     |
#****** check/delete_result() ******
# 
#  NAME
#     delete_result -- ??? 
#
#  SYNOPSIS
#     delete_result { path runtime level } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#     path    - ??? 
#     runtime - ??? 
#     level   - ??? 
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc delete_result {path runtime level} {
  global check_name check_description check_needs check_functions check_errno check_errstr CHECK_RESULT_DIR CHECK_BAD_RESULT_DIR
  global CHECK_CORE_RESULT_DIR CHECK_CORE_BAD_RESULT_DIR CHECK_OUTPUT check_highest_level

  if { [is_level_enabled $level] == -1 } { 
     debug_puts "\n--> delete_result - info: test level $level not activated, aborting\n"
     return   ;# level not enabled
  }

  set good_dir $CHECK_CORE_RESULT_DIR
  set bad_dir $CHECK_CORE_BAD_RESULT_DIR

  if {[string compare $check_name "init_core_system"] != 0} {
    set good_dir $CHECK_RESULT_DIR
    set bad_dir $CHECK_BAD_RESULT_DIR
  }

  debug_puts "saving results for $check_name (level $level)..."
  debug_puts $good_dir
  debug_puts $bad_dir

  set myfile "$good_dir/$check_name.res.$level" 
  if {[file isfile $myfile] == 1} {
    delete_file $myfile
  }

  set data ""

  lappend data $path
  lappend data $check_name;
  lappend data $check_description($level)
 
  lappend data $check_needs



  if { [ info exists check_functions ] } {
     if { [ string length $check_functions ] < 1 } {
        lappend data "{-> no check_function name <-}"
     } else {
        lappend data $check_functions
     } 
  } else {
     lappend data "{-> no check_function name <-}"
  }
  

  lappend data $check_errno
 
  lappend data $check_errstr
  lappend data $runtime
  lappend data [exec date]
  lappend data $check_highest_level

  set output [open "$bad_dir/$check_name.res.$level" "w"]  
  puts $output "$data"
  close $output 
}



# save results in CHECK_RESULT_DIR
#                                                             max. column:     |
#****** check/save_result() ******
# 
#  NAME
#     save_result -- ??? 
#
#  SYNOPSIS
#     save_result { path runtime level } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#     path    - ??? 
#     runtime - ??? 
#     level   - ??? 
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc save_result {path runtime level} {
  global check_name check_description check_needs check_functions check_errno check_errstr CHECK_RESULT_DIR CHECK_BAD_RESULT_DIR
 
  global CHECK_CORE_RESULT_DIR CHECK_CORE_BAD_RESULT_DIR CHECK_OUTPUT check_highest_level

  if { [is_level_enabled $level] == -1 } { 
     puts $CHECK_OUTPUT "\n--> save_result - error: test level $level not activated\n"
     return   ;# level not enabled
  }


  set good_dir $CHECK_CORE_RESULT_DIR
  set bad_dir $CHECK_CORE_BAD_RESULT_DIR

  if {[string compare $check_name "init_core_system"] != 0} {
    set good_dir $CHECK_RESULT_DIR
    set bad_dir $CHECK_BAD_RESULT_DIR
  } 

  puts "saving results for $check_name (level $level) ..."
  puts $good_dir
  puts $bad_dir
  
  set data ""
  lappend data $path
  lappend data $check_name;
  lappend data $check_description($level)
 
  lappend data $check_needs
  lappend data $check_functions
  lappend data $check_errno
 
  lappend data $check_errstr
  lappend data $runtime
  lappend data [exec date]
  lappend data $check_highest_level

  set output [open "$good_dir/$check_name.res.$level" "w"]  
  puts $output "$data"
  close $output

  if {[file isfile "$bad_dir/$check_name.res.$level"] == 1} {
    delete_file "$bad_dir/$check_name.res.$level"
    puts $CHECK_OUTPUT "\nset state of \"$check_name\" for level $level to completed !"
  }

} 

# get_check_name
#                                                             max. column:     |
#****** check/get_check_name() ******
# 
#  NAME
#     get_check_name -- ??? 
#
#  SYNOPSIS
#     get_check_name { path } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#     path - ??? 
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc get_check_name {path} {
   global CHECK_INFORMATION_FILE check_name
   source $path/$CHECK_INFORMATION_FILE
  
   return $check_name
}

# get test result
#                                                             max. column:     |
#****** check/get_test_result() ******
# 
#  NAME
#     get_test_result -- ??? 
#
#  SYNOPSIS
#     get_test_result { filename } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#     filename - ??? 
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc get_test_result {filename} {
   if {[file isfile $filename] != 1} {
      return {"file not found"}
   }
   if {[file readable $filename] != 1} {
      return {"file not readable"}
   }
   set input [open $filename "r"]
   gets $input data
   close $input
   return $data
}

# create report
#                                                             max. column:     |
#****** check/create_report() ******
# 
#  NAME
#     create_report -- ??? 
#
#  SYNOPSIS
#     create_report { file goodbad } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#     file    - ??? 
#     goodbad - ??? 
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc create_report {file goodbad} {
  global CHECK_RESULT_DIR CHECK_BAD_RESULT_DIR CHECK_CORE_RESULT_DIR
  global CHECK_CORE_BAD_RESULT_DIR CHECK_PRODUCT_VERSION_NUMBER CHECK_PRODUCT_ROOT


  set output [open $file "WRONLY APPEND CREAT"]
  puts $output "\n checksystem report"
  puts $output " ==================\n"
  puts $output " Date: [exec date]\n\n"
  puts $output " Version: $CHECK_PRODUCT_VERSION_NUMBER"
  puts $output " Installed in: $CHECK_PRODUCT_ROOT"
  if {$goodbad == 0} { 
     set total1 [ print_results $CHECK_CORE_RESULT_DIR $output ]
     set total2 [ print_results $CHECK_RESULT_DIR $output ]
     puts $output "\nTotal number of test functions: [expr ($total1 + $total2) ]"
  } else {
     print_results $CHECK_CORE_BAD_RESULT_DIR $output
     print_results $CHECK_BAD_RESULT_DIR $output
  }

  flush $output  
  close $output
 
  puts "report was written to $file"
}

# formatted output
#                                                             max. column:     |
#****** check/format_output() ******
# 
#  NAME
#     format_output -- ??? 
#
#  SYNOPSIS
#     format_output { prefix size text } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#     prefix - ??? 
#     size   - ??? 
#     text   - ??? 
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc format_output { prefix size text} {

  if {[string length $text] <= $size } {
     return $text;
  }

  set otext $text
  set buffer ""

  while { 1 == 1 } {
     set buffer "$buffer[string range $otext 0 $size]"
     set otext [string range $otext [expr ($size+1)] [string length $otext] ]
     set buffer "$buffer\n$prefix"
     if {[string length $otext] <= $size} {
        set buffer "$buffer$otext"
        return $buffer
     }
  }

}

# print results
#                                                             max. column:     |
#****** check/print_results() ******
# 
#  NAME
#     print_results -- ??? 
#
#  SYNOPSIS
#     print_results { ckpath where } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#     ckpath - ??? 
#     where  - ??? 
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc print_results {ckpath where} {

   set numb_of_check_functions 0 
   set filenames [get_file_names $ckpath]
   set catch_return [ catch {
      foreach elem $filenames {
         set data [get_test_result "$ckpath/$elem"]
   
         set path [lindex $data 0]
         set check_name [lindex $data 1]
         set check_descrip [lindex $data 2]
         set check_needs [lindex $data 3]
         set check_functions [lindex $data 4]
         set check_errno [lindex $data 5]
         set check_errstr [lindex $data 6]
         set check_clock [lindex $data 7]
         set check_date  [lindex $data 8]
         set high_level [lindex $data 9]
         set file_level [split $elem "."]
         set file_level [lindex $file_level 2]
   
         set check_description($file_level) $check_descrip
   
         puts $where "############################################################################"
         puts $where "check: $check_name (level $file_level)"
         puts $where "############################################################################"
         puts $where "----------------------------------------------------------------------------"
         puts $where "results:"
      
         set index 0
         puts $where "----------------------------------------------------------------------------"
         puts $where "run time:       [format_output "                " 59 $check_clock]"
         puts $where "----------------------------------------------------------------------------"
         puts $where "date (end):     [format_output "                " 59 $check_date]" 
         puts $where "----------------------------------------------------------------------------"
         set leveltext $check_description($file_level)
         puts $where "description:    [format_output "                " 59 $leveltext]"
         puts $where "----------------------------------------------------------------------------"
         puts $where "dependencies:   [format_output "                " 59 $check_needs]"
         puts $where "----------------------------------------------------------------------------"
         puts $where "functions:      [format_output "                " 59 $check_functions]"
         puts $where "----------------------------------------------------------------------------"
         puts $where "function count: [format_output "                " 59 [llength $check_functions]]"
         puts $where "----------------------------------------------------------------------------"
         puts $where "directory:      [format_output "                " 59 $path]"
         puts $where "----------------------------------------------------------------------------\n"
   
         set numb_of_check_functions [ expr ($numb_of_check_functions + [llength $check_functions]) ]
         if {[string compare $where "stdout" ] == 0 } {
            puts $where "please press RETURN"
            gets stdin pressed
         }
      }
   } my_error ]
   if { $catch_return != 0 } {
       add_proc_error "print_results" -1 "error creating test report:\n$my_error"
   }
   


   puts $where "\nTotal number of check functions in\n\"$ckpath\":\n$numb_of_check_functions\n"
   return $numb_of_check_functions
}
#                                                             max. column:     |
#****** check/is_level_enabled() ******
# 
#  NAME
#     is_level_enabled -- ??? 
#
#  SYNOPSIS
#     is_level_enabled { level_nr } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#     level_nr - ??? 
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc is_level_enabled { level_nr } {

    global CHECK_GUILTY_RUNLEVELS

    foreach level_start $CHECK_GUILTY_RUNLEVELS {
       set level_end [ expr ( $level_start + 99 ) ]

       if { ( $level_start <= $level_nr ) && ( $level_nr <= $level_end ) } {
          return 0
       }
    }

    return -1
}

# delete tests
#                                                             max. column:     |
#****** check/delete_tests() ******
# 
#  NAME
#     delete_tests -- ??? 
#
#  SYNOPSIS
#     delete_tests { path { only_if_not_there 0 } } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#     path                    - ??? 
#     { only_if_not_there 0 } - ??? 
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc delete_tests {path { only_if_not_there 0 } } {
  global CHECK_DIRECTORIES check_errno check_errstr check_functions validate_needs check_name
  global CHECK_INFORMATION_FILE CHECK_OUTPUT check_highest_level check_name check_description
  global check_init_level_procedure CHECK_ACT_LEVEL CHECK_OUTPUT

  set CHECK_DIRECTORIES ""
  get_check_dirs $path 

  if { [info exists CHECK_DIRECTORIES] == 1 } {
    foreach elem $CHECK_DIRECTORIES {
#       puts "--"
       set check_highest_level 0
       set check_errstr ""
       set check_errno ""
       set check_name ""
       set check_init_level_procedure "--"
       source $elem/$CHECK_INFORMATION_FILE
       set check_errstr ""
       set check_errno ""
       if { [ info exists check_functions ] } {
          foreach element $check_functions {
             lappend check_errstr "was never running" 
             lappend check_errno "-1"
          }
       } else {
          puts $CHECK_OUTPUT "no check_functions variable available!!"
          sleep 5
       }
       debug_puts "sourced \"$elem/$CHECK_INFORMATION_FILE\""

       set do_delete 1
       if {$only_if_not_there == 1 } { 
          set result [ validate_needs $check_name ]
          if { $result == 0 } {
             set do_delete 0
          }
       }

       if {$do_delete == 1} {
          for {set i 0} {$i <= $check_highest_level} {incr i 1} {
             if { [string compare $check_init_level_procedure "--" ] != 0 } { 
                set CHECK_ACT_LEVEL $i
                if { [$check_init_level_procedure ]  == 0 } { 
                   delete_result $elem 0 $i
                } 
             } else {
               delete_result $elem 0 $i
             }
          }
       }

    }
  }
}


#                                                             max. column:     |
#****** check/run_tests() ******
# 
#  NAME
#     run_tests -- ??? 
#
#  SYNOPSIS
#     run_tests { path runcompleted } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#     path         - ??? 
#     runcompleted - ??? 
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc run_tests { path runcompleted } {
    global CHECK_DIRECTORIES CHECK_OUTPUT CHECK_HOST check_errstr
    global CHECK_MAILS_SENT CHECK_ENABLE_MAIL CHECK_MAX_ERROR_MAILS
    global CHECK_CHECKTREE_ROOT CHECK_ACT_PATH check_use_installed_system
    global check_reinit_on_tcl_error

    set CHECK_DIRECTORIES ""
    get_check_dirs $path 

    set CHECK_MAILS_SENT 0  ;# clear mail counter

    if { [info exists CHECK_DIRECTORIES] == 1 } {
       
        # check if root password is needed
        foreach elem $CHECK_DIRECTORIES {
            debug_puts "checking whether test in directory $elem needs root access ..."
            if { ([check_root_access $elem ] == 0) && ([have_root_passwd] == -1 ) } {
                puts $CHECK_OUTPUT "test in directory $elem needs root access ..."
                set_root_passwd
            }
        }

        set stop 0
        set pass_no 1
        set checks_to_do $CHECK_DIRECTORIES
        set last_to_do -1
        set check_ok_name     ""
        set check_ok_state    "" 
        set check_ok_date     ""
        set check_ok_pass     ""
#        set check_ok_text     ""
        set check_error_name  ""
        set check_error_state ""
        set check_error_date  ""
        set check_error_pass  ""
#        set check_error_text  ""
        set check_missing_dep ""
        set check_warning_name ""
        set check_warning_state ""
        set check_warning_date ""
        set check_warning_pass ""
#        set check_warning_text ""


        while { $stop == 0 } {
           set todo [ llength $checks_to_do ]
           puts $CHECK_OUTPUT "---PASS${pass_no}----------------------------------------"
           puts $CHECK_OUTPUT "   Nr. of tests remaining: $todo"
           puts $CHECK_OUTPUT "------------------------------------------------" 

           # start tests
           foreach check $checks_to_do {
              if { $CHECK_MAILS_SENT > $CHECK_MAX_ERROR_MAILS } {
                 mail_report "testsuite - disable mail report" "\nreached max. mail count limit" 
                 set CHECK_ENABLE_MAIL 0
              }   

              set test_result [ run_test $check $runcompleted ]

              switch -- $test_result {
                       0 { 
                            # test OK
                            lappend check_ok_name  $check
                            lappend check_ok_state $test_result
                            lappend check_ok_date  [ exec date ]
                            lappend check_ok_pass  $pass_no 
#                            foreach err_message $check_errstr {
#                               lappend check_ok_text("$check") "{$err_message}"
#                            }

                         }
                      -2 { 
                            # dependencies - try again
                            lappend check_missing_dep  $check
                         }
                      -3 {
                            # impossible / unusefull to run this test
                            lappend check_warning_name $check 
                            lappend check_warning_state $test_result
                            lappend check_warning_date [ exec date ]
                            lappend check_warning_pass  $pass_no 
                            foreach err_message $check_errstr {
                               lappend check_warning_text("$check") "{$err_message}"
                            }
                         }
                       1 { 
                            # test was allready done in an earlier run
                            # no action
                            puts $CHECK_OUTPUT "run_tests - check allready done"
                         }
                    -101 {
                            # check failed due to tcl error
                            lappend check_error_name  $check
                            lappend check_error_state $test_result
                            lappend check_error_date  [ exec date ]
                            lappend check_error_pass  $pass_no 
                                    
                            foreach err_message $check_errstr {
                               lappend check_error_text("$check") "{$err_message}"
                            }
     
                            if { $check_reinit_on_tcl_error == 1 } {
                               # reinit system
                               set save_installed_value $check_use_installed_system
                               set save_CHECK_ACT_PATH $CHECK_ACT_PATH
                               set check_use_installed_system 1
                               set CHECK_ACT_PATH "$CHECK_CHECKTREE_ROOT/install_core_system"  
                               close_open_rlogin_sessions  ;# session reset
                               if { [run_test $CHECK_ACT_PATH 1] != 0 } {
                                  set CHECK_ACT_PATH "$CHECK_CHECKTREE_ROOT/install_core_system" 
                                  run_test $CHECK_ACT_PATH 1
                               }
                               set CHECK_ACT_PATH $save_CHECK_ACT_PATH
                               set check_use_installed_system $save_installed_value
                            }
                         }

                 default {
                            # check failed
                            lappend check_error_name  $check
                            lappend check_error_state $test_result
                            lappend check_error_date  [ exec date ]
                            lappend check_error_pass  $pass_no 
                                    
                            foreach err_message $check_errstr {
                               lappend check_error_text("$check") "{$err_message}"
                            }
                         }
              }           
           }
   
           if { [llength $check_missing_dep] > 0 } {
              # missing dependencies , run again
              set checks_to_do $check_missing_dep
              set check_missing_dep ""
              incr pass_no 1
              if { $todo == $last_to_do } {
                 set stop 1
              } else {
                 puts $CHECK_OUTPUT "restarting test with missing dependencies ..."
              } 
              set last_to_do $todo
           } else {
              # all done
              set stop 1
           } 
        }  ;# while stop == 0

        puts $CHECK_OUTPUT "Number of completed tests   : [llength $check_ok_name]"  
        puts $CHECK_OUTPUT "Number of failed tests      : [llength $check_error_name]"  
        puts $CHECK_OUTPUT "Number of unsupported tests : [llength $check_warning_name]"

        set mail_body "Testsuite run on host $CHECK_HOST complete\n\n"


        # tests ok
        append mail_body "completed tests:\n"
        append mail_body "================\n\n"
        for {set index 0} {$index < [llength $check_ok_name]} {incr index 1} {
            append mail_body "Date: [ lindex $check_ok_date $index ]\n" 
            append mail_body "Test: [ lindex $check_ok_name $index ]\n"
            append mail_body "Info: Pass[lindex $check_ok_pass $index], State: [lindex $check_ok_state $index]\n\n"
#            foreach err_message $check_ok_text("[ lindex $check_ok_name $index ]") {
#                foreach sm $err_message {
#                   set error_output [ create_error_message $sm ]
#                   puts $CHECK_OUTPUT $error_output 
#                   append mail_body $error_output
#                }
#            }
        }
        set nr_complete [llength $check_ok_name] 
        append mail_body "Number of completed tests: $nr_complete"        

        # tests failed
        append mail_body "\n\nfailed tests:\n"
        append mail_body "=============\n"
        for {set index 0} {$index < [llength $check_error_name]} {incr index 1} {
            append mail_body "Date: [ lindex $check_error_date $index ]\n" 
            append mail_body "Test: [ lindex $check_error_name $index ]\n"
            append mail_body "Info: Pass[lindex $check_error_pass $index], State: [lindex $check_error_state $index]\n\n"
            foreach err_message $check_error_text("[ lindex $check_error_name $index ]") {
                foreach sm $err_message {
                   set error_output [ create_error_message $sm ]
                   append mail_body $error_output
                }
            }
        }
        set nr_failed [llength $check_error_name]
        append mail_body "Number of failed tests: $nr_failed"  

        # test run not usefull (warning)
        append mail_body "\n\nunsupported tests:\n"
        append mail_body "==================\n"
        for {set index 0} {$index < [llength $check_warning_name]} {incr index 1} {
            append mail_body "Date: [ lindex $check_warning_date $index ]\n" 
            append mail_body "Test: [ lindex $check_warning_name $index ]\n"
            append mail_body "Info: Pass[lindex $check_warning_pass $index], State: [lindex $check_warning_state $index]\n\n"
            foreach err_message $check_warning_text("[ lindex $check_warning_name $index ]") {
                foreach sm $err_message {
                   set error_output [ create_error_message $sm ]
                   append mail_body $error_output
                }
            }
        }
        set nr_unsupported [llength $check_warning_name]
        append mail_body "Number of unsupported tests: $nr_unsupported"  


        set mail_subject "testsuite run complete - ok:$nr_complete;failed:$nr_failed;unsup.:$nr_unsupported"
        mail_report "$mail_subject" $mail_body
      
 
    } else {
       puts $CHECK_OUTPUT "check directories not found"
    }

}


#                                                             max. column:     |
#****** check/lock_testsuite() ******
# 
#  NAME
#     lock_testsuite -- ??? 
#
#  SYNOPSIS
#     lock_testsuite { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc lock_testsuite {} {
    global CHECK_TESTSUITE_ROOT CHECK_OUTPUT CHECK_HOST CHECK_USER CHECK_MAIN_RESULTS_DIR
    global CHECK_SCRIPT_FILE_DIR

    set pid [getpid]
    
    debug_puts "-> lock_testsuite: pid=$pid host=$CHECK_HOST user=$CHECK_USER"

    set result 0
    set time [ expr ( [timestamp] + 60 ) ] 
    while { $result  != 10 } {
       puts $CHECK_OUTPUT "waiting for lock ..."
       set result [ catch {  
           eval exec "$CHECK_TESTSUITE_ROOT/$CHECK_SCRIPT_FILE_DIR/lock.sh $CHECK_MAIN_RESULTS_DIR/testsuite_lockfile $pid $CHECK_HOST $CHECK_USER"
       } ]
       puts $CHECK_OUTPUT "lock.sh returned $result"
       set file_size 0
       catch { set file_size [file size "$CHECK_MAIN_RESULTS_DIR/testsuite_lockfile"]}
       if { $file_size == 0 } {
           puts $CHECK_OUTPUT "file size is 0, deleteing lockfile..."
           sleep 60  ;# wait for NFS to update file
           unlock_testsuite
           sleep 60  ;# wait for NFS to update file
           return [ lock_testsuite ]  
       }
       if { $result != 10 } {
          puts $CHECK_OUTPUT "checking lockfile owner process ..."
          set data ""
          catch {
              set input [ open "$CHECK_MAIN_RESULTS_DIR/testsuite_lockfile" "r" ]
              gets $input data 
              close $input
          }
          set owner_pid  [lindex $data 0]
          set owner_host [lindex $data 1]
          set owner_user [lindex $data 2]

          debug_puts "testsuite is locked by user $owner_user, process $owner_pid on host $owner_host!"
          if { ([lindex $data 0] == $pid ) && ([lindex $data 1] == $CHECK_HOST ) && ([lindex $data 2] == $CHECK_USER) } {
              debug_puts "thats me, so we have the lock"
              set result 10
              continue
          }
          debug_puts "checking whether process is still alive ..."
           
          get_ps_info $owner_pid $owner_host
          if { $ps_info($owner_pid,error) == 0 } {
             puts $CHECK_OUTPUT "process exists, command is \n-----\n\"$ps_info($owner_pid,string)\"\n-----"
          } else {
             puts $CHECK_OUTPUT "process doesn't exist -> unlock_testsuite ..." 
             unlock_testsuite 
          }
       }
    }
    debug_puts "new lockfile written! Testing for correct lock ..."

    set time [ expr ( [timestamp] + 60 ) ] 
    set tries 0 
    set ok 0
    set failed 0
    set file_size 0
    while {$ok != 1} {
       sleep 1
       catch { set input [ open "$CHECK_MAIN_RESULTS_DIR/testsuite_lockfile" "r" ]
               gets $input data 
               close $input } 
 
       debug_puts $CHECK_OUTPUT "pid  [lindex $data 0] == $pid"
       debug_puts $CHECK_OUTPUT "host [lindex $data 1] == $CHECK_HOST"
       debug_puts $CHECK_OUTPUT "user [lindex $data 2] == $CHECK_USER"
 
       if { ([lindex $data 0] == $pid ) && ([lindex $data 1] == $CHECK_HOST ) && ([lindex $data 2] == $CHECK_USER) } {
          incr tries 1
          if {$tries >= 2} {
             set ok 1
          }
       }
       debug_puts "waiting to get lock"

       catch { set file_size [file size "$CHECK_MAIN_RESULTS_DIR/testsuite_lockfile"]}
       debug_puts "file size is: $file_size"

       if { [timestamp] > $time } {
          set failed 1
          set ok 1
       }      
    }

    if {$failed == 1} {
        puts $CHECK_OUTPUT "no success! Try again ..."
        if { $file_size == 0 } {
           debug_puts "file size is zero, deleteing lockfile..."
           unlock_testsuite
        }
        return [ lock_testsuite ] 
    } 

    debug_puts "lock success!" 

}

#                                                             max. column:     |
#****** check/unlock_testsuite() ******
# 
#  NAME
#     unlock_testsuite -- ??? 
#
#  SYNOPSIS
#     unlock_testsuite { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc unlock_testsuite {} {
    global CHECK_TESTSUITE_ROOT CHECK_OUTPUT CHECK_MAIN_RESULTS_DIR

    if {[file isfile "$CHECK_MAIN_RESULTS_DIR/testsuite_lockfile"] == 1 } {
        puts $CHECK_OUTPUT "removing lockfile \"$CHECK_MAIN_RESULTS_DIR/testsuite_lockfile\"" 

       set catch_return [ catch {exec rm "$CHECK_MAIN_RESULTS_DIR/testsuite_lockfile"} ]
       if { $catch_return != 0 } {
          puts $CHECK_OUTPUT "unlock_testsuite - could not unlock testsuite"
          return
       } 
       while { [ file isfile $CHECK_MAIN_RESULTS_DIR/testsuite_lockfile ] == 1 } {
          puts $CHECK_OUTPUT "file still existing" 
          sleep 1
       }
    }
    puts $CHECK_OUTPUT "testsuite unlocked!" 
}



# run_test_level: returns
# -1 on error, 
# -2 check can not run
#  0 if ok, 
#  1 allready done
#
#                                                             max. column:     |
#****** check/run_test_level() ******
# 
#  NAME
#     run_test_level -- ??? 
#
#  SYNOPSIS
#     run_test_level { path runcompleted level {do_save 1} } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#     path         - ??? 
#     runcompleted - ??? 
#     level        - ??? 
#     {do_save 1}  - ??? 
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc run_test_level {path runcompleted level {do_save 1}} {
   global CHECK_INFORMATION_FILE check_needs CHECK_RESULT_DIR check_name CHECK_ACTUAL_TEST_PATH
   global CHECK_CORE_RESULT_DIR check_errstr CHECK_OUTPUT check_description check_functions check_errno 
   global CHECK_CUR_PROC_NAME CHECK_CUR_PROC_RESULTS CHECK_CUR_PROC_ERRORS
   global CHECK_CURRENT_WORKING_DIR check_init_level_procedure CHECK_ACT_LEVEL
   global set_error_proc_called errorInfo
   
   # do not run allready completed tests
   debug_puts "runcompleted is $runcompleted"
   if { $runcompleted == 0 } {
     if { ( [file isfile "$CHECK_RESULT_DIR/$check_name.res.$level"] == 1) } {
        return 1 
     }
     if { ( [file isfile "$CHECK_CORE_RESULT_DIR/$check_name.res.$level"] == 1) } {
        return 1 
     }
   }  


   # get lock  
   lock_testsuite

 
   set CHECK_ACT_LEVEL $level
   puts $CHECK_OUTPUT "starting test functions (runlevel is $CHECK_ACT_LEVEL)..."
 
   # call init_check_level procedure!
   if {[info exists check_init_level_procedure] == 1 } {
       if {[ string compare $check_init_level_procedure "--"] != 0 } {
          puts $CHECK_OUTPUT "\ncalling init level function \"$check_init_level_procedure\" ..."
          $check_init_level_procedure
       }
   }

 
   # call all check functions 
   set check_errno "-1"
   set check_errstr "was never running"
   set start_time [clock seconds]
   set was_error 0
   set was_unsupported 0
   set complete_errstr ""
   set complete_errno ""

   if { [info exists check_functions] == 1 } {
      foreach elem $check_functions {
         
         puts $CHECK_OUTPUT "\n>>>>>>>>>>>>>>>>>>>>>>"
         puts $CHECK_OUTPUT "$elem"    
         puts $CHECK_OUTPUT "runlevel: [get_run_level_name $level]($level)"
         puts $CHECK_OUTPUT ">>>>>>>>>>>>>>>>>>>>>>"

         set check_errno "-1"
         set check_errstr "was never running"
         set was_empty 0
 
         # set public procedure error state to "no error"
         set check_cur_proc_result "0"
         set check_cur_proc_error "ok"
         set CHECK_CUR_PROC_ERRORS ""
         set CHECK_CUR_PROC_RESULTS "" 
         set CHECK_CUR_PROC_NAME $elem
         set set_error_proc_called 0  

         

         # this starts the test procedure
         set catch_return [ catch { $elem } errMsg ]
         if { $catch_return != 0 } {
            puts $CHECK_OUTPUT $errMsg
            add_proc_error "run_test_level" "-2" "catch returns not 0\n${errMsg}\n${errorInfo}" 
            set_error -2 "tcl error"
         } 
         
         # examine public procedure error states
         set myindex 0
         set procedure_error_text ""
         set procedure_errno ""
         foreach element $CHECK_CUR_PROC_RESULTS {
            if { $element != 0 } {
               # we got an error: append it to the check_xxx lists
               lappend procedure_error_text [lindex $CHECK_CUR_PROC_ERRORS $myindex]
               lappend procedure_errno $element 
            }
            incr myindex 1
         }        

         if { $set_error_proc_called == 0 } {
             lappend procedure_error_text "{$elem|no \"set_error\" call on procedure return|$check_name|run_test_level}"
             lappend procedure_errno "-1"
             set was_empty 1
         }



 
         # flush output file
         flush $CHECK_OUTPUT  
      
         set stop 0 
         if { [ llength $procedure_errno ] == 0 } {
            lappend procedure_error_text "{$elem|$check_errstr|$check_name|run_test_level}"
            lappend procedure_errno $check_errno
            set was_empty 1
         }
         set cur_check_errno [ lindex $procedure_errno [ expr ( [ llength $procedure_errno] - 1 ) ] ]
         debug_puts $CHECK_OUTPUT "cur_check_errno = \"$cur_check_errno\""
         set cur_check_err_text  [ lindex $procedure_error_text [ expr ( [ llength $procedure_error_text] - 1 ) ] ]


         if {$cur_check_errno != 0} {
            incr was_error 1

            debug_puts $CHECK_OUTPUT "DEBUG: cur_errno = $cur_check_errno"           
 
            if { $was_empty == 1  } { 
               show_proc_error $cur_check_errno $cur_check_err_text
            }

            if {$cur_check_errno == -2 } {    ;# hard error dedected run no more test functions
              set stop 1   ;# stop with this test or not ?
            }

            if {$cur_check_errno == -3 } {    ;# test not possible for this host (no error)
              set was_unsupported 1
              incr was_error -1

#              set myindex 0
#              foreach element $procedure_errno {
#                 if { $element != 0 } {
#                    lappend complete_errstr [lindex $procedure_error_text $myindex]
#                    lappend complete_errno  $element
#                 }
#                 incr myindex 1
#              }
#              set check_errstr $complete_errstr
#              set check_errno $complete_errno
              puts $CHECK_OUTPUT "U N S U P P O R T E D   test \"$check_name\" in run level $level, procedure $elem !"
#              set end_time [clock seconds]
#              if { $do_save == 1 } {  
#                  delete_result $path [expr ($end_time - $start_time)] $level
#              }
#              unlock_testsuite
#              return -2


            }
         } else {
            debug_puts $CHECK_OUTPUT "status: $check_errstr"
         }

         set myindex 0
         foreach element $procedure_errno {
            if { $element != 0 } {
               lappend complete_errstr [lindex $procedure_error_text $myindex]
               lappend complete_errno  $element
            }
            incr myindex 1
         }
         if {$stop == 1} {
           break;
         }

      } 
      
      if { [llength $check_functions] == 0 } {   
         set no_func_error "{none|check_functions list has length 0 ( level: $level)|$check_name|run_test_level}"
         lappend complete_errstr "$no_func_error"
         lappend complete_errno -1
         show_proc_error -1 "$no_func_error"
         set was_error 1
      }

      
      if { $catch_return != 0 } {
         set check_errstr $complete_errstr
         set check_errno $complete_errno
         puts $CHECK_OUTPUT "T C L   E R R O R   running test \"$check_name\" in run level $level !"
         set end_time [clock seconds]
         unlock_testsuite
         return -101 
      }

      if { $was_unsupported == 1 && $was_error == 0 } {
         set check_errstr $complete_errstr
         set check_errno $complete_errno
         puts $CHECK_OUTPUT "U N S U P P O R T E D   test \"$check_name\" in run level $level !"
         set end_time [clock seconds]
         if { $do_save == 1 } {  
             save_result $path [expr ($end_time - $start_time)] $level
         }
         unlock_testsuite
         return -2
      }


      if {$was_error == 0} {
         set check_errstr $complete_errstr
         set check_errno $complete_errno
         puts $CHECK_OUTPUT "S U C C E S S F U L L Y performed \"$check_name\" in run level $level !"
         set end_time [clock seconds]
         if { $do_save == 1 } {      
            save_result $path [expr ($end_time - $start_time)] $level
         }
         unlock_testsuite
         return 0
      } 
   } else {
     set no_func_error "{none|check_functions variable not found (level: $level)|$check_name|run_test_level}"
     lappend complete_errstr "$no_func_error"
     lappend complete_errno -1
     show_proc_error -1 "$no_func_error"

   }
 
   # check function does not exist or had an error
   
   set check_errstr $complete_errstr
   set check_errno $complete_errno


   set end_time [clock seconds]
   if { $do_save == 1 } {   
      delete_result $path [expr ($end_time - $start_time)] $level
   }
   puts $CHECK_OUTPUT "\ncheck \"$check_name\" F A I L E D  in run level $level !"
   unlock_testsuite
   return -1
}


#                                                             max. column:     |
#****** check/check_root_access() ******
# 
#  NAME
#     check_root_access -- ??? 
#
#  SYNOPSIS
#     check_root_access { path } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#     path - ??? 
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc check_root_access {path} {

  global check_root_access_needs CHECK_INFORMATION_FILE

  set check_root_access_needs ""  
  source $path/$CHECK_INFORMATION_FILE

  if { [string compare "" $check_root_access_needs ] != 0 } {
     return 0
  } 

  return -1
}


# run test
#                                                             max. column:     |
#****** check/run_test() ******
# 
#  NAME
#     run_test -- ??? 
#
#  SYNOPSIS
#     run_test { path runcompleted {run_single_test "all"} } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#     path                    - ??? 
#     runcompleted            - ??? 
#     {run_single_test "all"} - ??? 
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc run_test {path runcompleted {run_single_test "all"} { send_mail_report 1 } } {
  

  global CHECK_INFORMATION_FILE check_needs CHECK_RESULT_DIR check_name CHECK_ACTUAL_TEST_PATH
  global CHECK_CORE_RESULT_DIR check_errstr CHECK_OUTPUT check_description check_functions check_errno 
  global CHECK_CUR_PROC_NAME CHECK_CUR_PROC_RESULTS CHECK_CUR_PROC_ERRORS check_root_access_needs
  global CHECK_CURRENT_WORKING_DIR check_highest_level check_init_level_procedure CHECK_ACT_LEVEL
  global CHECK_PRODUCT_TYPE CHECK_PRODUCT_VERSION_NUMBER CHECK_PRODUCT_ROOT CHECK_TESTSUITE_ROOT
  global CHECK_PRODUCT_FEATURE

  set del_file_name "$CHECK_TESTSUITE_ROOT/.testsuite_delete"
  if { [ file isfile $del_file_name ] == 1 } {
     set del_file [ open $del_file_name "r" ]
     puts $CHECK_OUTPUT "deleting old temp script files ..."
     while { [gets $del_file line] >= 0 } {
        debug_puts $CHECK_OUTPUT $line
        file delete $line
     }
     close $del_file
     file delete $del_file_name     
     sleep 1
  }


  cd $CHECK_CURRENT_WORKING_DIR

  set do_only_one_test 0

  set CHECK_ACTUAL_TEST_PATH $path

  set check_name          ""
  set check_needs         ""
  set check_functions     ""
  set check_highest_level 0
  set check_init_level_procedure "--"
  set check_root_access_needs   "" 
  source_procedures 
  source $path/$CHECK_INFORMATION_FILE
  if { [string compare $run_single_test "all"] != 0 } {
     set do_only_one_test 1
     puts $CHECK_OUTPUT "running only test \"$run_single_test\""
     set check_functions "$run_single_test"
  }

  if { ( [string compare "" $check_root_access_needs] != 0) && ([have_root_passwd] == -1 ) } {
     set_root_passwd
  }

  # first check the dependencies
  
  puts $CHECK_OUTPUT ">>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>"
  puts $CHECK_OUTPUT ">>> $check_name"
  puts $CHECK_OUTPUT ">>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>"
  debug_puts $CHECK_OUTPUT "file: $path/check.exp"


  set result [validate_needs $check_needs]

  debug_puts "needs returned $result"
  debug_puts "highest level of test is $check_highest_level"

  if { $result != 0 } {
     puts $CHECK_OUTPUT "dependencies not fulfilled! Stop!"
     set check_errstr ""
     set check_errno ""
     foreach elem $check_functions {
        lappend check_errstr "{run_test|dependencies not fulfilled!|$check_name|run_test}"
        lappend check_errno "-1"
     }
     for {set level 0} {$level <= $check_highest_level} {incr level 1} {
       if { [string compare $check_init_level_procedure "--" ] != 0 } { 
         set CHECK_ACT_LEVEL $level
         if { [$check_init_level_procedure ]  == 0 } { 
            delete_result $path 0 $level 
         }
       } else { 
         delete_result $path 0 $level
       }
     }
     return -2   ;# dependencies not fulfilled
  }

  set nr_errors 0
  set nr_warnings 0
  set nr_allready_done 0
  set nr_new_done 0
  set my_current_runlevel 0
  set do_send_mail 0
  set no_level_calls 0 


  for {set level 0} { $level <= $check_highest_level} {incr level 1} {

     if {[is_level_enabled $level] == -1 } {
        continue
     } 
     set my_current_runlevel $level
     if { [string compare $check_init_level_procedure "--" ] != 0 } { 
         set CHECK_ACT_LEVEL $level
         if { [$check_init_level_procedure ]  != 0 } { 
            continue 
         }
     }
     puts $CHECK_OUTPUT "\n----------------------------------------------"
     puts $CHECK_OUTPUT "-> enter check level $level"
     if { $do_only_one_test == 0 } {
        set back [run_test_level $path $runcompleted $level]
        debug_puts "level $level return value: $back"
        incr no_level_calls 1
     } else {
        set back [run_test_level $path $runcompleted $level 0 ]
        debug_puts "level $level return value of test $run_single_test: $back"
        incr no_level_calls 1
     }
     if {$back == -101  } { 
        incr nr_errors 1
        debug_puts $CHECK_OUTPUT "--> TCL ERROR in check $path in level $level <--"
        return -101
     }
     if {$back == -1} {
        incr nr_errors 1     ;# we had an error
        debug_puts $CHECK_OUTPUT "--> ERROR in check $path in level $level <--"
        return -1
     }
     if {$back == -2} {
        incr nr_warnings 1     ;# check can not run
        debug_puts $CHECK_OUTPUT "--> check $path in level $level: can't start test <--"
        
#        return -3
     }
     if {$back == 0} {
        set do_send_mail 1  ;# a successfull test run
        incr nr_new_done 1
        debug_puts $CHECK_OUTPUT "no errors"
     } 

     if {$back == 1} {
        debug_puts $CHECK_OUTPUT "check allready done"
        incr nr_allready_done 1
     }
     debug_puts "calls=$no_level_calls, allready done=$nr_allready_done"
  }

#  if { $nr_warnings != 0 } {
#     return -3 ;# warning
#  }

  if { $nr_allready_done == $no_level_calls } {
     return 1  ;# was done time before
  }
  
  if { $send_mail_report != 1 } {
     set do_send_mail 0
  }

  if { $nr_errors == 0 && $nr_warnings == 0 } {
     if { $do_send_mail == 1 } {
        set mail_body "Successfully performed check $check_name in directory\n$path\n"
        set mail_body "${mail_body}Date: [ exec date ]\n\n"
        set mail_body "${mail_body}product type:     $CHECK_PRODUCT_TYPE\n"
        set mail_body "${mail_body}product feature:  $CHECK_PRODUCT_FEATURE\n"
        set mail_body "${mail_body}product version:  $CHECK_PRODUCT_VERSION_NUMBER\n"
        set mail_body "${mail_body}product root:     $CHECK_PRODUCT_ROOT\n"
        set mail_body "${mail_body}runlevel:         [get_run_level_name $my_current_runlevel]\n"
        set mail_body "${mail_body}max. runlevel:    [get_run_level_name $check_highest_level]\n"
        set mail_body "${mail_body}dependencies:     $check_needs\n"
        set mail_body "${mail_body}check functions:  \n"
        foreach elem $check_functions {
           set mail_body "${mail_body}                   $elem\n"
        } 
        set mail_body "${mail_body}init level proc:  $check_init_level_procedure\n"
        mail_report "testsuite success - $check_name" $mail_body
     }
     return 0
  } else {
     if { $nr_errors == 0 } {
        return -3 ;# we had warnings
     }
     return -1
  }
}

#                                                             max. column:     |
#****** check/clean_up_globals() ******
# 
#  NAME
#     clean_up_globals -- ??? 
#
#  SYNOPSIS
#     clean_up_globals { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc clean_up_globals {} {
  global check_init_level_procedure check_name check_description check_highest_level
  global check_needs check_functions check_errno check_errstr 
 

  set check_name        ""                 ;# name of actual check module 
  set check_needs       ""          ;# dependencies of this check (name of other check)
  set check_functions   ""          ;# functions to call (in order)
  set check_init_level_procedure "--"   ;# name of procedure to call before starting level run
  set check_errno      -1          ;# 0 -> OK , != 0 means error (-2 = break test , -1 failure )
  set check_errstr       ""          ;# short error description in text form  
  set check_highest_level 0        ;# here a check can define his check levels count 0 ... 
}

# show test description
#                                                             max. column:     |
#****** check/show_test() ******
# 
#  NAME
#     show_test -- ??? 
#
#  SYNOPSIS
#     show_test { path full } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#     path - ??? 
#     full - ??? 
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc show_test {path full} {
  global CHECK_INFORMATION_FILE check_errno check_needs check_highest_level 
  global check_init_level_procedure CHECK_ACT_LEVEL

  clean_up_globals  
  set check_highest_level 0 
  set check_init_level_procedure "--"
  source $path/$CHECK_INFORMATION_FILE

  puts "===============================================================================" 
  puts "name:         | $check_name"
  puts "===============================================================================" 

  if { $full == 1} {
    puts "filename:     | [ format_output "              | " 61 $path/$CHECK_INFORMATION_FILE ]"

    puts "===============================================================================" 
    for {set i 0} {$i <= $check_highest_level} {incr i 1} {
       set blank ""
       if { $i <= 99} {
         set blank " "
       }
       if { $i <= 9 } {
         set blank "  "
       } 

       set do_print 0
       if { [string compare $check_init_level_procedure "--" ] != 0 } { 
          set CHECK_ACT_LEVEL $i
          if { [$check_init_level_procedure ]  == 0 } { 
             set do_print 1
          } 
       } else {
          set do_print 1
       }
       if { $do_print == 1 } { 
          puts "run level ${blank}$i |"
          puts "description:  | [ format_output "              | " 61 $check_description($i)]"
          puts "==============================================================================="
       }
      

    }

    puts "dependencies: |"
    foreach element $check_needs {
      puts "              | [ format_output "              | " 61 $element]"
    }
    puts "==============================================================================="
  }
}

#                                                             max. column:     |
#****** check/select_runlevel() ******
# 
#  NAME
#     select_runlevel -- ??? 
#
#  SYNOPSIS
#     select_runlevel { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc select_runlevel {} {
     global CHECK_GUILTY_RUNLEVELS

     set data ""

     while { $data != 5 } {
       
        clear_screen    
        set selected_levels ""
        foreach elem $CHECK_GUILTY_RUNLEVELS {
           set a_level [ get_run_level_name $elem ] 
  
           if { [string first $a_level $selected_levels ] < 0 } {
              set selected_levels "$selected_levels $a_level"
           } 
        }
        puts "===============================================================" 
        puts "selected runlevels: $selected_levels"
        puts "===============================================================" 

        puts "\n\nplease select/unselect new runlevels: \n"
        puts "(0) short  (   0 min - 15 min / run level   0 -  99 )"
        puts "(1) medium (  16 min -  1 h   / run level 100 - 199 )"
        puts "(2) long   (   1 h   -  4 h   / run level 200 - 299 )"
        puts "(3) day    ( > 4 h   - 24 h   / run level 300 - 399 )"
        puts "(4) week   ( >24 h            / run level 400 - 499 )"
        puts "\n(5) return to previous menu"

   
        gets stdin data
 
        set in 0
        if { $data <= 4 && $data >= 0 } {
           foreach x $CHECK_GUILTY_RUNLEVELS {
              if { $x == [ expr ( $data * 100 ) ] } {
                 set in 1
              }      
           }
        }

        if { $data <= 4 && $data >= 0 } {
          if {$in == 0} {
            lappend CHECK_GUILTY_RUNLEVELS [ expr ( $data * 100 )] 
          } else {
            set new_guilty_runlevels ""
            foreach x $CHECK_GUILTY_RUNLEVELS {
               if { $x != [ expr ( $data * 100 ) ] } { 
                  lappend new_guilty_runlevels $x
               }
            }
            set CHECK_GUILTY_RUNLEVELS $new_guilty_runlevels
          } 
        }

     } 
}

#                                                             max. column:     |
#****** check/get_max_level_count() ******
# 
#  NAME
#     get_max_level_count -- ??? 
#
#  SYNOPSIS
#     get_max_level_count { path } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#     path - ??? 
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc get_max_level_count {path} {
  global CHECK_DIRECTORIES CHECK_INFORMATION_FILE check_highest_level 
  global CHECK_MAX_LEVEL check_init_level_procedure CHECK_ACT_LEVEL
 
  set CHECK_DIRECTORIES ""
  set CHECK_MAX_LEVEL "0"
  get_check_dirs $path  
  if { [info exists CHECK_DIRECTORIES] == 1 } {
    foreach elem $CHECK_DIRECTORIES {
       
       if { [file isfile $elem/$CHECK_INFORMATION_FILE] == 1 } {
          set check_highest_level 0 
          set check_init_level_procedure "--"
          source $elem/$CHECK_INFORMATION_FILE
          if { [string compare $check_init_level_procedure "--" ] != 0 } {
             for {set x 0 } {$x <= $check_highest_level} {incr x 1 } {
                set CHECK_ACT_LEVEL $x
                if { [$check_init_level_procedure ]  == 0 } {
                   if { [lsearch $CHECK_MAX_LEVEL $x] < 0 } {
                      lappend CHECK_MAX_LEVEL $x
                   }
                }
             } 
          }
       }
    }  
  }
  return $CHECK_MAX_LEVEL
}

# show test descriptons (of all subtests)
#                                                             max. column:     |
#****** check/show_tests() ******
# 
#  NAME
#     show_tests -- ??? 
#
#  SYNOPSIS
#     show_tests { path full } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#     path - ??? 
#     full - ??? 
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc show_tests {path full} {
  global CHECK_DIRECTORIES

  set CHECK_DIRECTORIES ""
  get_check_dirs $path 

  if { [info exists CHECK_DIRECTORIES] == 1 } {
    foreach elem $CHECK_DIRECTORIES {
      clear_screen
      show_test $elem $full
      wait_for_enter
    }  
  }
}

# change directory
#                                                             max. column:     |
#****** check/change_dir() ******
# 
#  NAME
#     change_dir -- ??? 
#
#  SYNOPSIS
#     change_dir { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc change_dir { } {
  global CHECK_ACT_PATH CHECK_CHECKTREE_ROOT 

  print_menu_header

  set dirs [ get_dir_names $CHECK_ACT_PATH ]

  set count 1 

  if {[string compare $CHECK_ACT_PATH $CHECK_CHECKTREE_ROOT] != 0 } {
    puts "($count) - up"
    incr count 1
  }
  puts "($count) - stay"
  incr count 1
  foreach elem $dirs {
     puts "($count) - go to \"$elem\""
     set newdir($count) $elem
     incr count 1
  }

  gets stdin input 
  
  if { ($input == 1) && ([string compare $CHECK_ACT_PATH $CHECK_CHECKTREE_ROOT] != 0)}  {
     puts "go to upper dir ..."
     set test [split $CHECK_ACT_PATH "/\/"] 
     set CHECK_ACT_PATH [lrange $test 0 [expr [llength $test] - 2] ]
     set CHECK_ACT_PATH [ join $CHECK_ACT_PATH "/"]  
     return
  }

  if { [info exists newdir($input)] == 1 } {
     puts "go to dir $newdir($input) ..."
     set CHECK_ACT_PATH "$CHECK_ACT_PATH/$newdir($input)"
     return
  }
}


#                                                             max. column:     |
#****** check/get_run_level_name() ******
# 
#  NAME
#     get_run_level_name -- ??? 
#
#  SYNOPSIS
#     get_run_level_name { level } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#     level - ??? 
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc get_run_level_name { level } {
  
  if { $level >= 400 } {
     return "week"
  }

  if { $level >= 300 } {
     return "day"
  }

  if { $level >= 200 } {
     return "long"
  }

  if { $level >= 100 } {
     return "medium"
  }

  if { $level >= 00 } {
     return "short"
  }

  return ""
}

#                                                             max. column:     |
#****** check/clear_screen() ******
# 
#  NAME
#     clear_screen -- ??? 
#
#  SYNOPSIS
#     clear_screen { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc clear_screen {} {
 
  set clear_sequence [ format "%c%c%c%c%c%c%c" 0x1b 0x5b 0x48 0x1b 0x5b 0x32 0x4a 0x00 ]
  puts $clear_sequence
}

#                                                             max. column:     |
#****** check/print_menu_header() ******
# 
#  NAME
#     print_menu_header -- ??? 
#
#  SYNOPSIS
#     print_menu_header { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc print_menu_header {} {
  global CHECK_ACT_PATH CHECK_DIRECTORIES CHECK_INFORMATION_FILE CHECK_RESULT_DIR 
  global CHECK_USER CHECK_REPORT_FILE CHECK_OUTPUT CHECK_HOST CHECK_BAD_RESULT_DIR 
  global CHECK_CORE_RESULT_DIR CHECK_CORE_BAD_RESULT_DIR CHECK_MAIN_RESULTS_DIR 
  global CHECK_GUILTY_RUNLEVELS CHECK_MAX_LEVEL CHECK_PRODUCT_VERSION_NUMBER
  global CHECK_PRODUCT_FEATURE

  
  clear_screen
  get_version_info
  puts "===============================================================================" 

  puts " system version    :  $CHECK_PRODUCT_VERSION_NUMBER ([resolve_version])"
  puts " product feature   :  $CHECK_PRODUCT_FEATURE"
  puts " current dir       :  [ format_output "                      " 55 $CHECK_ACT_PATH ]"

  set dirs [ get_dir_names $CHECK_ACT_PATH ]
  set files [get_file_names $CHECK_ACT_PATH ]

  set test_counts ""
  set test_text ""
  foreach elem $dirs {
     set CHECK_DIRECTORIES ""
     get_check_dirs "$CHECK_ACT_PATH/$elem"
     set count [llength $CHECK_DIRECTORIES]
     if { $count > 9 } {
        set blank " "
     } else {
        set blank "  "
     }
     lappend test_counts "$count"
     lappend test_text   "${blank}${count} test(s) available in subdir: ${elem}"
  }
  set test_count 0
  foreach elem $test_counts {
     incr test_count $elem 
  }

  get_max_level_count $CHECK_ACT_PATH
  set possible_levels ""

  foreach elem $CHECK_MAX_LEVEL {
     set a_level [ get_run_level_name $elem ] 
     if { [string first $a_level $possible_levels ] < 0 } {
        set possible_levels "$possible_levels $a_level"
     } 
  } 
  puts "===============================================================================" 
  puts " max. runlevel     : $possible_levels"  

  set selected_levels ""
  foreach elem $CHECK_GUILTY_RUNLEVELS {
     set a_level [ get_run_level_name $elem ] 

     if { [string first $a_level $selected_levels ] < 0 } {
        set selected_levels "$selected_levels $a_level"
     } 
  } 
  puts " selected runlevels: $selected_levels"
  puts "===============================================================================" 
  foreach elem $test_text {
     puts $elem
  }
  puts "===============================================================================" 
  set blank "  "
  if { $test_count > 9 } {
     set blank " "
  }  
  puts "${blank}$test_count test(s) available in current subdirs"
  puts "===============================================================================\n" 
  return $files
}

#                                                             max. column:     |
#****** check/wait_for_enter() ******
# 
#  NAME
#     wait_for_enter -- ??? 
#
#  SYNOPSIS
#     wait_for_enter { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc wait_for_enter {} {
   global CHECK_OUTPUT
   flush $CHECK_OUTPUT

   puts "\npress enter..."
   gets stdin enter 
}

#                                                             max. column:     |
#****** check/wait_for_start_time() ******
# 
#  NAME
#     wait_for_start_time -- ??? 
#
#  SYNOPSIS
#     wait_for_start_time { substring } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#     substring - ??? 
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc wait_for_start_time { substring } {
   puts "wait for start time: \"$substring\""
   while { 1 } {
      set date_output [ exec date "+%D %H:%M" ]
      puts -nonewline "\r$date_output"
      flush stdout
      if { [string compare $date_output $substring] == 0 } {
         break; 
      }
      sleep 30
   }
   puts ""
}

#
#                                                             max. column:     |
#
#****** check/compile_source() ******
#  NAME
#     compile_source() -- ??? 
#
#  SYNOPSIS
#     compile_source { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
#
proc compile_source {} {

   global CHECK_SOURCE_DIR CHECK_OUTPUT CHECK_SOURCE_HOSTNAME CHECK_SOURCE_COMPILE_HOSTS
   global CHECK_TESTSUITE_ROOT CHECK_SCRIPT_FILE_DIR CHECK_PRODUCT_TYPE CHECK_PRODUCT_ROOT
   global CHECK_PRODUCT_FEATURE
   global CHECK_DEFAULTS_FILE CHECK_SOURCE_CVS_RELEASE do_not_update check_name
   global CHECK_AIMK_COMPILE_OPTIONS CHECK_DIST_INSTALL_OPTIONS CHECK_JOB_OUTPUT_DIR
   global CHECK_CORE_EXECD CHECK_PROTOCOL_DIR

   

   set check_name "compile_source"
   set CHECK_CUR_PROC_NAME "compile_source"
   set mail_subject "testsuite error - compile_source"
   set mail_body    "date: [exec date]\n"

 
   set was_error 0
   set cvs_change_log ""

   if { ( [ string compare $CHECK_SOURCE_DIR "unknown" ] == 0 ) || ( [ string compare $CHECK_SOURCE_DIR "" ] == 0 ) } {
       puts $CHECK_OUTPUT "source directory unknown - check defaults file"
       mail_report $mail_subject "$mail_body source directory unknown - check defaults file" 
       return -1
   }
   if { ( [ string compare $CHECK_SOURCE_HOSTNAME "unknown" ] == 0 ) || ( [ string compare $CHECK_SOURCE_HOSTNAME "" ] == 0  ) } {
       puts $CHECK_OUTPUT "host for cvs checkout unknown - check defaults file"
       mail_report $mail_subject "$mail_body host for cvs checkout unknown - check defaults file"
       return -1
   }
   if { ( [ string compare $CHECK_SOURCE_COMPILE_HOSTS "unknown" ] == 0 ) || ([ string compare $CHECK_SOURCE_COMPILE_HOSTS "" ] == 0) } {
       puts $CHECK_OUTPUT "host list to compile for unknown - check defaults file"
       mail_report $mail_subject "$mail_body host list to compile for unknown - check defaults file"
       return -1
   }

   if {[file isdirectory "$CHECK_PROTOCOL_DIR"] != 1} {
      set catch_return [ catch {  file mkdir "$CHECK_PROTOCOL_DIR" } ]
      if { $catch_return != 0 } {
           puts $CHECK_OUTPUT "could not create directory \"$CHECK_PROTOCOL_DIR\""
           return -1
      } 
   }


   # shutdown eventually running system
   shutdown_core_system


   # update source 
   if { $do_not_update == 0 } {
      puts $CHECK_OUTPUT "updating source in directory $CHECK_SOURCE_DIR on host $CHECK_SOURCE_HOSTNAME ..."
      set return_state [ catch { eval exec rsh $CHECK_SOURCE_HOSTNAME "\"cd $CHECK_SOURCE_DIR ; cvs update -dP \"" } output ]
      set cvs_output [ open "$CHECK_SOURCE_DIR/cvs_update.log.[timestamp]" "w" ]
      puts $cvs_output $output
      close $cvs_output
      set update_output [split $output "\n"] 
      foreach elem $update_output {
         if { ([string range $elem 0 2 ] != "cvs") && ([string range $elem 0 0] != "?") } {
            puts $CHECK_OUTPUT $elem
            set cvs_change_log "$cvs_change_log $elem\n"
         } 
      }
   } 

   puts $CHECK_OUTPUT "-> starting scripts/zerodepend on host $CHECK_SOURCE_HOSTNAME ..."
   set return_state [ catch { eval exec rsh $CHECK_SOURCE_HOSTNAME "\"cd $CHECK_SOURCE_DIR ; scripts/zerodepend\"" } output ]
   puts $CHECK_OUTPUT "return state: $return_state"
   #puts $CHECK_OUTPUT "$output\n"

   puts $CHECK_OUTPUT "-> starting aimk $CHECK_AIMK_COMPILE_OPTIONS depend on host $CHECK_SOURCE_HOSTNAME ..."
   set return_state [ catch { eval exec rsh $CHECK_SOURCE_HOSTNAME "\"cd $CHECK_SOURCE_DIR ; aimk $CHECK_AIMK_COMPILE_OPTIONS depend\"" } output ]
   puts $CHECK_OUTPUT "return state: $return_state"
   #puts $CHECK_OUTPUT "$output\n"

   
   set host_list $CHECK_SOURCE_COMPILE_HOSTS
   
   set num 0
   set spawn_list {} 
   set file_list {}
   set file_name_list {}
 
   set cvs_tag "maintrunc"
   if { [ file isfile "${CHECK_SOURCE_DIR}/CVS/Tag" ] } {
      set cvs_tag "no_tag_dir" 
      set tag_state [ catch { eval exec "cat ${CHECK_SOURCE_DIR}/CVS/Tag" } cvs_tag ]
   }

   foreach elem $host_list {
      # compile the staff
      puts $CHECK_OUTPUT "-> starting compiling on host $elem ..."
      set prog "$CHECK_TESTSUITE_ROOT/$CHECK_SCRIPT_FILE_DIR/remotecompile.sh"
      set par1 "$CHECK_SOURCE_DIR"
      set par2 "$CHECK_AIMK_COMPILE_OPTIONS"
      
      eval spawn rsh $elem "\"$prog $par1 '$par2'\""
      lappend spawn_list $spawn_id
      set myfilename "$CHECK_PROTOCOL_DIR/${elem}_compile_${cvs_tag}.out"
      lappend file_name_list $myfilename
      catch { file delete $myfilename }
      lappend file_list [open $myfilename w]
     
      incr num 
      puts $CHECK_OUTPUT " spawn id is $spawn_id"

   }
  
   append mail_body "\n\ncompile output saved in the files:"
   foreach elem $file_name_list {
      append mail_body "\n$elem"
   }
   append mail_body "\n"

   puts $CHECK_OUTPUT "now waiting for end of compile ..." 
   set timeout -1
   set done_count 0
   set compile_bad {}
   log_user 0

   set original_spawn_list $spawn_list  
 
   while { [llength $spawn_list] > 0   } {
      if {[info exists spawn_id]} {
            unset spawn_id
      }
      expect {
         -i $spawn_list full_buffer {
         }
         -i $spawn_list "remotecompile * aimk compile error" {
              set spawn_id $expect_out(spawn_id)
              set host_index 0
              set host_nr 0
              foreach el $original_spawn_list {
                 if { [string compare $el $spawn_id] == 0 } {
                    set host_index $host_nr
                 }
                 incr host_nr 1
              }
              lappend compile_bad [lindex $host_list $host_index]
              puts $CHECK_OUTPUT $expect_out(0,string)
              catch {wait -i $spawn_id} output
              catch {close -i $spawn_id} output
              set index [lsearch -exact $spawn_list $spawn_id]
              set spawn_list [lreplace $spawn_list $index $index]
         }
         -i $spawn_list "remotecompile * aimk no errors" {
              set spawn_id $expect_out(spawn_id)
              puts $CHECK_OUTPUT $expect_out(0,string)
              catch {wait -i $spawn_id} output
              catch {close -i $spawn_id} output
              set index [lsearch -exact $spawn_list $spawn_id]
              set spawn_list [lreplace $spawn_list $index $index]
         }
         -i $spawn_list "*\n" {
              set spawn_id $expect_out(spawn_id)
              set index 0
              set nr 0
              foreach elem $original_spawn_list {
                 if { [string compare $elem $spawn_id] == 0 } {
                    set index $nr
                 }
                 incr nr 1
              }
#              puts [lindex $file_list $index] "$spawn_id report from host [lindex $host_list $index]"
              puts [lindex $file_list $index] "$expect_out(0,string)"
              flush [lindex $file_list $index]
         }
      }
   }
   log_user 1
   foreach elem $file_list {
      flush $elem
      close $elem
   } 

   set compile_error 0
   foreach elem $compile_bad {
      set compile_error 1
      puts $CHECK_OUTPUT "\n=============\ncompile error on host $elem:\n=============\n"
      append mail_body "\n=============\ncompile error on host $elem:\n=============\n"
      foreach file $file_name_list {
         if { [string first $elem $file] >= 0 } {
             catch { eval exec "touch $file"  }
             set fp [open $file r]
             while { [gets $fp line] >= 0 } {
                append mail_body "\n$line"
                puts $CHECK_OUTPUT $line
             }
             close $fp
         } 
      }
   }
   if { $compile_error != 0 } {
      mail_report $mail_subject $mail_body
      return -1
   } 

   # install to $CHECK_PRODUCT_ROOT
   set var_name "SGE_ROOT"
   if {[string compare $CHECK_PRODUCT_TYPE "sgeee"] == 0 } {
      set link_name "myinst"
      set sgeee_param "-sgeee"
   } else {
      set link_name "myinst"
      set sgeee_param ""
   }
   puts $CHECK_OUTPUT "\nusing environment variable \"$var_name\""

   # copy pos. host_aliases file to trash_
   if { [ file isfile "$CHECK_PRODUCT_ROOT/default/common/host_aliases"] == 1 } {
      puts $CHECK_OUTPUT "saving host_aliases file ..."
      catch { exec "cp" "$CHECK_PRODUCT_ROOT/default/common/host_aliases" "$CHECK_JOB_OUTPUT_DIR/host_aliases"  } result
      puts $result
   } 

   # now delete install directory
   puts $CHECK_OUTPUT "moving directory \"$CHECK_PRODUCT_ROOT\" to testsuite_trash"
   if { [delete_directory "$CHECK_PRODUCT_ROOT"] != 0 } {
      add_proc_error "compile option running - could not delete $CHECK_PRODUCT_ROOT directory" -2 "critical error - stop"
      return -1
   }
  

   catch { exec "mkdir" "$CHECK_PRODUCT_ROOT"  } result
   puts $result
   catch { exec "chmod" "755" "$CHECK_PRODUCT_ROOT"  } result
   puts $result
 

   puts $CHECK_OUTPUT "\ncreating link \"$link_name\""
   set return_state [ catch { eval exec ln -s $CHECK_SOURCE_DIR/scripts/distinst $CHECK_SOURCE_DIR/$link_name } output ]


   set arch_list {}
   set compiled_mail_architectures ""
   puts -nonewline $CHECK_OUTPUT "\narchitectures: "
   foreach elem $host_list {
      set return_state [ catch { exec rsh $elem "$CHECK_SOURCE_DIR/dist/util/arch" } output ]
      lappend arch_list $output 
      puts -nonewline $CHECK_OUTPUT "$output "
      append compiled_mail_architectures "\n$elem ($output)"
   }

     

 
   puts $CHECK_OUTPUT "\ninstalling product binaries"
   eval spawn rsh [lindex $host_list 0] "\"cd $CHECK_SOURCE_DIR ; setenv $var_name $CHECK_PRODUCT_ROOT ; ./$link_name $sgeee_param $CHECK_DIST_INSTALL_OPTIONS $arch_list\""  
   set timeout -1
   set done 0
   while { $done != 1 } {
      expect {
         full_buffer {
            puts $CHECK_OUTPUT "testsuite - compile_source buffer overflow please increment CHECK_EXPECT_MATCH_MAX_BUFFER value"
         }
         "Base directory:" {
             send "y\n"
         }
         "overriding mode" {
             send "y\n"
         }
         eof {
            catch {wait -i $spawn_id} output
            catch {close -i $spawn_id} output
            set done 1
         }
      }
   }
   foreach elem $CHECK_CORE_EXECD {
      set host_arch [ resolve_arch $elem ]
      if { ([string compare $host_arch ""] != 0) && ([string compare $host_arch "unknown" ] != 0) } {
         puts $CHECK_OUTPUT " arch on host $elem is $host_arch - successfully installed binaries"
      } else {
         puts $CHECK_OUTPUT " error installing binaries for host $elem"
         set was_error 1
      }
   }
 
   catch { file mkdir "$CHECK_PRODUCT_ROOT/man" } 
   catch { file mkdir "$CHECK_PRODUCT_ROOT/catman" } 
   catch { file mkdir "$CHECK_PRODUCT_ROOT/default" } 
   catch { file mkdir "$CHECK_PRODUCT_ROOT/default/common" } 

  
   # copy pos. host_aliases file to new product root /default/common
   if { [ file isfile "$CHECK_JOB_OUTPUT_DIR/host_aliases"] == 1 } {
        puts $CHECK_OUTPUT "restoring host_aliases file ..."
        catch { exec "cp" "$CHECK_JOB_OUTPUT_DIR/host_aliases" "$CHECK_PRODUCT_ROOT/default/common/host_aliases" } result
        puts $result
   }


   if { $was_error != 0 } {
      mail_report $mail_subject "$mail_body - compile error(s)"
      return -1
   }
   
   append mail_body "\nSuccessfully compiled and pre-installed following architectures:"
   append mail_body "\n${compiled_mail_architectures}\n"
   
   append mail_body "\ninit_core_system check will install the $CHECK_PRODUCT_TYPE execd at:"
   foreach elem $CHECK_CORE_EXECD {
      set host_arch [ resolve_arch $elem ]
      append mail_body "\n$elem ($host_arch)"
   }
   if { [string compare $cvs_change_log "" ] != 0 } {
      set mail_body "$mail_body \n\n Update output:\n$cvs_change_log\n\n"
   }
   set mail_subject "testsuite success - compile"
   mail_report $mail_subject $mail_body

   # try to resolve hostnames in settings file
   set catch_return [ catch { eval exec "cp ${CHECK_DEFAULTS_FILE} ${CHECK_DEFAULTS_FILE}.[timestamp]" } ]
   if { $catch_return != 0 } { 
        puts "could not copy defaults file"
        return -1
   }
#   do_wait 1
   setup 1 
#   do_wait 1
   return 0
}

#                                                             max. column:     |
#****** check/run_all_at_starttime() ******
# 
#  NAME
#     run_all_at_starttime -- ??? 
#
#  SYNOPSIS
#     run_all_at_starttime { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc run_all_at_starttime {} {

   global CHECK_ACT_PATH CHECK_REPORT_FILE CHECK_CHECKTREE_ROOT

   set start_time 0
   set should_we_compile 0

   print_menu_header
   if { [ ask_user_yes_or_no " Do you want to enter a special starttime (y/N) ? " ] } {
      puts "\n now it is: [exec date "+%D %H:%M" ]"
      set start_time [ get_user_input "    Please enter start time : " ]
      puts "\n testsuite will start at \"$start_time\""
   } else {
      
      puts "\n testsuite will run continuously"
   }

   if { [ ask_user_yes_or_no "\n\n Should the testsuite update, compile and install before testing (y/N) ? " ] } {
      set should_we_compile 1
      puts "\n testsuite will update, compile and install the latest source code"
   } else {
      puts "\n testsuite will use the current installation"
   }

   if { [ ask_user_yes_or_no "\n\n Are this settings correct (y/N) ? " ] == 0 } {
      puts "\n testsuite will return to the main menue, please"
      return
   }

   set_root_passwd
 

   if { $start_time != 0 } {
      wait_for_start_time $start_time
   }
   delete_tests $CHECK_ACT_PATH
   if { $should_we_compile == 1 } {
#     remove_old_cvs_tree
      set back [ compile_source ]
      if { $back != 0 } {
         puts "error in compile_source - stop"
         exit -1
      }
      set saved_path $CHECK_ACT_PATH
      set CHECK_ACT_PATH "$CHECK_CHECKTREE_ROOT/install_core_system"
      set back [ run_test $CHECK_ACT_PATH 1 ]
      if { $back != 0 } {
         puts "error in test install_core_system - stop"
         exit -1
      }
      set CHECK_ACT_PATH $saved_path
   }
   run_tests $CHECK_ACT_PATH 0
   create_report ${CHECK_REPORT_FILE}.ok 0
   create_report ${CHECK_REPORT_FILE}.failed 1

   wait_for_enter
}

#                                                             max. column:     |
#****** check/do_wait() ******
# 
#  NAME
#     do_wait -- ??? 
#
#  SYNOPSIS
#     do_wait { time } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#     time - ??? 
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc do_wait { time } {

   set timestart [ timestamp ]
   while { 1 } {
       if { [ expr ( [ timestamp  ] - $timestart ) ] >= $time } {
         puts ""
         return
       }
       puts -nonewline "."
       flush stdout
       sleep 1
   }
}

#                                                             max. column:     |
#****** check/get_user_input() ******
# 
#  NAME
#     get_user_input -- ??? 
#
#  SYNOPSIS
#     get_user_input { what } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#     what - ??? 
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc get_user_input { what } {
   puts -nonewline $what
   flush stdout 
   gets stdin myinput
   return $myinput
}


#****** check/restart_debug_daemons() ******************************************
#  NAME
#     restart_debug_daemons() -- used for menu point 20/21
#
#  SYNOPSIS
#     restart_debug_daemons { { shutdown 0 } } 
#
#  FUNCTION
#     This procedure will shutdown and restart the qmaster and scheduler
#
#  INPUTS
#     { shutdown 0 } - 0 -> do shutdown (otherwise only do starup)
#
#*******************************************************************************
proc restart_debug_daemons { { shutdown 0 } } {
   global daemon_debug master_debug schedd_debug
   global CHECK_CORE_MASTER

   if { [ have_root_passwd ] != 0 } {
      set_root_passwd
   }
   if { $shutdown == 0 } {
      get_config config_tmp
      if { [info exists config_tmp(qmaster_spool_dir) ] != 1 } { 
         return 
      }
      shutdown_master_and_scheduler $CHECK_CORE_MASTER $config_tmp(qmaster_spool_dir) 
   }
   startup_qmaster 
   wait_for_load_from_all_queues 300 
}

#                                                             max. column:     |
#****** check/ask_user_yes_or_no() ******
# 
#  NAME
#     ask_user_yes_or_no -- ??? 
#
#  SYNOPSIS
#     ask_user_yes_or_no { question } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#     question - ??? 
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc ask_user_yes_or_no { question } {
  
   puts -nonewline $question
   flush stdout 
   gets stdin myinput

   if { [ string compare -nocase $myinput "yes" ] == 0 } {
       return 1
   }
   if { [ string compare -nocase $myinput "y" ] == 0 } {
       return 1
   }
   return 0
}

# select action
#                                                             max. column:     |
#****** check/menu() ******
# 
#  NAME
#     menu -- ??? 
#
#  SYNOPSIS
#     menu { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc menu {} {
  global CHECK_ACT_PATH CHECK_DIRECTORIES CHECK_INFORMATION_FILE CHECK_RESULT_DIR 
  global CHECK_USER CHECK_REPORT_FILE CHECK_OUTPUT CHECK_HOST CHECK_BAD_RESULT_DIR 
  global CHECK_CORE_RESULT_DIR CHECK_CORE_BAD_RESULT_DIR CHECK_MAIN_RESULTS_DIR 
  global CHECK_GUILTY_RUNLEVELS CHECK_MAX_LEVEL CHECK_PRODUCT_VERSION_NUMBER
  global daemon_debug

  set files [  print_menu_header ]
 
  puts "  (0) select runlevels"
  puts "  (1) change dir"
  puts "  (2) run not completed tests (including subdirectories)"
  puts "  (3) show test descriptions"
  puts "  (4) exit (press ^C to exit without shutdown of the cluster)"
  puts "  (5) show completed test list"
  puts "  (6) show not completed test list"
  puts "  (7) reset completed test list (for all subdirectories)"
  puts "  (8) create check report"
  puts "  (9) run all tests at a special starttime"
  if { [ string compare "stdout" $CHECK_OUTPUT ] == 0 } {
     puts " (10) use file \"${CHECK_HOST}.checklog\" for output" 
  } else {
     puts " (10) use \"stdout\" for output"
  }

  set localtest [lsearch $files $CHECK_INFORMATION_FILE]
  if { $localtest >= 0 } {
    puts " (11) show test descriptions of local test"
    puts " (12) run local test"
    puts " (13) run local test continously"
  }

    puts " (20) shutdown and restart master and scheduler"
    puts " (21) only start master and scheduler daemons"

  
  gets stdin input; 

  clear_screen

  switch -- $input {
    "20" { restart_debug_daemons } 
    "21" { restart_debug_daemons 1 }
    "0" { select_runlevel }
    "1" { change_dir; }
    "2" { run_tests $CHECK_ACT_PATH 0
          wait_for_enter
        }
    "3" { show_tests $CHECK_ACT_PATH 1
        }
    "4" { puts "bye!\n"; 
          shutdown_core_system;
          if { [string compare "stdout" $CHECK_OUTPUT ] != 0 } {
             close $CHECK_OUTPUT
          } 
          exit 0; 
        }
    "5" { set total1 [print_results $CHECK_CORE_RESULT_DIR stdout]
          set total2 [print_results $CHECK_RESULT_DIR stdout]
          puts stdout "Total number of test functions: [expr ($total1 + $total2) ]"
          wait_for_enter
        }
    "6" { print_results $CHECK_CORE_BAD_RESULT_DIR stdout
          print_results $CHECK_BAD_RESULT_DIR stdout
          wait_for_enter
        }
    "7" { delete_tests $CHECK_ACT_PATH
          wait_for_enter
        }
    "8" { 
          if {[ file isfile "${CHECK_REPORT_FILE}.ok" ] == 1 } {
             delete_file "${CHECK_REPORT_FILE}.ok"
          }
          if {[ file isfile "${CHECK_REPORT_FILE}.failed" ] == 1 } {
             delete_file "${CHECK_REPORT_FILE}.failed"
          }
          create_report "${CHECK_REPORT_FILE}.ok" 0
          create_report "${CHECK_REPORT_FILE}.failed"  1
          wait_for_enter
        }
    "9" {
          run_all_at_starttime
          wait_for_enter
        }
    "10" {
           if { [ string compare "stdout" $CHECK_OUTPUT ] == 0 } {
              set CHECK_OUTPUT [open "$CHECK_MAIN_RESULTS_DIR/$CHECK_HOST.checklog" "w"]  
           } else {
              close $CHECK_OUTPUT
              set CHECK_OUTPUT stdout
           }
           

         }
    "11" {
          if {$localtest >= 0} {
            puts "local test description ..."
            show_test $CHECK_ACT_PATH 1
            wait_for_enter
          }
        }
    "12" {
          if {$localtest >= 0} {
            puts "running local test ..."
            run_test $CHECK_ACT_PATH 1
            wait_for_enter
          }
         }
    "13" {
            if {$localtest >= 0} {
               while { 1 == 1 } {
                  puts "running local test ..."
                  run_test $CHECK_ACT_PATH 1
                  create_report ${CHECK_REPORT_FILE}.ok 0
                  create_report ${CHECK_REPORT_FILE}.failed 1
               } 
            }
         }

   }
  menu
}

proc setup_shared_lib_path {} {
   global env CHECK_PRODUCT_ROOT CHECK_ARCH CHECK_OUTPUT

   switch -exact $CHECK_ARCH {
      aix41 -
      aix42 -
      aix43 {
         set name LIBPATH
      }
      hp10 -
      hp11 {
         set name SHLIB_PATH
      }
      default {
         set name LD_LIBRARY_PATH
      }
   }

   if { [info exists env($name)] } {
      set env($name) "$env($name):$CHECK_PRODUCT_ROOT/lib/$CHECK_ARCH"
   } else {
      set env($name) "$CHECK_PRODUCT_ROOT/lib/$CHECK_ARCH"
   }

   puts $CHECK_OUTPUT "set environment variable $name to $env($name)"
}

# Main programm:

set do_kill           0
set do_install        0
set do_compile        0
set do_not_update     0
set do_all            0
set do_nomain         0
set do_only_reset_config 0
set be_quiet          0
set CHECK_CUR_PROC_NAME "main"
set check_name "main"
set CHECK_ACTUAL_TEST_PATH "not in testmode"
set mail_subject "testsuite error - main"
set mail_body    "date: [exec date]\n:\n"

for { set i 0 } { $i < $argc } { incr i } {
   
   if {([string compare [lindex $argv $i] "--setup"] == 0) || ([string compare [lindex $argv $i] "setup"] == 0) } {
      set catch_return [ catch { eval exec "cp ${CHECK_DEFAULTS_FILE} ${CHECK_DEFAULTS_FILE}.[timestamp]" } ]
      if { $catch_return == 0 } { 
        set CHECK_DO_SETUP 1 
      } else {
        puts "could not copy defaults file"
      }
      continue
   }
   
   if {([string compare [lindex $argv $i] "--quiet"] == 0) || ([string compare [lindex $argv $i] "quiet"] == 0) } {
      set be_quiet 1
      continue
   }
   if {([string compare [lindex $argv $i] "--close_rlogin"] == 0) || ([string compare [lindex $argv $i] "close_rlogin"] == 0) } {
      set do_close_rlogin 1
      continue
   }


   if {([string compare [lindex $argv $i] "--help"] == 0) || ([string compare [lindex $argv $i] "help"] == 0) } {
      puts "usage: expect check.exp \[options\]"
      puts "\noptions are:"
      puts "help                  show this"
      puts ""
      puts "install               just install core system and exit"
      puts ""
      puts "kill                  shutdown cluster"
      puts ""
      puts "setup                 run setup"
      puts ""
      puts "file FILE             use FILE as defaults file"
      puts ""
      puts "re_init               use allready installed system (will only shutdown/reconfigure the cluster!)"
      puts "                      when test install_core_system is called or install option is set"
      puts ""
      puts "re_init_on_tcl_error  reinitialize cluster when tcl error occurs"
      puts ""
      puts "compile               checkout source code and recompile"
      puts ""
      puts "no_update             do not update source when compile option is used"
      puts ""
      puts "all RUNLEVEL          run every test automatically up to runlevel RUNLEVEL"
      puts "                      (RUNLEVEL is a value from 0=short tests, up to 4=week tests)"
      puts "" 
      puts "no_main               don't run main part (usefull for sourceing this file)"
      puts ""
      puts "reset_conf            reset test cluster"
      puts ""
      puts "debug LEVEL           run testsuite in debuglevel 0,1 or 2"
      puts "                      0=no debug, 1=more output, 2=1+user response"
      puts ""
      puts "quiet                 no output on setup"
      puts ""
      puts "mfile FILE            write all mails into file FILE (when mail is enabled)"
      puts ""
      puts "close_rlogin          don't let rlogin connections open for next command (per default the testsuite"
      puts "                      not close a rlogin connection. The testsuite will reuse the open connection"
      puts "                      for a later remote command. Use close_rlogin if the number of open file "
      puts "                      descriptors is low on your system)"
      puts ""
      puts "master_debug          procedure startup_qmaster will startup qmaster"
      puts "                      in debug mode (using x host from DISPLAY,"
      puts "                      please enable xhost display for all users)"
      puts ""
      puts "schedd_debug          procedure startup_qmaster will startup schedduler"
      puts "                      in debug mode (using x host from DISPLAY,"
      puts "                      please enable xhost display for all users)"
      puts ""
      puts "display DISPLAY       set display for daemon debug windows"

      exit 1
   }
   if { ( [string compare [lindex $argv $i] "--re_init"] == 0 ) || ([string compare [lindex $argv $i] "re_init"] == 0) } {
      set check_use_installed_system 1
      continue
   }

   if { ( [string compare [lindex $argv $i] "--re_init_on_tcl_error"] == 0 ) || ([string compare [lindex $argv $i] "re_init_on_tcl_error"] == 0) } {
      set check_reinit_on_tcl_error 1
      continue
   }


   if { ( [string compare [lindex $argv $i] "--master_debug"] == 0 ) || ([string compare [lindex $argv $i] "master_debug"] == 0) } {
      set master_debug 1
      set daemon_debug 1
      continue
   }
   if { ( [string compare [lindex $argv $i] "--schedd_debug"] == 0 ) || ([string compare [lindex $argv $i] "schedd_debug"] == 0) } {
      set schedd_debug 1
      set daemon_debug 1
      continue
   }
   if { ( [string compare [lindex $argv $i] "--display"] == 0 ) || ([string compare [lindex $argv $i] "display"] == 0) } {
      incr i
      set CHECK_DISPLAY_OUTPUT [lindex $argv $i]
      continue
   }

   


   if { ( [string compare [lindex $argv $i] "--kill"] == 0 ) || ([string compare [lindex $argv $i] "kill"] == 0) } {
      set do_kill 1
      continue
   }
   
   if { ( [string compare [lindex $argv $i] "--mfile"] == 0 ) || ([string compare [lindex $argv $i] "mfile"] == 0) } {
      incr i
      set CHECK_MAIL_OUTPUT_FILE [lindex $argv $i]
      if { [llength $CHECK_MAIL_OUTPUT_FILE] != 1 } {
         puts $CHECK_OUTPUT "can't use \"mfile\" option without filename!"
         exit -1 
      }
      if { ([ string first "/" $CHECK_MAIL_OUTPUT_FILE ] < 0) && ([ string first "\/" $CHECK_MAIL_OUTPUT_FILE ] < 0)} {
          set CHECK_MAIL_OUTPUT_FILE "$CHECK_CURRENT_WORKING_DIR/$CHECK_MAIL_OUTPUT_FILE"
      }
      set write_mail_to_file 1
      puts $CHECK_OUTPUT " ---> writing all mails into \"$CHECK_MAIL_OUTPUT_FILE\" ! <---"
      continue
   }
 
   if { ( [string compare [lindex $argv $i] "--file"] == 0 ) || ([string compare [lindex $argv $i] "file"] == 0) } {
      incr i
      set CHECK_DEFAULTS_FILE [lindex $argv $i]
      if { [llength $CHECK_DEFAULTS_FILE] != 1 } {
         puts $CHECK_OUTPUT "can't use \"file\" option without filename!"
         exit -1 
      }

      if { ([ string first "/" $CHECK_DEFAULTS_FILE ] < 0) && ([ string first "\/" $CHECK_DEFAULTS_FILE ] < 0)} {
          set CHECK_DEFAULTS_FILE "$CHECK_CURRENT_WORKING_DIR/$CHECK_DEFAULTS_FILE"
      }
      puts $CHECK_OUTPUT " ---> using \"$CHECK_DEFAULTS_FILE\" for setup! <---"
      continue
   }
  
   

   if { ( [string compare [lindex $argv $i] "--install"] == 0 ) || ([string compare [lindex $argv $i] "install"] == 0 ) } {
      set do_install 1
      continue
   }

   if { ( [string compare [lindex $argv $i] "--compile"] == 0 ) || ([string compare [lindex $argv $i] "compile"] == 0 ) } {
      set do_compile 1
      continue
   }

   if { ( [string compare [lindex $argv $i] "--no_update"] == 0 ) || ([string compare [lindex $argv $i] "no_update"] == 0 ) } {
      set do_not_update 1
      continue
   }

   
   
   if { ( [string compare [lindex $argv $i] "--reset_conf"] == 0 ) || ([string compare [lindex $argv $i] "reset_conf"] == 0 ) } {
      set do_only_reset_config 1
      set check_use_installed_system 1
      continue
   }
  

   if { ( [string compare [lindex $argv $i] "--all"] == 0 ) || ([string compare [lindex $argv $i] "all"] == 0 ) } {
      set do_all 1
      set ru_lev [ expr (1 + $i) ] 
      set do_all_runlevel [lindex $argv $ru_lev]
      if { [ llength $do_all_runlevel ] != 1 } {
         puts $CHECK_OUTPUT "used all parameter without runlevel"
         setup
         set mail_body "$mail_body product version is [get_version_info]\n"
         set mail_body "$mail_body testsuite root directory is \"$CHECK_TESTSUITE_ROOT\"\n"
         set mail_body "$mail_body check is running on host \"$CHECK_HOST\" architecture is \"$CHECK_ARCH\"\n"
         set mail_body "$mail_body product root directory is \"$CHECK_PRODUCT_ROOT\"\n-------\n"
         mail_report $mail_subject "$mail_body used all parameter without runlevel" 
         exit -1
      }
      incr i
      continue
   }

   if { ( [string compare [lindex $argv $i] "--debug"] == 0 ) || ([string compare [lindex $argv $i] "debug"] == 0 ) } {
      set deb_lev [ expr (1 + $i) ] 
      set CHECK_DEBUG_LEVEL [lindex $argv $deb_lev]

      debug_puts "debuglevel is $CHECK_DEBUG_LEVEL"
      incr i
      continue
   }



   if { ( [string compare [lindex $argv $i] "--no_main"] == 0 ) || ([string compare [lindex $argv $i] "no_main"] == 0 ) } {
      set do_nomain 1
      set no_action 0
      continue
   }
}   

# load defaults file
setup

set CHECK_ACT_PATH $CHECK_CHECKTREE_ROOT


set mail_body "$mail_body product version is [get_version_info]\n"
set mail_body "$mail_body testsuite root directory is \"$CHECK_TESTSUITE_ROOT\"\n"
set mail_body "$mail_body check is running on host \"$CHECK_HOST\" architecture is \"$CHECK_ARCH\"\n"
set mail_body "$mail_body product root directory is \"$CHECK_PRODUCT_ROOT\"\n-------\n"

if { $no_action == 1 } {
  puts "No action flag is set -> exit 1"
  exit 1
}

if { $check_reinit_on_tcl_error == 1 } {
   set_root_passwd   
}

if { $do_compile } {
   if { [ compile_source ] != 0 } {
      exit -1
   } else {
      exit 0
   }
}


if { $do_all } {
   set CHECK_ACT_PATH "$CHECK_CHECKTREE_ROOT"
   delete_tests $CHECK_ACT_PATH

   puts $CHECK_OUTPUT "install_core_system ..."
   set CHECK_ACT_PATH "$CHECK_CHECKTREE_ROOT/install_core_system"
   set dirs [ get_dir_names $CHECK_ACT_PATH ]
   set files [get_file_names $CHECK_ACT_PATH ]

   foreach elem $dirs {
     set CHECK_DIRECTORIES ""
     get_check_dirs "$CHECK_ACT_PATH/$elem"
     set count [llength $CHECK_DIRECTORIES]
     puts $CHECK_OUTPUT "$count test(s) available in subdir: $elem"
   }
   
   get_max_level_count $CHECK_ACT_PATH
   set selected_levels ""
   set CHECK_GUILTY_RUNLEVELS ""
   for {set i 0} {$i<= $do_all_runlevel} {incr i 1} {
      lappend CHECK_GUILTY_RUNLEVELS [ expr ( $i * 100 )  ]
   }

   foreach elem $CHECK_GUILTY_RUNLEVELS {
      set a_level [ get_run_level_name $elem ] 
 
      if { [string first $a_level $selected_levels ] < 0 } {
         set selected_levels "$selected_levels $a_level"
      } 
   } 
   puts $CHECK_OUTPUT "selected runlevel: $selected_levels"

   run_test $CHECK_ACT_PATH 1

   
   puts $CHECK_OUTPUT "run all tests ..."
   set CHECK_ACT_PATH "$CHECK_CHECKTREE_ROOT"
   set dirs [ get_dir_names $CHECK_ACT_PATH ]
   set files [get_file_names $CHECK_ACT_PATH ]
   
   foreach elem $dirs {
     set CHECK_DIRECTORIES ""
     get_check_dirs "$CHECK_ACT_PATH/$elem"
     set count [llength $CHECK_DIRECTORIES]
     puts $CHECK_OUTPUT "$count test(s) available in subdir: $elem"
   }
   
   get_max_level_count $CHECK_ACT_PATH
   set selected_levels ""
   set CHECK_GUILTY_RUNLEVELS ""
   for {set i 0} {$i<= $do_all_runlevel} {incr i 1} {
      lappend CHECK_GUILTY_RUNLEVELS [ expr ( $i * 100 )  ]
   }


   foreach elem $CHECK_GUILTY_RUNLEVELS {
      set a_level [ get_run_level_name $elem ] 
 
      if { [string first $a_level $selected_levels ] < 0 } {
         set selected_levels "$selected_levels $a_level"
      } 
   } 
   puts $CHECK_OUTPUT "selected runlevel: $selected_levels"

   run_tests $CHECK_ACT_PATH 0

   if {[ file isfile ${CHECK_REPORT_FILE}.ok ] == 1 } {
      delete_file "${CHECK_REPORT_FILE}.ok"
   }
   if {[ file isfile ${CHECK_REPORT_FILE}.failed ] == 1 } {
      delete_file "${CHECK_REPORT_FILE}.failed"
   }
   create_report "${CHECK_REPORT_FILE}.ok" 0
   create_report "${CHECK_REPORT_FILE}.failed"  1

   sleep 5
   set mail_subject "testsuite run complete"
   set mail_body "\n######## Tests ok ($CHECK_REPORT_FILE.ok):\n"
   
   set good_rep [open "${CHECK_REPORT_FILE}.ok" "RDONLY"]
   set line ""
   while { [gets $good_rep line] >= 0 } {
          set mail_body "$mail_body  $line\n"
   }
   close $good_rep

   set mail_body "$mail_body\n\n######## Tests failed ($CHECK_REPORT_FILE.failed):\n"
   set bad_rep [open "${CHECK_REPORT_FILE}.failed" "RDONLY"]
   set line ""
   while { [gets $bad_rep line] >= 0 } {
          set mail_body "$mail_body  $line\n"
   }
   close $bad_rep

   mail_report $mail_subject $mail_body
   exit 0
} 

#setup
#set CHECK_ACT_PATH $CHECK_CHECKTREE_ROOT


if { $do_install } {
   puts "installing core system on host $CHECK_HOST ..."
   set CHECK_ACT_PATH "$CHECK_ACT_PATH/install_core_system"  
   run_test $CHECK_ACT_PATH 1
   exit 0 
}

if { $do_kill } {
   shutdown_core_system
   exit 0   
}

if { $do_only_reset_config == 1 } {
  set result 1
 
  set CHECK_ACT_PATH "$CHECK_ACT_PATH/install_core_system"
  run_test $CHECK_ACT_PATH 1 "setup_queues" 0
  run_test $CHECK_ACT_PATH 1 "setup_testcheckpointobject" 0
  run_test $CHECK_ACT_PATH 1 "setup_conf" 0
  run_test $CHECK_ACT_PATH 1 "setup_mytestproject" 0
  run_test $CHECK_ACT_PATH 1 "setup_mytestpe" 0
  run_test $CHECK_ACT_PATH 1 "setup_deadlineuser" 0
  run_test $CHECK_ACT_PATH 1 "setup_schedconf" 0
  run_test $CHECK_ACT_PATH 1 "setup_default_calendars" 0
  run_test $CHECK_ACT_PATH 1 "setup_inhouse_cluster" 0
 
  puts "configuration reset done" 
  exit $result
}


 
if {$do_nomain == 0} {
  if { $daemon_debug != 0 } {
     if { [ string compare $CHECK_DISPLAY_OUTPUT "undefined" ] == 0 } {
        puts "no debug x display set"
        exit -1
     } 
     start_remote_prog "$CHECK_CORE_MASTER" "$CHECK_USER" "/usr/openwin/bin/xterm" "-bg darkolivegreen -fg navajowhite -sl 5000 -sb -j -display $CHECK_DISPLAY_OUTPUT -e sleep 1"
     if { $prg_exit_state != 0 } {
         puts "can't open display $CHECK_DISPLAY_OUTPUT as user $CHECK_USER from host $CHECK_CORE_MASTER"    
         exit -1
     }


     if { [ have_root_passwd ] != 0 } {
         set_root_passwd
     }
     start_remote_prog "$CHECK_CORE_MASTER" "root" "/usr/openwin/bin/xterm" "-bg darkolivegreen -fg navajowhite -sl 5000 -sb -j -display $CHECK_DISPLAY_OUTPUT -e sleep 1"
     if { $prg_exit_state != 0 } {
         puts "can't open display $CHECK_DISPLAY_OUTPUT as user root from host $CHECK_CORE_MASTER"    
         exit -1
     }
  }
  puts "please press <RETURN>"
  gets stdin test
  menu 
}


