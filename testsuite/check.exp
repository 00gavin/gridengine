#!/vol2/TCL_TK/glinux/bin/expect
# expect script 
# test SGE/SGEEE System
#___INFO__MARK_BEGIN__
##########################################################################
#
#  The Contents of this file are made available subject to the terms of
#  the Sun Industry Standards Source License Version 1.2
#
#  Sun Microsystems Inc., March, 2001
#
#
#  Sun Industry Standards Source License Version 1.2
#  =================================================
#  The contents of this file are subject to the Sun Industry Standards
#  Source License Version 1.2 (the "License"); You may not use this file
#  except in compliance with the License. You may obtain a copy of the
#  License at http://gridengine.sunsource.net/Gridengine_SISSL_license.html
#
#  Software provided under this License is provided on an "AS IS" basis,
#  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
#  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
#  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
#  See the License for the specific provisions governing your rights and
#  obligations concerning the Software.
#
#  The Initial Developer of the Original Code is: Sun Microsystems, Inc.
#
#  Copyright: 2001 by Sun Microsystems, Inc.
#
#  All Rights Reserved.
#
##########################################################################
#___INFO__MARK_END__

global daemon_debug 
set daemon_debug 0
global master_debug
set master_debug 0
global schedd_debug
set schedd_debug 0

global no_action                   ;# just used for testing/debug  procedures
set no_action 0
global be_quiet
set be_quiet 0
global write_mail_to_file
set write_mail_to_file 0
global do_close_rlogin
set do_close_rlogin 0

global do_compile
global CHECK_TESTSUITE_LOCKFILE
set CHECK_TESTSUITE_LOCKFILE "testsuite_lockfile"

# path/file variables
global CHECK_TESTSUITE_ROOT        ;# path to TESTSUITE directory
global CHECK_CHECKTREE_ROOT        ;# path where checktree lies

# never touch these dirs: begin
global CHECK_RESULT_DIR            ;# check result directory            
global CHECK_BAD_RESULT_DIR        ;# check rusult directory for failed checkes
global CHECK_CORE_RESULT_DIR       ;# check result core system directory
global CHECK_CORE_BAD_RESULT_DIR   ;# check result directory for failed core system checkes
# never touch these dirs : end

# this is for new tests:
global CHECK_PROTOCOL_DIR          ;# directory for test protocols, logs etc.
global CHECK_JOB_OUTPUT_DIR        ;# directory for qsub job outputs
############################################################################

global CHECK_ACTUAL_TEST_PATH      ;# directory of current running test
global CHECK_PRODUCT_ROOT          ;# path to sge system
global CHECK_OUTPUT                ;# output from testsuite 
global CHECK_CURRENT_WORKING_DIR   ;# current work directory
global CHECK_HTML_DIRECTORY        ;# directory for HTML output of testsuite 
set CHECK_HTML_DIRECTORY ""
# globals for source code specific staff
global CHECK_SOURCE_DIR            ;# path to source code directory (c4)
global CHECK_SOURCE_CVS_RELEASE    ;# release name to check out e.g. V52_BRANCH
set CHECK_SOURCE_CVS_RELEASE "maintrunk"    ;# default is "maintrunk"
global CHECK_SOURCE_HOSTNAME       ;# name of host with cvs installed on (e.g. fangorn)
global CHECK_AIMK_COMPILE_OPTIONS     ;# optional: aimk options
global CHECK_DIST_INSTALL_OPTIONS     ;# optional: mydistinst options
global CHECK_PACKAGE_DIRECTORY        ;# optional: no compile directory, use distribution (tar or sun packages)
global CHECK_PACKAGE_TYPE             ;# zip or tar
set CHECK_PACKAGE_TYPE "tar"
global CHECK_QMASTER_INSTALL_OPTIONS  ;# optional: qmaster install parameter
global CHECK_EXECD_INSTALL_OPTIONS    ;# optional: execd install parameter 
set CHECK_AIMK_COMPILE_OPTIONS ""
set CHECK_DIST_INSTALL_OPTIONS "-allall"
set CHECK_PACKAGE_DIRECTORY "none"
set CHECK_QMASTER_INSTALL_OPTIONS ""
set CHECK_EXECD_INSTALL_OPTIONS   ""

# test system specific 
global CHECK_L10N  ;# is sge/sgeee system l10n'ed ?
set CHECK_L10N 0
global CHECK_DNS_DOMAINNAME
set CHECK_DNS_DOMAINNAME ""
global CHECK_REMOTE_ENVIRONMENT
set CHECK_REMOTE_ENVIRONMENT ""
global CHECK_DISPLAY_OUTPUT 
if { [info exists env(DISPLAY)] } {
set CHECK_DISPLAY_OUTPUT [set env(DISPLAY)]
} else {
set CHECK_DISPLAY_OUTPUT "undefined"  
}
global CHECK_SETTINGS_VERSION    ;# settings file version number
set CHECK_SETTINGS_VERSION "undefined"
global CHECK_PRODUCT_VERSION_NUMBER ;# version string of qstat -help of tested system
set CHECK_PRODUCT_VERSION_NUMBER "unknown"
global CHECK_PRODUCT_TYPE           ;# "sgeee" or "sge" 
global CHECK_COMMD_PORT            ;# commd port
global CHECK_ARCH                  ;# architecture of this system (e.g. irix6)
set CHECK_ARCH "unknown"
global CHECK_USER                  ;# user who start test
global CHECK_GROUP                 ;# group of user who start test
global CHECK_HOST                  ;# hostname of this system (e.g. DWAIN)
global CHECK_CORE_EXECD            ;# known execd hostnames
set CHECK_CORE_EXECD ""
global CHECK_SUBMIT_ONLY_HOSTS     ;# list of submithosts (no execd/commd running)
set CHECK_SUBMIT_ONLY_HOSTS ""
global CHECK_CORE_MASTER           ;# qmaster hostname
set CHECK_CORE_MASTER ""
global CHECK_ACT_LEVEL             ;# actual check level ( value from 0 up to xxx )
global CHECK_ROOT_PASSWORD         ;# stored root password ( only stored in a variable )
global CHECK_SPOOL_DIR_CONFIG_FILE ;# file for local spooldirs in $CHECK_CONFIG_DIR path
set CHECK_SPOOL_DIR_CONFIG_FILE "local-spool.conf"
global CHECK_LOCAL_BINARY_DIR_CONFIG_FILE ;# file for local spooldirs in $CHECK_CONFIG_DIR path
set CHECK_LOCAL_BINARY_DIR_CONFIG_FILE "local-bin.conf"
global CHECK_BINARY_DIR_CONFIG_FILE ;# file for binary directories in $CHECK_CONFIG_DIR
set CHECK_BINARY_DIR_CONFIG_FILE "binary-path.conf"
global CHECK_LOADSENSOR_DIR_CONFIG_FILE ;# file for architecture specific loadsensor binaries in
set CHECK_LOADSENSOR_DIR_CONFIG_FILE "loadsensor.conf" ;# $CHECK_CONFIG_DIR
global CHECK_MAIL_OUTPUT_FILE
set CHECK_MAIL_OUTPUT_FILE "all_test_mails.txt"

global check_use_installed_system   ;# used only for install_core_system test (noinst parameter)
set check_use_installed_system 0    ;# set to 1 when installed system parameter is set

global check_do_not_use_spool_config_entries
set check_do_not_use_spool_config_entries 0

global check_do_clean_compile
set check_do_clean_compile 0

global check_reinit_on_tcl_error
set check_reinit_on_tcl_error 0

global CHECK_FIRST_FOREIGN_SYSTEM_USER       ;# other system user for e.g. submitting jobs 
set CHECK_FIRST_FOREIGN_SYSTEM_USER "nobody"

global CHECK_SECOND_FOREIGN_SYSTEM_USER      ;# other system user for e.g. submitting jobs 
set CHECK_SECOND_FOREIGN_SYSTEM_USER "nobody"

global CHECK_FIRST_FOREIGN_SYSTEM_GROUP      ;# other system group for e.g. submitting jobs
set CHECK_FIRST_FOREIGN_SYSTEM_GROUP "nogroup" 

global CHECK_SECOND_FOREIGN_SYSTEM_GROUP      ;# other system group for e.g. submitting jobs
set CHECK_SECOND_FOREIGN_SYSTEM_GROUP "nogroup" 

global CHECK_DEFAULT_DOMAIN                ;# default domain for install test
set CHECK_DEFAULT_DOMAIN "none"

global CHECK_MAILX_HOST                    ;# host where the mailx binary is available
set CHECK_MAILX_HOST "none"

global CHECK_REPORT_EMAIL_TO               ;# mail reports/errors to this email-account
set CHECK_REPORT_EMAIL_TO "none"

global CHECK_REPORT_EMAIL_CC               ;# cc reports/errors to this email-accounts
set CHECK_REPORT_EMAIL_CC "none"                 

global CHECK_SEND_ERROR_MAILS              ;# flag 0 off  1 on
set CHECK_SEND_ERROR_MAILS "1"

global CHECK_MAX_ERROR_MAILS              ;# max mails on run all test
set CHECK_MAX_ERROR_MAILS 400

global CHECK_USE_SSH                             ;# enable/disable use of ssh (o means disable)     
set CHECK_USE_SSH 0

global CHECK_TCL_SCRIPTFILE_DIR   ;# testsuite's subdir for tcl files
set CHECK_TCL_SCRIPTFILE_DIR "tcl_files"

global CHECK_SCRIPT_FILE_DIR  ;# testsuite's subdir for script files
set CHECK_SCRIPT_FILE_DIR "scripts"

global CHECK_EXPECT_MATCH_MAX_BUFFER   ;# read buffer for expect
set CHECK_EXPECT_MATCH_MAX_BUFFER 640000

# to redefine in checks:
global check_name                  ;# name of actual check module 
global check_category              ;# check category name array (z.b. COMPATIBILITY, NONROOT, SYSTEM, PERFORMANCE)
global check_description           ;# description of actual check module (append more levels as list)
global check_needs                 ;# dependencies of this check (name of other check)
global check_functions             ;# functions to call (in order)
global check_init_level_procedure   ;# name of procedure to call before starting level run
global check_errno                ;# 0 -> OK , != 0 means error (-2 = break test , -1 failure )
global check_errstr                 ;# short error description in text form   
global check_highest_level         ;# here a check can define his check levels count 0 ...

# for global procedures
global check_cur_proc_error        ;# short error description in text form ( in public procedures )
global check_cur_proc_result       ;# 0 -> OK , != 0 means error (-2 = break test , -1 failure )    


# testsuite intern
global CHECK_INFORMATION_FILE      ;# filename of check information (check.exp)
global CHECK_INFORMATION_EXT       ;# fileextension of check information (check.exp)
global CHECK_DIRECTORIES           ;# all sub directories with check's in actual checkpath
global CHECK_REPORT_FILE           ;# filename (with path) for report
global CHECK_MAIN_RESULTS_DIR      ;# check result root directory for all RESULTS
global CHECK_CONFIG_DIR            ;# global configuration testsuite directory
global CHECK_DEFAULTS_FILE         ;# default settings save file
global CHECK_DO_SETUP              ;# flag: do setup option called ?
global CHECK_CUR_PROC_NAME         ;# name of current running test procedure
global CHECK_CUR_PROC_ERRORS       ;# list of procedure errors   ({error text} {error text} ... )
global CHECK_CUR_PROC_RESULTS      ;# list of procedure results  (0 -1 -2 0 ...)
global CHECK_ENABLED_RUNLEVELS      ;# enabled runlevels
global CHECK_ENABLED_CATEGORIES     ;# enabled categories
global CHECK_MAX_LEVEL             ;# highest level number of all subtests
global CHECK_ACT_PATH              ;# actual checkpath (while switching in menu mode)
global arch_cache                  ;# cache for architecture names (lower case) e.g. solaris64
global pe_for_version_check_result ;# cache for pe/checkpnt version
global build_arch_cache            ;# cache for architecture names (upper case) e.g. SOLARIS64
global l10n_raw_cache              ;# chche for l10n translation strings
global l10n_install_cache          ;# cache for l10n installation script strings
global set_error_proc_called       ;# flag
global open_spawn_buffer           ;# buffer for open_spawn_process arguments
global have_ssh_access_state       ;# global variable for have_ssh_access procedure (remember state)
global check_timestamp             ;# for use in is_job_running
global CHECK_SGE_DEBUG_LEVEL       ;# SGE_DEBUG_LEVEL for starting qmaster and scheduler in debug mode
set CHECK_SGE_DEBUG_LEVEL "2 0 0 0 0 0 0 0"
global CHECK_MAILS_SENT            ;# counter for send mails
set CHECK_MAILS_SENT 0
global CHECK_ENABLE_MAIL           ;# is mail sending enabled
set CHECK_ENABLE_MAIL 1
global CHECK_ADMIN_USER_SYSTEM     ;# if no root account is possible
set CHECK_ADMIN_USER_SYSTEM 0
set check_timestamp [timestamp]
set have_ssh_access_state -1
set pe_for_version_check_result "undefined"
set CHECK_ROOT_PASSWORD    "none"
set CHECK_ENABLED_RUNLEVELS "0"
set CHECK_ENABLED_CATEGORIES {}
set CHECK_DO_SETUP         0
set CHECK_INFORMATION_FILE "check"   ;# this is the filename of each check in different
set CHECK_INFORMATION_EXT  "exp"     ;# default extension for check files
                                         ;# subdirectories of "checktree"
                                         ;# every file with this name is interpreded as check routine


# debuglevel 0 - none
# debuglevel 1 - more output
# debuglevel 2 - wait for user response (sometimes!)

global CHECK_DEBUG_LEVEL
set CHECK_DEBUG_LEVEL 0 

#
#                                                             max. column:     |
#****** check/debug_puts() ******
#  NAME
#     debug_puts -- ??? 
#
#  SYNOPSIS
#     debug_puts { args } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#     args - ??? 
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
#
proc debug_puts { args } {
   global CHECK_OUTPUT CHECK_DEBUG_LEVEL
   global CHECK_CUR_PROC_NAME CHECK_HOST
   if { $CHECK_DEBUG_LEVEL == 0 } {
      return
   }
   set output ""
   foreach elem $args {
      set output "$output $elem"
   }   

   if { [info exists CHECK_HOST ] == 0 } {
      set CHECK_HOST "unknown"
   }

   puts $CHECK_OUTPUT "\[host: $CHECK_HOST, debug/$CHECK_CUR_PROC_NAME\] $output" 
}

#
#                                                             max. column:     |
#****** check/dump_ts_config() ******
#  NAME
#     dump_ts_config -- dump the testsuite configuration
#
#  SYNOPSIS
#     dump_ts_config { outputfile } 
#
#  FUNCTION
#     Dumps the contents of the ts_config array holding the testsuite 
#     configuration.
#     It is written to a file with the given outputfile name in a 
#     TAB separated ASCII file format:
#     The fields Name, Value and Description are written where
#     - Name is the name of the parameter
#     - Value is the value of the parameter in the current configuration
#     - Description is the testsuite internal description of the parameter
#
#  INPUTS
#     outputfile - name of the output file 
#
#  EXAMPLE
#     A call of
#     expect check.exp execute_func dump_ts_config ts_config.txt
#
#     will generate a file as follows:
#
#     Name    Value   Description
#     add_compile_archs       none    Forced compilation for architectures
#     aimk_compile_options    -secure Aimk compile options
#     checktree_root_dir   ...
#
#*******************************
#
proc dump_ts_config {outputfile} {
   global ts_config
  
   set output [open "$outputfile" w]
  
   set names {}
   
   foreach name [array names ts_config] {
      if {[string first "," $name] == -1} {
         lappend names $name
      }
   }

   puts $output "Name\tValue\tDescription\t"
   foreach name [lsort -dictionary $names] {
      puts $output [format "%s\t%s\t%s" "$name" "$ts_config($name)" "$ts_config($name,desc)"]
   }

   close $output
}



#                                                             max. column:     |
#****** check/get_current_working_dir() ******
# 
#  NAME
#     get_current_working_dir -- ??? 
#
#  SYNOPSIS
#     get_current_working_dir { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc get_current_working_dir { } {

  set work_dir [pwd]
  debug_puts "working dir is $work_dir"
  set help0 $work_dir
  while  { 1 } {
     set help [ split $help0 "/" ]
     set help2 [ lreplace $help 0 1 ]
     set new_work_dir "/[ join $help2 "/" ]"
     set help0 $new_work_dir
     set catch_return_1 [ catch { 
         eval exec "ls $work_dir"
     } result_1 ] 

     set catch_return_2 [ catch { 
         eval exec "ls $new_work_dir" 
     } result_2 ]
     if { $catch_return_1 == 0 && $catch_return_2 == 0} {
        if { [ string compare $result_1 $result_2 ] == 0 } {
           # possibly mounted directory try to create a file
           set f_name "testsuite_test_[timestamp]"
           set catch_return_3 [ catch { 
              eval exec "touch $work_dir/$f_name" 
           } result_3 ]
           if { [ file isfile "$new_work_dir/$f_name" ] } {
              puts "--> mount prefix found, using $new_work_dir"
              set work_dir $new_work_dir
           }
           set catch_return_4 [ catch { 
              eval exec "rm $work_dir/$f_name" 
           } result_4 ]
        }
     }
     if { [string compare $help0 "/" ] == 0 } {
        break;
     }
  }
  return $work_dir 
}

set CHECK_CURRENT_WORKING_DIR [get_current_working_dir]
set CHECK_DEFAULTS_FILE    "$CHECK_CURRENT_WORKING_DIR/defaults.sav"

set CHECK_TESTSUITE_ROOT "$CHECK_CURRENT_WORKING_DIR"
set CHECK_CHECKTREE_ROOT "$CHECK_CURRENT_WORKING_DIR/checktree"
set CHECK_MAIN_RESULTS_DIR "$CHECK_CURRENT_WORKING_DIR/results"
set CHECK_TESTSUITE_LOCKFILE "$CHECK_CURRENT_WORKING_DIR/testsuite_lockfile"

#set CHECK_OUTPUT [open /dev/null "w"]
set CHECK_OUTPUT stdout 


# some useful functions for test implementation



# 
#                                                             max. column:     |
#****** check/add_proc_error() ******
# 
#  NAME
#     add_proc_error -- append testsuite error message
#
#  SYNOPSIS
#     add_proc_error { proc_name result text } 
#
#  FUNCTION
#     This procedure adds a new error to the global error arrays for the global 
#     procedures.  
#
#     So a test programmer doesn't have to set the error states after calling 
#     a global procedure which uses add_proc_error. Each global procedure 
#     set the error state by itself. 
#
#     The test run will report ALL global errors and doesn't set the test run 
#     to a correct state if such an error is reported. 
#
#     Some global procedures have an optional flag to switch off the global 
#     error report. For some cases it is necessary to turn off the error 
#     reporting. (e.g. forced timeout test)
#
#  INPUTS
#     proc_name - name of the calling procedure
#     result    - error state (e.g. -1)
#     text      - error text (e.g. "open file xxx failed)
#
#  RESULT
#     no result
#
#  SEE ALSO
#     check/set_error
#*******************************
proc add_proc_error { proc_name result text } {
   global CHECK_CUR_PROC_ERRORS CHECK_CUR_PROC_RESULTS CHECK_CUR_PROC_NAME CHECK_OUTPUT check_name CHECK_TESTSUITE_ROOT
   global CHECK_ARCH CHECK_HOST CHECK_PRODUCT_ROOT CHECK_ACT_LEVEL CHECK_CORE_MASTER CHECK_CORE_EXECD
   global CHECK_USER CHECK_TESTSUITE_ROOT CHECK_SCRIPT_FILE_DIR check_name

   lappend CHECK_CUR_PROC_RESULTS $result
   set new_error ""
   lappend new_error "$proc_name|$text|$check_name|$CHECK_CUR_PROC_NAME"
   lappend CHECK_CUR_PROC_ERRORS $new_error

   if { $check_name != "setup" } {
      show_proc_error $result $new_error
   } else {
      puts $CHECK_OUTPUT [ create_error_message $new_error ]
   }
}

#                                                             max. column:     |
#****** check/show_proc_error() ******
# 
#  NAME
#     show_proc_error -- ??? 
#
#  SYNOPSIS
#     show_proc_error { result new_error } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#     result    - ??? 
#     new_error - ??? 
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc show_proc_error { result new_error } {
   global CHECK_CUR_PROC_ERRORS CHECK_CUR_PROC_RESULTS CHECK_CUR_PROC_NAME CHECK_OUTPUT check_name CHECK_TESTSUITE_ROOT
   global CHECK_ARCH CHECK_HOST CHECK_PRODUCT_ROOT CHECK_ACT_LEVEL CHECK_CORE_MASTER CHECK_CORE_EXECD
   global CHECK_SEND_ERROR_MAILS

   if { $result != 0 } {
      set category "error"
      if { $result == -3 } {
         set category "unsupported test warning"
      }
      puts $CHECK_OUTPUT ">>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>"
      puts $CHECK_OUTPUT ">>> $category"
      puts $CHECK_OUTPUT ">>> runlevel    : \"[get_run_level_name $CHECK_ACT_LEVEL]\", ($CHECK_ACT_LEVEL)"
      puts $CHECK_OUTPUT ">>> "
      set error_output [ create_error_message $new_error ]
      puts $CHECK_OUTPUT $error_output 


      flush $CHECK_OUTPUT
      if { $CHECK_SEND_ERROR_MAILS == 1 } {
         append mail_body "\nDate                     : [exec date]\n"
         append mail_body "testsuite root directory : \"$CHECK_TESTSUITE_ROOT\"\n"
         append mail_body "check host               : \"$CHECK_HOST\"\n"
         append mail_body "architecture             : \"$CHECK_ARCH\"\n"
         append mail_body "product version          : \"[get_version_info]\"\n"
         append mail_body "product root directory   : \"$CHECK_PRODUCT_ROOT\"\n"
         append mail_body "master host              : \"$CHECK_CORE_MASTER\"\n"
         append mail_body "execution hosts          : \"$CHECK_CORE_EXECD\"\n\n"
         append mail_body "-----------------------------------------------------\n\n"
         append mail_body "check_name  : \"$check_name\"\n"
         append mail_body "category    : \"$category\"\n"
         append mail_body "runlevel    : \"[get_run_level_name $CHECK_ACT_LEVEL]\", ($CHECK_ACT_LEVEL)\n"
         append mail_body "$error_output"
         catch {
            foreach level "1 2 3 4" {
               upvar $level expect_out out
               if {[info exists out]} {
                  append mail_body "----- expect buffer in upper level $level --------\n"
                  foreach i [array names out] {
                     append mail_body "$i:\t$out($i)\n"
                  }
               }
            }
         }
         mail_report "testsuite $category - $check_name" $mail_body
      }
    }
}

#                                                             max. column:     |
#****** check/create_error_message() ******
# 
#  NAME
#     create_error_message -- ??? 
#
#  SYNOPSIS
#     create_error_message { error_array } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#     error_array - ??? 
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc create_error_message { error_array} {

  set catch_return [catch {
  #set err_string [lindex $error_array 0]
  set err_string $error_array
  } ]
  if { $catch_return != 0 } {
     set err_string "catch error: error reading error_array"
  }
  
  set err_complete [ split $err_string "|" ]
  set err_procedure [ lindex $err_complete 0 ]
  set err_text      [ lindex $err_complete 1 ]
  set err_checkname [ lindex $err_complete 2 ]
  set err_calledby  [ lindex $err_complete 3 ]
  set output ">>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>\n"
  append output ">>> check \"$err_checkname\", procedure \"$err_procedure\"\n"
  if { [ string compare $err_calledby $err_procedure ] != 0 } {
     append output ">>> called from \"$err_calledby\":\n"
  }
  append output "\"$err_text\"\n"
  append output ">>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>\n\n"

  return $output
}

#                                                             max. column:     |
#****** check/have_ssh_access() ******
# 
#  NAME
#     have_ssh_access -- is ssh accessable ?
#
#  SYNOPSIS
#     have_ssh_access { } 
#
#  FUNCTION
#     This procedure tries to get a ssh (secure shell) connection to each execd 
#     host from the cluster. The result of this test is stored in a global 
#     variable so the next call will not cause the connection test again.
#
#  INPUTS
#
#  RESULT
#     0: no ssh access
#     1: ok
#
#  SEE ALSO
#     ???/???
#*******************************
proc have_ssh_access {} {
  global CHECK_CORE_EXECD open_spawn_buffer CHECK_OUTPUT have_ssh_access_state CHECK_USE_SSH CHECK_HOST


  if { $have_ssh_access_state != -1 } {
     return $have_ssh_access_state
  }

  if { $CHECK_USE_SSH == 0 } {
     set have_ssh_access_state 0
     return $have_ssh_access_state
  }

  set run_again 0
  if { [ info exists CHECK_CORE_EXECD ] != 1 } {
     puts $CHECK_OUTPUT "no execd hosts defined, checking only local ssh connection"
     set run_again 1
     set host_array $CHECK_HOST 
  } else {
     set host_array $CHECK_CORE_EXECD
  }

  set ssh_binary [get_binary_path $CHECK_HOST ssh]
  if { $ssh_binary == "" } {
     add_proc_error "have_ssh_access" "-1" "--> no ssh binary configured for host $CHECK_HOST - please update your testsuite host configuration"
     return 0
  }

  log_user 0
  set have_complete_access 1
  
  foreach elem $host_array { 
     set catch_state [ catch {

        puts $CHECK_OUTPUT "trying $ssh_binary -l root $elem id"

        set id [ open_spawn_process "$ssh_binary" "-l" "root" "$elem" "id"]
        set sp_id [ lindex $id 1 ] 
 
        set timeout 30
        set end_val 0
        set have_access 0
        while { $end_val == 0} {
           log_user 0
           expect {
               -i $sp_id full_buffer {
                  add_proc_error "have_ssh_access" "-1" "buffer overflow please increment CHECK_EXPECT_MATCH_MAX_BUFFER value"
               }

               -i $sp_id "uid*0*root" {
                  log_user 1 
                  puts $CHECK_OUTPUT "--> having ssh access to host $elem"
                  set end_val 1
                  set have_access 1
               }
               -i $sp_id "assword" {
                  set end_val 1
               }
               -i $sp_id timeout {
                  log_user 1 
                  puts $CHECK_OUTPUT "--> timeout waiting to get root access"
                  set end_val 1
               }
               -i $sp_id eof {
                  log_user 1 
                  puts $CHECK_OUTPUT "--> end of file dedected"
                  set end_val 1
               }
           }
        }
        set log_user 0
        close_spawn_process $id 1
        if { $have_access != 1 } {
            log_user 1
            set have_complete_access 0
            puts $CHECK_OUTPUT "--> no ssh access to host $elem"
            add_proc_error "have_ssh_access" "-1" "--> no ssh access to host $elem"
        }
     } ] ;# end of chatch
     if { $catch_state != 0} {
        puts $CHECK_OUTPUT "--> no ssh access to host $elem (maybe no ssh installed)"
        add_proc_error "have_ssh_access" "-1" "--> no ssh access to host $elem (maybe no ssh installed)"
        set have_complete_access 0
     }
  }
  log_user 1
  if { $run_again == 0 } {
     set have_ssh_access_state $have_complete_access
  }
  return $have_complete_access
}

#****** check/set_root_passwd() ******
# 
#  NAME
#     set_root_passwd -- ask user for root password
#
#  SYNOPSIS
#     set_root_passwd { } 
#
#  FUNCTION
#     This procedure reads in the root password from stdin. If the root password 
#     is not used ( ssh access garanted) the procedure returns immediately.
#     The root password is tested with an id call as root on the local machine.
#
#  INPUTS
#
#  SEE ALSO
#     check/have_root_passwd
#     check/get_root_passwd
#*******************************
proc set_root_passwd {} {
  global CHECK_ROOT_PASSWORD CHECK_OUTPUT CHECK_HOST CHECK_ADMIN_USER_SYSTEM

  if { $CHECK_ADMIN_USER_SYSTEM != 0 } {
     puts $CHECK_OUTPUT "--> running without root access"
     set CHECK_ROOT_PASSWORD "none"
     return
  }
  set result "no password" 
  puts "root access needed, please enter root password: "
  if { [have_ssh_access] == 0 } {
     stty -echo
     set  CHECK_ROOT_PASSWORD [wait_for_enter 1]
#     gets stdin CHECK_ROOT_PASSWORD
     stty echo
     if { [ string compare "" $CHECK_ROOT_PASSWORD ] == 0 } {
        set CHECK_ROOT_PASSWORD "none"
        puts $CHECK_OUTPUT "--> root password not set!"
     } else {
        puts $CHECK_OUTPUT "--> testing root access ..."
        set result [ start_remote_prog $CHECK_HOST "root" "id" "" ]
     }
  }
  
  if {[string first "root" $result] < 0 } {
     puts $CHECK_OUTPUT "--> id as root output:\n$result"
     puts $CHECK_OUTPUT "--> no root access"
     puts $CHECK_OUTPUT "enter \"noroot\" to start testsuite without root access\nOR\npress >ENTER< to type in the root password again"
     set user_input [wait_for_enter 1]
     if { [ string compare "noroot" $user_input ] != 0 } {
         set_root_passwd
         return
     } else { 
         set CHECK_ADMIN_USER_SYSTEM 1

     }
  } else {
     puts $CHECK_OUTPUT "--> id as root output:\n$result"
  }
 

  puts $CHECK_OUTPUT "starting now ..."
  flush $CHECK_OUTPUT
}

# 0 no action
# 1 new pre_install
# 2 only shutdown system
proc get_setup_change_state {} {
   global CHECK_OUTPUT CHECK_SETUP_CHANGES CHECK_SETUP_NAMES
   global CHECK_SETTINGS_VERSION CHECK_CURRENT_SETTINGS_VERSION
   global CHECK_CHECKTREE_ROOT CHECK_CORE_MASTER CHECK_CORE_EXECD
   global CHECK_SUBMIT_ONLY_HOSTS CHECK_COMMD_PORT CHECK_TESTSUITE_ROOT
   global CHECK_MAIN_RESULTS_DIR CHECK_PRODUCT_TYPE 
   global CHECK_PRODUCT_ROOT CHECK_DEFAULTS_FILE
   global CHECK_SOURCE_DIR CHECK_SOURCE_HOSTNAME
   global CHECK_AIMK_COMPILE_OPTIONS CHECK_DIST_INSTALL_OPTIONS
   global CHECK_PACKAGE_DIRECTORY CHECK_PACKAGE_TYPE
   global CHECK_QMASTER_INSTALL_OPTIONS CHECK_EXECD_INSTALL_OPTIONS
   global CHECK_DNS_DOMAINNAME CHECK_REMOTE_ENVIRONMENT
   global CHECK_FIRST_FOREIGN_SYSTEM_USER CHECK_SECOND_FOREIGN_SYSTEM_USER 
   global CHECK_FIRST_FOREIGN_SYSTEM_GROUP CHECK_SECOND_FOREIGN_SYSTEM_GROUP
   global CHECK_DEFAULT_DOMAIN
   global CHECK_MAILX_HOST 
   global CHECK_REPORT_EMAIL_TO CHECK_REPORT_EMAIL_CC  CHECK_USE_SSH CHECK_SOURCE_CVS_RELEASE
   global CHECK_OUTPUT CHECK_SETUP_NAMES CHECK_CONFIG_DIR CHECK_SEND_ERROR_MAILS
   global CHECK_MAX_ERROR_MAILS CHECK_HOST CHECK_USER
   global CHECK_SETUP_CHANGES

   set restart 0
   set pre_install 0

   foreach change $CHECK_SETUP_CHANGES {
      puts $CHECK_OUTPUT "cange of $change"
      puts $CHECK_OUTPUT "  old value: \"$CHECK_SETUP_NAMES($change,old)\""
      puts $CHECK_OUTPUT "  new value: \"[ set $CHECK_SETUP_NAMES($change)]\""

      switch -- $change {
         "qmaster_host" { 
            set help $CHECK_CORE_MASTER
            set  CHECK_CORE_MASTER $CHECK_SETUP_NAMES($change,old)
            puts $CHECK_OUTPUT "shutting down old system ..."  
            shutdown_core_system
            set CHECK_CORE_MASTER $help
         }
         "list_of_execution_hosts" {
            set help $CHECK_CORE_EXECD
            set  CHECK_CORE_EXECD  $CHECK_SETUP_NAMES($change,old)
            puts $CHECK_OUTPUT "shutting down old system ..."
            shutdown_core_system
            set CHECK_CORE_EXECD $help
         }
      }
 
      switch -- $CHECK_SETUP_NAMES($change,reinstall) {
         1 { incr pre_install  }
         2 { incr restart }
      }
   }
   set CHECK_SETUP_CHANGES ""
   if { $restart == 0 && $pre_install == 0 } { return 0 }
   if { $pre_install > 0 } { return 1 }
   if { $restart > 0 } { return 2 }

}


#                                                             max. column:     |
#****** check/have_root_passwd() ******
# 
#  NAME
#     have_root_passwd -- is root password available ?
#
#  SYNOPSIS
#     have_root_passwd { } 
#
#  FUNCTION
#     test if root password was typed in 
#
#  INPUTS
#     0  : root password should be ok
#     -1 : no root access
#  RESULT
#     
#
#  SEE ALSO
#     check/set_root_passwd
#     check/get_root_passwd
#*******************************
proc have_root_passwd {} {
  global CHECK_ROOT_PASSWORD CHECK_OUTPUT

  if { [have_ssh_access] == 1 } {
     return 0
  }

  if { [string compare "none" $CHECK_ROOT_PASSWORD ] == 0 } {
     puts $CHECK_OUTPUT "you have no ssh access and no root password"
     return -1
  }
  return 0
}

#                                                             max. column:     |
#****** check/get_root_passwd() ******
# 
#  NAME
#     get_root_passwd -- return root password 
#
#  SYNOPSIS
#     get_root_passwd { } 
#
#  FUNCTION
#     This procedure returns the root password, typed in by the user.
#
#  INPUTS
#
#  RESULT
#     string with root password
#
#  SEE ALSO
#     check/have_root_passwd
#     check/set_root_passwd
#*******************************
proc get_root_passwd {} {
  global CHECK_ROOT_PASSWORD
  
  if { [ string compare "none" $CHECK_ROOT_PASSWORD ] == 0 } {
     add_proc_error "get_root_passwd" "-2" "root password not set"
  }

  return $CHECK_ROOT_PASSWORD    
}





#                                                  max. column:     |
#****** check/mail_report() ******
# 
#  NAME
#     mail_report -- send mail
#
#  SYNOPSIS
#     mail_report { subject body } 
#
#  FUNCTION
#     This procedure sends an e-mail to the e-mail-address configured
#     with the global variables CHECK_REPORT_EMAIL_CC  and 
#     CHECK_REPORT_EMAIL_TO. Subject and body of the mail is taken 
#     from the parameters subject and body.
#
#  INPUTS
#     subject - e-mail subject text
#     body    - e-mail body text
#
#  SEE ALSO
#     check/send_mail
#*******************************
proc mail_report { subject body } {
  global CHECK_REPORT_EMAIL_TO CHECK_REPORT_EMAIL_CC CHECK_OUTPUT

  if { [string compare $CHECK_REPORT_EMAIL_TO "none"] == 0 } {
     puts $CHECK_OUTPUT "--> mail_report - no mail address"
     return
  }

  set mail_cc ""
  if { [string compare $CHECK_REPORT_EMAIL_CC "none"] != 0 } {
      set mail_cc $CHECK_REPORT_EMAIL_CC
  }

  send_mail $CHECK_REPORT_EMAIL_TO $mail_cc $subject $body 
}



#                                                             max. column:     |
#****** check/send_mail() ******
# 
#  NAME
#     send_mail -- send mail  
#
#  SYNOPSIS
#     send_mail { address cc subject body } 
#
#  FUNCTION
#     This procedure calls the mailx binary by using remote shell to 
#     send an e-mail. 
#
#  INPUTS
#     address - e-mail address
#     cc      - e-mail CC address
#     subject - e-mail subject text  
#     body    - e-mail body text 
#
#  SEE ALSO
#     check/mail_report
#*******************************
proc send_mail { address cc subject body } {
   global ts_config
  global CHECK_TESTSUITE_ROOT CHECK_MAILX_HOST CHECK_OUTPUT
  global CHECK_MAILS_SENT CHECK_ENABLE_MAIL CHECK_USER CHECK_MAX_ERROR_MAILS
  global write_mail_to_file CHECK_MAIL_OUTPUT_FILE CHECK_ENABLE_MAIL


  if { $write_mail_to_file != 0 } {
     set fd [ open $CHECK_MAIL_OUTPUT_FILE "a" ]
     puts $fd "-=*************************************************************=-"
     puts $fd "Grid Engine Version: [get_version_info]"
     puts $fd "Subject            : $subject"
     puts $fd "-=*************************************************************=-"
     puts $fd "$body"
     puts $fd "-=*=-"
     flush $fd
     close $fd 
     puts $CHECK_OUTPUT "Added entry in mail output file $CHECK_MAIL_OUTPUT_FILE"
     return
  }

  set new_subject "[get_version_info] ($ts_config(cell)) - $subject"

  if { $CHECK_ENABLE_MAIL != 1 } {
     puts $CHECK_OUTPUT "mail sending disabled, mails sent: $CHECK_MAILS_SENT"
     puts $CHECK_OUTPUT "mail new_subject: $new_subject"
     puts $CHECK_OUTPUT "mail body:"
     puts $CHECK_OUTPUT "$body"
     return
  }


  file delete "$CHECK_TESTSUITE_ROOT/mailbody_testsuite_tmp" 

  set output_file [ open "$CHECK_TESTSUITE_ROOT/mailbody_testsuite_tmp" "w"]
  puts $output_file $body
  flush $output_file
  close $output_file

  set file_size 0
   while { $file_size == 0 } {
      catch { set file_size [file size "$CHECK_TESTSUITE_ROOT/mailbody_testsuite_tmp"]}
      if { $file_size == 0 } { 
         puts $CHECK_OUTPUT "--> file size of \"$CHECK_TESTSUITE_ROOT/mailbody_testsuite_tmp\": $file_size ; waiting for filesize > 0"
         sleep 1
      }
   }



  catch { exec "touch" "$CHECK_TESTSUITE_ROOT/mailbody_testsuite_tmp" } result
  catch { exec "chmod" "0755" "$CHECK_TESTSUITE_ROOT/mailbody_testsuite_tmp" } result

  if { [string compare $cc "none"] != 0 } {
     set mail_args "-s \"$new_subject\" -c \"$cc\" \"$address\" < \"$CHECK_TESTSUITE_ROOT/mailbody_testsuite_tmp\""
  } else {
     set mail_args "-s \"$new_subject\" \"$address\" < \"$CHECK_TESTSUITE_ROOT/mailbody_testsuite_tmp\""
  }
  set mail_output [ start_remote_prog $CHECK_MAILX_HOST $CHECK_USER "mailx" "$mail_args" prg_exit_state 60 0 "" 1 0 ]

  if { $prg_exit_state != 0 } {
     puts $CHECK_OUTPUT "--> send_mail - could not send mail:\n$mail_output"
  } else {
     puts $CHECK_OUTPUT "--> send_mail - mail sent to $address"
     incr CHECK_MAILS_SENT 1
     if { $CHECK_MAILS_SENT == $CHECK_MAX_ERROR_MAILS } {
        if { [string compare $cc "none"] != 0 } {
           set mail_args "-s \"max mail count reached\" -c \"$cc\" \"$address\" < \"$CHECK_TESTSUITE_ROOT/mailbody_testsuite_tmp\""
        } else {
           set mail_args "-s \"max mail count reached\" \"$address\" < \"$CHECK_TESTSUITE_ROOT/mailbody_testsuite_tmp\""
        }
        start_remote_prog $CHECK_MAILX_HOST $CHECK_USER "mailx" "$mail_args" prg_exit_state 60 0 "" 1 0 
        set CHECK_ENABLE_MAIL 0
     }  
  }
  file delete "$CHECK_TESTSUITE_ROOT/mailbody_testsuite_tmp" 
}




# This procedure simply sets the global variables check_errno 
# and check_errstr to the given parameters. It 
#                                                             max. column:     |
#****** check/set_error() ******
# 
#  NAME
#     set_error -- set error for current check 
#
#  SYNOPSIS
#     set_error { erno errtext } 
#
#  FUNCTION
#     This procedure simply sets the global variables check_errno and 
#     check_errstr to the given parameters. Beyond it the procedure 
#     add_proc_error is called in order to append the errors to the global error 
#     list.
#
#  INPUTS
#     erno    - integer
#               0  = no error
#               -1 = error, but the check will run till end
#               -2 = error, the current check will stop (no further check function
#                    is called)
#               -3 = warning, (e.g. test can not run on this host)
#
#     errtext - short error description
#
#
#  EXAMPLE
#     set_error 0 "ok"  ;# Test is "OK"
#
#  SEE ALSO
#     check/add_proc_error
#*******************************
proc set_error {erno errtext} {
  global check_errno 
  global check_errstr CHECK_CUR_PROC_RESULTS
  global set_error_proc_called

  set set_error_proc_called 1
  set check_errno $erno
  set check_errstr $errtext

  add_proc_error "set_error" $erno $errtext

  if { $check_errno == 0 } {
    foreach element $CHECK_CUR_PROC_RESULTS {
      if { $element != 0 && $element != -3 } {   ;# there was a former error in this test !!
         set check_errno -1
         set check_errstr "error!"
      }
    }
  }

  return $erno
}

#****** check/get_testsuite_root_dir_from_file() *******************************
#  NAME
#     get_testsuite_root_dir_from_file() -- get testsuite root directory
#
#  SYNOPSIS
#     get_testsuite_root_dir_from_file { filename } 
#
#  FUNCTION
#     This procedure greps for the testsuite configuration in the given file.
#     It only returns the testsuite root directory. This function is used
#     to setup the CHECK_TESTSUITE_ROOT variable before sourcing the
#     file procedures script in the tcl_directory.
#
#  INPUTS
#     filename - path to testsuite configuration file (defaults file)
#
#  RESULT
#     testsuite root directory path
#
#  SEE ALSO
#     check/setup2
#*******************************************************************************
proc get_testsuite_root_dir_from_file { filename } {

   if { [file isfile $filename] != 1 } {
      return "no_such_file" 
   }
   set file [open $filename "r"]
   set found_object 0
   set next 0
   while { [gets $file line] >= 0 } {
      if { $next == 1 } {
         break
      }
      if { [ string first "OBJ_START:testsuite configuration:" $line] >= 0 } { 
         set found_object 1
      }
      if { [ string first ":testsuite_root_dir:" $line] >= 0 && $found_object == 1 } {
         set next 1
      }
   }
   if { $next == 1 } {
      set start [ string first ":" $line ]
      set end   [ string last ":" $line ]   
      incr start 1
      incr end -1
      return [string range $line $start $end]
   } 
   close $file
   return "testsuite_root_dir_not_found"
}

#                                                             max. column:     |
#****** check/edit_defaults() ******
# 
#  NAME
#     edit_defaults -- ??? 
#
#  SYNOPSIS
#     edit_defaults { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc edit_defaults {} {
  global CHECK_OUTPUT CHECK_DEFAULTS_FILE CHECK_HOST CHECK_CONFIG_DIR
  global CHECK_TESTSUITE_ROOT CHECK_SCRIPT_FILE_DIR
  global env

  load_defaults
  set return_value -1
  if { [ write_edit_defaults_file "/tmp/testsuite_tmp_defaults_file" ] != 0 } {
     puts $CHECK_OUTPUT "error open file \"$def_edit_file\" for writing"
     return -1
  }

  puts $def_edit_file
  set exit_edit_loop 0
  while { $exit_edit_loop == 0 } {
     if { $CHECK_CONFIG_DIR != "" } {
        set vim_binary [get_binary_path "$CHECK_HOST" "vim"]
     } else {
        puts $CHECK_OUTPUT "config directory path not set ..."
        set env_variable "EDITOR"
        puts $CHECK_OUTPUT "checking for $env_variable environment setting..."
        if { [info exists env($env_variable)] } {
           puts $CHECK_OUTPUT "$env_variable=$env($env_variable)"
           set vim_binary $env($env_variable)
           puts $CHECK_OUTPUT "using environment $env_variable"
        } else {
           puts $CHECK_OUTPUT "environment $env_variable not set, using default"
           set vim_binary "vim"
        }
        set catch_return [ catch { eval exec which $vim_binary } catch_value ]
        puts $CHECK_OUTPUT "exec \"which $vim_binary\" returns: $catch_return"
        if { $catch_return != 0 } {
           puts $CHECK_OUTPUT "error executing \"which $vim_binary\"!!!"
        } else {
           set vim_binary $catch_value
        }
        if { [file exists $vim_binary] != 1 } {
           puts $CHECK_OUTPUT "could not find binary"
           puts $CHECK_OUTPUT "$vim_binary"
           exit 1
        }
        puts $CHECK_OUTPUT "using \"$vim_binary\" as editor"
     }
     set env(EDITOR) $vim_binary
     set id [ open_spawn_process $vim_binary "$def_edit_file" ]
     interact -o -i [lindex $id 1]
     set exit_state [ close_spawn_process $id ]

     if { $exit_state == 0 } {
        set read_return [ read_edit_defaults_file "$def_edit_file" ] 
        if { $read_return >= 0 } { 
           if { $read_return == 0 } {
              puts $CHECK_OUTPUT "no changes"
              set return_value 1
              set exit_edit_loop 1
           } else {
              puts $CHECK_OUTPUT "$read_return changes in defaults file \"$CHECK_DEFAULTS_FILE\""
              set return_value 0
              set exit_edit_loop 1
           }
        } else {
           puts $CHECK_OUTPUT "error reading file \"$def_edit_file\""
           puts $CHECK_OUTPUT "\n>> press CTRL-C to abort setup configuration!"
           wait_for_enter
        }
     }
  }
  if { [ string first "/tmp/testsuite_tmp_defaults_file" $def_edit_file ] >= 0 } {
     file delete $def_edit_file
     puts $CHECK_OUTPUT "file \"$def_edit_file\" deleted!" 
  }
  return $return_value 
}

#                                                             max. column:     |
#****** check/calc_space() ******
# 
#  NAME
#     calc_space -- ??? 
#
#  SYNOPSIS
#     calc_space { space name } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#     space - ??? 
#     name  - ??? 
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc calc_space {space name} {

  set length [ string length $name ]
  set spaces [ expr ( $space - $length )  ]
  set back ""
  for {set i 0} { $i < $spaces} { incr i 1} {
     set back "$back "
  }
  return $back
}

proc get_local_hostname {} {
   global env CHECK_OUTPUT 
   set catch_return [ catch { exec "hostname" } result ]
   if { $catch_return == 0 } {
      set result [split $result "."]
      set newname [lindex $result 0]
      puts $CHECK_OUTPUT "got hostname: \"$newname\""
      return $newname
   } else {
      puts $CHECK_OUTPUT "local hostname error or binary not found"
      puts $CHECK_OUTPUT "error: $result"
      puts $CHECK_OUTPUT "error: $catch_return"
      puts $CHECK_OUTPUT "trying local HOST environment variable ..."
      if { [ info exists env(HOST) ] } {
         set result [split $env(HOST) "."]
         set newname [lindex $result 0]
         if { [ string length $newname ] > 0 } {
             puts $CHECK_OUTPUT "got hostname_ \"$newname\""
             return $newname
         } 
      }
   }
   puts $CHECK_OUTPUT "tcl procedure get_local_hostname() can't get local hostname"
   puts $CHECK_OUTPUT "please set check if binary \"hostname\" is in path or"
   puts $CHECK_OUTPUT "set the environment variable \"HOST\" to the hostname value"
   exit 1
   return "unknown"
}

#****** check/check_executable_files() *****************************************
#  NAME
#     check_executable_files() -- check if testsuite files are executable
#
#  SYNOPSIS
#     check_executable_files { } 
#
#  FUNCTION
#     testsuite setup
#
#  SEE ALSO
#     check/setup2()
#*******************************************************************************
proc check_executable_files {  } {

   global CHECK_TESTSUITE_ROOT CHECK_OUTPUT CHECK_SOURCE_DIR

   set filelist ""
   lappend filelist "$CHECK_TESTSUITE_ROOT/scripts/lock.sh"
   lappend filelist "$CHECK_TESTSUITE_ROOT/scripts/remote_submit_log.sh"
   lappend filelist "$CHECK_TESTSUITE_ROOT/scripts/remote_tcl_command.sh"
   lappend filelist "$CHECK_TESTSUITE_ROOT/scripts/remotecompile.sh"
   lappend filelist "$CHECK_TESTSUITE_ROOT/scripts/sleeper.sh"
   lappend filelist "$CHECK_TESTSUITE_ROOT/scripts/ssh_progstarter.csh"
   lappend filelist "$CHECK_TESTSUITE_ROOT/checktree/functional/migration/checkpt_job.sh"
   lappend filelist "$CHECK_TESTSUITE_ROOT/checktree/functional/migration/migrate.sh"
   lappend filelist "$CHECK_TESTSUITE_ROOT/checktree/system_tests/clients/qmod/general/qmod_job.sh"
   lappend filelist "$CHECK_TESTSUITE_ROOT/checktree/system_tests/clients/qrsh/qsub_gid.sh"
   lappend filelist "$CHECK_TESTSUITE_ROOT/checktree/system_tests/clients/qrsh/sleep_pid.sh"
   lappend filelist "$CHECK_TESTSUITE_ROOT/checktree/system_tests/clients/qrsh/terminate.sh"
   lappend filelist "$CHECK_TESTSUITE_ROOT/checktree/system_tests/clients/qrsh/trap.sh" 
   lappend filelist "$CHECK_TESTSUITE_ROOT/checktree/system_tests/clients/qrsh/ulimit.sh"
   lappend filelist "$CHECK_TESTSUITE_ROOT/checktree/system_tests/qmaster/size/pminiworm.sh"
   lappend filelist "$CHECK_TESTSUITE_ROOT/checktree/system_tests/qmaster/size/flood_sleeper.sh"
   lappend filelist "$CHECK_TESTSUITE_ROOT/checktree/system_tests/qmaster/size/qstat.sh"
   lappend filelist "$CHECK_TESTSUITE_ROOT/checktree/system_tests/qmaster/size/redir_stderr.sh"
   lappend filelist "$CHECK_TESTSUITE_ROOT/checktree/system_tests/qmaster/size/sge_start.sh"
   lappend filelist "$CHECK_SOURCE_DIR/aimk"
   lappend filelist "$CHECK_SOURCE_DIR/dist/examples/jobs/array_submitter.sh"
   lappend filelist "$CHECK_SOURCE_DIR/dist/examples/jobs/env-tester.csh"
   lappend filelist "$CHECK_SOURCE_DIR/dist/examples/jobs/jobnet_submitter.sh"
   lappend filelist "$CHECK_SOURCE_DIR/dist/examples/jobs/pminiworm.sh"
   lappend filelist "$CHECK_SOURCE_DIR/dist/examples/jobs/simple.sh"
   lappend filelist "$CHECK_SOURCE_DIR/dist/examples/jobs/sleeper.sh"
   lappend filelist "$CHECK_SOURCE_DIR/dist/examples/jobs/step_A_array_submitter.sh"
   lappend filelist "$CHECK_SOURCE_DIR/dist/examples/jobs/step_B_array_submitter.sh"
   lappend filelist "$CHECK_SOURCE_DIR/dist/examples/jobs/worker.sh"
   

   set change_files ""


   set file_error 0
   foreach elem $filelist {
      set filename $elem
      if { [ file isfile $filename ] != 1  } {
         puts $CHECK_OUTPUT "file not found: $filename"
         set file_error 1
         continue
      }
      set attribs [ file attributes $filename -permissions] 
      if { [ string compare $attribs "00755" ] != 0 } {
         puts $CHECK_OUTPUT "file not executable (attributes: $attribs):\n $filename"
         lappend change_files $filename
         set file_error 1
         continue
      }
   }

   if { $file_error != 0 } {
      while { 1 } {
         puts $CHECK_OUTPUT "should I set the file permissions to 00755? (yes/no)"
         set answer [wait_for_enter 1]
         if { [ string compare $answer "yes" ] == 0 } {
            foreach elem $change_files {
                catch { file attributes $elem -permissions 00755 }
                set attribs [ file attributes $elem -permissions] 
                if { [ string compare $attribs "00755" ] != 0  } {
                   puts $CHECK_OUTPUT "check_executable_files - error setting file permissions: $elem"
                   exit -1
                }
            }  
            break
         } 
         if { [ string compare $answer "no" ] == 0 } {
            puts $CHECK_OUTPUT "check_executable_files - file errors. exit."
            exit -1
         } 
         puts $CHECK_OUTPUT "please enter \"yes\" or \"no\"!"
      }
   }
}

#****** check/set_users_environment() ******************************************
#  NAME
#     set_users_environment() -- setup user and l10n environment
#
#  SYNOPSIS
#     set_users_environment { host {variable_name env} { show_variables 0 } } 
#
#  FUNCTION
#     This procedure is used to generate the users environment for the
#     local environment and for the create_shell_script() procedure.
#
#  INPUTS
#     host                 - hostname (used for l10n)
#     {variable_name env}  - variable to store environment
#     { show_variables 0 } - if 1: print setting info
#
#  SEE ALSO
#     file_procedures/create_shell_script()
#*******************************************************************************
proc set_users_environment { node {variable_name env} { show_variables 0 } } {
   global CHECK_REMOTE_ENVIRONMENT CHECK_OUTPUT env 
   global CHECK_L10N ts_host_config ts_config

   upvar $variable_name environment

   set host [node_get_host $node]

   set remote_environment $CHECK_REMOTE_ENVIRONMENT

   if { $CHECK_L10N == 0 && [llength $remote_environment] == 0 } {
      return 0
   }

   if { $show_variables } {
      puts $CHECK_OUTPUT "==============================================================================="
   }

   if { $CHECK_L10N != 0 } {
      set locale $ts_config(l10n_test_locale)
      if { [ info exist ts_host_config($host,${locale}_locale) ] != 1 } {
         if { [set pos [ string first $ts_config(dns_domain) $host]] >= 0 } {
            if { $ts_config(dns_for_install_script) == "none" } {
                incr pos -2
                set host [ string range $host 0 $pos ]
            }
         }
      }

      if { [ info exist ts_host_config($host,${locale}_locale) ] } {
         set locale_env $ts_host_config($host,${locale}_locale)
         if { $locale_env == "" } {
            debug_puts "no value for ${locale}_locale on host $host, please set LANG, LC_MESSAGES ..."
         }
         append locale_env " SGE_ENABLE_MSG_ID=2 SGE_INFOTEXT_MAX_COLUMN=5000"
         debug_puts "L10N enabled"
         debug_puts "locale = \"$locale\""
         debug_puts "environment on host $host: $locale_env"
         foreach u_env $locale_env {
            debug_puts "environment: $u_env"
            set help [split $u_env "="]
            set env_name  [lindex $help 0]
            set env_value [lindex $help 1]
            debug_puts "env_name: $env_name"
            if { [string compare $env_name ""] == 0 } {
               puts $CHECK_OUTPUT "error setting users environment (setup parameter user_environment)"
               return -1
            }
            debug_puts "env_value: $env_value"
            if { [string compare $env_value ""] == 0 } {
               if { [info exists env($env_name)] } {
                  set env_value $env($env_name)
               } else {
                  puts $CHECK_OUTPUT "error setting users environment (setup parameter user_environment)"
                  return -1
               }
            }
            if { [string compare $variable_name "env"] == 0 } {
               if { $show_variables } {
                  puts $CHECK_OUTPUT "setting local l10n variable $env_name=\"$env_value\""
               }
            } else {
               if { $show_variables } {
                  puts $CHECK_OUTPUT "setting remote l10n variable $env_name=\"$env_value\""
               }
            }
            set environment($env_name) $env_value 
            debug_puts "$env_name set to \"$env_value\""
         }
      } else {
         debug_puts "could not find l10n configuration for host $host"
      }
   }

   foreach u_env $remote_environment {
      debug_puts "environment: $u_env"
      set help [split $u_env "="]
      set env_name  [lindex $help 0]
      set env_value [lindex $help 1]
      debug_puts "env_name: $env_name"
      if { [string compare $env_name ""] == 0 } {
         puts $CHECK_OUTPUT "error setting users environment (setup parameter user_environment)"
         return -1
      }
      debug_puts "env_value: $env_value"
      if { [string compare $env_value ""] == 0 } {
         if { [info exists env($env_name)] } {
            set env_value $env($env_name)
         } else {
            puts $CHECK_OUTPUT "error setting users environment (setup parameter user_environment)"
            return -1
         }
      }
      if { [string compare $variable_name "env"] == 0 } {
         if { $show_variables } {
            puts $CHECK_OUTPUT "setting local variable $env_name=\"$env_value\""
         }
      } else {
         if { $show_variables } {
            puts $CHECK_OUTPUT "setting remote variable $env_name=\"$env_value\""
         }
      }
      set environment($env_name) $env_value 
      debug_puts "$env_name set to \"$env_value\""
   }
   if { $show_variables } {
      puts $CHECK_OUTPUT "==============================================================================="
   }

   return 0
}

proc show_setup_information { } {

   global CHECK_OUTPUT

   clear_screen
   puts $CHECK_OUTPUT "Testsuite Setup Information"
   puts $CHECK_OUTPUT "==========================="
   puts $CHECK_OUTPUT ""
   puts $CHECK_OUTPUT "If you are starting the testsuite for the first time you should read this short"
   puts $CHECK_OUTPUT "setup guide to make it easier for you to understand the setup questions."
   puts $CHECK_OUTPUT ""
   puts $CHECK_OUTPUT "The testsuite needs 3 user accounts:\n"
   puts $CHECK_OUTPUT " a) testsuite user:   The user who is starting the testsuite\n"
   puts $CHECK_OUTPUT " b) first_foreign_system_username:  "
   puts $CHECK_OUTPUT "                      Test user account (used for submitting, deleting jobs)"
   puts $CHECK_OUTPUT "                      This user must be member of two system groups (use <SPACE>"
   puts $CHECK_OUTPUT "                      to seperate the groups)\n"
   puts $CHECK_OUTPUT " c) second_foreign_system_username:"
   puts $CHECK_OUTPUT "                      Test user account (used for submitting, deleting jobs)"
   puts $CHECK_OUTPUT "                      This user must be member of a system group where b) is not"
   puts $CHECK_OUTPUT "                      group member.\n"
 
   wait_for_enter

   clear_screen
   puts $CHECK_OUTPUT "Testsuite Setup Information"
   puts $CHECK_OUTPUT "==========================="
   puts $CHECK_OUTPUT ""
   puts $CHECK_OUTPUT "The 3 user accounts must have rlogin access to the cluster hosts. (.rhost file)\n"
   puts $CHECK_OUTPUT "Every output to stdout in\n"
   puts $CHECK_OUTPUT " /etc/csh.cshrc, /etc/csh.login, \$HOME/.cshrc, \$HOME/.login , ...\n"
   puts $CHECK_OUTPUT "is not allowed. The testsuite will use e.g. rlogin \$EXEC_HOST pwd to get the"
   puts $CHECK_OUTPUT "working directory on that host. Any output made in the files would influence"
   puts $CHECK_OUTPUT "the result of the call.\n" 

   puts $CHECK_OUTPUT "Each of the 3 user must have read access to\n"
   puts $CHECK_OUTPUT "   - testsuite directory"
   puts $CHECK_OUTPUT "   - source code directory"
   puts $CHECK_OUTPUT "   - installation directory (\$SGE_ROOT)"   
  
   wait_for_enter

   clear_screen
   puts $CHECK_OUTPUT "Testsuite Setup Information"
   puts $CHECK_OUTPUT "==========================="
   puts $CHECK_OUTPUT ""
   puts $CHECK_OUTPUT "All path statements have to be absolute. The use of links may cause troubles."
    
   wait_for_enter
}


#****** check/save_host_configuration() ****************************************
#  NAME
#     save_host_configuration() -- save host configuration
#
#  SYNOPSIS
#     save_host_configuration { file } 
#
#  FUNCTION
#     This procedure will save the actual host configuration to the given
#     file. (ts_host_config array)
#
#  INPUTS
#     file - host configuration file
#
#  SEE ALSO
#     check/save_user_configuration()
#     check/save_configuration()
#*******************************************************************************
proc save_host_configuration { file } {
   global ts_host_config
   global CHECK_OUTPUT

   set conf_name "testsuite host configuration"

   if { [ info exists ts_host_config(version) ] == 0 } {
      puts $CHECK_OUTPUT "no version specified - abort saving"
      wait_for_enter
      return -1
   }

   # first get old configuration
   read_array_from_file  $file $conf_name old_host_config
   # save old configuration 
   spool_array_to_file $file "$conf_name.old" old_host_config
   spool_array_to_file $file $conf_name ts_host_config  
   puts $CHECK_OUTPUT "new host configuration saved: version: $ts_host_config(version)"
   wait_for_enter
   return 0
}

#****** check/save_user_configuration() ****************************************
#  NAME
#     save_user_configuration() -- save user configuration file
#
#  SYNOPSIS
#     save_user_configuration { file } 
#
#  FUNCTION
#     This procedure will save the actual user configuration to the given
#     file. (ts_user_config array)
#
#  INPUTS
#     file - user configuration file
#
#  SEE ALSO
#     check/save_host_configuration()
#     check/save_configuration()
#*******************************************************************************
proc save_user_configuration { file } {
   global ts_user_config
   global CHECK_OUTPUT

   if { [ info exists ts_user_config(version) ] == 0 } {
      puts $CHECK_OUTPUT "no version specified - abort saving"
      wait_for_enter
      return -1
   }


   set conf_name "testsuite user configuration"
   # first get old configuration
   read_array_from_file  $file $conf_name old_user_config
   # save old configuration 
   spool_array_to_file $file "$conf_name.old" old_user_config
   spool_array_to_file $file $conf_name ts_user_config  
   
   puts $CHECK_OUTPUT "new user configuration saved"
   wait_for_enter

   return 0
}


#****** check/save_configuration() *********************************************
#  NAME
#     save_configuration() -- save testsuite configuration (ts_config array)
#
#  SYNOPSIS
#     save_configuration { } 
#
#  FUNCTION
#     This procedure will save the actual ts_config array settings to the
#     testsuite setup file.
#
#  SEE ALSO
#     check/restore_configuration()
#*******************************************************************************
proc save_configuration {} {
   global ts_config
   global CHECK_OUTPUT
   global CHECK_DEFAULTS_FILE
   global pe_for_version_check_result

   set conf_name "testsuite configuration"

   if { [ info exists ts_config(version) ] == 0 } {
      puts $CHECK_OUTPUT "no version"
      wait_for_enter
      return -1
   }

   # first get old configuration
   read_array_from_file  $CHECK_DEFAULTS_FILE $conf_name old_config
   # save old configuration 
   spool_array_to_file $CHECK_DEFAULTS_FILE "$conf_name.old" old_config
   spool_array_to_file $CHECK_DEFAULTS_FILE $conf_name ts_config  
   puts $CHECK_OUTPUT "new testsuite configuration saved"

   set pe_for_version_check_result "undefined"

   wait_for_enter

   return 0
}

#****** check/restore_configuration() ******************************************
#  NAME
#     restore_configuration() -- restore old testsuite configuration
#
#  SYNOPSIS
#     restore_configuration { } 
#
#  FUNCTION
#     This procedure can be used to get the previous testsuite configuration
#
#  SEE ALSO
#     check/save_configuration()
#*******************************************************************************
proc restore_configuration { } {
   global ts_config
   global CHECK_OUTPUT
   global CHECK_DEFAULTS_FILE

   set conf_name "testsuite configuration"

   # first get old configuration
   read_array_from_file  $CHECK_DEFAULTS_FILE "$conf_name.old" old_config
   if { [ info exists old_config(version) ] } {
      puts $CHECK_OUTPUT "spooling previous configuration (Version: $old_config(version)"
      spool_array_to_file $CHECK_DEFAULTS_FILE $conf_name old_config
   } else {
      puts $CHECK_OUTPUT "no previous configuration available!"
   }
   puts $CHECK_OUTPUT "reading latest configuration ..."
   read_array_from_file  $CHECK_DEFAULTS_FILE "$conf_name" ts_config

   return 0
}


#****** check/get_configuration_element_name_on_pos() **************************
#  NAME
#     get_configuration_element_name_on_pos() -- return config elem name on pos
#
#  SYNOPSIS
#     get_configuration_element_name_on_pos { config_array config_pos } 
#
#  FUNCTION
#     This procedure returns the name of the configuration element on the
#     given position.
#
#  INPUTS
#     config_array - ts_config, ts_host_config or ts_user_config
#     config_pos   - pos number
#
#  SEE ALSO
#     check/get_configuration_element_count()
#*******************************************************************************
proc get_configuration_element_name_on_pos { config_array config_pos } {
   global CHECK_OUTPUT actual_ts_config_version
   upvar  $config_array config

   set params ""
   set pos_entries [lsort [ array names config "*,pos" ]]
   foreach pos $pos_entries {
      set name_end_pos [ string last "," $pos]
      incr name_end_pos -1
      set name [ string range $pos 0 $name_end_pos ]
      lappend params $name
   }
   set params [lsort $params]

   set max_pos 0
   foreach elem $params {
      if { $config($elem,pos) == $config_pos } {
         return $elem
      }
   }
   return ""
}



#****** check/get_configuration_element_count() ********************************
#  NAME
#     get_configuration_element_count() -- returns number of conig elements
#
#  SYNOPSIS
#     get_configuration_element_count { config_array } 
#
#  FUNCTION
#     This procedure returns the config parameter count for one of the testsuite
#     setup arrays (ts_config, ts_host_config, ts_user_config)
#
#  INPUTS
#     config_array - ts_config, ts_host_config or ts_user_config
#
#  SEE ALSO
#     check/get_configuration_element_name_on_pos()
#*******************************************************************************
proc get_configuration_element_count { config_array } {
   global CHECK_OUTPUT actual_ts_config_version
   upvar  $config_array config

   set params ""
   set pos_entries [lsort [ array names config "*,pos" ]]
   foreach pos $pos_entries {
      set name_end_pos [ string last "," $pos]
      incr name_end_pos -1
      set name [ string range $pos 0 $name_end_pos ]
      lappend params $name
   }
   set params [lsort $params]

   set max_pos 0
   foreach elem $params {
      if { $config($elem,pos) > $max_pos } {
         set max_pos $config($elem,pos)
      }
   }
   return $max_pos
}



#****** check/update_ts_host_config_version() **********************************
#  NAME
#     update_ts_host_config_version() -- used for version update of ts_host_config
#
#  SYNOPSIS
#     update_ts_host_config_version { filename } 
#
#  FUNCTION
#     This procedure is called when the versions of the testsuite host configuration
#     are not equal.
#
#  INPUTS
#     filename - host configuration file
#
#  SEE ALSO
#     check/update_ts_config_version()
#*******************************************************************************
proc update_ts_host_config_version { filename } {
   global actual_ts_host_config_version
   global ts_host_config ts_config
   global CHECK_OUTPUT

   if { $ts_host_config(version) == "1.0" && $actual_ts_host_config_version == "1.1" } {
      puts $CHECK_OUTPUT "\ntestsuite host configuration update from 1.0 to 1.1 ..."

      foreach host $ts_host_config(hostlist) {
         set ts_host_config($host,fr_locale) ""
         set ts_host_config($host,ja_locale) ""
         set ts_host_config($host,zh_locale) ""
      }
      set ts_host_config(version) "1.1"
     
      show_config ts_host_config
      wait_for_enter
      if { [ save_host_configuration $filename] != 0} {
         puts $CHECK_OUTPUT "Could not save host configuration"
         wait_for_enter
         return
      }
   }

   if { $ts_host_config(version) == "1.1" && $actual_ts_host_config_version == "1.2" } {
      puts $CHECK_OUTPUT "\ntestsuite host configuration update from 1.1 to 1.2 ..."

      foreach host $ts_host_config(hostlist) {
         set ts_host_config($host,ssh) ""
      }
      set ts_host_config(version) "1.2"
     
      show_config ts_host_config
      wait_for_enter
      if { [ save_host_configuration $filename] != 0} {
         puts $CHECK_OUTPUT "Could not save host configuration"
         wait_for_enter
         return
      }
   }

   if { $ts_host_config(version) == "1.2" && $actual_ts_host_config_version == "1.3" } {
      puts $CHECK_OUTPUT "\ntestsuite host configuration update from 1.2 to 1.3 ..."

      foreach host $ts_host_config(hostlist) {
         set ts_host_config($host,java) ""
      }
      set ts_host_config(version) "1.3"
     
      show_config ts_host_config
      wait_for_enter
      if { [ save_host_configuration $filename] != 0} {
         puts $CHECK_OUTPUT "Could not save host configuration"
         wait_for_enter
         return
      }
      return 0
   }

   if { $ts_host_config(version) == "1.3" && $actual_ts_host_config_version == "1.4" } {
      puts $CHECK_OUTPUT "\ntestsuite host configuration update from 1.3 to 1.4 ..."

      foreach host $ts_host_config(hostlist) {
         set ts_host_config($host,zones) ""
      }
      set ts_host_config(version) "1.4"
     
      show_config ts_host_config
      wait_for_enter
      if { [ save_host_configuration $filename] != 0} {
         puts $CHECK_OUTPUT "Could not save host configuration"
         wait_for_enter
         return
      }
      return 0
   }

   puts $CHECK_OUTPUT "\nunexpected version"
   return -1
}

#****** check/update_ts_config_version() ***************************************
#  NAME
#     update_ts_config_version() -- used for version update of ts_config
#
#  SYNOPSIS
#     update_ts_config_version { } 
#
#  FUNCTION
#     This procedure is called when the versions of the testsuite configuration
#     are not equal.
#
#  SEE ALSO
#     check/update_ts_host_config_version()
#*******************************************************************************
proc update_ts_config_version {} {
   global actual_ts_config_version 
   global ts_config
   global CHECK_OUTPUT
puts $CHECK_OUTPUT "entering update_ts_config_version"
   if { $ts_config(version) == "1.0" } {
      puts $CHECK_OUTPUT "\ntestsuite configuration update from 1.0 to 1.1 ..."
      config_build_ts_config_1_1
      show_config ts_config
      wait_for_enter
   }

   if { $ts_config(version) == "1.1" } {
      puts $CHECK_OUTPUT "\ntestsuite configuration update from 1.1 to 1.2 ..."
      config_build_ts_config_1_2
      show_config ts_config
      wait_for_enter
   }

   if { $ts_config(version) == "1.2" } {
      puts $CHECK_OUTPUT "\ntestsuite configuration update from 1.2 to 1.3 ..."
      config_build_ts_config_1_3
      show_config ts_config
      wait_for_enter
   }
   
   if { $ts_config(version) == "1.3" } {
      puts $CHECK_OUTPUT "\ntestsuite configuration update from 1.3 to 1.4 ..."
      config_build_ts_config_1_4
      show_config ts_config
      wait_for_enter
   }
   
   if { $ts_config(version) == "1.4" } {
      puts $CHECK_OUTPUT "\ntestsuite configuration update from 1.4 to 1.5 ..."
      config_build_ts_config_1_5
      show_config ts_config
      wait_for_enter
   }
   
   if { $ts_config(version) == "1.5" } {
      puts $CHECK_OUTPUT "\ntestsuite configuration update from 1.5 to 1.6 ..."
      config_build_ts_config_1_6
      show_config ts_config
      wait_for_enter
   }
  
   if { $ts_config(version) == "1.6" } {
      puts $CHECK_OUTPUT "\ntestsuite configuration update from 1.6 to 1.7 ..."
      config_build_ts_config_1_7
      show_config ts_config
      wait_for_enter
   }

   if { $ts_config(version) == "1.7" } {
      puts $CHECK_OUTPUT "\ntestsuite configuration update from 1.7 to 1.8 ..."
      config_build_ts_config_1_8
      show_config ts_config
      wait_for_enter
      return 0
   }
   
   puts $CHECK_OUTPUT "\nunexpected version $ts_config(version), need version $actual_ts_config_version"
   return -1
}

#****** check/get_spaces() *****************************************************
#  NAME
#     get_spaces() -- return string with given number of spaces 
#
#  SYNOPSIS
#     get_spaces { nr } 
#
#  FUNCTION
#     This procedure returns a string with the given number of spaces
#
#  INPUTS
#     nr - nr of spaces in string
#
#  RESULT
#     string with given number of spaces
#
#  SEE ALSO
#     ???/???
#*******************************************************************************
proc get_spaces { nr } {
   set spaces ""
   for { set i 0 } { $i < $nr } { incr i 1 } {
      append spaces " "
   }
   return $spaces
}


#****** check/setup2() *********************************************************
#  NAME
#     setup2() -- testsuite initialization procedure
#
#  SYNOPSIS
#     setup2 { } 
#
#  FUNCTION
#     This procedure is used for testsuite initalization.
#
#  INPUTS
#
#  SEE ALSO
#     check/__setup()
#*******************************************************************************
proc setup2 { } {
   global sge_config
   global ts_config ts_host_config ts_user_config actual_ts_config_version
   global CHECK_OUTPUT CHECK_DO_SETUP
   global CHECK_DEFAULTS_FILE do_nomain
   global env be_quiet be_quiet
   global check_name CHECK_ACT_LEVEL have_defaults
   global CHECK_USER CHECK_CURRENT_WORKING_DIR



   global CHECK_PRODUCT_TYPE
   global CHECK_PRODUCT_VERSION_NUMBER
   global CHECK_PRODUCT_ROOT
   global CHECK_COMMD_PORT
   global CHECK_TESTSUITE_ROOT
   global CHECK_CONFIG_DIR
   global CHECK_CHECKTREE_ROOT
   global CHECK_MAIN_RESULTS_DIR
   global CHECK_JOB_OUTPUT_DIR
   global CHECK_PROTOCOL_DIR
   global CHECK_CORE_MASTER
   global CHECK_CORE_EXECD
   global CHECK_SUBMIT_ONLY_HOSTS
   global CHECK_USER
   global CHECK_GROUP
   global CHECK_CURRENT_WORKING_DIR
   global CHECK_SOURCE_DIR
   global CHECK_SOURCE_CVS_RELEASE
   global CHECK_SOURCE_HOSTNAME
   global CHECK_AIMK_COMPILE_OPTIONS
   global CHECK_DIST_INSTALL_OPTIONS
   global CHECK_PACKAGE_DIRECTORY
   global CHECK_PACKAGE_TYPE
   global CHECK_QMASTER_INSTALL_OPTIONS
   global CHECK_EXECD_INSTALL_OPTIONS
   global CHECK_DNS_DOMAINNAME
   global CHECK_REMOTE_ENVIRONMENT
   global CHECK_FIRST_FOREIGN_SYSTEM_USER
   global CHECK_SECOND_FOREIGN_SYSTEM_USER
   global CHECK_FIRST_FOREIGN_SYSTEM_GROUP
   global CHECK_SECOND_FOREIGN_SYSTEM_GROUP
   global CHECK_DEFAULT_DOMAIN
   global CHECK_MAILX_HOST
   global CHECK_REPORT_EMAIL_TO
   global CHECK_REPORT_EMAIL_CC
   global CHECK_SEND_ERROR_MAILS 
   global CHECK_MAX_ERROR_MAILS
   global CHECK_USE_SSH 
 

   # unset old system environment
   if { $be_quiet == 0 } { 
      puts "starting setup ..."
   }
   if { [info exists env(GRD_ROOT) ] } {
      if { $be_quiet == 0 } { 
         puts "unsetting GRD_ROOT"
      }
      unset env(GRD_ROOT)
   }
   if { [info exists env(CODINE_ROOT) ] } {
      if { $be_quiet == 0 } { 
         puts "unsetting CODINE_ROOT"
      }
      unset env(CODINE_ROOT)
   }
   
   # setup check information for error mails
   set check_name "setup"
   set CHECK_ACT_LEVEL "0"
   set have_defaults 0
   set configuration_updated 0

   if { [read_array_from_file $CHECK_DEFAULTS_FILE "testsuite configuration" ts_config ] == 0 } {
      if { $ts_config(version) != $actual_ts_config_version } {
         puts $CHECK_OUTPUT "unkown configuration file version: $ts_config(version)"
         while { [update_ts_config_version] != 0 } {
            wait_for_enter
         }

         # we have to store it later, after verifying the updated config
         set configuration_updated 1
      }
      # got config
     
      read_array_from_file $ts_config(host_config_file) "testsuite host configuration" ts_host_config
     
      if { [verify_config ts_config 1 err_list] != 0 } {
       
         # configuration problems

         foreach elem $err_list {
            puts "$elem"
         } 
         puts "Press enter to edit setup configurations"
         set answer [wait_for_enter 1]
         set not_ok 1
         while { $not_ok } {
            if { [verify_config ts_config 0 err_list ] != 0 } {
               wait_for_enter
               set not_ok 1
               foreach elem $err_list {
                  puts $CHECK_OUTPUT "error in: $elem"
               } 
               puts $CHECK_OUTPUT "Try again? (y/n)"
               set answer [wait_for_enter 1]
               if { $answer == "n" } {
                  # restore old config ?
                  puts $CHECK_OUTPUT "Do you want to restore previous configuration? (y/n)"
                  set answer [ wait_for_enter 1 ]
                  if { $answer == "y" } {
                     if { [restore_configuration] != 0 } {
                        puts $CHECK_OUTPUT "error restoring configuration!"
                        exit 1
                     }
                     exit 0
                  }
                  # save anyway
                  puts $CHECK_OUTPUT "Do you want to save your changes? (y/n)"
                  set answer [ wait_for_enter 1 ]
                  if { $answer == "y" } {
                     if { [save_configuration] != 0 } {
                        puts $CHECK_OUTPUT "error saving configuration!"
                        exit 1
                     }
                  }
                  exit 1
               } 
            } else {
               set not_ok 0
               if { [save_configuration] != 0 } {
                  puts $CHECK_OUTPUT "error saving configuration!"
                  exit 1
               }
            }
         }
      } else {
         if { $configuration_updated } {
            puts $CHECK_OUTPUT "Do you want to save the updated configuration? (y/n)"
            set answer [ wait_for_enter 1 ]
            if { $answer == "y" } {
               if { [save_configuration] != 0 } {
                  puts $CHECK_OUTPUT "error saving configuration!"
                  exit 1
               }
            }
         }
      }
      set CHECK_CONFIG_DIR "not supported in setup2 config file"
      if { $be_quiet == 0 } { 
         puts $CHECK_OUTPUT "\nstarting setup ... ok"
      }
      enhanced_setup
      
      if { $CHECK_DO_SETUP == 1 } {
         modify_setup2
      }
      
      unlock_testsuite
   } else {
      puts $CHECK_OUTPUT "could not open defaults file."
      if { [ file isfile $CHECK_DEFAULTS_FILE ] } {
         puts $CHECK_OUTPUT "file exists -> assuming old configuration file!"
         convert_old_defaults_file_to_new_format
         exit -1
      }
      puts $CHECK_OUTPUT "press return to create new configuration file \"$CHECK_DEFAULTS_FILE\""
      wait_for_enter 1 
      if { [save_configuration] != 0 } {
         exit -1
      }
      setup2
   }

}

#****** check/enhanced_setup() *************************************************
#  NAME
#     enhanced_setup() -- addition testsuite setup
#
#  SYNOPSIS
#     enhanced_setup { } 
#
#  FUNCTION
#     Procedure is called at the end of setup2(). Here some additional testsuite
#     setup calls are made.
#
#  SEE ALSO
#     check/setup2()
#*******************************************************************************
proc enhanced_setup {} {
   global ts_config
   global CHECK_CHECKTREE_ROOT CHECK_ENABLED_RUNLEVELS
   global CHECK_ENABLED_CATEGORIES CHECK_OUTPUT check_name
   global be_quiet CHECK_PACKAGE_DIRECTORY
   global env CHECK_COMMD_PORT CHECK_PRODUCT_ROOT CHECK_ARCH CHECK_HOST

   if { $be_quiet == 0 } { 
      puts "starting enhanced setup ..."
   }
   set check_name "enhanced_setup"

   set env(COMMD_PORT) $CHECK_COMMD_PORT;
   set env(SGE_QMASTER_PORT) $CHECK_COMMD_PORT;
   set env(SGE_EXECD_PORT) [expr ( $CHECK_COMMD_PORT + 1 ) ];
   set env(SGE_ROOT) $CHECK_PRODUCT_ROOT;
   set env(SGE_CELL) $ts_config(cell)
   set env(SGE_SINGLE_LINE) 1

   set_users_environment $CHECK_HOST

   get_max_level_count $CHECK_CHECKTREE_ROOT

   set CHECK_ENABLED_RUNLEVELS "0" ;# 100 200 300 400" ;#$CHECK_MAX_LEVEL is 400
   # JG: changed default categories to VERIFIED, reset to SYSTEM, once we get
   #     rid of the VERFIED category (when all tests are verified).
   set CHECK_ENABLED_CATEGORIES "VERIFIED" ;# [get_categories $CHECK_CHECKTREE_ROOT ]

   delete_tests $CHECK_CHECKTREE_ROOT 1

   setup_shared_lib_path
   check_executable_files
   
   if { $be_quiet == 0 } { 
      puts "   architecture: $CHECK_ARCH";
      puts "   local host:   $CHECK_HOST";
      puts "starting enhanced setup ... ok"
   }
   update_macro_messages_list
#
# uncomment the following line, if the unused macros should be removed from source code
# ======================================================================================  
# 
# --   check_c_source_code_files_for_macros
}


# get directories with checkprog
#                                                             max. column:     |
#****** check/get_check_dirs() ******
# 
#  NAME
#     get_check_dirs -- ??? 
#
#  SYNOPSIS
#     get_check_dirs { path } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#     path - ??? 
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc get_check_dirs { path } {
   global ts_config
   global CHECK_DIRECTORIES 
   global CHECK_INFORMATION_FILE CHECK_INFORMATION_EXT

   # get all files and subdirectories
   set files [get_file_names $path] 
   set dirs [get_dir_names $path]

   # look for check.exp and check.<version>.exp
   set dep_name "$CHECK_INFORMATION_FILE.$ts_config(gridengine_version).$CHECK_INFORMATION_EXT"
   set indep_name "$CHECK_INFORMATION_FILE.$CHECK_INFORMATION_EXT"
   if { [lsearch $files $dep_name] >= 0 || [lsearch $files $indep_name] >= 0 }  {
      lappend CHECK_DIRECTORIES $path;
   } 

   # recursive call on subdirectories
   foreach element $dirs {
      get_check_dirs "$path/$element"
   }
}


# check dependencies
#                                                             max. column:     |
#****** check/validate_needs() ******
# 
#  NAME
#     validate_needs -- ??? 
#
#  SYNOPSIS
#     validate_needs { needs } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#     needs - ??? 
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc validate_needs {needs} {
  global CHECK_RESULT_DIR CHECK_CORE_RESULT_DIR CHECK_OUTPUT

  if {$needs == ""} {
     return 0;
  } 

  set uncomplete 0;

  foreach elem $needs {

    set result_files ""
    set core_result_files ""
    catch { set result_files [glob "$CHECK_RESULT_DIR/$elem.res.*"] }
    catch { set core_result_files [glob "$CHECK_CORE_RESULT_DIR/$elem.res.*"] }

    debug_puts $result_files $core_result_files

    debug_puts " validate_needs: matching files in $CHECK_RESULT_DIR: $result_files"
    debug_puts " validate_needs: matching files in $CHECK_CORE_RESULT_DIR: $core_result_files"

    if {([file isfile [lindex $result_files 0]] != 1) && ([file isfile [lindex $core_result_files 0]] != 1 )} {
       debug_puts " validate_needs: need to run check $elem.";
       incr uncomplete 1; 
    }
  }

  if {$uncomplete == 0} {
    return 0;
  }
  return -1;
}

# delete result in CHECK_RESULT_DIR
#                                                             max. column:     |
#****** check/delete_result() ******
# 
#  NAME
#     delete_result -- ??? 
#
#  SYNOPSIS
#     delete_result { path runtime level } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#     path    - ??? 
#     runtime - ??? 
#     level   - ??? 
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc delete_result {path runtime level} {
  global check_name check_description check_needs check_functions check_errno check_errstr CHECK_RESULT_DIR CHECK_BAD_RESULT_DIR
  global CHECK_CORE_RESULT_DIR CHECK_CORE_BAD_RESULT_DIR CHECK_OUTPUT check_highest_level

  if { [is_level_enabled $level] == -1 } { 
     debug_puts "\n--> delete_result - info: test level $level not activated, aborting\n"
     return   ;# level not enabled
  }

  if { [is_category_enabled $path] == -1 } { 
     debug_puts "\n--> delete_result - info: category not activated, aborting\n"
     return  
  }
  
  

  set good_dir $CHECK_CORE_RESULT_DIR
  set bad_dir $CHECK_CORE_BAD_RESULT_DIR

  if {[string compare $check_name "init_core_system"] != 0} {
    set good_dir $CHECK_RESULT_DIR
    set bad_dir $CHECK_BAD_RESULT_DIR
  }

  debug_puts "saving results for $check_name (level $level)..."
  debug_puts $good_dir
  debug_puts $bad_dir

  set myfile "$good_dir/$check_name.res.$level" 
  if {[file isfile $myfile] == 1} {
    delete_file $myfile
  }

  set data ""

  lappend data $path
  lappend data $check_name;
  lappend data $check_description($level)
 
  lappend data $check_needs



  if { [ info exists check_functions ] } {
     if { [ string length $check_functions ] < 1 } {
        lappend data "{-> no check_function name <-}"
     } else {
        lappend data $check_functions
     } 
  } else {
     lappend data "{-> no check_function name <-}"
  }
  

  lappend data $check_errno
 
  lappend data $check_errstr
  lappend data $runtime
  lappend data [exec date]
  lappend data $check_highest_level

  set output [open "$bad_dir/$check_name.res.$level" "w"]  
  puts $output "$data"
  close $output 
}



# save results in CHECK_RESULT_DIR
#                                                             max. column:     |
#****** check/save_result() ******
# 
#  NAME
#     save_result -- ??? 
#
#  SYNOPSIS
#     save_result { path runtime level } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#     path    - ??? 
#     runtime - ??? 
#     level   - ??? 
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc save_result {path runtime level} {
  global check_name check_description check_needs check_functions check_errno check_errstr CHECK_RESULT_DIR CHECK_BAD_RESULT_DIR
 
  global CHECK_CORE_RESULT_DIR CHECK_CORE_BAD_RESULT_DIR CHECK_OUTPUT check_highest_level

  if { [is_level_enabled $level] == -1 } { 
     puts $CHECK_OUTPUT "\n--> save_result - error: test level $level not activated\n"
     return   ;# level not enabled
  }


  set good_dir $CHECK_CORE_RESULT_DIR
  set bad_dir $CHECK_CORE_BAD_RESULT_DIR

  if {[string compare $check_name "init_core_system"] != 0} {
    set good_dir $CHECK_RESULT_DIR
    set bad_dir $CHECK_BAD_RESULT_DIR
  } 

  puts "saving results for $check_name (level $level) ..."
  puts $good_dir
  puts $bad_dir
  
  set data ""
  lappend data $path
  lappend data $check_name;
  lappend data $check_description($level)
 
  lappend data $check_needs
  lappend data $check_functions
  lappend data $check_errno
 
  lappend data $check_errstr
  lappend data $runtime
  lappend data [exec date]
  lappend data $check_highest_level

  set output [open "$good_dir/$check_name.res.$level" "w"]  
  puts $output "$data"
  close $output

  if {[file isfile "$bad_dir/$check_name.res.$level"] == 1} {
    delete_file "$bad_dir/$check_name.res.$level"
    puts $CHECK_OUTPUT "\nset state of \"$check_name\" for level $level to completed !"
  }

} 

# get_check_name
#                                                             max. column:     |
#****** check/get_check_name() ******
# 
#  NAME
#     get_check_name -- ??? 
#
#  SYNOPSIS
#     get_check_name { path } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#     path - ??? 
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc get_check_name {path} {
   global CHECK_INFORMATION_FILE CHECK_INFORMATION_EXT
   global check_name

   set check_name ""
   ts_source $path/$CHECK_INFORMATION_FILE $CHECK_INFORMATION_EXT
  
   return $check_name
}

proc get_check_levels { path } {
   global CHECK_INFORMATION_FILE CHECK_INFORMATION_EXT
   global CHECK_ACT_LEVEL check_highest_level

   set saved_level $CHECK_ACT_LEVEL
   set check_highest_level 0
   set check_init_level_procedure "blub"
   unset check_init_level_procedure

   set levels ""
   if { [ts_source $path/$CHECK_INFORMATION_FILE $CHECK_INFORMATION_EXT] } {
      if { $check_highest_level > 0 && [info exists check_init_level_procedure] == 1} {
         for {set i 0} {$i <= $check_highest_level} {incr i 1} {
            set CHECK_ACT_LEVEL $i
            if { [$check_init_level_procedure ]  != 0 } { 
               continue 
            }
            lappend levels $CHECK_ACT_LEVEL
         }
      } else {
         lappend levels 0
      }
   }
   set CHECK_ACT_LEVEL $saved_level
   return $levels
}

# get test result
#                                                             max. column:     |
#****** check/get_test_result() ******
# 
#  NAME
#     get_test_result -- ??? 
#
#  SYNOPSIS
#     get_test_result { filename } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#     filename - ??? 
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc get_test_result {filename} {
   if {[file isfile $filename] != 1} {
      return {"file not found"}
   }
   if {[file readable $filename] != 1} {
      return {"file not readable"}
   }
   set input [open $filename "r"]
   gets $input data
   close $input
   return $data
}

# create report
#                                                             max. column:     |
#****** check/create_report() ******
# 
#  NAME
#     create_report -- ??? 
#
#  SYNOPSIS
#     create_report { file goodbad } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#     file    - ??? 
#     goodbad - ??? 
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc create_report {file goodbad} {
  global CHECK_RESULT_DIR CHECK_BAD_RESULT_DIR CHECK_CORE_RESULT_DIR
  global CHECK_CORE_BAD_RESULT_DIR CHECK_PRODUCT_VERSION_NUMBER CHECK_PRODUCT_ROOT


  set output [open $file "WRONLY APPEND CREAT"]
  puts $output "\n checksystem report"
  puts $output " ==================\n"
  puts $output " Date: [exec date]\n\n"
  puts $output " Version: $CHECK_PRODUCT_VERSION_NUMBER"
  puts $output " Installed in: $CHECK_PRODUCT_ROOT"
  if {$goodbad == 0} { 
     set total1 [ print_results $CHECK_CORE_RESULT_DIR $output ]
     set total2 [ print_results $CHECK_RESULT_DIR $output ]
     puts $output "\nTotal number of test functions: [expr ($total1 + $total2) ]"
  } else {
     print_results $CHECK_CORE_BAD_RESULT_DIR $output
     print_results $CHECK_BAD_RESULT_DIR $output
  }

  flush $output  
  close $output
 
  puts "report was written to $file"
}

# formatted output
#                                                             max. column:     |
#****** check/format_output() ******
# 
#  NAME
#     format_output -- ??? 
#
#  SYNOPSIS
#     format_output { prefix size text } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#     prefix - ??? 
#     size   - ??? 
#     text   - ??? 
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc format_output { prefix size text} {

  if {[string length $text] <= $size } {
     return $text;
  }

  set otext $text
  set buffer ""

  while { 1 == 1 } {
     set buffer "$buffer[string range $otext 0 $size]"
     set otext [string range $otext [expr ($size+1)] [string length $otext] ]
     set buffer "$buffer\n$prefix"
     if {[string length $otext] <= $size} {
        set buffer "$buffer$otext"
        return $buffer
     }
  }

}

# print results
#                                                             max. column:     |
#****** check/print_results() ******
# 
#  NAME
#     print_results -- ??? 
#
#  SYNOPSIS
#     print_results { ckpath where } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#     ckpath - ??? 
#     where  - ??? 
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc print_results {ckpath where} {

   set numb_of_check_functions 0 
   set filenames [get_file_names $ckpath]
   set catch_return [ catch {
      foreach elem $filenames {
         clear_screen
         set data [get_test_result "$ckpath/$elem"]
   
         set path [lindex $data 0]
         set check_name [lindex $data 1]
         set check_descrip [lindex $data 2]
         set check_needs [lindex $data 3]
         set check_functions [lindex $data 4]
         set check_errno [lindex $data 5]
         set check_errstr [lindex $data 6]
         set check_clock [lindex $data 7]
         set check_date  [lindex $data 8]
         set high_level [lindex $data 9]
         set file_level [split $elem "."]
         set file_level [lindex $file_level 2]
   
         set check_description($file_level) $check_descrip
   
         puts $where "############################################################################"
         puts $where "check: $check_name (level $file_level)"
         puts $where "############################################################################"
         puts $where "----------------------------------------------------------------------------"
         puts $where "results:"
      
         set index 0
         puts $where "----------------------------------------------------------------------------"
         puts $where "run time:       [format_output "                " 59 $check_clock]"
         puts $where "----------------------------------------------------------------------------"
         puts $where "date (end):     [format_output "                " 59 $check_date]" 
         puts $where "----------------------------------------------------------------------------"
         set leveltext $check_description($file_level)
         puts $where "description:    [format_output "                " 59 $leveltext]"
         puts $where "----------------------------------------------------------------------------"
         puts $where "dependencies:   [format_output "                " 59 $check_needs]"
         puts $where "----------------------------------------------------------------------------"
         puts $where "functions:      [format_output "                " 59 $check_functions]"
         puts $where "----------------------------------------------------------------------------"
         puts $where "function count: [format_output "                " 59 [llength $check_functions]]"
         puts $where "----------------------------------------------------------------------------"
         puts $where "directory:      [format_output "                " 59 $path]"
         puts $where "----------------------------------------------------------------------------\n"
   
         set numb_of_check_functions [ expr ($numb_of_check_functions + [llength $check_functions]) ]
         if {[string compare $where "stdout" ] == 0 } {
            puts $where "please press RETURN"
            set pressed [wait_for_enter 1]
         }
      }
   } my_error ]
   if { $catch_return != 0 } {
       add_proc_error "print_results" -1 "error creating test report:\n$my_error"
   }
   


   puts $where "\nTotal number of check functions in\n\"$ckpath\":\n$numb_of_check_functions\n"
   return $numb_of_check_functions
}
#                                                             max. column:     |
#****** check/is_level_enabled() ******
# 
#  NAME
#     is_level_enabled -- ??? 
#
#  SYNOPSIS
#     is_level_enabled { level_nr } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#     level_nr - ??? 
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc is_level_enabled { level_nr } {

    global CHECK_ENABLED_RUNLEVELS

    foreach level_start $CHECK_ENABLED_RUNLEVELS {
       set level_end [ expr ( $level_start + 99 ) ]

       if { ( $level_start <= $level_nr ) && ( $level_nr <= $level_end ) } {
          return 0
       }
    }

    return -1
}

proc get_check_category { path } {
   global CHECK_INFORMATION_FILE CHECK_INFORMATION_EXT
   global check_category

   ts_source $path/$CHECK_INFORMATION_FILE $CHECK_INFORMATION_EXT
   return $check_category
}

proc is_category_enabled { path } {
   global CHECK_ENABLED_CATEGORIES CHECK_OUTPUT
   set checks_cat [get_check_category $path]

   foreach elem $checks_cat {
      if { [ lsearch $CHECK_ENABLED_CATEGORIES $elem] != -1 } {
         return 0
      }
   }

   return -1
}

# delete tests
#                                                             max. column:     |
#****** check/delete_tests() ******
# 
#  NAME
#     delete_tests -- ??? 
#
#  SYNOPSIS
#     delete_tests { path { only_if_not_there 0 } } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#     path                    - ??? 
#     { only_if_not_there 0 } - ??? 
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc delete_tests {path { only_if_not_there 0 } } {
  global CHECK_DIRECTORIES check_errno check_errstr check_functions validate_needs check_name
  global CHECK_OUTPUT check_highest_level check_name check_description
  global check_init_level_procedure CHECK_ACT_LEVEL CHECK_OUTPUT
  global CHECK_INFORMATION_FILE CHECK_INFORMATION_EXT


  set old_check_name $check_name

  set CHECK_DIRECTORIES ""
  get_check_dirs $path 

  if { [info exists CHECK_DIRECTORIES] == 1 } {
    foreach elem $CHECK_DIRECTORIES {
#       puts "--"
       set check_highest_level 0
       set check_errstr ""
       set check_errno ""
       set check_name ""
       set check_init_level_procedure "--"

       if {[ts_source $elem/$CHECK_INFORMATION_FILE $CHECK_INFORMATION_EXT]} {
          set check_errstr ""
          set check_errno ""
          if { [ info exists check_functions ] } {
             foreach element $check_functions {
                lappend check_errstr "was never running" 
                lappend check_errno "-1"
             }
          } else {
             puts $CHECK_OUTPUT "no check_functions variable available!!"
             sleep 5
          }
          debug_puts "sourced \"$elem/$CHECK_INFORMATION_FILE.$CHECK_INFORMATION_EXT\""

          set do_delete 1
          if {$only_if_not_there == 1 } { 
             set result [ validate_needs $check_name ]
             if { $result == 0 } {
                set do_delete 0
             }
          }

          if {$do_delete == 1} {
             for {set i 0} {$i <= $check_highest_level} {incr i 1} {
                if { [string compare $check_init_level_procedure "--" ] != 0 } {
                   set CHECK_ACT_LEVEL $i
                   if { [$check_init_level_procedure]  == 0 } { 
                      delete_result $elem 0 $i
                   } 
                } else {
                   delete_result $elem 0 $i
                }
             }
          }

       }
  }
  }
  set check_name $old_check_name
}


#                                                             max. column:     |
#****** check/run_tests() ******
# 
#  NAME
#     run_tests -- ??? 
#
#  SYNOPSIS
#     run_tests { path runcompleted } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#     path         - ??? 
#     runcompleted - ??? 
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc run_tests { path runcompleted } {
    global CHECK_DIRECTORIES CHECK_OUTPUT CHECK_HOST check_errstr CHECK_RESULT_DIR
    global CHECK_MAILS_SENT CHECK_ENABLE_MAIL CHECK_MAX_ERROR_MAILS CHECK_CORE_RESULT_DIR
    global CHECK_CHECKTREE_ROOT CHECK_ACT_PATH check_use_installed_system ts_config
    global check_reinit_on_tcl_error CHECK_CORE_MASTER CHECK_PRODUCT_ROOT CHECK_ARCH

    set CHECK_DIRECTORIES ""
    get_check_dirs $path 

    set CHECK_MAILS_SENT 0  ;# clear mail counter

    if { [info exists CHECK_DIRECTORIES] == 1 } {
       
        set checks_to_do ""
        foreach elem $CHECK_DIRECTORIES {
           if { [is_category_enabled $elem ] == 0 } {
               set test_name [get_check_name $elem] 
               set tests_runlevels [get_check_levels $elem]
               foreach tests_runlevel $tests_runlevels {
                  if { ( [file isfile "$CHECK_RESULT_DIR/$test_name.res.$tests_runlevel"] == 1) } {
                     continue
                  }
                  if { ( [file isfile "$CHECK_CORE_RESULT_DIR/$test_name.res.$tests_runlevel"] == 1) } {
                     continue
                  }
                  lappend checks_to_do $elem
                  break
               }
           }
        }
        set checks_to_do [lsort $checks_to_do]
        if {[llength $checks_to_do] == 0} {
           return
        }

        # check if root password is needed
        foreach elem $checks_to_do {
            debug_puts "checking whether test in directory $elem needs root access ..."
            if { ([check_root_access $elem ] == 0) && ([have_root_passwd] == -1 ) } {
                puts $CHECK_OUTPUT "test in directory $elem needs root access ..."
                set_root_passwd
            }
        }

        set stop 0
        set pass_no 1
        set last_to_do -1
        set check_ok_name     ""
        set check_ok_state    "" 
        set check_ok_date     ""
        set check_ok_pass     ""
#        set check_ok_text     ""
        set check_error_name  ""
        set check_error_state ""
        set check_error_date  ""
        set check_error_pass  ""
#        set check_error_text  ""
        set check_missing_dep ""
        set check_warning_name ""
        set check_warning_state ""
        set check_warning_date ""
        set check_warning_pass ""
        set check_missing_dep ""
#        set check_warning_text ""

        while { $stop == 0 } {
           set todo [ llength $checks_to_do ]
           puts $CHECK_OUTPUT "---PASS${pass_no}----------------------------------------"
           puts $CHECK_OUTPUT "   Nr. of tests remaining: $todo"
           puts $CHECK_OUTPUT "------------------------------------------------" 

           # start tests
           foreach check $checks_to_do {
              set test_result [ run_test $check $runcompleted ]

              switch -- $test_result {
                       0 { 
                            # test OK
                            lappend check_ok_name  $check
                            lappend check_ok_state $test_result
                            lappend check_ok_date  [ exec date ]
                            lappend check_ok_pass  $pass_no 
#                            foreach err_message $check_errstr {
#                               lappend check_ok_text("$check") "{$err_message}"
#                            }

                         }
                      -2 { 
                            # dependencies - try again
                            lappend check_missing_dep  $check
                         }
                      -3 {
                            # impossible / unusefull to run this test
                            lappend check_warning_name $check 
                            lappend check_warning_state $test_result
                            lappend check_warning_date [ exec date ]
                            lappend check_warning_pass  $pass_no 
                            foreach err_message $check_errstr {
                               if { [info exists check_warning_text("$check") ] } {
                                  lappend check_warning_text("$check") "{$err_message}"
                               } else {
                                  set check_warning_text("$check") "{$err_message}"
                               }
                            }
                         }
                       1 { 
                            # test was allready done in an earlier run
                            # no action
                            puts $CHECK_OUTPUT "run_tests - check allready done"
                         }

                       2 {  
                            # test has no valid test in this run level
                            # no action
                            puts $CHECK_OUTPUT "test does not support actual runlevel"
                         }
                    -101 {
                            # check failed due to tcl error
                            lappend check_error_name  $check
                            lappend check_error_state $test_result
                            lappend check_error_date  [ exec date ]
                            lappend check_error_pass  $pass_no 
                                    
                            foreach err_message $check_errstr {
                               if { [info exists check_error_text("$check") ] } {
                                  lappend check_error_text("$check") "{$err_message}"
                               } else {
                                  set check_error_text("$check") "{$err_message}"
                               }
                            }
     
                            if { $check_reinit_on_tcl_error == 1 } {
                               # reinit system
                               puts $CHECK_OUTPUT "deleting all jobs"
                               delete_all_jobs
                               wait_for_end_of_all_jobs 60

                               set save_installed_value $check_use_installed_system
                               set save_CHECK_ACT_PATH $CHECK_ACT_PATH
                               set check_use_installed_system 1
                               set CHECK_ACT_PATH "$CHECK_CHECKTREE_ROOT/install_core_system"  
                               close_open_rlogin_sessions  ;# session reset
                               if { [run_test $CHECK_ACT_PATH 1] != 0 } {
                                  set CHECK_ACT_PATH "$CHECK_CHECKTREE_ROOT/install_core_system" 
                                  run_test $CHECK_ACT_PATH 1
                               }
                               set CHECK_ACT_PATH $save_CHECK_ACT_PATH
                               set check_use_installed_system $save_installed_value
                            }
                         }

                 default {
                            # check failed
                            lappend check_error_name  $check
                            lappend check_error_state $test_result
                            lappend check_error_date  [ exec date ]
                            lappend check_error_pass  $pass_no 
                                    
                            foreach err_message $check_errstr {
                               if { [info exists check_error_text("$check") ] } {
                                  lappend check_error_text("$check") "{$err_message}"
                               } else {
                                  set check_error_text("$check") "{$err_message}"
                               }
                            }
                            if { $check_reinit_on_tcl_error == 1 } {
                               # reinit system
                               # reinit system
                               puts $CHECK_OUTPUT "deleting all jobs"
                               delete_all_jobs
                               wait_for_end_of_all_jobs 60

                               set save_installed_value $check_use_installed_system
                               set save_CHECK_ACT_PATH $CHECK_ACT_PATH
                               set check_use_installed_system 1
                               set CHECK_ACT_PATH "$CHECK_CHECKTREE_ROOT/install_core_system"  
                               close_open_rlogin_sessions  ;# session reset
                               if { [run_test $CHECK_ACT_PATH 1] != 0 } {
                                  set CHECK_ACT_PATH "$CHECK_CHECKTREE_ROOT/install_core_system" 
                                  run_test $CHECK_ACT_PATH 1
                               }
                               set CHECK_ACT_PATH $save_CHECK_ACT_PATH
                               set check_use_installed_system $save_installed_value
                           }
                         }
              }
           }
   
           if { [llength $check_missing_dep] > 0 } {
              # missing dependencies , run again
              set checks_to_do $check_missing_dep
              incr pass_no 1
              if { $todo == $last_to_do } {
                 set stop 1
              } else {
                 puts $CHECK_OUTPUT "restarting test with missing dependencies ..."
                 set check_missing_dep ""
              } 
              set last_to_do $todo
           } else {
              # all done
              set stop 1
           } 
        }  ;# while stop == 0

        puts $CHECK_OUTPUT "Number of completed tests     : [llength $check_ok_name]"  
        puts $CHECK_OUTPUT "Number of failed tests        : [llength $check_error_name]"  
        puts $CHECK_OUTPUT "Number of unsupported tests   : [llength $check_warning_name]"
        puts $CHECK_OUTPUT "Number of dependencies errors : [llength $check_missing_dep]"
 

        set mail_body "Testsuite run on host $CHECK_HOST complete\n\n"


        # dependencies errors
        if { [llength $check_missing_dep ] > 0 } { 
           append mail_body "missing dependencies:\n"
           append mail_body "=====================\n\n"
           foreach elem $check_missing_dep {
              append mail_body "check [get_check_name $elem] in directory\n$elem\n" 
           } 
           append mail_body "\n"
        }
        # tests ok

        append mail_body "completed tests:\n"
        append mail_body "================\n\n"
        for {set index 0} {$index < [llength $check_ok_name]} {incr index 1} {
            append mail_body "Date: [ lindex $check_ok_date $index ]\n" 
            append mail_body "Test: [ lindex $check_ok_name $index ]\n"
            append mail_body "Info: Pass[lindex $check_ok_pass $index], State: [lindex $check_ok_state $index]\n\n"
        }
        set nr_complete [llength $check_ok_name] 
        append mail_body "Number of completed tests: $nr_complete"        

        # tests failed
        append mail_body "\n\nfailed tests:\n"
        append mail_body "=============\n"
        for {set index 0} {$index < [llength $check_error_name]} {incr index 1} {
            append mail_body "Date: [ lindex $check_error_date $index ]\n" 
            append mail_body "Test: [ lindex $check_error_name $index ]\n"
            append mail_body "Info: Pass[lindex $check_error_pass $index], State: [lindex $check_error_state $index]\n\n"
            foreach err_message $check_error_text("[ lindex $check_error_name $index ]") {
                foreach sm $err_message {
                   set error_output [ create_error_message $sm ]
                   append mail_body $error_output
                }
            }
        }
        set nr_failed [llength $check_error_name]
        append mail_body "Number of failed tests: $nr_failed"  

        # test run not usefull (warning)
        append mail_body "\n\nunsupported tests:\n"
        append mail_body "==================\n"
        for {set index 0} {$index < [llength $check_warning_name]} {incr index 1} {
            append mail_body "Date: [ lindex $check_warning_date $index ]\n" 
            append mail_body "Test: [ lindex $check_warning_name $index ]\n"
            append mail_body "Info: Pass[lindex $check_warning_pass $index], State: [lindex $check_warning_state $index]\n\n"
            if { [info exists check_warning_text("[ lindex $check_warning_name $index ]")] } {
               foreach err_message $check_warning_text("[ lindex $check_warning_name $index ]") {
                  foreach sm $err_message {
                     set error_output [ create_error_message $sm ]
                     append mail_body $error_output
                  }
               }
            }
        }
        set nr_unsupported [llength $check_warning_name]
        append mail_body "Number of unsupported tests: $nr_unsupported"  
        if { [llength $check_missing_dep ] > 0 } {
           set mail_subject "testsuite run complete - ok:$nr_complete;failed:$nr_failed;unsup.:$nr_unsupported;depend:[llength $check_missing_dep]"
        } else {
           set mail_subject "testsuite run complete - ok:$nr_complete;failed:$nr_failed;unsup.:$nr_unsupported"
        }
        mail_report "$mail_subject" $mail_body
      
 
    } else {
       puts $CHECK_OUTPUT "check directories not found"
    }

}


#                                                             max. column:     |
#****** check/lock_testsuite() ******
# 
#  NAME
#     lock_testsuite -- ??? 
#
#  SYNOPSIS
#     lock_testsuite { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc lock_testsuite {} {
    global CHECK_TESTSUITE_ROOT CHECK_OUTPUT CHECK_HOST CHECK_USER CHECK_MAIN_RESULTS_DIR
    global CHECK_SCRIPT_FILE_DIR CHECK_TESTSUITE_LOCKFILE

    set pid [getpid]
    
    debug_puts "-> lock_testsuite: pid=$pid host=$CHECK_HOST user=$CHECK_USER"

    set result 0
    set time [ expr ( [timestamp] + 60 ) ] 
    while { $result  != 10 } {
       puts $CHECK_OUTPUT "waiting for lock ..."
       set result [ catch {  
           eval exec "$CHECK_TESTSUITE_ROOT/$CHECK_SCRIPT_FILE_DIR/lock.sh $CHECK_TESTSUITE_LOCKFILE $pid $CHECK_HOST $CHECK_USER"
       } ]
       puts $CHECK_OUTPUT "lock.sh returned $result"
       set file_size 0
       catch { set file_size [file size $CHECK_TESTSUITE_LOCKFILE]}
       if { $file_size == 0 } {
           puts $CHECK_OUTPUT "file size is 0, deleteing lockfile..."
           sleep 60  ;# wait for NFS to update file
           unlock_testsuite
           sleep 60  ;# wait for NFS to update file
           return [ lock_testsuite ]  
       }
       if { $result != 10 } {
          puts $CHECK_OUTPUT "checking lockfile owner process ..."
          set data ""
          catch {
              set input [ open "$CHECK_TESTSUITE_LOCKFILE" "r" ]
              gets $input data 
              close $input
          }
          set owner_pid  [lindex $data 0]
          set owner_host [lindex $data 1]
          set owner_user [lindex $data 2]

          debug_puts "testsuite is locked by user $owner_user, process $owner_pid on host $owner_host!"
          if { ([lindex $data 0] == $pid ) && ([lindex $data 1] == $CHECK_HOST ) && ([lindex $data 2] == $CHECK_USER) } {
              debug_puts "thats me, so we have the lock"
              set result 10
              continue
          }
          debug_puts "checking whether process is still alive ..."
           
          get_ps_info $owner_pid $owner_host
          if { $ps_info($owner_pid,error) == 0 } {
             puts $CHECK_OUTPUT "process exists, command is \n-----\n\"$ps_info($owner_pid,string)\"\n-----"
          } else {
             puts $CHECK_OUTPUT "process doesn't exist -> unlock_testsuite ..." 
             unlock_testsuite 
          }
       }
    }
    debug_puts "new lockfile written! Testing for correct lock ..."

    set time [ expr ( [timestamp] + 60 ) ] 
    set tries 0 
    set ok 0
    set failed 0
    set file_size 0
    while {$ok != 1} {
       sleep 1
       catch { set input [ open $CHECK_TESTSUITE_LOCKFILE "r" ]
               gets $input data 
               close $input } 
 
       debug_puts "pid  [lindex $data 0] == $pid"
       debug_puts "host [lindex $data 1] == $CHECK_HOST"
       debug_puts "user [lindex $data 2] == $CHECK_USER"
 
       if { ([lindex $data 0] == $pid ) && ([lindex $data 1] == $CHECK_HOST ) && ([lindex $data 2] == $CHECK_USER) } {
          incr tries 1
          if {$tries >= 2} {
             set ok 1
          }
       }
       debug_puts "waiting to get lock"

       catch { set file_size [file size $CHECK_TESTSUITE_LOCKFILE]}
       debug_puts "file size is: $file_size"

       if { [timestamp] > $time } {
          set failed 1
          set ok 1
       }      
    }

    if {$failed == 1} {
        puts $CHECK_OUTPUT "no success! Try again ..."
        if { $file_size == 0 } {
           debug_puts "file size is zero, deleteing lockfile..."
           unlock_testsuite
        }
        return [ lock_testsuite ] 
    } 

    debug_puts "lock success!" 

}

#                                                             max. column:     |
#****** check/unlock_testsuite() ******
# 
#  NAME
#     unlock_testsuite -- ??? 
#
#  SYNOPSIS
#     unlock_testsuite { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc unlock_testsuite {} {
    global CHECK_TESTSUITE_ROOT CHECK_OUTPUT CHECK_MAIN_RESULTS_DIR CHECK_TESTSUITE_LOCKFILE

    if {[file isfile $CHECK_TESTSUITE_LOCKFILE] == 1 } {
        puts $CHECK_OUTPUT "removing lockfile \"$CHECK_TESTSUITE_LOCKFILE\"" 

       set catch_return [ catch {exec rm "$CHECK_TESTSUITE_LOCKFILE"} ]
       if { $catch_return != 0 } {
          puts $CHECK_OUTPUT "unlock_testsuite - could not unlock testsuite"
          return
       } 
       while { [ file isfile $CHECK_TESTSUITE_LOCKFILE ] == 1 } {
          puts $CHECK_OUTPUT "file still existing" 
          sleep 1
       }
    }
    puts $CHECK_OUTPUT "testsuite unlocked!" 
}



# run_test_level: returns
# -1 on error, 
# -2 check can not run
#  0 if ok, 
#  1 allready done
#
#                                                             max. column:     |
#****** check/run_test_level() ******
# 
#  NAME
#     run_test_level -- ??? 
#
#  SYNOPSIS
#     run_test_level { path runcompleted level {do_save 1} } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#     path         - ??? 
#     runcompleted - ??? 
#     level        - ??? 
#     {do_save 1}  - ??? 
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc run_test_level {path runcompleted level {do_save 1}} {
   global check_needs CHECK_RESULT_DIR check_name CHECK_ACTUAL_TEST_PATH
   global CHECK_CORE_RESULT_DIR check_errstr CHECK_OUTPUT check_description check_functions check_errno 
   global CHECK_CUR_PROC_NAME CHECK_CUR_PROC_RESULTS CHECK_CUR_PROC_ERRORS
   global CHECK_CURRENT_WORKING_DIR check_init_level_procedure CHECK_ACT_LEVEL
   global set_error_proc_called errorInfo CHECK_CORE_MASTER
   global check_setup_level_function check_cleanup_level_function
   
   # do not run allready completed tests
   debug_puts "runcompleted is $runcompleted"
   if { $runcompleted == 0 } {
     if { ( [file isfile "$CHECK_RESULT_DIR/$check_name.res.$level"] == 1) } {
        return 1 
     }
     if { ( [file isfile "$CHECK_CORE_RESULT_DIR/$check_name.res.$level"] == 1) } {
        return 1 
     }
   }  


   # get lock  
   delete_temp_script_files
   lock_testsuite

 
   set CHECK_ACT_LEVEL $level
   puts $CHECK_OUTPUT "starting test functions (runlevel is $CHECK_ACT_LEVEL)..."
 
   # call init_check_level procedure!
   # JG:       init_check_level is run twice (already in run_test.
   #           do we really have to call it twice?
   #           or call it here and return if it doesn't return 0
   # CR:       This must be done, because a test can be started for a
   #           specified runlevel
   if {[info exists check_init_level_procedure] == 1 } {
       if {[ string compare $check_init_level_procedure "--"] != 0 } {
          puts $CHECK_OUTPUT "\ncalling init level function \"$check_init_level_procedure\" ..."
          $check_init_level_procedure
       }
   }

 
   # call all check functions 
   set check_errno "-1"
   set check_errstr "was never running"
   set start_time [clock seconds]
   set was_error 0
   set was_unsupported 0
   set complete_errstr ""
   set complete_errno ""
   set catch_return 0

   # unless we are in install - check if system is running
   if { [ string compare $check_name "init_core_system" ] != 0 && 
        [ string compare $check_needs "" ] != 0 } {
      if { [is_scheduler_alive $CHECK_CORE_MASTER [get_qmaster_spool_dir]] != 1 } {
         add_proc_error "run_test_level" -1 "scheduler is not alive"
      }
      wait_for_load_from_all_queues 60
   }

   if { [info exists check_functions] } {
      # if we have a level specific setup function: execute it
      set setup_error 0
      if { $check_setup_level_function != "" } {
         set errorInfo ""
         set CHECK_CUR_PROC_NAME $check_setup_level_function
         puts $CHECK_OUTPUT "starting level setup function $check_setup_level_function"
         set setup_catch_return [ catch { $check_setup_level_function } setup_catch_message ]
         if { $setup_catch_return != 0 } {
            add_proc_error "run_test_level" "-2" "setup level function failed\n${errorInfo}" 
            set setup_error 1
         } else {
            if { $setup_catch_message != 0 } {
               add_proc_error "run_test_level" "-2" "setup level function returned error $setup_catch_message"
               set setup_error 1
            }
         }
      }
      if { ! $setup_error } {
      foreach elem $check_functions {
         puts $CHECK_OUTPUT "\n>>>>>>>>>>>>>>>>>>>>>>"
         puts $CHECK_OUTPUT "$elem"    
         puts $CHECK_OUTPUT "runlevel: [get_run_level_name $level]($level)"
         puts $CHECK_OUTPUT ">>>>>>>>>>>>>>>>>>>>>>"

         set check_errno "-1"
         set check_errstr "was never running"
         set was_empty 0
 
         # set public procedure error state to "no error"
         set check_cur_proc_result "0"
         set check_cur_proc_error "ok"
         set CHECK_CUR_PROC_ERRORS ""
         set CHECK_CUR_PROC_RESULTS "" 
         set CHECK_CUR_PROC_NAME $elem
         set set_error_proc_called 0  

         # this starts the test procedure
         set catch_return [ catch { $elem } errMsg ]
         if { $catch_return != 0 } {
            puts $CHECK_OUTPUT $errMsg
            add_proc_error "run_test_level" "-2" "catch returns not 0\n${errMsg}\n${errorInfo}" 
            set_error -2 "tcl error"
         } 
         
         # examine public procedure error states
         set myindex 0
         set procedure_error_text ""
         set procedure_errno ""
         foreach element $CHECK_CUR_PROC_RESULTS {
            if { $element != 0 } {
               # we got an error: append it to the check_xxx lists
               lappend procedure_error_text [lindex $CHECK_CUR_PROC_ERRORS $myindex]
               lappend procedure_errno $element 
            }
            incr myindex 1
         }        

         if { $set_error_proc_called == 0 } {
             lappend procedure_error_text "{$elem|no \"set_error\" call on procedure return|$check_name|run_test_level}"
             lappend procedure_errno "-1"
             set was_empty 1
         }
 
         flush $CHECK_OUTPUT  
      
         set stop 0 
         if { [ llength $procedure_errno ] == 0 } {
            lappend procedure_error_text "{$elem|$check_errstr|$check_name|run_test_level}"
            lappend procedure_errno $check_errno
            set was_empty 1
         }
         set cur_check_errno [ lindex $procedure_errno [ expr ( [ llength $procedure_errno] - 1 ) ] ]
         debug_puts "cur_check_errno = \"$cur_check_errno\""
         set cur_check_err_text  [ lindex $procedure_error_text [ expr ( [ llength $procedure_error_text] - 1 ) ] ]


         if {$cur_check_errno != 0} {
            incr was_error 1

            debug_puts "DEBUG: cur_errno = $cur_check_errno"           
 
            if { $was_empty == 1  } { 
               show_proc_error $cur_check_errno $cur_check_err_text
            }

            if {$cur_check_errno == -2 } {    ;# hard error dedected run no more test functions
              set stop 1   ;# stop with this test or not ?
            }

            if {$cur_check_errno == -3 } {    ;# test not possible for this host (no error)
              set was_unsupported 1
              incr was_error -1

              puts $CHECK_OUTPUT "U N S U P P O R T E D   test \"$check_name\" in run level $level, procedure $elem !"
            }
         } else {
            debug_puts "status: $check_errstr"
         }

         set myindex 0
         foreach element $procedure_errno {
            if { $element != 0 } {
               lappend complete_errstr [lindex $procedure_error_text $myindex]
               lappend complete_errno  $element
            }
            incr myindex 1
         }
         if {$stop == 1} {
           break;
         }
      }
      
      if { [llength $check_functions] == 0 } {   
         set no_func_error "{none|check_functions list has length 0 ( level: $level)|$check_name|run_test_level}"
         lappend complete_errstr "$no_func_error"
         lappend complete_errno -1
         show_proc_error -1 "$no_func_error"
         set was_error 1
      }
      }

      # if we have a level specific cleanup function: execute it
      if { $check_cleanup_level_function != "" } {
         set errorInfo ""
         set CHECK_CUR_PROC_NAME $check_cleanup_level_function
         puts $CHECK_OUTPUT "starting level cleanup function $check_cleanup_level_function"
         set setup_catch_return [ catch { $check_cleanup_level_function } setup_catch_message ]
         if { $setup_catch_return != 0 } {
            add_proc_error "run_test_level" "-2" "cleanup level function returns not 0\n${errorInfo}" 
            set was_error 1
         } else {
            if { $setup_catch_message != 0 } {
               add_proc_error "run_test_level" "-2" "cleanup level function returned error $setup_catch_message"
               set was_error 1
            }
         } 
      }

      if { $setup_error } {
         set was_error 1
      }

      if { $catch_return != 0 } {
         set check_errstr $complete_errstr
         set check_errno $complete_errno
         puts $CHECK_OUTPUT "T C L   E R R O R   running test \"$check_name\" in run level $level !"
         set end_time [clock seconds]
         unlock_testsuite
         return -101 
      }

      if { $was_unsupported == 1 && $was_error == 0 } {
         set check_errstr $complete_errstr
         set check_errno $complete_errno
         puts $CHECK_OUTPUT "U N S U P P O R T E D   test \"$check_name\" in run level $level !"
         set end_time [clock seconds]
         if { $do_save == 1 } {  
             save_result $path [expr ($end_time - $start_time)] $level
         }
         unlock_testsuite
         return -2
      }

      if {$was_error == 0} {
         set check_errstr $complete_errstr
         set check_errno $complete_errno
         puts $CHECK_OUTPUT "S U C C E S S F U L L Y performed \"$check_name\" in run level $level !"
         set end_time [clock seconds]
         if { $do_save == 1 } {      
            save_result $path [expr ($end_time - $start_time)] $level
         }
         unlock_testsuite
         return 0
      } 
   } else {
     set no_func_error "{none|check_functions variable not found (level: $level)|$check_name|run_test_level}"
     lappend complete_errstr "$no_func_error"
     lappend complete_errno -1
     show_proc_error -1 "$no_func_error"
   }
 
   # check function does not exist or had an error
   
   set check_errstr $complete_errstr
   set check_errno $complete_errno


   set end_time [clock seconds]
   if { $do_save == 1 } {   
      delete_result $path [expr ($end_time - $start_time)] $level
   }
   puts $CHECK_OUTPUT "\ncheck \"$check_name\" F A I L E D  in run level $level !"
   unlock_testsuite
   return -1
}


#                                                             max. column:     |
#****** check/check_root_access() ******
# 
#  NAME
#     check_root_access -- ??? 
#
#  SYNOPSIS
#     check_root_access { path } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#     path - ??? 
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc check_root_access {path} {
  global check_root_access_needs 
  global CHECK_INFORMATION_FILE CHECK_INFORMATION_EXT

  set check_root_access_needs ""  
  ts_source $path/$CHECK_INFORMATION_FILE $CHECK_INFORMATION_EXT

  if { [string compare "" $check_root_access_needs ] != 0 } {
     return 0
  } 

  return -1
}

proc delete_temp_script_files { } {
  global CHECK_TESTSUITE_ROOT CHECK_OUTPUT

  set del_file_name "$CHECK_TESTSUITE_ROOT/.testsuite_delete"
  if { [ file isfile $del_file_name ] == 1 } {
     set del_file [ open $del_file_name "r" ]
     while { [gets $del_file line] >= 0 } {
        if { [ file isfile $line ] == 1 } {
           file delete $line
        }
     }
     close $del_file
     file delete $del_file_name     
  } 
}
# run test
#                                                             max. column:     |
#****** check/run_test() ******
# 
#  NAME
#     run_test -- ??? 
#
#  SYNOPSIS
#     run_test { path runcompleted {run_single_test "all"} } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#     path                    - ??? 
#     runcompleted            - ??? 
#     {run_single_test "all"} - ??? 
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc run_test {path runcompleted {run_single_test "all"} { send_mail_report 1 } } {
   global ts_config  

  global CHECK_INFORMATION_FILE CHECK_INFORMATION_EXT check_needs CHECK_RESULT_DIR check_name CHECK_ACTUAL_TEST_PATH
  global CHECK_CORE_RESULT_DIR check_errstr CHECK_OUTPUT check_description check_functions check_errno 
  global CHECK_CUR_PROC_NAME CHECK_CUR_PROC_RESULTS CHECK_CUR_PROC_ERRORS check_root_access_needs
  global CHECK_CURRENT_WORKING_DIR check_highest_level check_init_level_procedure CHECK_ACT_LEVEL
  global CHECK_PRODUCT_TYPE CHECK_PRODUCT_VERSION_NUMBER CHECK_PRODUCT_ROOT CHECK_TESTSUITE_ROOT
  global check_category CHECK_GROUP
  global check_setup_function check_cleanup_function check_setup_level_function check_cleanup_level_function

  cd $CHECK_CURRENT_WORKING_DIR

  set do_only_one_test 0

  set CHECK_ACTUAL_TEST_PATH $path

  set check_name          ""
  set check_category      ""
  set check_needs         ""
  set check_functions     ""
  set check_setup_function ""
  set check_cleanup_function ""
  set check_setup_level_function ""
  set check_cleanup_level_function ""
  set check_highest_level 0
  set check_init_level_procedure "--"
  set check_root_access_needs   "" 

  ts_source $path/$CHECK_INFORMATION_FILE $CHECK_INFORMATION_EXT
  if { [string compare $run_single_test "all"] != 0 } {
     set do_only_one_test 1
     puts $CHECK_OUTPUT "running only test \"$run_single_test\""
     set check_functions "$run_single_test"
  }

  if { ( [string compare "" $check_root_access_needs] != 0) && ([have_root_passwd] == -1 ) } {
     set_root_passwd
  }

  # first check the dependencies
  
  puts $CHECK_OUTPUT ">>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>"
  puts $CHECK_OUTPUT ">>> $check_name"
  puts $CHECK_OUTPUT ">>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>"
  debug_puts "file: $path/check.exp"


  set result [validate_needs $check_needs]

  debug_puts "needs returned $result"
  debug_puts "highest level of test is $check_highest_level"

  if { $result != 0 } {
     puts $CHECK_OUTPUT "dependencies ($check_needs) not fulfilled! Stop!"
     set check_errstr ""
     set check_errno ""
     foreach elem $check_functions {
        lappend check_errstr "{run_test|dependencies not fulfilled!|$check_name|run_test}"
        lappend check_errno "-1"
     }

     for {set level 0} {$level <= $check_highest_level} {incr level 1} {
       if { [string compare $check_init_level_procedure "--" ] != 0 } { 
         set CHECK_ACT_LEVEL $level
         if { [$check_init_level_procedure ]  == 0 } { 
            delete_result $path 0 $level 
         }
       } else { 
         delete_result $path 0 $level
       }
     }
     return -2  ;# dependencies not fulfilled
  }

  set nr_errors 0
  set nr_warnings 0
  set nr_allready_done 0
  set nr_new_done 0
  set my_current_runlevel 0
  set do_send_mail 0
  set no_level_calls 0 
  set no_of_test_runs 0

   set immediate_return 0

   # check if this test is enabled for the actual runlevel, test is already done, ...
   for {set level 0} { $level <= $check_highest_level} {incr level 1} {

      # check if this is a global enabled level
      if {[is_level_enabled $level] == -1 } {
         continue
      } 

      # check test's init level procedure return value
      if { [string compare $check_init_level_procedure "--" ] != 0 } { 
         set CHECK_ACT_LEVEL $level
         if { [$check_init_level_procedure ]  != 0 } { 
            continue 
         }
      }

      # check if test was allready running
      if { $runcompleted == 0 } {
         if { ( [file isfile "$CHECK_RESULT_DIR/$check_name.res.$level"] == 1) } {
            continue 
         }
         if { ( [file isfile "$CHECK_CORE_RESULT_DIR/$check_name.res.$level"] == 1) } {
            continue  
         }
      }
      incr no_of_test_runs 1
   }

   if { $no_of_test_runs == 0 } {
      # no active runlevel for this check, return 2
      return 2 
   }

   # if we have a specific setup function: execute it
   if { $check_setup_function != "" } {
      set errorInfo ""
      puts $CHECK_OUTPUT "starting setup function $check_setup_function"
      set setup_catch_return [ catch { $check_setup_function } setup_catch_message ]
      if { $setup_catch_return != 0 } {
         add_proc_error "run_test" "-2" "setup function returns not 0\n${errorInfo}" 
         set immediate_return -1
      } else {
         if { $setup_catch_message != 0 } {
            add_proc_error "run_test" "-2" "setup function returned error $setup_catch_message"
            set immediate_return -1
         }
      }
   }

   if { $immediate_return == 0 } {
  for {set level 0} { $level <= $check_highest_level} {incr level 1} {
     if {[is_level_enabled $level] == -1 } {
        continue
     } 
     set my_current_runlevel $level
     if { [string compare $check_init_level_procedure "--" ] != 0 } { 
         set CHECK_ACT_LEVEL $level
         if { [$check_init_level_procedure ]  != 0 } { 
            continue 
         }
     }
     puts $CHECK_OUTPUT "\n----------------------------------------------"
     puts $CHECK_OUTPUT "-> enter check level $level"

     if { $do_only_one_test == 0 } {
        set back [run_test_level $path $runcompleted $level]
        debug_puts "level $level return value: $back"
        incr no_level_calls 1
     } else {
        set back [run_test_level $path $runcompleted $level 0 ]
        debug_puts "level $level return value of test $run_single_test: $back"
        incr no_level_calls 1
     }

     if { [string first "unknown" $CHECK_GROUP] >= 0 } {
         add_proc_error "run_test" -1 "CHECK_GROUP set to unknown, test was $path in level $level"
     }

     if {$back == -101  } { 
        incr nr_errors 1
        debug_puts "--> TCL ERROR in check $path in level $level <--"
        set immediate_return -101
        break
     }
     if {$back == -1} {
        incr nr_errors 1     ;# we had an error
        debug_puts "--> ERROR in check $path in level $level <--"
        set immediate_return -1
        break
     }
     if {$back == -2} {
        incr nr_warnings 1     ;# check can not run
        debug_puts "--> check $path in level $level: can't start test <--"
     }
     if {$back == 0} {
        set do_send_mail 1  ;# a successfull test run
        incr nr_new_done 1
        debug_puts "no errors"
     } 

     if {$back == 1} {
        debug_puts "check allready done"
        incr nr_allready_done 1
     }
     debug_puts "calls=$no_level_calls, allready done=$nr_allready_done"
  }
   }

   # if we have a specific cleanup function: execute it
   if { $check_cleanup_function != "" } {
      set errorInfo ""
      puts $CHECK_OUTPUT "starting cleanup function $check_cleanup_function"
      set setup_catch_return [ catch { $check_cleanup_function } setup_catch_message ]
      if { $setup_catch_return != 0 } {
         add_proc_error "run_test" "-2" "cleanup function returns not 0\n${errorInfo}" 
         set immediate_return -1
      } else {
         if { $setup_catch_message != 0 } {
            add_proc_error "run_test" "-2" "cleanup function returned error $setup_catch_message"
            set immediate_return -1
         }
      } 
   }

   if { $immediate_return != 0 } {
      return $immediate_return
   }

  if { $nr_allready_done == $no_level_calls } {
     return 1  ;# was done time before
  }
  
  if { $send_mail_report != 1 } {
     set do_send_mail 0
  }

  if { $nr_errors == 0 && $nr_warnings == 0 } {
     if { $do_send_mail == 1 } {
        set mail_body "Successfully performed check $check_name in directory\n$path\n"
        set mail_body "${mail_body}Date: [ exec date ]\n\n"
        set mail_body "${mail_body}product type:     $CHECK_PRODUCT_TYPE\n"
        set mail_body "${mail_body}product feature:  $ts_config(product_feature)\n"
        set mail_body "${mail_body}product version:  $CHECK_PRODUCT_VERSION_NUMBER\n"
        set mail_body "${mail_body}product root:     $CHECK_PRODUCT_ROOT\n"
        set mail_body "${mail_body}cell:             $ts_config(cell)\n"
        set mail_body "${mail_body}runlevel:         [get_run_level_name $my_current_runlevel]\n"
        set mail_body "${mail_body}max. runlevel:    [get_run_level_name $check_highest_level]\n"
        set mail_body "${mail_body}dependencies:     $check_needs\n"
        set mail_body "${mail_body}check functions:  \n"
        foreach elem $check_functions {
           set mail_body "${mail_body}                   $elem\n"
        } 
        set mail_body "${mail_body}init level proc:  $check_init_level_procedure\n"
        mail_report "testsuite success - $check_name" $mail_body
     }
     return 0
  } else {
     if { $nr_errors == 0 } {
        return -3 ;# we had warnings
     }
     return -1
  }
}

#                                                             max. column:     |
#****** check/clean_up_globals() ******
# 
#  NAME
#     clean_up_globals -- ??? 
#
#  SYNOPSIS
#     clean_up_globals { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc clean_up_globals {} {
  global check_init_level_procedure check_name check_description check_highest_level
  global check_needs check_functions check_errno check_errstr check_category
 
  if { [ info exists check_category ] } {
     unset check_category 
  }

  if { [ info exists check_description] } {
     unset check_description 
  }


  set check_name        ""                 ;# name of actual check module 
  set check_needs       ""          ;# dependencies of this check (name of other check)
  set check_functions   ""          ;# functions to call (in order)
  set check_init_level_procedure "--"   ;# name of procedure to call before starting level run
  set check_errno      -1          ;# 0 -> OK , != 0 means error (-2 = break test , -1 failure )
  set check_errstr       ""          ;# short error description in text form  
  set check_highest_level 0        ;# here a check can define his check levels count 0 ... 
}

# show test description
#                                                             max. column:     |
#****** check/show_test() ******
# 
#  NAME
#     show_test -- ??? 
#
#  SYNOPSIS
#     show_test { path full } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#     path - ??? 
#     full - ??? 
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc show_test {path full} {
  global CHECK_INFORMATION_FILE CHECK_INFORMATION_EXT check_errno check_needs check_highest_level 
  global check_init_level_procedure CHECK_ACT_LEVEL check_category

  clean_up_globals  

  ts_source $path/$CHECK_INFORMATION_FILE $CHECK_INFORMATION_EXT
  puts "===============================================================================" 
  puts "name:         | $check_name"
  puts -nonewline "categories:   | "
  foreach cat $check_category {
     puts -nonewline "$cat "
  }
  puts ""
  puts "===============================================================================" 

  if { $full == 1} {
    puts "filename:     | [ format_output "              | " 61 $path/$CHECK_INFORMATION_FILE.$CHECK_INFORMATION_EXT ]"

    puts "===============================================================================" 
    for {set i 0} {$i <= $check_highest_level} {incr i 1} {
       set blank ""
       if { $i <= 99} {
         set blank " "
       }
       if { $i <= 9 } {
         set blank "  "
       } 

       set do_print 0
       if { [string compare $check_init_level_procedure "--" ] != 0 } { 
          set CHECK_ACT_LEVEL $i
          if { [$check_init_level_procedure ]  == 0 } { 
             set do_print 1
          } 
       } else {
          set do_print 1
       }
       if { $do_print == 1 } { 
          puts "run level ${blank}$i |"
          puts "description:  | [ format_output "              | " 61 $check_description($i)]"
          puts "==============================================================================="
       }
      

    }

    puts "dependencies: |"
    foreach element $check_needs {
      puts "              | [ format_output "              | " 61 $element]"
    }
    puts "==============================================================================="
  }
}

#                                                             max. column:     |
#****** check/select_runlevel() ******
# 
#  NAME
#     select_runlevel -- ??? 
#
#  SYNOPSIS
#     select_runlevel { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc select_runlevel {} {
     global CHECK_ENABLED_RUNLEVELS CHECK_ENABLED_CATEGORIES CHECK_CHECKTREE_ROOT

     set data ""
     set my_cats [get_categories $CHECK_CHECKTREE_ROOT]

     while { $data != 0 } {
       
        clear_screen
        print_menu_header
        set selected_levels ""
        foreach elem $CHECK_ENABLED_RUNLEVELS {
           set a_level [ get_run_level_name $elem ] 
  
           if { [string first $a_level $selected_levels ] < 0 } {
              set selected_levels "$selected_levels $a_level"
           } 
        }

        puts "\nplease select/unselect new runlevels/categories: \n"
        puts "(0) return to previous menu\n"

        puts "runlevels:\n"
        puts "(1) short  (   0 min - 15 min / run level   0 -  99 )"
        puts "(2) medium (  16 min -  1 h   / run level 100 - 199 )"
        puts "(3) long   (   1 h   -  4 h   / run level 200 - 299 )"
        puts "(4) day    ( > 4 h   - 24 h   / run level 300 - 399 )"
        puts "(5) week   ( >24 h            / run level 400 - 499 )\n"
        puts "categories:\n"
        set numbs 6
        foreach elem $my_cats {
           puts "($numbs) $elem"
           incr numbs 1
        }

        set data [wait_for_enter 1]
        if { $data <= 5 && $data > 0 } {
           incr data -1
           set in 0
           if { $data <= 4 && $data >= 0 } {
              foreach x $CHECK_ENABLED_RUNLEVELS {
                 if { $x == [ expr ( $data * 100 ) ] } {
                    set in 1
                 }      
              }
           }
   
           if { $data <= 4 && $data >= 0 } {
             if {$in == 0} {
               lappend CHECK_ENABLED_RUNLEVELS [ expr ( $data * 100 )] 
             } else {
               set new_enabled_runlevels ""
               foreach x $CHECK_ENABLED_RUNLEVELS {
                  if { $x != [ expr ( $data * 100 ) ] } { 
                     lappend new_enabled_runlevels $x
                  }
               }
               set CHECK_ENABLED_RUNLEVELS $new_enabled_runlevels
             } 
           }
           incr data 1
        } else {
           # categories
           set max_number [llength $my_cats]
           incr max_number 5
           if { $data > $max_number || $data <= 5  } {
              continue
           }   
           set my_cat [ expr ( $data - 6 ) ]   
           set new_cat [ lindex $my_cats $my_cat ]
           set cat_pos [ lsearch $CHECK_ENABLED_CATEGORIES  $new_cat ]
           if { $cat_pos != -1 } {
              set CHECK_ENABLED_CATEGORIES [ lreplace $CHECK_ENABLED_CATEGORIES $cat_pos $cat_pos ]
           } else {
              lappend CHECK_ENABLED_CATEGORIES $new_cat
           }
        }
     } 
}
proc check_display {} {
     global CHECK_DISPLAY_OUTPUT CHECK_CORE_MASTER CHECK_USER 

     if { [ string compare $CHECK_DISPLAY_OUTPUT "undefined" ] == 0 } {
        puts "no debug x display set"
        return -1
     } 
     start_remote_prog "$CHECK_CORE_MASTER" "$CHECK_USER" "/usr/openwin/bin/xterm" "-bg darkolivegreen -fg navajowhite -sl 5000 -sb -j -display $CHECK_DISPLAY_OUTPUT -e sleep 1"
     if { $prg_exit_state != 0 } {
         puts "can't open display $CHECK_DISPLAY_OUTPUT as user $CHECK_USER from host $CHECK_CORE_MASTER"    
         return -1
     }

     if { [ have_root_passwd ] != 0 } {
         set_root_passwd
     }
     start_remote_prog "$CHECK_CORE_MASTER" "root" "/usr/openwin/bin/xterm" "-bg darkolivegreen -fg navajowhite -sl 5000 -sb -j -display $CHECK_DISPLAY_OUTPUT -e sleep 1"
     if { $prg_exit_state != 0 } {
         puts "can't open display $CHECK_DISPLAY_OUTPUT as user root from host $CHECK_CORE_MASTER"    
         return -1
     }
     return 0
}


proc set_command_line_options {} {
     global CHECK_ENABLED_RUNLEVELS CHECK_ENABLED_CATEGORIES CHECK_CHECKTREE_ROOT 
     global CHECK_SGE_DEBUG_LEVEL
     global master_debug schedd_debug do_not_update CHECK_DISPLAY_OUTPUT daemon_debug
     set data ""
     while { $data != 0 } {
        clear_screen
        print_menu_header
        puts "\nplease select/unselect command line options: \n"
        puts "(0) return to previous menu\n"

        puts "options:\n"


        if { $master_debug == 0 } {
           set md_flag "off"
        } else {
           set md_flag "on"
        }
        if { $schedd_debug == 0 } {
           set sd_flag "off"
        } else {
           set sd_flag "on"
        }
        if { $do_not_update == 0 } {
           set nu_flag "off"
        } else {
           set nu_flag "on"
        }


        puts "(1) master_debug    : $md_flag"
        puts "(2) schedd_debug    : $sd_flag"
        puts "(3) SGE_DEBUG_LEVEL : $CHECK_SGE_DEBUG_LEVEL"
        puts "(4) no_update       : $nu_flag"

        set data [wait_for_enter 1]
        if { $data <= 2 && $data > 0 } {
        }
        switch $data {
           "1" { 
              puts "master_debug" 
              if { $master_debug == 0 } {
                 set result [check_display]
                 if { $result != 0 } {
                    puts "current display \"$CHECK_DISPLAY_OUTPUT\" does not work,\nplease enter correct display: "
                    set CHECK_DISPLAY_OUTPUT [wait_for_enter 1]
                    set result [check_display]
                    if { $result != 0 } { 
                       puts "still errors"
                       wait_for_enter
                       continue
                    }
                 }
                 set master_debug 1
              } else {
                 set master_debug 0
              }
           }
           "2" {
              puts "schedd_debug" 
              if { $schedd_debug == 0 } {
                 set result [check_display]
                 if { $result != 0 } {
                    puts "current display \"$CHECK_DISPLAY_OUTPUT\" does not work,\nplease enter correct display: "
                    set CHECK_DISPLAY_OUTPUT [wait_for_enter 1]
                    set result [check_display]
                    if { $result != 0 } { 
                       puts "still errors"
                       wait_for_enter
                       continue
                    }
                 }
                 set schedd_debug 1
              } else {
                 set schedd_debug 0
              }
           }
           "3" {
               puts "enter new SGE_DEBUG_LEVEL: "
               set CHECK_SGE_DEBUG_LEVEL [wait_for_enter 1]
           }
           "4" {
               if { $do_not_update == 0 } {
                  set do_not_update 1
               } else { 
                  set do_not_update 0
               }
           }
        }

        if { $schedd_debug == 0 && $master_debug == 0 } {
           set daemon_debug 1
        } else {
           set daemon_debug 0
        }
     } 
}

#                                                             max. column:     |
#****** check/get_max_level_count() ******
# 
#  NAME
#     get_max_level_count -- ??? 
#
#  SYNOPSIS
#     get_max_level_count { path } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#     path - ??? 
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc get_max_level_count {path} {
  global CHECK_DIRECTORIES CHECK_INFORMATION_FILE CHECK_INFORMATION_EXT check_highest_level 
  global CHECK_MAX_LEVEL check_init_level_procedure CHECK_ACT_LEVEL check_name
 
  set old_check_name $check_name

  set CHECK_DIRECTORIES ""
  set CHECK_MAX_LEVEL "0"
  get_check_dirs $path  
  if { [info exists CHECK_DIRECTORIES] == 1 } {
    foreach elem $CHECK_DIRECTORIES {
       set check_highest_level 0 
       set check_init_level_procedure "--"
       ts_source $elem/$CHECK_INFORMATION_FILE $CHECK_INFORMATION_EXT
       if { [string compare $check_init_level_procedure "--" ] != 0 } {
          for {set x 0 } {$x <= $check_highest_level} {incr x 1 } {
             set CHECK_ACT_LEVEL $x
             if { [$check_init_level_procedure ]  == 0 } {
                if { [lsearch $CHECK_MAX_LEVEL $x] < 0 } {
                   lappend CHECK_MAX_LEVEL $x
                }
             }
          } 
       }
    }  
  }
  set check_name $old_check_name
  return $CHECK_MAX_LEVEL
}

proc get_categories {path} {
  global CHECK_DIRECTORIES CHECK_INFORMATION_FILE CHECK_INFORMATION_EXT check_highest_level 
  global CHECK_MAX_LEVEL check_init_level_procedure CHECK_ACT_LEVEL
  global check_category
 
  set CHECK_DIRECTORIES ""
  set CHECK_MAX_LEVEL "0"
  set back ""
  get_check_dirs $path  
  if { [info exists CHECK_DIRECTORIES] == 1 } {
    foreach elem $CHECK_DIRECTORIES {
       clean_up_globals
       ts_source $elem/$CHECK_INFORMATION_FILE $CHECK_INFORMATION_EXT
       if { [info exists check_category] } {
          foreach elem $check_category {
             if { [ lsearch -exact $back $elem ] == -1 } {
                lappend back $elem
             }
          }
       }
    }  
  }
  set back [lsort $back]
  return $back
}




# show test descriptons (of all subtests)
#                                                             max. column:     |
#****** check/show_tests() ******
# 
#  NAME
#     show_tests -- ??? 
#
#  SYNOPSIS
#     show_tests { path full } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#     path - ??? 
#     full - ??? 
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc show_tests {path full} {
  global CHECK_DIRECTORIES

  set CHECK_DIRECTORIES ""
  get_check_dirs $path 

  if { [info exists CHECK_DIRECTORIES] == 1 } {
    foreach elem $CHECK_DIRECTORIES {
      clear_screen
      show_test $elem $full
      wait_for_enter
    }  
  }
}

# change directory
#                                                             max. column:     |
#****** check/change_dir() ******
# 
#  NAME
#     change_dir -- ??? 
#
#  SYNOPSIS
#     change_dir { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc change_dir { { have_input "" } } {
  global CHECK_ACT_PATH CHECK_CHECKTREE_ROOT 
  set index_start 1
  print_menu_header

  set dirs [ get_dir_names $CHECK_ACT_PATH ]

  set count 1 

  if {[string compare $CHECK_ACT_PATH $CHECK_CHECKTREE_ROOT] != 0 } {
    puts "($count) - up"
    incr count 1
    incr index_start 1
  }
  puts "($count) - stay"
  incr count 1
  incr index_start 1

  foreach elem $dirs {
#     puts "($count) - go to \"$elem\""
     set newdir($count) $elem
     incr count 1
  }

  if { $have_input == "" } {
     puts -nonewline "\nEnter number or a subdirectory name:\n> "
     set input [wait_for_enter 1] 
  } else {
     set input $have_input
  }
  set nr_of_dirs [llength $dirs]
  for { set i 0 } { $i < $nr_of_dirs } { incr i 1 } {
     if { [lindex $dirs $i] == $input } {
        set input $i 
        incr input $index_start
     }
  }
  
  if { ($input == 1) && ([string compare $CHECK_ACT_PATH $CHECK_CHECKTREE_ROOT] != 0)}  {
     puts "go to upper dir ..."
     set test [split $CHECK_ACT_PATH "/\/"] 
     set CHECK_ACT_PATH [lrange $test 0 [expr [llength $test] - 2] ]
     set CHECK_ACT_PATH [ join $CHECK_ACT_PATH "/"]  
     return
  }

  if { [info exists newdir($input)] == 1 } {
     puts "go to dir $newdir($input) ..."
     set CHECK_ACT_PATH "$CHECK_ACT_PATH/$newdir($input)"
     return
  }
}


#                                                             max. column:     |
#****** check/get_run_level_name() ******
# 
#  NAME
#     get_run_level_name -- ??? 
#
#  SYNOPSIS
#     get_run_level_name { level } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#     level - ??? 
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc get_run_level_name { level } {
  
  if { $level >= 400 } {
     return "week"
  }

  if { $level >= 300 } {
     return "day"
  }

  if { $level >= 200 } {
     return "long"
  }

  if { $level >= 100 } {
     return "medium"
  }

  if { $level >= 00 } {
     return "short"
  }
  return ""
}
# time in minutes
proc get_run_level_time { level } {
  
  if { $level >= 400 } {
     return [expr (48 * 60)]
  }

  if { $level >= 300 } {
     return [expr (14 * 60)]
  }

  if { $level >= 200 } {
     return [expr (2 * 60)]
  }

  if { $level >= 100 } {
     return 30
  }

  if { $level >= 00 } {
     return 10
  }
  return 0
}


#                                                             max. column:     |
#****** check/clear_screen() ******
# 
#  NAME
#     clear_screen -- ??? 
#
#  SYNOPSIS
#     clear_screen { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc clear_screen {} {
  set clear_sequence [ format "%c%c%c%c%c%c%c" 0x1b 0x5b 0x48 0x1b 0x5b 0x32 0x4a 0x00 ]
  puts -nonewline $clear_sequence
}

#                                                             max. column:     |
#****** check/print_menu_header() ******
# 
#  NAME
#     print_menu_header -- ??? 
#
#  SYNOPSIS
#     print_menu_header { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc print_menu_header {} {
  global CHECK_ACT_PATH CHECK_DIRECTORIES CHECK_RESULT_DIR 
  global CHECK_USER CHECK_REPORT_FILE CHECK_OUTPUT CHECK_HOST CHECK_BAD_RESULT_DIR 
  global CHECK_CORE_RESULT_DIR CHECK_CORE_BAD_RESULT_DIR CHECK_MAIN_RESULTS_DIR 
  global CHECK_ENABLED_RUNLEVELS CHECK_MAX_LEVEL CHECK_PRODUCT_VERSION_NUMBER
  global CHECK_ENABLED_CATEGORIES CHECK_USER CHECK_GROUP
  global ts_config

  clear_screen
  set_users_environment $CHECK_HOST env 1
  get_version_info
  puts "===============================================================================" 

  puts " system version     :  $CHECK_PRODUCT_VERSION_NUMBER ($ts_config(gridengine_version))"
  puts " feature            :  $ts_config(product_feature)"
  puts " current dir        :  [ format_output "                       " 54 $CHECK_ACT_PATH ]"
#  puts " user group         :  $CHECK_GROUP"
#  puts " user name          :  $CHECK_USER"
  set dirs [ get_dir_names $CHECK_ACT_PATH ]
  set files [get_file_names $CHECK_ACT_PATH ]
  if { [ llength $dirs ] == 0 } {
     lappend dirs "."
  }
  set test_counts ""
  set test_text ""
  set time_count 0
  foreach elem $dirs {
     set test_name ""
     set CHECK_DIRECTORIES ""
     get_check_dirs "$CHECK_ACT_PATH/$elem"
     set count 0
     foreach test $CHECK_DIRECTORIES {
        if { [is_category_enabled $test] == 0 } {
           set run_test_ok 0
           set tests_runlevels [get_check_levels $test]
            
           foreach tests_runlevel $tests_runlevels {
              if { [ is_level_enabled $tests_runlevel ] == 0 } {
                 set test_name [get_check_name $test]
                 if { ( [file isfile "$CHECK_RESULT_DIR/$test_name.res.$tests_runlevel"] == 1) } {
                    continue
                 }
                 if { ( [file isfile "$CHECK_CORE_RESULT_DIR/$test_name.res.$tests_runlevel"] == 1) } {
                    continue
                 }
                 set run_test_ok 1
                 incr time_count [get_run_level_time $tests_runlevel] 
              }
           }
           if { $run_test_ok == 1 } {
              incr count 1  
           }
        }
     }
     if { $count > 9 } {
        set blank " "
     } else {
        set blank "  "
     }
     lappend test_counts "$count"
     if { ${elem} == "." } {
        lappend test_text   " test name: $test_name"
     } else {
        lappend test_text   "${blank}${count} test(s) available in subdir: ${elem}"
     }
  }
  set test_count 0
  foreach elem $test_counts {
     incr test_count $elem 
  }

  get_max_level_count $CHECK_ACT_PATH
  set possible_levels ""

  foreach elem $CHECK_MAX_LEVEL {
     set a_level [ get_run_level_name $elem ] 
     if { [string first $a_level $possible_levels ] < 0 } {
        set possible_levels "$possible_levels $a_level"
     } 
  }
  set possible_levels [lsort $possible_levels]
  puts " max. runlevel      :  $possible_levels"  

  set selected_levels ""
  set CHECK_ENABLED_RUNLEVELS [ lsort $CHECK_ENABLED_RUNLEVELS  ]
  foreach elem $CHECK_ENABLED_RUNLEVELS {
     set a_level [ get_run_level_name $elem ] 

     if { [string first $a_level $selected_levels ] < 0 } {
        set selected_levels "$selected_levels $a_level"
     } 
  } 

  set selected_levels [ lsort $selected_levels ]
  puts " selected runlevels :  $selected_levels"
  set my_cats [get_categories $CHECK_ACT_PATH]
  puts -nonewline " categories         :  "
  foreach elem $my_cats {
     puts -nonewline "$elem "
  }
  puts ""

  puts -nonewline " selected categories:  "
  set CHECK_ENABLED_CATEGORIES [ lsort $CHECK_ENABLED_CATEGORIES]
  foreach elem $CHECK_ENABLED_CATEGORIES {
     puts -nonewline "$elem "
  }
  puts ""
  set hours [ expr ( $time_count / 60 ) ]
  set minutes [ expr (  $time_count % 60 ) ]
  puts " est. run time      :  $hours h $minutes m"
  puts "===============================================================================" 
  foreach elem $test_text {
     puts $elem
  }
#  puts "===============================================================================" 
#  set blank "  "
#  if { $test_count > 9 } {
#     set blank " "
#  }  
#  puts "${blank}$test_count test(s) available in current subdirs"
  puts "===============================================================================" 
  return $files
}

#                                                             max. column:     |
#****** check/wait_for_enter() ******
# 
#  NAME
#     wait_for_enter -- ??? 
#
#  SYNOPSIS
#     wait_for_enter { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc wait_for_enter { {no_text 0} } {
   global CHECK_OUTPUT CHECK_TESTSUITE_ROOT CHECK_SCRIPT_FILE_DIR
   flush $CHECK_OUTPUT

   if { $no_text == 0 } {
      puts "\npress enter..."
   }
   set output ""
   set en_result [ catch {
      set output [eval exec "$CHECK_TESTSUITE_ROOT/$CHECK_SCRIPT_FILE_DIR/wait_for_enter.sh"]
   } catch_output ]
   return [string trim $output]
}

#                                                             max. column:     |
#****** check/wait_for_start_time() ******
# 
#  NAME
#     wait_for_start_time -- ??? 
#
#  SYNOPSIS
#     wait_for_start_time { substring } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#     substring - ??? 
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc wait_for_start_time { substring } {
   puts "wait for start time: \"$substring\""
   while { 1 } {
      set date_output [ exec date "+%D %H:%M" ]
      puts -nonewline "\r$date_output"
      flush stdout
      if { [string compare $date_output $substring] == 0 } {
         break; 
      }
      sleep 30
   }
   puts ""
}

# returns -1: error
# returns 0 : no error
proc prepare_packages { } {
   global ts_config
   global CHECK_PACKAGE_DIRECTORY CHECK_OUTPUT CHECK_DEFAULTS_FILE
   global CHECK_PRODUCT_ROOT CHECK_JOB_OUTPUT_DIR CHECK_HOST CHECK_PACKAGE_TYPE
   global CHECK_USER CHECK_PRODUCT_TYPE CHECK_CORE_EXECD CHECK_PROTOCOL_DIR
   global CHECK_GROUP check_name CHECK_CUR_PROC_NAME

   set check_name "prepare_packages"
   set CHECK_CUR_PROC_NAME "prepare_packages"


   #do pre checks like in compile
   if {[file isdirectory "$CHECK_PROTOCOL_DIR"] != 1} {
      set catch_return [ catch {  file mkdir "$CHECK_PROTOCOL_DIR" } ]
      if { $catch_return != 0 } {
           puts $CHECK_OUTPUT "could not create directory \"$CHECK_PROTOCOL_DIR\""
           return -1
      } 
   }

   set have_tar 0
   set have_zip 0
   if { [ check_packages_directory $CHECK_PACKAGE_DIRECTORY check_tar ] == 0 } {
      puts $CHECK_OUTPUT "found tar files"
      set have_tar 1
   }

   if { [ check_packages_directory $CHECK_PACKAGE_DIRECTORY check_zip ] == 0 } {
      puts $CHECK_OUTPUT "found zip files"
      set have_zip 1
   }

   if { $have_tar == 0 && $CHECK_PACKAGE_TYPE == "tar" } {
      add_proc_error "prepare_packages" -1 "not all tar files available"
      return -1
   }

   if { $have_zip == 0 && $CHECK_PACKAGE_TYPE == "zip" } {
      add_proc_error "prepare_packages" -1 "not all zip files available"
      return -1
   }


   if { $have_tar == 1 && $CHECK_PACKAGE_TYPE == "tar" } {

      # shutdown eventually running system
      shutdown_core_system

      set tar_files [ check_packages_directory $CHECK_PACKAGE_DIRECTORY check_both tar ]

      set restore_host_aliases_file 0
      # copy pos. host_aliases file 
      if { [ file isfile "$CHECK_PRODUCT_ROOT/$ts_config(cell)/common/host_aliases"] == 1 } {
         puts $CHECK_OUTPUT "saving host_aliases file ..."
         set restore_host_aliases_file 1
         catch { exec "cp" "$CHECK_PRODUCT_ROOT/$ts_config(cell)/common/host_aliases" "$CHECK_JOB_OUTPUT_DIR/host_aliases"  } result
         puts $result
      } 
      # now delete install directory
      puts $CHECK_OUTPUT "moving directory \"$CHECK_PRODUCT_ROOT\" to testsuite_trash"
      if { [delete_directory "$CHECK_PRODUCT_ROOT"] != 0 } {
         add_proc_error "prepare_packages" -2 "could not delete $CHECK_PRODUCT_ROOT directory, critical error - stop"
         return -1
      }
      # checking permissions
      catch { exec "mkdir" "$CHECK_PRODUCT_ROOT"  } result
      puts $result
      catch { exec "chmod" "755" "$CHECK_PRODUCT_ROOT"  } result
      puts $result

      catch { file mkdir "$CHECK_PRODUCT_ROOT/$ts_config(cell)" } 
      catch { file mkdir "$CHECK_PRODUCT_ROOT/$ts_config(cell)/common" } 

      # copy pos. host_aliases file to new product root /cell/common
      if { [ file isfile "$CHECK_JOB_OUTPUT_DIR/host_aliases"] == 1 && 
           $restore_host_aliases_file == 1 } {
         puts $CHECK_OUTPUT "restoring host_aliases file ..."
         catch { exec "cp" "$CHECK_JOB_OUTPUT_DIR/host_aliases" "$CHECK_PRODUCT_ROOT/$ts_config(cell)/common/host_aliases" } result
         puts $result
      }

      # copy package files to product root directory
      puts $CHECK_OUTPUT "copy package files to product root directory ..."
      set i 0
      foreach file $tar_files { 
         puts -nonewline $CHECK_OUTPUT [washing_machine $i]
         flush $CHECK_OUTPUT
         incr i 1
         file copy $CHECK_PACKAGE_DIRECTORY/$file $CHECK_PRODUCT_ROOT
      } 
      puts $CHECK_OUTPUT ""

      # gunzip package files
      puts $CHECK_OUTPUT "gunzip package files ..."
      set i 0
      foreach file $tar_files { 
         puts -nonewline $CHECK_OUTPUT [washing_machine $i]
         flush $CHECK_OUTPUT
         incr i 1
         set catch_out [catch { exec "gunzip" "$CHECK_PRODUCT_ROOT/$file"  } result]
         if { $catch_out != 0 } {
            puts $CHECK_OUTPUT $result
         }
      } 
      puts $CHECK_OUTPUT ""

      # extract package files
      puts $CHECK_OUTPUT "extract package files ..."
      set i 0
      foreach file $tar_files { 
         puts -nonewline $CHECK_OUTPUT [washing_machine $i]
         flush $CHECK_OUTPUT
         incr i 1
         set help [ string first ".gz" $file ]
         incr help -1
         set file_no_gz [string range $file 0 $help]
         set result [ start_remote_prog $CHECK_HOST $CHECK_USER "cd" "$CHECK_PRODUCT_ROOT ; tar -xvf $CHECK_PRODUCT_ROOT/$file_no_gz" ]
         if { $prg_exit_state != 0 } {
            puts $CHECK_OUTPUT $result
         }
      } 
      puts $CHECK_OUTPUT ""
     
      # delete untared package files
      puts $CHECK_OUTPUT "delete untared package files ..."
      foreach file $tar_files { 
         set help [ string first ".gz" $file ]
         incr help -1
         set file_no_gz [string range $file 0 $help]
         delete_file $CHECK_PRODUCT_ROOT/$file_no_gz
      } 
      puts $CHECK_OUTPUT ""

      # checking for correct system 
      set sys_info "unkown"
      if { [ file isfile $CHECK_PRODUCT_ROOT/inst_sge ] } {
         set sys_info "sge"
      }
      if { [ file isfile $CHECK_PRODUCT_ROOT/inst_sgeee ] } {
         set sys_info "sgeee"
      }

      puts $CHECK_OUTPUT "system       : $sys_info"      

      # checking for installed archs
      set sys_archs [get_dir_names $CHECK_PRODUCT_ROOT/utilbin ]
      
      set local_host_arch [ resolve_arch $CHECK_HOST ]
      set local_arch_ok 0
      puts -nonewline $CHECK_OUTPUT "architectures:"
     
      foreach arch $sys_archs {
         puts -nonewline $CHECK_OUTPUT " $arch"
         if { [ string compare $arch $local_host_arch ] == 0 } {
            set local_arch_ok 1
         }
      }
      puts $CHECK_OUTPUT ""
      
      # check for testsuite host binaries
      if { $local_arch_ok != 1 } {
         add_proc_error "prepare_packages" -1 "host architecture for host $CHECK_HOST not installed"
         return -1
      }

      # check if settings file is correct for the system
      if { $CHECK_PRODUCT_TYPE != $sys_info } {
         add_proc_error "prepare_packages" -1 "setup entry for product_type is \"$CHECK_PRODUCT_TYPE\", but system is \"$sys_info\""
         return -1
      }

      # check all archs to appear in execd host list and vice versa
      set execd_archs ""
      foreach elem $CHECK_CORE_EXECD {
         set host_arch [ resolve_arch $elem ]
         if { [string compare $host_arch "unkown" ] == 0 } {
            add_proc_error "prepare_packages" -1 "could not resolve host \"$elem\"!"
            return -1
         }
         lappend execd_archs $host_arch
         set found_arch 0
         foreach sarch $sys_archs {
            if { [ string compare $sarch $host_arch] == 0 } {
               set found_arch 1
            }
         }
         if { $found_arch != 1 } {
            add_proc_error "prepare_packages" -1 "binaries for host \"$elem\" not in tar files, please add tar file"
            return -1
         }
      }

      foreach elem $sys_archs {
         set found_arch 0
         foreach execd $execd_archs {
            if { [ string compare $elem $execd] == 0 } {
               set found_arch 1
            }
         }
         if { $found_arch != 1 } {
            add_proc_error "prepare_packages" -1 "found no host for tar architecture \"$elem\""
            return -1
         }
      } 

      # try to resolve hostnames in settings file
      set catch_return [ catch { eval exec "cp ${CHECK_DEFAULTS_FILE} ${CHECK_DEFAULTS_FILE}.[timestamp]" } ]
      if { $catch_return != 0 } { 
         puts "could not copy defaults file"
         return -1
      }
      return 0
   }

   if { $have_zip == 1 && $CHECK_PACKAGE_TYPE == "zip" } {

      # shutdown eventually running system
      shutdown_core_system

      set zip_files [ check_packages_directory $CHECK_PACKAGE_DIRECTORY check_both zip ]

      set restore_host_aliases_file 0
      # copy pos. host_aliases file 
      if { [ file isfile "$CHECK_PRODUCT_ROOT/$ts_config(cell)/common/host_aliases"] == 1 } {
         puts $CHECK_OUTPUT "saving host_aliases file ..."
         set restore_host_aliases_file 1
         catch { exec "cp" "$CHECK_PRODUCT_ROOT/$ts_config(cell)/common/host_aliases" "$CHECK_JOB_OUTPUT_DIR/host_aliases"  } result
         puts $result
      } 
      # now delete install directory
      puts $CHECK_OUTPUT "moving directory \"$CHECK_PRODUCT_ROOT\" to testsuite_trash"
      if { [delete_directory "$CHECK_PRODUCT_ROOT"] != 0 } {
         add_proc_error "prepare_packages" -2 "could not delete $CHECK_PRODUCT_ROOT directory, critical error - stop"
         return -1
      }
      # checking permissions
      catch { exec "mkdir" "$CHECK_PRODUCT_ROOT"  } result
      puts $result
      catch { exec "chmod" "755" "$CHECK_PRODUCT_ROOT"  } result
      puts $result

      catch { file mkdir "$CHECK_PRODUCT_ROOT/$ts_config(cell)" } 
      catch { file mkdir "$CHECK_PRODUCT_ROOT/$ts_config(cell)/common" } 

      # copy pos. host_aliases file to new product root /$SGE_CELL/common
      if { [ file isfile "$CHECK_JOB_OUTPUT_DIR/host_aliases"] == 1 && 
           $restore_host_aliases_file == 1 } {
         puts $CHECK_OUTPUT "restoring host_aliases file ..."
         catch { exec "cp" "$CHECK_JOB_OUTPUT_DIR/host_aliases" "$CHECK_PRODUCT_ROOT/$ts_config(cell)/common/host_aliases" } result
         puts $result
      }

      # copy package files to product root directory
      puts $CHECK_OUTPUT "copy package files to product root directory ..."
      set i 0
      if { [catch { file mkdir "$CHECK_PRODUCT_ROOT/tmp_zip_copy" }] != 0 } {
         puts $CHECK_OUTPUT "could not create directory \"$CHECK_PRODUCT_ROOT/tmp_zip_copy\""
         return -1    
      }
      foreach file $zip_files { 
         puts -nonewline $CHECK_OUTPUT [washing_machine $i]
         flush $CHECK_OUTPUT
         incr i 1
         file copy $CHECK_PACKAGE_DIRECTORY/$file $CHECK_PRODUCT_ROOT/tmp_zip_copy
      } 
      puts $CHECK_OUTPUT ""

      
      # unzip package files
      puts $CHECK_OUTPUT "unzip package files ..."
      set i 0
      foreach file $zip_files { 
         puts -nonewline $CHECK_OUTPUT [washing_machine $i]
         flush $CHECK_OUTPUT
         incr i 1
         set catch_out [catch { exec "unzip" "$CHECK_PRODUCT_ROOT/tmp_zip_copy/$file" "-d" "$CHECK_PRODUCT_ROOT/tmp_zip_copy"  } result]
         if { $catch_out != 0 } {
            puts $CHECK_OUTPUT $result
         }
      } 
      puts $CHECK_OUTPUT ""

      # delete untared package files
      puts $CHECK_OUTPUT "delete untared package files ..."
      foreach file $zip_files { 
         delete_file $CHECK_PRODUCT_ROOT/tmp_zip_copy/$file
      } 
      puts $CHECK_OUTPUT ""


      # now check if packages are allready installed and remove installed ones
      set package_names [ get_dir_names $CHECK_PRODUCT_ROOT/tmp_zip_copy ]
      puts -nonewline $CHECK_OUTPUT "Found following packages:"
      foreach pkg $package_names {
         puts -nonewline $CHECK_OUTPUT " $pkg" 
      }
      puts $CHECK_OUTPUT "\n"
      set user_key "unknown"
      foreach pkg $package_names {
         puts -nonewline $CHECK_OUTPUT "Checking if package \"$pkg\" is allready installed on host \"$CHECK_HOST\" ... "
         set output [ start_remote_prog $CHECK_HOST "root" "pkginfo" "$pkg" ]
         if { $prg_exit_state != 0 } {
            puts $CHECK_OUTPUT "not installed"
         } else {
            puts $CHECK_OUTPUT "allready installed."
            puts $CHECK_OUTPUT "\n$output\n"
            puts $CHECK_OUTPUT "Press \"yes\" to uninstall ALL packages listed above or \"no\" to continue ..."
            if { $user_key == "unknown" } {
               set user_key [ wait_for_enter 1 ]
            }
            if { $user_key == "yes" } {
               puts $CHECK_OUTPUT "removing package \"$pkg\" ..."
               set output [ start_remote_prog $CHECK_HOST "root" "pkgrm" "-n $pkg" ]
               puts $CHECK_OUTPUT $output
               if { $prg_exit_state != 0 } {
                  puts $CHECK_OUTPUT "error uninstalling package \"$pkg\""
                   puts $CHECK_OUTPUT "stop package installation"
                   return -1
               }
            } else {
               puts $CHECK_OUTPUT "will NOT remove package \"\""
               puts $CHECK_OUTPUT "stop package installation"
               return -1
            }
         }
      }
      
      # now install the packages ...
      set send_speed .1
      set send_slow "1 $send_speed"
      foreach pkg $package_names {
         set id [open_remote_spawn_process "$CHECK_HOST" "root" "pkgadd" "-d $CHECK_PRODUCT_ROOT/tmp_zip_copy $pkg" ]
         log_user 1
         set sp_id [ lindex $id 1 ]
         set timeout 60
         set do_stop 0
         set exit_state 1
         while { $do_stop == 0 } {
            flush $CHECK_OUTPUT
            expect {
               -i $sp_id full_buffer { 
                  add_proc_error "prepare_packages" -1 "buffer overflow please increment CHECK_EXPECT_MATCH_MAX_BUFFER value"
                  close_spawn_process $id
                  return -1
               }
               -i $sp_id timeout {
                  add_proc_error "prepare_packages" -1 "unexpected timeout"
                  close_spawn_process $id
                  return -1
               } 
               -i $sp_id eof {
                  set exit_state [close_spawn_process $id]
                  set do_stop 1
               } 
               -i $sp_id "_exit_status_:*\n" {
                  set buf $expect_out(buffer)
                  set s_start [ string first "(" $buf ]
                  set s_end [ string first ")" $buf ]
                  incr s_start 1
                  incr s_end -1
                  set exit_state [ string range $buf $s_start $s_end ]
                  puts $CHECK_OUTPUT "exit state is: \"$exit_state\""
                  close_spawn_process $id
                  set do_stop 1
               }
               -i $sp_id "default /gridware/sge*]" {
                  flush $CHECK_OUTPUT
                  if { [ string length $CHECK_PRODUCT_ROOT ] >= 5  } {
                     send -s -i $sp_id "$CHECK_PRODUCT_ROOT\n"
                  } else {
                     add_proc_error "prepare_packages" -1 "can't use product root directory (shorter than 5 chars)"
                     close_spawn_process $id
                     return -1
                  }
                  flush $CHECK_OUTPUT
               } 
               -i $sp_id "default sgeadmin*]" {
                  flush $CHECK_OUTPUT
                  send -s -i $sp_id "$CHECK_USER\n"   
                  flush $CHECK_OUTPUT
               } 
               -i $sp_id "Do you want to install these as setuid/setgid files*]" {
                  flush $CHECK_OUTPUT
                  send -s -i $sp_id "y\n"   
                  flush $CHECK_OUTPUT
               }


               -i $sp_id "default adm*]" {
                  send -s -i $sp_id "$CHECK_GROUP\n"
                  flush $CHECK_OUTPUT
               } 
               -i $sp_id "Waiting for pkgadd of*" {
                  add_proc_error "prepare_packages" -1 "$CHECK_HOST: another pkgadd session is running...\n$expect_out(buffer)"
                  close_spawn_process $id
                  return -1
               }
               -i $sp_id "*\n" { 
                  flush $CHECK_OUTPUT
               } 
               -i $sp_id default {
                  add_proc_error "prepare_packages" -1 "undefined behaviour: $expect_out(buffer)"
                  close_spawn_process $id
                  return -1
               } 
            }
         }
         if { $exit_state != 0 } {
            add_proc_error "prepare_packages" -1 "exit state of pgkadd \"$pkg\" is $exit_state -> error"
            return -1
         }
      }
           



      # checking for correct system 
      set sys_info "unkown"
      if { [ file isfile $CHECK_PRODUCT_ROOT/inst_sge ] } {
         set sys_info "sge"
      }
      if { [ file isfile $CHECK_PRODUCT_ROOT/inst_sgeee ] } {
         set sys_info "sgeee"
      }

      puts $CHECK_OUTPUT "system       : $sys_info"      

      # checking for installed archs
      set sys_archs [get_dir_names $CHECK_PRODUCT_ROOT/utilbin ]
      
      set local_host_arch [ resolve_arch $CHECK_HOST ]
      set local_arch_ok 0
      puts -nonewline $CHECK_OUTPUT "architectures:"
     
      foreach arch $sys_archs {
         puts -nonewline $CHECK_OUTPUT " $arch"
         if { [ string compare $arch $local_host_arch ] == 0 } {
            set local_arch_ok 1
         }
      }
      puts $CHECK_OUTPUT ""
      
      # check for testsuite host binaries
      if { $local_arch_ok != 1 } {
         add_proc_error "prepare_packages" -1 "host architecture for host $CHECK_HOST not installed"
         return -1
      }

      # check if settings file is correct for the system
      if { $CHECK_PRODUCT_TYPE != $sys_info } {
         add_proc_error "prepare_packages" -1 "setup entry for product_type is \"$CHECK_PRODUCT_TYPE\", but system is \"$sys_info\""
         return -1
      }

      # check all archs to appear in execd host list and vice versa
      set execd_archs ""
      foreach elem $CHECK_CORE_EXECD {
         set host_arch [ resolve_arch $elem ]
         if { [string compare $host_arch "unkown" ] == 0 } {
            add_proc_error "prepare_packages" -1 "could not resolve host \"$elem\"!"
            return -1
         }
         lappend execd_archs $host_arch
         set found_arch 0
         foreach sarch $sys_archs {
            if { [ string compare $sarch $host_arch] == 0 } {
               set found_arch 1
            }
         }
         if { $found_arch != 1 } {
            add_proc_error "prepare_packages" -1 "binaries for host \"$elem\" not in zip files, please add zip file"
            return -1
         }
      }

      foreach elem $sys_archs {
         set found_arch 0
         foreach execd $execd_archs {
            if { [ string compare $elem $execd] == 0 } {
               set found_arch 1
            }
         }
         if { $found_arch != 1 } {
            add_proc_error "prepare_packages" -1 "found no host for zip architecture \"$elem\""
            return -1
         }
      } 

      # try to resolve hostnames in settings file
      set catch_return [ catch { eval exec "cp ${CHECK_DEFAULTS_FILE} ${CHECK_DEFAULTS_FILE}.[timestamp]" } ]
      if { $catch_return != 0 } { 
         puts "could not copy defaults file"
         return -1
      }
      return 0
   }

   return -1
}
# mode : check_both, check_tar, check_zip
# get_files : no, tar, zip
proc check_packages_directory { path { mode "check_both" } { get_files "no" } } {

   global CHECK_OUTPUT CHECK_PACKAGE_TYPE

   set tar_bin_files [ get_file_names $path "sge*-bin-*.tar.gz" ] 
   set zip_bin_files [ get_file_names $path "sge*-bin-*.zip" ]      
   set tar_common_files [ get_file_names $path "sge*-common*.tar.gz" ] 
   set zip_common_files [ get_file_names $path "sge*-common*.zip" ]   
   set tar_doc_files [ get_file_names $path "sge*-doc*.tar.gz" ] 
   set zip_doc_files [ get_file_names $path "sge*-doc*.zip" ]    

   set tar_list "$tar_bin_files $tar_common_files $tar_doc_files"
   set zip_list "$zip_bin_files $zip_common_files $zip_doc_files"
     

   set nr_tar_bin_files [ llength $tar_bin_files ]
   set nr_zip_bin_files [ llength $zip_bin_files ] 
   set nr_tar_common_files [ llength $tar_common_files ]
   set nr_zip_common_files [ llength $zip_common_files ] 
   set nr_tar_doc_files [ llength $tar_doc_files ]
   set nr_zip_doc_files [ llength $zip_doc_files ] 

   set tar_complete 0
   set zip_complete 0

   if { $tar_bin_files  > 0 && $tar_common_files > 0 && $tar_doc_files > 0 } {
      set tar_complete 1
   }
   if { $zip_bin_files  > 0 && $zip_common_files > 0 && $zip_doc_files > 0 } {
      set zip_complete 1
   }

   if { $get_files == "no" } {
      puts $CHECK_OUTPUT "nr. of binary tar files: $nr_tar_bin_files"
      puts $CHECK_OUTPUT "nr. of binary zip files: $nr_zip_bin_files"
      puts $CHECK_OUTPUT "nr. of common tar files: $nr_tar_common_files"
      puts $CHECK_OUTPUT "nr. of common zip files: $nr_zip_common_files"
      puts $CHECK_OUTPUT "nr. of doc tar files: $nr_tar_doc_files"
      puts $CHECK_OUTPUT "nr. of doc zip files: $nr_zip_doc_files"
      if { $tar_complete == 1 } {
         puts $CHECK_OUTPUT "tar files complete"
      } else {
         puts $CHECK_OUTPUT "tar files INCOMPLETE"
      }
      if { $zip_complete == 1 } {
         puts $CHECK_OUTPUT "zip files complete"
      } else {
         puts $CHECK_OUTPUT "zip files INCOMPLETE"
      }
      
      if { $tar_complete == 1 && $zip_complete == 1 && $mode == "check_both" } {
         return 0
      }
      if { $tar_complete == 1 && $mode == "check_tar" } {
         return 0
      }
      if { $zip_complete == 1 && $mode == "check_zip" } {
         return 0
      }
      return -1
   } else {
      switch -- $get_files {
         "tar" {
             if { $tar_complete == 0 } {
                add_proc_error "check_packages_directory" -1 "tar files incomplete error"
                return ""
             }
             return $tar_list
         }
         "zip" {
             if { $tar_complete == 0 } {
                add_proc_error "check_packages_directory" -1 "zip files incomplete error"
                return ""
             }
             return $zip_list
         } 
      }
   }
   return -1
}
#
#                                                             max. column:     |
#
#****** check/compile_source() ******
#  NAME
#     compile_source() -- ??? 
#
#  SYNOPSIS
#     compile_source { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
#
proc compile_source { { do_only_install 0 } } {
   global ts_config ts_host_config
   global CHECK_SOURCE_DIR CHECK_OUTPUT CHECK_SOURCE_HOSTNAME
   global CHECK_TESTSUITE_ROOT CHECK_SCRIPT_FILE_DIR CHECK_PRODUCT_TYPE CHECK_PRODUCT_ROOT
   global CHECK_HTML_DIRECTORY
   global CHECK_DEFAULTS_FILE CHECK_SOURCE_CVS_RELEASE do_not_update check_name
   global CHECK_AIMK_COMPILE_OPTIONS CHECK_DIST_INSTALL_OPTIONS CHECK_JOB_OUTPUT_DIR
   global CHECK_CORE_EXECD CHECK_PROTOCOL_DIR CHECK_USER CHECK_HOST check_do_clean_compile

   # settings for mail
   set check_name "compile_source"
   set CHECK_CUR_PROC_NAME "compile_source"
   set mail_subject "testsuite error - compile_source"
   set mail_body    "date: [exec date]\n"

   # settings for html output
   set html_body [ create_html_text "date: [exec date]" 1 ]
   append html_body [ create_html_text "compiling ..." 1 ]
   update_compile_html_output $html_body
   set html_body [ create_html_text "date: [exec date]" 1 ]

   set was_error 0
   set cvs_change_log ""

   # if we configured to install precompiled packages - stop
   if { $ts_config(package_directory) != "none" && 
        ($ts_config(package_type) == "tar" || $ts_config(package_type) == "zip") } {
      puts $CHECK_OUTPUT "will not compile but use precompiled packages"
      puts $CHECK_OUTPUT "set package_directory to \"none\" or set package_type to \"create_tar\""
      puts $CHECK_OUTPUT "if compilation (and package creation) should be done"
      mail_report $mail_subject "$mail_body using precompiled packages" 
      append html_body [ create_html_text "using precompiled packages" ]
      update_compile_html_output $html_body
      return -1
   }

   # compile hosts required for master, exec, shadow, submit_only, bdb_server hosts
   set compile_hosts [compile_host_list]

   # add compile hosts for additional compile archs
   if {$ts_config(add_compile_archs) != "none"} {
      foreach arch $ts_config(add_compile_archs) {
         lappend compile_hosts [compile_search_compile_host $arch]
      }
   }

   # eliminate duplicates
   set compile_hosts [compile_unify_host_list $compile_hosts]

   # check source directory
   if { ( [ string compare $CHECK_SOURCE_DIR "unknown" ] == 0 ) || ( [ string compare $CHECK_SOURCE_DIR "" ] == 0 ) } {
      puts $CHECK_OUTPUT "source directory unknown - check defaults file"
      mail_report $mail_subject "$mail_body source directory unknown - check defaults file" 
      append html_body [ create_html_text "source directory unknown - check defaults file" ]
      update_compile_html_output $html_body
      return -1
   }

   # check compile host
   if { ( [ string compare $CHECK_SOURCE_HOSTNAME "unknown" ] == 0 ) || ( [ string compare $CHECK_SOURCE_HOSTNAME "" ] == 0  ) } {
      puts $CHECK_OUTPUT "host for cvs checkout unknown - check defaults file"
      mail_report $mail_subject "$mail_body host for cvs checkout unknown - check defaults file"
      append html_body [ create_html_text "host for cvs checkout unknown - check defaults file" ]
      update_compile_html_output $html_body
      return -1
   }

   # check compile hosts
   if { ( [ string compare $compile_hosts "unknown" ] == 0 ) || ([ string compare $compile_hosts "" ] == 0) } {
      puts $CHECK_OUTPUT "host list to compile for unknown - check defaults file"
      mail_report $mail_subject "$mail_body host list to compile for unknown - check defaults file"
      append html_body [ create_html_text "host list to compile for unknown - check defaults file" ]
      update_compile_html_output $html_body
      return -1
   }

   # figure out the compile archs
   set compile_arch_list ""
   foreach chost $compile_hosts {
      puts $CHECK_OUTPUT "\n-> checking architecture for host $chost ..."
      set output [ start_remote_prog $chost $CHECK_USER "cd" "$CHECK_SOURCE_DIR ; ./aimk -no-mk" prg_exit_state 60 0 "" 1 0 ]
      puts $CHECK_OUTPUT "return state: $prg_exit_state"
      if { $prg_exit_state != 0 } {
         puts $CHECK_OUTPUT "error starting \"aimk -no-mk\" on host $chost"
         append html_body [ create_html_text "error starting \"aimk -no-mk\" on host $chost" ]
         update_compile_html_output $html_body
         return -1
      }
      puts $CHECK_OUTPUT "host $chost will build [string trim $output] binaries"
      lappend compile_arch_list $output
   }

   # check if compile hosts are unique per arch
   foreach elem $compile_arch_list {
     set found 0
     set hostarch ""
     foreach host $compile_arch_list {
        if { [ string compare $host $elem ] == 0 }  {
           incr found 1
           set hostarch $host
        }
     }
     if { $found != 1 } {
        puts $CHECK_OUTPUT "two compile hosts have the same architecture -> error"
        append html_body [ create_html_text "two compile hosts have the same architecture -> error" ]
        update_compile_html_output $html_body
        return -1
     }
   }

   # create protocol directory
   if {[file isdirectory "$CHECK_PROTOCOL_DIR"] != 1} {
      set catch_return [ catch {  file mkdir "$CHECK_PROTOCOL_DIR" } ]
      if { $catch_return != 0 } {
           puts $CHECK_OUTPUT "could not create directory \"$CHECK_PROTOCOL_DIR\""
           append html_body [ create_html_text "could not create directory \"$CHECK_PROTOCOL_DIR\"" ]
           update_compile_html_output $html_body
           return -1
      } 
   }

   # shutdown possibly running system
   shutdown_core_system

   # update sources
   if { $do_only_install != 1 } {
      # update source 
      if { $do_not_update == 0 } {
         set tries 1

         set output ""
         set update_ok 0
         while { $tries <= 3 && $update_ok == 0 } {
            puts $CHECK_OUTPUT "------------------------------------------"
            puts $CHECK_OUTPUT "$tries. cvs update try ..."
            puts $CHECK_OUTPUT "updating gridengine directory $CHECK_SOURCE_DIR/.. on host $CHECK_SOURCE_HOSTNAME ..."
            append output [ start_remote_prog $CHECK_SOURCE_HOSTNAME $CHECK_USER "cd" "$CHECK_SOURCE_DIR/.. ; cvs -z 9 update -dP" ]
            append output "\n"
            if { $prg_exit_state != 0 } {
               set update_ok 0
               sleep 60
            } else {
               set update_ok 1
            }
            incr tries 1
         }
         if { $update_ok != 1 } {
            add_proc_error "compile_source" -2 "cvs update -dP error:\n$output" 
            append html_body [ create_html_text "cvs update -dP error:\n$output" ]
            update_compile_html_output $html_body
            return -1
         }

         puts $CHECK_OUTPUT "------------------------------------------"
         set cvs_output [ open "$CHECK_SOURCE_DIR/cvs_update.log.[timestamp]" "w" ]
         puts $cvs_output $output
         close $cvs_output
         set update_output [split $output "\n"] 
         set frame_work_script_update 0
         set testsuite_update 0
         foreach elem $update_output {
            if { ([string range $elem 0 2 ] != "cvs") && ([string range $elem 0 0] != "?") } {
               puts $CHECK_OUTPUT $elem
               append cvs_change_log "$elem\n"
               if { [ string first "testsuite/check.exp" $elem ] >= 0 && [string range $elem 0 0] != "M" } {
                  set frame_work_script_update 1
               }
               if { [ string first "testsuite/tcl_files" $elem ] >= 0 && [string range $elem 0 0] != "M" } {
                  set testsuite_update 1
               }
            } 
         }

         # if the testsuite itself has been update, require restart
         if { $frame_work_script_update == 1 } {
            puts $CHECK_OUTPUT "TESTSUITE FRAMEWORK SCRIPT was updated!!! Stop !!!"
            flush $CHECK_OUTPUT
            mail_report $mail_subject "$mail_body TESTSUITE FRAMEWORK SCRIPT was updated!!! Stop !!!" 
            append html_body [ create_html_text "TESTSUITE FRAMEWORK SCRIPT was updated!!! Stop !!!" ]
            exit 1 
         }
         if { $testsuite_update == 1 } {
            puts $CHECK_OUTPUT "testsuite source procedures were updated!!! resourcing it !!!"
         }
         puts $CHECK_OUTPUT "------------------------------------------"

         # after an update, do an aimk clean
         foreach chost $compile_hosts {
            puts $CHECK_OUTPUT "------------------------------------------"
            puts $CHECK_OUTPUT "-> starting aimk $CHECK_AIMK_COMPILE_OPTIONS clean on host $chost ..."
            set output [ start_remote_prog $chost $CHECK_USER "cd" "$CHECK_SOURCE_DIR ; ./aimk $CHECK_AIMK_COMPILE_OPTIONS clean" prg_exit_state 60 0 "" 1 0 ]
            puts $CHECK_OUTPUT "------------------------------------------"
            puts $CHECK_OUTPUT "return state: $prg_exit_state"
            puts $CHECK_OUTPUT "------------------------------------------"
            puts $CHECK_OUTPUT "output:\n$output"
            puts $CHECK_OUTPUT "------------------------------------------"
         }

         # after an update, delete macro messages file to have it updated
         set macro_messages_file [get_macro_messages_file_name]
         puts $CHECK_OUTPUT "deleting macro messages file after update!"
         puts $CHECK_OUTPUT "file: $macro_messages_file"
         if { [ file isfile $macro_messages_file] } {
            file delete $macro_messages_file
         }
         update_macro_messages_list
      }
   }

   if { $check_do_clean_compile == 1 } {
      foreach chost $compile_hosts {
         puts $CHECK_OUTPUT "------------------------------------------"
         puts $CHECK_OUTPUT "-> starting aimk $CHECK_AIMK_COMPILE_OPTIONS clean on host $chost ..."
         set output [ start_remote_prog $chost $CHECK_USER "cd" "$CHECK_SOURCE_DIR ; ./aimk $CHECK_AIMK_COMPILE_OPTIONS clean" prg_exit_state 60 0 "" 1 0 ]
         puts $CHECK_OUTPUT "------------------------------------------"
         puts $CHECK_OUTPUT "return state: $prg_exit_state"
         puts $CHECK_OUTPUT "------------------------------------------"
         puts $CHECK_OUTPUT "output:\n$output"
         puts $CHECK_OUTPUT "------------------------------------------"
      }
   }


   # choose a host for aimk depend, we prefer to do it on solaris 64bit
   if { $do_only_install != 1 } {
      set depend_host_name [lindex $compile_hosts 0] 

      foreach help_host $compile_hosts {
         if { [ string compare $ts_host_config($help_host,arch) "solaris64"] == 0 || 
              [ string compare $ts_host_config($help_host,arch) "sol-sparc64"] == 0 } {
            puts $CHECK_OUTPUT "using host $help_host to create dependencies"
            set depend_host_name $help_host
         }
      }

      # clean dependency files (zerodepend)
      puts $CHECK_OUTPUT "------------------------------------------"
      puts $CHECK_OUTPUT "-> starting scripts/zerodepend on host $depend_host_name ..."
      set output [ start_remote_prog $depend_host_name $CHECK_USER "cd" "$CHECK_SOURCE_DIR ; scripts/zerodepend" prg_exit_state 60 0 "" 1 0 ]
      puts $CHECK_OUTPUT "------------------------------------------"
      puts $CHECK_OUTPUT "return state: $prg_exit_state"
      puts $CHECK_OUTPUT "------------------------------------------"
      puts $CHECK_OUTPUT "output:\n$output"
      puts $CHECK_OUTPUT "------------------------------------------"

      puts $CHECK_OUTPUT "------------------------------------------"

      # build the depencency building program
      set my_compile_options $CHECK_AIMK_COMPILE_OPTIONS
      puts $CHECK_OUTPUT "-> starting aimk -only-depend on host $depend_host_name ..."
      set output [ start_remote_prog $depend_host_name $CHECK_USER "cd" "$CHECK_SOURCE_DIR ; ./aimk -only-depend" prg_exit_state 60 0 "" 1 0 ]
      puts $CHECK_OUTPUT "------------------------------------------"
      puts $CHECK_OUTPUT "return state: $prg_exit_state"
      puts $CHECK_OUTPUT "------------------------------------------"
      puts $CHECK_OUTPUT "output:\n$output"
      puts $CHECK_OUTPUT "------------------------------------------"
      if { $prg_exit_state != 0 } {
         mail_report $mail_subject "$mail_body aimk -only-depend on host $depend_host_name returned:\n$output"
         append html_body [ create_html_text "aimk -only-depend on host $depend_host_name returned:\n$output" ]
         update_compile_html_output $html_body

         return -1
      }

      # build the dependencies
      puts $CHECK_OUTPUT "------------------------------------------"
      puts $CHECK_OUTPUT "-> starting aimk $my_compile_options depend on host $depend_host_name ..."
      set output [ start_remote_prog $depend_host_name $CHECK_USER "cd" "$CHECK_SOURCE_DIR ; ./aimk $my_compile_options depend" prg_exit_state 60 0 "" 1 0 ]
      puts $CHECK_OUTPUT "------------------------------------------"
      puts $CHECK_OUTPUT "return state: $prg_exit_state"
      puts $CHECK_OUTPUT "------------------------------------------"
      puts $CHECK_OUTPUT "output:\n$output"
      puts $CHECK_OUTPUT "------------------------------------------"

      if { $prg_exit_state != 0 } {
         mail_report $mail_subject "$mail_body aimk $my_compile_options depend on host $depend_host_name returned:\n$output"
         append html_body [ create_html_text "aimk $my_compile_options depend on host $depend_host_name returned:\n$output" ]
         update_compile_html_output $html_body

         return -1
      }
   }

   # now start build on all compile hosts
   set host_list $compile_hosts
   if { $do_only_install != 1 } {
   
   set num 0
   set spawn_list {} 
   set remote_spawn_list {}
   set file_list {}
   set file_name_list {}
 
   set cvs_tag "maintrunk"
   if { [ file isfile "${CHECK_SOURCE_DIR}/CVS/Tag" ] } {
      set cvs_tag "no_tag_dir" 
      set tag_state [ catch { eval exec "cat ${CHECK_SOURCE_DIR}/CVS/Tag" } cvs_tag ]
   }

   set table_row 2
   foreach elem $host_list {
      # compile the staff
      puts $CHECK_OUTPUT "-> starting compiling on host $elem ..."

      set html_table($table_row,BGCOLOR) "#009900"
      set html_table($table_row,FNCOLOR) "#FFFFFF"
      set html_table($table_row,1) $elem
      set html_table($table_row,2) [resolve_arch $elem]

      set html_table($table_row,3) "ok"    ;# error is set later
      set html_table($table_row) "$elem"   ;# not neccessary for html table


      set prog "$CHECK_TESTSUITE_ROOT/$CHECK_SCRIPT_FILE_DIR/remotecompile.sh"
      set par1 "$CHECK_SOURCE_DIR"
      set par2 "$my_compile_options"
      
      puts $CHECK_OUTPUT "$prog $par1 '$par2'"
      set open_spawn [ open_remote_spawn_process $elem $CHECK_USER $prog "$par1 '$par2'" 0 "" 0 ] 

      lappend spawn_list [ lindex $open_spawn 1 ]
      lappend remote_spawn_list $open_spawn
      
      if { $CHECK_HTML_DIRECTORY != "" } {
         set myfilename "$CHECK_HTML_DIRECTORY/${elem}_compile_${cvs_tag}.out"
      } else {
         set myfilename "$CHECK_PROTOCOL_DIR/${elem}_compile_${cvs_tag}.out"
      }

      set html_table($table_row,4) [create_html_link "view" ${elem}_compile_${cvs_tag}.out]
  
      lappend file_name_list $myfilename
      catch { file delete $myfilename }
      lappend file_list [open $myfilename w]
      incr table_row 1    
      incr num 
   }  
   incr table_row -1
  
   append mail_body "\n\ncompile output saved in the files:"
   foreach elem $file_name_list {
      append mail_body "\n$elem"
#      eval exec "/usr/openwin/bin/xterm -sl 5000 -sb -j -e tail -f $elem &"
   }
   append mail_body "\n"
   
   
   }

   if { $do_only_install != 1 } {

   puts $CHECK_OUTPUT "now waiting for end of compile ..." 
   set timeout 300
   set done_count 0
   set compile_bad {}
   log_user 0

   set original_spawn_list $spawn_list  
   set show_info 1
   set output_buff ""
   while { [llength $spawn_list] > 0   } {
      if {[info exists spawn_id]} {
            unset spawn_id
      }
      if { $show_info == 1 } {
         clear_screen
         puts $CHECK_OUTPUT "============================================"
         puts $CHECK_OUTPUT "open compile connections: "
         foreach id $spawn_list {
            set host_nr 0
            set host_index 0
            foreach el $original_spawn_list {
               if { [string compare $el $id] == 0 } {
                    set host_index $host_nr
               }
               incr host_nr 1
            }
            puts -nonewline $CHECK_OUTPUT "[lindex $host_list $host_index] "
         }
         puts $CHECK_OUTPUT "\n============================================"
         puts $CHECK_OUTPUT $output_buff
         set show_info 1
      }

      expect {
         -i $spawn_list full_buffer {
         }
         -i $spawn_list timeout {
              set spawn_id [lindex $spawn_list 0]   ;# declare first connection as fault
              set host_index 0
              set host_nr 0
              foreach el $original_spawn_list {
                 if { [string compare $el $spawn_id] == 0 } {
                    set host_index $host_nr
                 }
                 incr host_nr 1
              }
              lappend compile_bad [lindex $host_list $host_index]
              puts $CHECK_OUTPUT "got timeout for host \"[lindex $host_list $host_index]\""
              foreach spawn_object $remote_spawn_list {
                 if { [ lindex $spawn_object 1 ] == $spawn_id } {
                    puts $CHECK_OUTPUT "found spawn object: $spawn_object"
                    close_spawn_process $spawn_object
                 }
              }
              set index [lsearch -exact $spawn_list $spawn_id]
              set spawn_list [lreplace $spawn_list $index $index]
              set show_info 1
         }
         -i $spawn_list eof {
              set spawn_id $expect_out(spawn_id)
              set host_index 0
              set host_nr 0
              foreach el $original_spawn_list {
                 if { [string compare $el $spawn_id] == 0 } {
                    set host_index $host_nr
                 }
                 incr host_nr 1
              }
              lappend compile_bad [lindex $host_list $host_index]
              puts $CHECK_OUTPUT $expect_out(0,string)
              foreach spawn_object $remote_spawn_list {
                 if { [ lindex $spawn_object 1 ] == $spawn_id } {
                    puts $CHECK_OUTPUT "found spawn object: $spawn_object"
                    close_spawn_process $spawn_object
                 }
              }

              set index [lsearch -exact $spawn_list $spawn_id]
              set spawn_list [lreplace $spawn_list $index $index]
              set show_info 1

         }
         -i $spawn_list "remotecompile * aimk compile error" {
              set spawn_id $expect_out(spawn_id)
              set host_index 0
              set host_nr 0
              foreach el $original_spawn_list {
                 if { [string compare $el $spawn_id] == 0 } {
                    set host_index $host_nr
                 }
                 incr host_nr 1
              }
              lappend compile_bad [lindex $host_list $host_index]
              puts $CHECK_OUTPUT $expect_out(0,string)
              foreach spawn_object $remote_spawn_list {
                 if { [ lindex $spawn_object 1 ] == $spawn_id } {
                    puts $CHECK_OUTPUT "found spawn object: $spawn_object"
                    close_spawn_process $spawn_object
                 }
              }

              set index [lsearch -exact $spawn_list $spawn_id]
              set spawn_list [lreplace $spawn_list $index $index]
              set show_info 1

         }
         -i $spawn_list "remotecompile * aimk no errors" {
              set spawn_id $expect_out(spawn_id)
              puts $CHECK_OUTPUT $expect_out(0,string)
              foreach spawn_object $remote_spawn_list {
                 if { [ lindex $spawn_object 1 ] == $spawn_id } {
                    puts $CHECK_OUTPUT "found spawn object: $spawn_object"
                    close_spawn_process $spawn_object
                 }
              }

              set index [lsearch -exact $spawn_list $spawn_id]
              set spawn_list [lreplace $spawn_list $index $index]
              set show_info 1
         }
         -i $spawn_list "*\n" {
              set spawn_id $expect_out(spawn_id)
              set index 0
              set nr 0
              foreach elem $original_spawn_list {
                 if { [string compare $elem $spawn_id] == 0 } {
                    set index $nr
                 }
                 incr nr 1
              }
              puts [lindex $file_list $index] "$expect_out(0,string)"
              flush [lindex $file_list $index]
              set output_buff ""
              append output_buff "\n[lindex $host_list $index]:\n"
              append output_buff "$expect_out(0,string)"
         }
      }
   }
   log_user 1
   foreach elem $file_list {
      flush $elem
      close $elem
   } 

   set compile_error 0
   foreach elem $compile_bad {
      set compile_error 1

      for { set html_c 2 } { $html_c <= $table_row }  { incr html_c 1 } {
          if { [ string compare $html_table($html_c) $elem ] == 0 } {
             set html_table($html_c,BGCOLOR) "#CC0000"
             set html_table($html_c,FNCOLOR) "#FFFFFF"
             set html_table($html_c,3) "compile error"
          }
      }


      puts $CHECK_OUTPUT "\n=============\ncompile error on host $elem:\n=============\n"
      append mail_body "\n=============\ncompile error on host $elem:\n=============\n"
      foreach file $file_name_list {
         if { [string first $elem $file] >= 0 } {
             catch { eval exec "touch $file"  }
             set fp [open $file r]
             while { [gets $fp line] >= 0 } {
                append mail_body "\n$line"
                puts $CHECK_OUTPUT $line
             }
             close $fp
         } 
      }
   }

   set html_table(1,BGCOLOR) "#3366FF"
   set html_table(1,FNCOLOR) "#66FFFF"

   set html_table(COLS) 4
   set html_table(1,1) "Host"
   set html_table(1,2) "Arch"
   set html_table(1,3) "State"
   set html_table(1,4) "Compile output"

   set html_table(ROWS) $table_row

   
   if { $compile_error != 0 } {
      mail_report $mail_subject $mail_body
      append html_body [ create_html_table html_table ]
      update_compile_html_output $html_body
      return -1
   } 

   }

   # install to $CHECK_PRODUCT_ROOT
   set var_name "SGE_ROOT"
   if { $ts_config(gridengine_version) == 53 } {
      if {[string compare $CHECK_PRODUCT_TYPE "sgeee"] == 0 } {
         set link_name "myinst"
         set sgeee_param "-sgeee"
      } else {
         set link_name "myinst"
         set sgeee_param ""
      }
   } 
   puts $CHECK_OUTPUT "\nusing environment variable \"$var_name\""

   # copy pos. host_aliases file to trash_
   if { [ file isfile "$CHECK_PRODUCT_ROOT/$ts_config(cell)/common/host_aliases"] == 1 } {
      puts $CHECK_OUTPUT "saving host_aliases file ..."
      catch { exec "cp" "$CHECK_PRODUCT_ROOT/$ts_config(cell)/common/host_aliases" "$CHECK_JOB_OUTPUT_DIR/host_aliases"  } result
      puts $result
   } 

   # now delete install directory
   puts $CHECK_OUTPUT "moving directory \"$CHECK_PRODUCT_ROOT\" to testsuite_trash"
   if { [delete_directory "$CHECK_PRODUCT_ROOT"] != 0 } {
      add_proc_error "compile_source" -2 "could not delete $CHECK_PRODUCT_ROOT directory, critical error - stop"
      return -1
   }
 
   # wait for nfs updates
   after 5000

   catch { exec "mkdir" "$CHECK_PRODUCT_ROOT"  } result
   puts $result
   catch { exec "touch" "$CHECK_PRODUCT_ROOT"  } result
   puts $result
   catch { exec "chmod" "755" "$CHECK_PRODUCT_ROOT"  } result
   puts $result
 
   if { $ts_config(gridengine_version) == 53 } {
      puts $CHECK_OUTPUT "\ncreating link \"$link_name\""
      set return_state [ catch { eval exec ln -s $CHECK_SOURCE_DIR/scripts/distinst $CHECK_SOURCE_DIR/$link_name } output ]
   }

   set arch_list {}
   set compiled_mail_architectures ""
   puts -nonewline $CHECK_OUTPUT "\narchitectures: "
   foreach elem $host_list {
      set output [resolve_arch $elem]
      lappend arch_list $output 
      puts -nonewline $CHECK_OUTPUT "$output "
      append compiled_mail_architectures "\n$elem ($output)"
   }
 
   puts $CHECK_OUTPUT "\ninstalling product binaries"
   if { $ts_config(gridengine_version) == 53 } {
      set open_spawn [ open_remote_spawn_process $CHECK_HOST $CHECK_USER "cd" "$CHECK_SOURCE_DIR ; $var_name=$CHECK_PRODUCT_ROOT ; export $var_name ; ./$link_name $sgeee_param $CHECK_DIST_INSTALL_OPTIONS $arch_list" ]
   } else {
      set open_spawn [ open_remote_spawn_process $CHECK_HOST $CHECK_USER "cd" "$CHECK_SOURCE_DIR ; $var_name=$CHECK_PRODUCT_ROOT ; export $var_name ; ./scripts/distinst -local -noexit $CHECK_DIST_INSTALL_OPTIONS $arch_list" ]
   }
   set sp_id [ lindex $open_spawn 1 ]
   set timeout -1
   set done 0
   while { $done != 1 } {
      expect_user {
         -i $sp_id full_buffer {
            puts $CHECK_OUTPUT "testsuite - compile_source buffer overflow please increment CHECK_EXPECT_MATCH_MAX_BUFFER value"
         }
         -i $sp_id "Base directory:" {
             send -i $sp_id "y\n"
         }
         -i $sp_id "overriding mode" {
             send -i $sp_id "y\n"
         }
         -i $sp_id "_exit_status_" {
            set done 1
         }
         -i $sp_id eof {
            set done 1
         }
         -i $sp_id "*\n" {
            puts $CHECK_OUTPUT $expect_out(0,string)
         }
      }
   }
   close_spawn_process $open_spawn
   puts $CHECK_OUTPUT ""

   foreach elem $CHECK_CORE_EXECD {
      set host_arch [ resolve_arch $elem ]
      if { ([string compare $host_arch ""] != 0) && ([string compare $host_arch "unknown" ] != 0) } {
         puts $CHECK_OUTPUT " arch on host $elem is $host_arch - successfully installed binaries"
      } else {
         puts $CHECK_OUTPUT " error installing binaries for host $elem"
         set found 0
         for { set html_c 2 } { $html_c <= $table_row }  { incr html_c 1 } {
            if { [ string compare $html_table($html_c) $elem ] == 0 } {
               set html_table($html_c,BGCOLOR) "#CC0000"
               set html_table($html_c,FNCOLOR) "#FFFFFF"
               set html_table($html_c,3) "error installing binaries"
               set found 1
               break
            }
         }
         if {$found != 1} {
            append html_body [ create_html_text "ERROR installing binaries for host $elem !!!" ]
         }
         set was_error 1
      }
   }
   if { $do_only_install != 1 } {
      append html_body [ create_html_table html_table ]
   }
 
   catch { file mkdir "$CHECK_PRODUCT_ROOT/man" } 
   catch { file mkdir "$CHECK_PRODUCT_ROOT/catman" } 
   catch { file mkdir "$CHECK_PRODUCT_ROOT/$ts_config(cell)" } 
   catch { file mkdir "$CHECK_PRODUCT_ROOT/$ts_config(cell)/common" } 

  
   # copy pos. host_aliases file to new product root /$SGE_CELL/common
   if { [ file isfile "$CHECK_JOB_OUTPUT_DIR/host_aliases"] == 1 } {
        puts $CHECK_OUTPUT "restoring host_aliases file ..."
        catch { exec "cp" "$CHECK_JOB_OUTPUT_DIR/host_aliases" "$CHECK_PRODUCT_ROOT/$ts_config(cell)/common/host_aliases" } result
        puts $result
   }


   if { $was_error != 0 } {
      mail_report $mail_subject "$mail_body - compile error(s)"
      update_compile_html_output $html_body
      return -1
   }
   
   append mail_body "\nSuccessfully compiled and pre-installed following architectures:"
   append mail_body "\n${compiled_mail_architectures}\n"
   
   append mail_body "\ninit_core_system check will install the $CHECK_PRODUCT_TYPE execd at:"
   foreach elem $CHECK_CORE_EXECD {
      set host_arch [ resolve_arch $elem ]
      append mail_body "\n$elem ($host_arch)"
   }
   if { [string compare $cvs_change_log "" ] != 0 } {
      set mail_body "$mail_body \n\n Update output:\n$cvs_change_log\n\n"
   }
   set mail_subject "testsuite success - compile"
   mail_report $mail_subject $mail_body

   update_compile_html_output $html_body

   # try to resolve hostnames in settings file
   set catch_return [ catch { eval exec "cp ${CHECK_DEFAULTS_FILE} ${CHECK_DEFAULTS_FILE}.[timestamp]" } ]
   if { $catch_return != 0 } { 
        puts "could not copy defaults file"
        return -1
   }

   # if required, build distribution
   if { $ts_config(package_type) == "create_tar" &&
        $ts_config(package_directory) != "none" } {
      puts $CHECK_OUTPUT "creating tar packages"  
      # distribution will be created using mk_dist
      # figure out which commandline options to use
      set args ""
      append args "-vdir $ts_config(product_root)"             ;# find the distrib here
      append args " -version $ts_config(source_cvs_release)"   ;# for package names
      append args " -basedir $ts_config(package_directory)"    ;# destination dir
      append args " -bin -common"                              ;# which packages

      if { $ts_config(gridengine_version) == 53 } {
         if { $ts_config(product_type) == "sgeee" } {
            append args " -sgeee"
         }
      }

      if { ! [file isdirectory $ts_config(package_directory)] } {
         file mkdir $ts_config(package_directory)
      }

      puts $CHECK_OUTPUT "starting mk_dist $args $arch_list"
      # start mk_dist
      set open_spawn [ open_remote_spawn_process $CHECK_HOST $CHECK_USER "cd" "$CHECK_SOURCE_DIR ; ./scripts/mk_dist $args $arch_list" ]
      set sp_id [ lindex $open_spawn 1 ]
      set timeout -1
      set done 0
      while { $done != 1 } {
         expect_user {
            -i $sp_id full_buffer {
               puts $CHECK_OUTPUT "testsuite - compile_source buffer overflow please increment CHECK_EXPECT_MATCH_MAX_BUFFER value"
            }
            -i $sp_id "_exit_status_" {
               set done 1
            }
            -i $sp_id eof {
               set done 1
            }
            -i $sp_id "*\n" {
               puts $CHECK_OUTPUT $expect_out(0,string)
            }
         }
      }
      close_spawn_process $open_spawn
      puts $CHECK_OUTPUT ""
   }
   
   return 0
}

#                                                             max. column:     |
#****** check/run_all_at_starttime() ******
# 
#  NAME
#     run_all_at_starttime -- ??? 
#
#  SYNOPSIS
#     run_all_at_starttime { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc run_all_at_starttime {} {

   global CHECK_ACT_PATH CHECK_REPORT_FILE CHECK_CHECKTREE_ROOT

   set start_time 0
   set should_we_compile 0

   print_menu_header
   if { [ ask_user_yes_or_no " Do you want to enter a special starttime (y/N) ? " ] } {
      puts "\n now it is: [exec date "+%D %H:%M" ]"
      set start_time [ get_user_input "    Please enter start time : " ]
      puts "\n testsuite will start at \"$start_time\""
   } else {
      
      puts "\n testsuite will run continuously"
   }

   if { [ ask_user_yes_or_no "\n\n Should the testsuite update, compile and install before testing (y/N) ? " ] } {
      set should_we_compile 1
      puts "\n testsuite will update, compile and install the latest source code"
   } else {
      puts "\n testsuite will use the current installation"
   }

   if { [ ask_user_yes_or_no "\n\n Are this settings correct (y/N) ? " ] == 0 } {
      puts "\n testsuite will return to the main menue, please"
      return
   }

   set_root_passwd
 

   if { $start_time != 0 } {
      wait_for_start_time $start_time
   }
   delete_tests $CHECK_ACT_PATH
   if { $should_we_compile == 1 } {
#     remove_old_cvs_tree
      set back [ compile_source ]
      if { $back != 0 } {
         puts "error in compile_source - stop"
         exit -1
      }
      set saved_path $CHECK_ACT_PATH
      set CHECK_ACT_PATH "$CHECK_CHECKTREE_ROOT/install_core_system"
      set back [ run_test $CHECK_ACT_PATH 1 ]
      if { $back != 0 } {
         puts "error in test install_core_system - stop"
         exit -1
      }
      set CHECK_ACT_PATH $saved_path
   }
   run_tests $CHECK_ACT_PATH 0
   create_report ${CHECK_REPORT_FILE}.ok 0
   create_report ${CHECK_REPORT_FILE}.failed 1

   wait_for_enter
}

#****** check/do_wait() ********************************************************
#  NAME
#     do_wait() -- wait for x seconds (and print .)
#
#  SYNOPSIS
#     do_wait { time } 
#
#  INPUTS
#     time - time in seconds
#
#*******************************************************************************
proc do_wait { time } {

   set timestart [ timestamp ]
   while { 1 } {
       if { [ expr ( [ timestamp  ] - $timestart ) ] >= $time } {
         puts ""
         return
       }
       puts -nonewline "."
       flush stdout
       sleep 1
   }
}

#                                                             max. column:     |
#****** check/get_user_input() ******
# 
#  NAME
#     get_user_input -- ??? 
#
#  SYNOPSIS
#     get_user_input { what } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#     what - ??? 
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc get_user_input { what } {
   puts -nonewline $what
   flush stdout 
   set myinput [wait_for_enter 1]
   return $myinput
}


#****** check/restart_debug_daemons() ******************************************
#  NAME
#     restart_debug_daemons() -- used for menu point 20/21
#
#  SYNOPSIS
#     restart_debug_daemons { { shutdown 0 } } 
#
#  FUNCTION
#     This procedure will shutdown and restart the qmaster and scheduler
#
#  INPUTS
#     { shutdown 0 } - 0 -> do shutdown (otherwise only do starup)
#
#*******************************************************************************
proc restart_debug_daemons { { shutdown 0 } } {
   global daemon_debug master_debug schedd_debug
   global CHECK_CORE_MASTER

   if { [ have_root_passwd ] != 0 } {
      set_root_passwd
   }
   if { $shutdown == 0 } {
      get_config config_tmp
      if { [info exists config_tmp(qmaster_spool_dir) ] != 1 } { 
         return 
      }
      shutdown_master_and_scheduler $CHECK_CORE_MASTER $config_tmp(qmaster_spool_dir) 
   }
   startup_qmaster 
   wait_for_load_from_all_queues 300 
}

proc got_command {  } {

  fconfigure stdin -blocking FALSE
  set data [wait_for_enter 1]
  if { [string length $data] > 0 } {
     return $data
  }  
  fconfigure stdin -blocking TRUE

  return 0
}

#                                                             max. column:     |
#****** check/ask_user_yes_or_no() ******
# 
#  NAME
#     ask_user_yes_or_no -- ??? 
#
#  SYNOPSIS
#     ask_user_yes_or_no { question } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#     question - ??? 
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc ask_user_yes_or_no { question } {
  
   puts -nonewline $question
   flush stdout 
   set myinput [wait_for_enter 1]

   if { [ string compare -nocase $myinput "yes" ] == 0 } {
       return 1
   }
   if { [ string compare -nocase $myinput "y" ] == 0 } {
       return 1
   }
   return 0
}

# select action
#                                                             max. column:     |
#****** check/menu() ******
# 
#  NAME
#     menu -- ??? 
#
#  SYNOPSIS
#     menu { } 
#
#  FUNCTION
#     ??? 
#
#  INPUTS
#
#  RESULT
#     ??? 
#
#  EXAMPLE
#     ??? 
#
#  NOTES
#     ??? 
#
#  BUGS
#     ??? 
#
#  SEE ALSO
#     ???/???
#*******************************
proc menu {} {
   global ts_config
  global CHECK_ACT_PATH CHECK_DIRECTORIES CHECK_INFORMATION_FILE CHECK_INFORMATION_EXT CHECK_RESULT_DIR 
  global CHECK_USER CHECK_REPORT_FILE CHECK_OUTPUT CHECK_HOST CHECK_BAD_RESULT_DIR 
  global CHECK_CORE_RESULT_DIR CHECK_CORE_BAD_RESULT_DIR CHECK_MAIN_RESULTS_DIR 
  global CHECK_ENABLED_RUNLEVELS CHECK_MAX_LEVEL CHECK_PRODUCT_VERSION_NUMBER CHECK_SETUP_NAMES
  global daemon_debug CHECK_DEBUG_LEVEL CHECK_DEFAULTS_FILE CHECK_DO_SETUP
  global CHECK_PACKAGE_DIRECTORY CHECK_SETUP_CHANGES CHECK_PACKAGE_TYPE
  global check_reinit_on_tcl_error

  delete_temp_script_files

  source_tcl_files

  set files [  print_menu_header ]
 
  puts "  (0) select runlevels/categories"
  puts "  (1) change dir"
  puts "  (2) run not completed tests (including subdirectories)"
  puts "  (3) show test descriptions"
  puts "  (4) exit (press ^C to exit without shutdown of the cluster)"
  puts "  (5) show completed test list"
  puts "  (6) show not completed test list"
  puts "  (7) reset completed test list (for all subdirectories)"
  puts "  (8) create check report"
  puts "  (9) run all tests at a special starttime"
  if { [ string compare "stdout" $CHECK_OUTPUT ] == 0 } {
     puts " (10) use file \"${CHECK_HOST}.checklog\" for output" 
  } else {
     puts " (10) use \"stdout\" for output"
  }
   set dep_name "$CHECK_INFORMATION_FILE.$ts_config(gridengine_version).$CHECK_INFORMATION_EXT"
   set indep_name "$CHECK_INFORMATION_FILE.$CHECK_INFORMATION_EXT"
   set localtest [lsearch $files $dep_name]
   if { $localtest < 0 } {
      set localtest [lsearch $files $indep_name]
   }

  if { $localtest >= 0 } {
    puts " (11) show test descriptions of local test"
    puts " (12) run local test"
    puts " (13) run local test continously"
  }
    puts "===============================================================================" 
    puts " (20) shutdown and restart master and scheduler"
    puts " (21) only start master and scheduler daemons"
    puts " (22) check messages files of execds and qmaster"
    if { $CHECK_PACKAGE_DIRECTORY == "none" } {
       puts " (23) compile source code and pre install binaries"
    } else {
       puts " (23) install product packages"
    }
    puts " (24) do (23), then (2)"
    puts " (25) set testsuite debug level (current value: $CHECK_DEBUG_LEVEL)"
    puts " (26) enter testsuite setup" 
    puts " (27) set command line options"
    puts " (28) restart cluster"
    puts " (29) check spool directory content"

  puts -nonewline "\nEnter number or subdirectory name:\n> "

  set input [wait_for_enter 1]; 

  clear_screen

  switch -- $input {
    "20" { restart_debug_daemons } 
    "21" { restart_debug_daemons 1 }
    "22" { set output [check_messages_files]
           puts $CHECK_OUTPUT $output
           wait_for_enter
         }
    "23" { 
            if { [have_root_passwd] == -1 } {
                  puts $CHECK_OUTPUT "need root access ..."
                  set_root_passwd
            }

            if { $ts_config(package_directory) == "none" ||
                 $ts_config(package_type) == "create_tar" } {
               # we compile the source and do a scripts/distinst
                set back [compile_source]
                if { $back != 0 } {
                   puts "--> error compiling and pre installing source code"
                } else {
                   puts "--> source code compiled and pre installed"
                }
                wait_for_enter
            } else {
               # we have product packages
                set back [prepare_packages]
                if { $back != 0 } {
                   puts "--> error installing product packages"
                } else {
                   puts "--> product packages pre installed"
                }
                wait_for_enter
            }
         }
    "24" {
          if { [have_root_passwd] == -1 } {
                puts $CHECK_OUTPUT "need root access ..."
                set_root_passwd
           }
           set back [compile_source]
           if { $back != 0 } {
              puts "--> error compiling and pre installing source code"
              wait_for_enter
           } else {
              puts "--> source code compiled and pre installed"
              run_tests $CHECK_ACT_PATH 0
              wait_for_enter
           }
         }
    "25" {  incr CHECK_DEBUG_LEVEL 1 
            if  { $CHECK_DEBUG_LEVEL > 2 } {
                set CHECK_DEBUG_LEVEL 0
            } 
         }
    "26" {  
            modify_setup2
            wait_for_enter
         }
    "27" {
         set_command_line_options
    }
    "28" {
         startup_core_system
    }
    "29" {
         check_local_spool_directories 1
         wait_for_enter
    }
    "0" { select_runlevel }
    "1" { change_dir; }
    "2" { set saved_check_reinit_on_tcl_error $check_reinit_on_tcl_error 
          set check_reinit_on_tcl_error 1
          run_tests $CHECK_ACT_PATH 0
          set check_reinit_on_tcl_error $saved_check_reinit_on_tcl_error
          wait_for_enter
        }
    "3" { show_tests $CHECK_ACT_PATH 1
        }
    "4" { puts "bye!\n"; 
          shutdown_core_system;
          if { [string compare "stdout" $CHECK_OUTPUT ] != 0 } {
             close $CHECK_OUTPUT
          } 
          exit 0; 
        }
    "5" { set total1 [print_results $CHECK_CORE_RESULT_DIR stdout]
          set total2 [print_results $CHECK_RESULT_DIR stdout]
          puts stdout "Total number of test functions: [expr ($total1 + $total2) ]"
          wait_for_enter
        }
    "6" { print_results $CHECK_CORE_BAD_RESULT_DIR stdout
          print_results $CHECK_BAD_RESULT_DIR stdout
          wait_for_enter
        }
    "7" { delete_tests $CHECK_ACT_PATH
          wait_for_enter
        }
    "8" { 
          if {[ file isfile "${CHECK_REPORT_FILE}.ok" ] == 1 } {
             delete_file "${CHECK_REPORT_FILE}.ok"
          }
          if {[ file isfile "${CHECK_REPORT_FILE}.failed" ] == 1 } {
             delete_file "${CHECK_REPORT_FILE}.failed"
          }
          create_report "${CHECK_REPORT_FILE}.ok" 0
          create_report "${CHECK_REPORT_FILE}.failed"  1
          wait_for_enter
        }
    "9" {
          run_all_at_starttime
          wait_for_enter
        }
    "10" {
           if { [ string compare "stdout" $CHECK_OUTPUT ] == 0 } {
              set CHECK_OUTPUT [open "$CHECK_MAIN_RESULTS_DIR/$CHECK_HOST.checklog" "w"]  
           } else {
              close $CHECK_OUTPUT
              set CHECK_OUTPUT stdout
           }
           

         }
    "11" {
          if {$localtest >= 0} {
            puts "local test description ..."
            show_test $CHECK_ACT_PATH 1
            wait_for_enter
          }
        }
    "12" {
          if {$localtest >= 0} {
            puts "running local test ..."
            run_test $CHECK_ACT_PATH 1
            wait_for_enter
          }
         }
    "13" {
            if {$localtest >= 0} {
               while { 1 == 1 } {
                  puts "running local test ..."
                  run_test $CHECK_ACT_PATH 1
                  create_report ${CHECK_REPORT_FILE}.ok 0
                  create_report ${CHECK_REPORT_FILE}.failed 1
               } 
            }
         }
     default {
        if { $input != "" } {
           change_dir $input
        }
     }
   }
  menu
}

proc update_compile_html_output { content } {
   global CHECK_HTML_DIRECTORY CHECK_OUTPUT
   if { $CHECK_HTML_DIRECTORY != "" } { 
      puts $CHECK_OUTPUT "-> UPDATING HTML FILES IN DIRECTORY: \"$CHECK_HTML_DIRECTORY\""
      puts $CHECK_OUTPUT "-> UPDATING file index.html"
      generate_html_file $CHECK_HTML_DIRECTORY/index.html "Nightly Build Compile Results" $content
   }
}

proc get_shared_lib_path { host name path } {

   global CHECK_PRODUCT_ROOT
   upvar $name var_name
   upvar $path var_value

   set host_arch [resolve_arch $host ]
   set var_name [get_shared_lib_path_variable_name $host_arch]
   if { [info exists CHECK_PRODUCT_ROOT ] } {
      set var_value $CHECK_PRODUCT_ROOT/lib/$host_arch
   } else {
      set var_value ""
   }
}


proc get_shared_lib_path_variable_name { arch } {
   set name ""
   switch -exact $arch {
      aix41 -
      aix42 -
      aix43 {
         set name LIBPATH
      }
      hp10 -
      hp11 {
         set name SHLIB_PATH
      }
      default {
         set name LD_LIBRARY_PATH
      }
   }
   return $name
}

proc setup_shared_lib_path {} {
   global env CHECK_PRODUCT_ROOT CHECK_ARCH CHECK_OUTPUT
   global be_quiet

   set name [get_shared_lib_path_variable_name $CHECK_ARCH]
   if { [info exists env($name)] } {
      set env($name) "$env($name):$CHECK_PRODUCT_ROOT/lib/$CHECK_ARCH"
   } else {
      set env($name) "$CHECK_PRODUCT_ROOT/lib/$CHECK_ARCH"
   }
   if { $be_quiet == 0 } { 
      puts $CHECK_OUTPUT "   set environment variable $name to $env($name)"
   }
}

proc source_tcl_files {} {
   global ts_config

   if [info exists ts_config] {
      set libdir "$ts_config(testsuite_root_dir)/tcl_files"
   } else {
      set libdir "tcl_files"
   }

   # these files have to be version independent
   source $libdir/version.tcl
   source $libdir/config.tcl

   # now we have a ts_config (before reading config file with "" as version)
   # and can use the ts_source command
   # all the following library files may be version dependent
   ts_source $libdir/config_user
   ts_source $libdir/config_host

   ts_source $libdir/compile
   ts_source $libdir/file_procedures
   ts_source $libdir/gettext_procedures
   ts_source $libdir/remote_procedures
   ts_source $libdir/control_procedures
   ts_source $libdir/parser
   ts_source $libdir/sge_config
   ts_source $libdir/sge_procedures
   ts_source $libdir/sge_job
   ts_source $libdir/sge_queue
   ts_source $libdir/sge_project
   ts_source $libdir/sge_sched_conf

   # source a user private tcl file, e.g. to contain a 
   # inhouse_cluster_post_install function
   ts_source $libdir/private
}

# Main programm:

set do_kill           0
set do_install        0
set do_compile        0
set do_not_update     0
set do_all            0
set do_one_test       0
set do_category       0
set do_nomain         0
set do_prog_start     0
set do_only_reset_config 0
set be_quiet          0
set CHECK_CUR_PROC_NAME "main"
set check_name "main"
set CHECK_ACTUAL_TEST_PATH "not in testmode"
set mail_subject "testsuite error - main"
set mail_body    "date: [exec date]\n:\n"

for { set i 0 } { $i < $argc } { incr i } {
   
   if {([string compare [lindex $argv $i] "--setup"] == 0) || ([string compare [lindex $argv $i] "setup"] == 0) } {
      set catch_return [ catch { eval exec "cp ${CHECK_DEFAULTS_FILE} ${CHECK_DEFAULTS_FILE}.[timestamp]" } ]
      if { $catch_return == 0 } { 
        set CHECK_DO_SETUP 1 
      } else {
        puts "could not copy defaults file"
      }
      continue
   }
   
   if {([string compare [lindex $argv $i] "--quiet"] == 0) || ([string compare [lindex $argv $i] "quiet"] == 0) } {
      set be_quiet 1
      continue
   }
   if {([string compare [lindex $argv $i] "--close_rlogin"] == 0) || ([string compare [lindex $argv $i] "close_rlogin"] == 0) } {
      set do_close_rlogin 1
      continue
   }
   

   if {([string compare [lindex $argv $i] "--help"] == 0) || ([string compare [lindex $argv $i] "help"] == 0) } {
      puts "usage: expect check.exp \[options\]"
      puts "\noptions are:"
      puts "help                  show this"
      puts ""
      puts "setup_help            show setup informations"
      puts ""
      puts "install               just install core system and exit"
      puts ""
      puts "kill                  shutdown cluster"
      puts ""
      puts "setup                 run setup"
      puts ""
      puts "file FILE             use FILE as defaults file"
      puts ""
      puts "re_init               use allready installed system (will only shutdown/reconfigure the cluster!)"
      puts "                      when test install_core_system is called or install option is set"
      puts ""
      puts "re_init_on_tcl_error  reinitialize cluster when tcl error occurs"
      puts ""
      puts "compile               checkout source code and recompile"
      puts ""
      puts "no_update             do not update source when compile option is used"
      puts ""
      puts "all RUNLEVEL          run every test automatically up to runlevel RUNLEVEL"
      puts "                      (RUNLEVEL is a value from 0=short tests, up to 4=week tests)"
      puts ""
      puts "check PATH RUNLEVEL   run test in checktree sub-path automatically up to runlevel"
      puts "                      RUNLEVEL. PATH is as check sub-path, relative to checktree."
      puts "                      (RUNLEVEL is a value from 0=short tests, up to 4=week tests)"
      puts ""
      puts "execute_func ARGS     just run this procedure with given arguments"
      puts "                      (all arguments after this keyword are used as function call)"
      puts "                      e.g.: .. no_update execute_func compare_dump_data_file arg1 arg2"
      puts ""
      puts "category CAT_LIST     set users category list (COMPATIBILITY SYSTEM \[...\])"
      puts "                      (CAT_LIST must be 1 single parameter, must be quoted"
      puts "                       when using more than one category)"
      puts "" 
      puts "no_main               don't run main part (usefull for sourceing this file)"
      puts ""
      puts "no_main2              don't run main part and don't do setup"
      puts "                      (usefull for sourceing this file)"
      puts ""
      puts "reset_conf            reset test cluster"
      puts ""
      puts "debug LEVEL           run testsuite in debuglevel 0,1 or 2"
      puts "                      0=no debug, 1=more output, 2=1+user response"
      puts ""
      puts "quiet                 no output on setup"
      puts ""
      puts "no_local_spool        ignore local spool directories from host configuration file"
      puts ""
      puts "compile_clean         force aimk clean when no_update option is set at compile time"
      puts ""
      puts "mfile FILE            write all mails into file FILE (when mail is enabled)"
      puts ""
      puts "html_dir              write testsuite html files into that directory"
      puts ""
      puts "close_rlogin          don't let rlogin connections open for next command (per default the testsuite"
      puts "                      not close a rlogin connection. The testsuite will reuse the open connection"
      puts "                      for a later remote command. Use close_rlogin if the number of open file "
      puts "                      descriptors is low on your system)"
      puts ""
      puts "master_debug          procedure startup_qmaster will startup qmaster"
      puts "                      in debug mode (using x host from DISPLAY,"
      puts "                      please enable xhost display for all users)"
      puts ""
      puts "schedd_debug          procedure startup_qmaster will startup schedduler"
      puts "                      in debug mode (using x host from DISPLAY,"
      puts "                      please enable xhost display for all users)"
      puts ""
      puts "display DISPLAY       set display for daemon debug windows"

      exit 1
   }

   if {([string compare [lindex $argv $i] "--setup_help"] == 0) || ([string compare [lindex $argv $i] "setup_help"] == 0) } {
      show_setup_information
      exit 1
   }
   
   if { ( [string compare [lindex $argv $i] "--no_local_spool"] == 0 ) || ([string compare [lindex $argv $i] "no_local_spool"] == 0) } {
      set check_do_not_use_spool_config_entries 1
      continue
   }

   if { ( [string compare [lindex $argv $i] "--compile_clean"] == 0 ) || ([string compare [lindex $argv $i] "compile_clean"] == 0) } {
      set check_do_clean_compile 1
      continue
   }

   if { ( [string compare [lindex $argv $i] "--re_init"] == 0 ) || ([string compare [lindex $argv $i] "re_init"] == 0) } {
      set check_use_installed_system 1
      continue
   }

   if { ( [string compare [lindex $argv $i] "--re_init_on_tcl_error"] == 0 ) || ([string compare [lindex $argv $i] "re_init_on_tcl_error"] == 0) } {
      set check_reinit_on_tcl_error 1
      continue
   }


   if { ( [string compare [lindex $argv $i] "--master_debug"] == 0 ) || ([string compare [lindex $argv $i] "master_debug"] == 0) } {
      set master_debug 1
      set daemon_debug 1
      continue
   }
   if { ( [string compare [lindex $argv $i] "--schedd_debug"] == 0 ) || ([string compare [lindex $argv $i] "schedd_debug"] == 0) } {
      set schedd_debug 1
      set daemon_debug 1
      continue
   }
   if { ( [string compare [lindex $argv $i] "--display"] == 0 ) || ([string compare [lindex $argv $i] "display"] == 0) } {
      incr i
      set CHECK_DISPLAY_OUTPUT [lindex $argv $i]
      continue
   }

   


   if { ( [string compare [lindex $argv $i] "--kill"] == 0 ) || ([string compare [lindex $argv $i] "kill"] == 0) } {
      set do_kill 1
      continue
   }
   
   if { ( [string compare [lindex $argv $i] "--mfile"] == 0 ) || ([string compare [lindex $argv $i] "mfile"] == 0) } {
      incr i
      set CHECK_MAIL_OUTPUT_FILE [lindex $argv $i]
      if { [llength $CHECK_MAIL_OUTPUT_FILE] != 1 } {
         puts $CHECK_OUTPUT "can't use \"mfile\" option without filename!"
         exit -1 
      }
      if { ([ string first "/" $CHECK_MAIL_OUTPUT_FILE ] < 0) && ([ string first "\/" $CHECK_MAIL_OUTPUT_FILE ] < 0)} {
          set CHECK_MAIL_OUTPUT_FILE "$CHECK_CURRENT_WORKING_DIR/$CHECK_MAIL_OUTPUT_FILE"
      }
      set write_mail_to_file 1
      puts $CHECK_OUTPUT " ---> writing all mails into \"$CHECK_MAIL_OUTPUT_FILE\" ! <---"
      continue
   }
 
   if { ( [string compare [lindex $argv $i] "--file"] == 0 ) || ([string compare [lindex $argv $i] "file"] == 0) } {
      incr i
      set help_var [lindex $argv $i]
      set CHECK_DEFAULTS_FILE [ string trim $help_var ]

      if { [llength $CHECK_DEFAULTS_FILE] != 1 } {
         puts $CHECK_OUTPUT "can't use \"file\" option without filename!"
         exit -1 
      }

      if { ([ string first "/" $CHECK_DEFAULTS_FILE ] != 0) } {
          set CHECK_DEFAULTS_FILE "$CHECK_CURRENT_WORKING_DIR/$CHECK_DEFAULTS_FILE"
      }
      
      puts $CHECK_OUTPUT "using configuration file \"$CHECK_DEFAULTS_FILE\""
      continue
   }

   if { ( [string compare [lindex $argv $i] "--html_dir"] == 0 ) || ([string compare [lindex $argv $i] "html_dir"] == 0) } {
      incr i
      set help_var [lindex $argv $i]
      set CHECK_HTML_DIRECTORY [ string trim $help_var ]

      if { [llength $CHECK_HTML_DIRECTORY] != 1 } {
         puts $CHECK_OUTPUT "can't use \"html_dir\" option without filename!"
         exit -1 
      }
      puts $CHECK_OUTPUT " ---> using \"$CHECK_HTML_DIRECTORY\" for HTML output <---"
      continue
   }

  
   

   if { ( [string compare [lindex $argv $i] "--install"] == 0 ) || ([string compare [lindex $argv $i] "install"] == 0 ) } {
      set do_install 1
      continue
   }

   if { ( [string compare [lindex $argv $i] "--compile"] == 0 ) || ([string compare [lindex $argv $i] "compile"] == 0 ) } {
      set do_compile 1
      continue
   }

   if { ( [string compare [lindex $argv $i] "--no_update"] == 0 ) || ([string compare [lindex $argv $i] "no_update"] == 0 ) } {
      set do_not_update 1
      continue
   }

   
   
   if { ( [string compare [lindex $argv $i] "--reset_conf"] == 0 ) || ([string compare [lindex $argv $i] "reset_conf"] == 0 ) } {
      set do_only_reset_config 1
      set check_use_installed_system 1
      continue
   }
  
   if { ( [string compare [lindex $argv $i] "--check"] == 0 ) || ([string compare [lindex $argv $i] "check"] == 0 ) } {
      set do_one_test 1
      set ru_lev [ expr ( 1 + $i ) ]
      set do_one_test_name [ lindex $argv $ru_lev ]
      set ru_lev [ expr ( 2 + $i ) ] 
      set do_one_test_level [lindex $argv $ru_lev]
      puts $CHECK_OUTPUT "path: $do_one_test_name"
      puts $CHECK_OUTPUT "level: $do_one_test_level"
      if { [ llength $do_one_test_level ] != 1 || [ llength $do_one_test_name ] != 1} {
         puts $CHECK_OUTPUT "used check parameter without runlevel or checkname"
         setup2
         set mail_body "$mail_body product version is [get_version_info]\n"
         set mail_body "$mail_body testsuite root directory is \"$CHECK_TESTSUITE_ROOT\"\n"
         set mail_body "$mail_body check is running on host \"$CHECK_HOST\" architecture is \"$CHECK_ARCH\"\n"
         set mail_body "$mail_body product root directory is \"$CHECK_PRODUCT_ROOT\"\n-------\n"
         set mail_body "$mail_body SGE CELL is  \"$ts_config(cell)\"\n-------\n"
         mail_report $mail_subject "$mail_body used check parameter without runlevel or checkname" 
         exit -1
      }
      incr i
      continue
   } 
   if { ( [string compare [lindex $argv $i] "--all"] == 0 ) || ([string compare [lindex $argv $i] "all"] == 0 ) } {
      set do_all 1
      set ru_lev [ expr (1 + $i) ] 
      set do_all_runlevel [lindex $argv $ru_lev]
      if { [ llength $do_all_runlevel ] != 1 } {
         puts $CHECK_OUTPUT "used all parameter without runlevel"
         setup2
         set mail_body "$mail_body product version is [get_version_info]\n"
         set mail_body "$mail_body testsuite root directory is \"$CHECK_TESTSUITE_ROOT\"\n"
         set mail_body "$mail_body check is running on host \"$CHECK_HOST\" architecture is \"$CHECK_ARCH\"\n"
         set mail_body "$mail_body product root directory is \"$CHECK_PRODUCT_ROOT\"\n-------\n"
         set mail_body "$mail_body SGE CELL is  \"$ts_config(cell)\"\n-------\n"
         mail_report $mail_subject "$mail_body used all parameter without runlevel" 
         exit -1
      }
      incr i
      continue
   }
   
   if { ( [string compare [lindex $argv $i] "--category"] == 0 ) || ([string compare [lindex $argv $i] "category"] == 0 ) } {
      set do_category 1
      set ru_lev [ expr (1 + $i) ] 
      set do_category_list [lindex $argv $ru_lev]
      if { [ llength $do_category_list ] == 0 } {
         puts $CHECK_OUTPUT "used category parameter without category list"
         setup2
         set mail_body "$mail_body product version is [get_version_info]\n"
         set mail_body "$mail_body testsuite root directory is \"$CHECK_TESTSUITE_ROOT\"\n"
         set mail_body "$mail_body check is running on host \"$CHECK_HOST\" architecture is \"$CHECK_ARCH\"\n"
         set mail_body "$mail_body product root directory is \"$CHECK_PRODUCT_ROOT\"\n-------\n"
         set mail_body "$mail_body SGE CELL is  \"$ts_config(cell)\"\n-------\n"
         mail_report $mail_subject "$mail_body used category parameter without category list" 
         exit -1
      }
      incr i
      continue
   }


   if { ( [string compare [lindex $argv $i] "--debug"] == 0 ) || ([string compare [lindex $argv $i] "debug"] == 0 ) } {
      set deb_lev [ expr (1 + $i) ] 
      set CHECK_DEBUG_LEVEL [lindex $argv $deb_lev]

      debug_puts "debuglevel is $CHECK_DEBUG_LEVEL"
      incr i
      continue
   }
   if { ( [string compare [lindex $argv $i] "--execute_func"] == 0 ) || ([string compare [lindex $argv $i] "execute_func"] == 0 ) } {
      set exec_args ""
      for { incr i 1 } { $i < $argc } { incr i } {
         lappend exec_args [lindex $argv $i]
      }
      set do_prog_start 1
      break
   }

   

   if { ( [string compare [lindex $argv $i] "--no_main"] == 0 ) || ([string compare [lindex $argv $i] "no_main"] == 0 ) } {
      set do_nomain 1
      set no_action 0
      continue
   }
   if { ( [string compare [lindex $argv $i] "--no_main2"] == 0 ) || ([string compare [lindex $argv $i] "no_main2"] == 0 ) } {
      set do_nomain 1
      set no_action 0
      puts "no_main2 active"
      return
   }
}   

# load defaults file
#__setup   ;# old setup

source_tcl_files
setup2
source_tcl_files

# fill sge_config array with minimal information
bootstrap_sge_config

if { $do_category == 1 } {
   set CHECK_ENABLED_CATEGORIES $do_category_list
}
set CHECK_ACT_PATH $CHECK_CHECKTREE_ROOT


set mail_body "$mail_body product version is [get_version_info]\n"
set mail_body "$mail_body testsuite root directory is \"$CHECK_TESTSUITE_ROOT\"\n"
set mail_body "$mail_body check is running on host \"$CHECK_HOST\" architecture is \"$CHECK_ARCH\"\n"
set mail_body "$mail_body product root directory is \"$CHECK_PRODUCT_ROOT\"\n-------\n"
set mail_body "$mail_body SGE CELL is  \"$ts_config(cell)\"\n-------\n"


if { $no_action == 1 } {
  puts $CHECK_OUTPUT "CHECK_GROUP=$CHECK_GROUP"
  puts "No action flag is set -> exit 1"
  exit 1
}

if { $do_prog_start == 1 } {
   puts $CHECK_OUTPUT "starting $exec_args ..."

   set exit_value [ eval $exec_args  ]

   if { $exit_value == "" || [string is integer $exit_value] != 1 } {
      exit 0
   } else {
      exit [ eval $exec_args  ]
   }
}

if { $check_reinit_on_tcl_error == 1 } {
   set_root_passwd   
}

if { $do_compile } {
   if { [have_root_passwd] == -1 } {
         puts $CHECK_OUTPUT "need root access ..."
         set_root_passwd
   }

   if { [ compile_source ] != 0 } {
      exit -1
   } else {
      exit 0
   }
}
if { $do_one_test } {
   set CHECK_ACT_PATH "$CHECK_CHECKTREE_ROOT/$do_one_test_name"
   set dirs [ get_dir_names $CHECK_ACT_PATH ]
   set files [get_file_names $CHECK_ACT_PATH ]
   
   get_max_level_count $CHECK_ACT_PATH
   set selected_levels ""
   set CHECK_ENABLED_RUNLEVELS ""
   for {set i 0} {$i<= $do_one_test_level} {incr i 1} {
      lappend CHECK_ENABLED_RUNLEVELS [ expr ( $i * 100 )  ]
   }
 
   delete_tests $CHECK_ACT_PATH
   # print_menu_header
   puts $CHECK_OUTPUT "run all tests ..."

   run_tests $CHECK_ACT_PATH 0

   exit 0

}

if { $do_all } {
   set CHECK_ACT_PATH "$CHECK_CHECKTREE_ROOT"
   delete_tests $CHECK_ACT_PATH

   set CHECK_ACT_PATH "$CHECK_CHECKTREE_ROOT"
   set dirs [ get_dir_names $CHECK_ACT_PATH ]
   set files [get_file_names $CHECK_ACT_PATH ]
   
   get_max_level_count $CHECK_ACT_PATH
   set selected_levels ""
   set CHECK_ENABLED_RUNLEVELS ""
   for {set i 0} {$i<= $do_all_runlevel} {incr i 1} {
      lappend CHECK_ENABLED_RUNLEVELS [ expr ( $i * 100 )  ]
   }

   print_menu_header
   puts $CHECK_OUTPUT "run all tests ..."

   run_tests $CHECK_ACT_PATH 0

   exit 0
} 

if { $do_install } {
   puts "installing core system on host $CHECK_HOST ..."
   set CHECK_ACT_PATH "$CHECK_ACT_PATH/install_core_system"  
   run_test $CHECK_ACT_PATH 1
   exit 0 
}

if { $do_kill } {
   shutdown_core_system
   exit 0   
}

if { $do_only_reset_config == 1 } {
  set result 1
 
  set CHECK_ACT_PATH "$CHECK_ACT_PATH/install_core_system"
  run_test $CHECK_ACT_PATH 1 "setup_queues" 0
  run_test $CHECK_ACT_PATH 1 "setup_testcheckpointobject" 0
  run_test $CHECK_ACT_PATH 1 "setup_conf" 0
  run_test $CHECK_ACT_PATH 1 "setup_execd_conf" 0
  run_test $CHECK_ACT_PATH 1 "setup_mytestproject" 0
  run_test $CHECK_ACT_PATH 1 "setup_mytestpe" 0
  run_test $CHECK_ACT_PATH 1 "setup_deadlineuser" 0
  run_test $CHECK_ACT_PATH 1 "setup_schedconf" 0
  run_test $CHECK_ACT_PATH 1 "setup_default_calendars" 0
  run_test $CHECK_ACT_PATH 1 "setup_inhouse_cluster" 0
 
  puts "configuration reset done" 
  exit $result
}


 
if {$do_nomain == 0} {
  if { $daemon_debug != 0 } {
     if { [check_display] != 0 } {
        exit 1
     }
  }
#  puts "please press <RETURN>"
#  wait_for_enter 1
  menu 
}

