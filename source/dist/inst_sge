#!/bin/sh
#
# SGE/SGEEE installation script
#
#___INFO__MARK_BEGIN__
##########################################################################
#
#  The Contents of this file are made available subject to the terms of
#  the Sun Industry Standards Source License Version 1.2
#
#  Sun Microsystems Inc., March, 2001
#
#
#  Sun Industry Standards Source License Version 1.2
#  =================================================
#  The contents of this file are subject to the Sun Industry Standards
#  Source License Version 1.2 (the "License"); You may not use this file
#  except in compliance with the License. You may obtain a copy of the
#  License at http://gridengine.sunsource.net/Gridengine_SISSL_license.html
#
#  Software provided under this License is provided on an "AS IS" basis,
#  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
#  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
#  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
#  See the License for the specific provisions governing your rights and
#  obligations concerning the Software.
#
#  The Initial Developer of the Original Code is: Sun Microsystems, Inc.
#
#  Copyright: 2001 by Sun Microsystems, Inc.
#
#  All Rights Reserved.
#
##########################################################################
#___INFO__MARK_END__
#
# set -x

# Reset PATH to a safe value
#
PATH=/bin:/usr/bin:/usr/sbin:/usr/bsd

# Easy way to prevent clearing of screen
#
CLEAR=clear
#CLEAR=:



#-------------------------------------------------------------------------
# USEFUL LOCAL SHELL PROCEDURES

#-------------------------------------------------------------------------
# ErrUsage: print usage string, exit
#
ErrUsage()
{
   myname=`basename $0`
   $ECHO >&2
   $INFOTEXT -e \
             "Usage: %s -m|-x|-s [-nostrict] [-fast] [-auto] [-noqueue]\n" \
             "              [-csp] [-resport] [-afs]\n" \
             "   -m         install qmaster host\n" \
             "   -x         install execution host\n" \
             "   -s         print how to install submit host\n" \
             "   -fast      do installation with default options\n" \
             "   -nostrict  do not check \$SGE_ROOT for write permissions\n" \
             "   -auto      non interactive installation (exec host only)\n" \
             "   -noqueue   do not install a default queue (exec host only)\n" \
             "   -csp       install system with security framework protocol\n" \
             "              functionality\n" \
             "   -afs       install system with AFS functionality\n" \
             "   -resport   install system with reserved port security" $myname
   exit 1
}

#-------------------------------------------------------------------------
# PreCheckForFastInstall: return 0 if all conditions for an accelerated
# installation procedure are met
#
PreCheckForFastInstall()
{

   if [ $resport = true ]; then
      qmaster_port_max=1023
   else
      qmaster_port_max=65500
   fi

   if [ $resport = true ]; then
      execd_port_max=1023
   else
      execd_port_max=65500
   fi


   # must be first check - sets variable $euid
   euid=`$V5UTILBIN/uidgid -euid`

   if [ $fast = false ]; then
      return 1
   fi

   if [ $euid != 0 ]; then
      return 1
   fi

   $V5UTILBIN/getservbyname $QSYST_SERVICE  >/dev/null 2>&1
   ret=$?

   if [ $ret = 1 -a "$SGE_QMASTER_PORT" = "" ]; then
      return 1
   fi

   if [ $ret = 1 -a "$SGE_EXECD_PORT" = "" ]; then
      return 1
   fi

   if [ "$SGE_QMASTER_PORT" != "" ]; then
      if [ "$SGE_QMASTER_PORT" -le 1 -o $SGE_QMASTER_PORT -ge $qmaster_port_max ]; then
         return 1
      fi
   fi

   if [ "$SGE_EXECD_PORT" != "" ]; then
      if [ "$SGE_EXECD_PORT" -le 1 -o $SGE_EXECD_PORT -ge $execd_port_max ]; then
         return 1
      fi
   fi

   this_dir_user=`$V5UTILBIN/filestat -owner . 2> /dev/null`
   ret=$?
   if [ $ret != 0 ]; then
      $INFOTEXT "\nCan't resolve user name from current directory.\n" \
                "Installation failed. Exit.\n"
      exit 1           
   fi

   if [ $this_dir_user = root ]; then
      touch ./tst$$ 2> /dev/null > /dev/null
      ret=$?
      rm -f ./tst$$
      if [ $ret != 0 ]; then
         return 1
      fi
   else
      ADMINUSER=$this_dir_user
      ExecuteAsAdmin $TOUCH ./tst$$ 2> /dev/null > /dev/null
      ret=$?
      ExecuteAsAdmin $RM -f ./tst$$
      if [ $ret != 0 ]; then
         return 1
      fi
   fi

   return 0
}

#-------------------------------------------------------------------------
# Ask the installer for the hostname resolving method
# (IGNORE_FQND=true/false)
#
SelectHostNameResolving()
{
   $CLEAR
   $INFOTEXT -u "\nSelect default Grid Engine hostname resolving method"
   $INFOTEXT "\nAre all hosts of your cluster in one DNS domain? If this is\n" \
             "the case the hostnames\n\n" \
             "   >hostA< and >hostA.foo.com<\n\n" \
             "would be treated as eqal, because the DNS domain name >foo.com<\n" \
             "is ignored when comparing hostnames.\n\n"

   $INFOTEXT -auto $autoinst -ask "y" "n" -def "y" -n \
             "Are all hosts of your cluster in a single DNS domain (y/n) [y] >> "
   if [ $? = 0 ]; then
      IGNORE_FQDN_DEFAULT=true
      $INFOTEXT "Ignoring domainname when comparing hostnames."
   else
      IGNORE_FQDN_DEFAULT=false
      $INFOTEXT "The domainname is not ignored when comparing hostnames."
   fi
   $INFOTEXT -wait -auto $autoinst -n "\nHit <RETURN> to continue >> "
   $CLEAR

   if [ $fast = false -a "$IGNORE_FQDN_DEFAULT" = false ]; then
      GetDefaultDomain
   else
      CFG_DEFAULT_DOMAIN=none
   fi
}

#-------------------------------------------------------------------------
# Check whether the qmaster is installed and the file systems is shared
#
CheckCellDirectory()
{
   $CLEAR
   check_cell_error=0
   error_text=0
   if [ ! -d $COMMONDIR ]; then
      error_text=1
      check_cell_error=1
   fi

#   if [ ! -f $COMMONDIR/configuration ]; then
#      if [ $check_cell_error = 0 ]; then
#         error_text=2
#      fi
#      check_cell_error=1
#   fi

   if [ ! -f $COMMONDIR/act_qmaster ]; then
      if [ $check_cell_error = 0 ]; then
         error_text=3
      fi
      check_cell_error=1
   fi

   if [ $check_cell_error != 0 ]; then
      $INFOTEXT -u "\nChecking cell directory"
      $INFOTEXT "\nCannot find required files. The following error was returned:\n\n"

      if [ $error_text = 1 ]; then
         $INFOTEXT ">common directory not found: %s<\n" $COMMONDIR
      fi

      if [ $error_text = 2 ]; then
         $INFOTEXT ">configuration file not found: %s<\n" $COMMONDIR/configuration
      fi

      if [ $error_text = 3 ]; then
         $INFOTEXT ">%s file not found: %s<\n" act_qmaster $COMMONDIR/act_qmaster
      fi

      $INFOTEXT "\nPlease make sure that you have installed the qmaster host before\n" \
                "installing an execution host.\n\n" \
                "The installation procedure will only work if you use a shared\n" \
                "directory (e.g. shared with NFS) for your installation.\n\n" \
                "The installation of the execution daemon will abort now.\n"

      exit 1
   fi
}


#-------------------------------------------------------------------------
# Check the hostnames and put out warning message on probably wrong
# hostname resolving
#
CheckHostNameResolving()
{

   resolve_get_configuration=`ExecuteAsAdmin $V5BIN/qconf -sconf global | grep "^ignore_fqdn" `
   resolve_qmaster_params=`echo $resolve_get_configuration | egrep -i "true|1"`
   if [ "x$resolve_qmaster_params" = "x" ]; then
      $ECHO ""
      set IGNORE_FQDN_DEFAULT=false
   else
#     don't need this check when IGNORE_FQDN=true in qmaster_params
      set IGNORE_FQDN_DEFAULT=true
      return
   fi

   done=false
   loop_counter=0
   while [ $done = false ]; do
       done=false
       $CLEAR
       $INFOTEXT -u "\nChecking hostname resolving"

       resolve_admin_hosts=`ExecuteAsAdmin $V5BIN/qconf -sh`
       resolve_this_hostname=`ExecuteAsAdmin $V5UTILBIN/gethostname -aname`
       resolve_default_domain=`ExecuteAsAdmin $V5BIN/qconf -sconf global | grep "^default_domain" | awk '{print $2}'`

       if [ "$resolve_default_domain" = "" ]; then
           resolve_default_domain="none"
       fi
       $INFOTEXT "\nThis host has the local hostname >%s<.\n" $resolve_this_hostname

       resolve_default_domain_upper=`echo $resolve_default_domain | tr "[a-z]" "[A-Z]"`
       if [ "$resolve_default_domain_upper" != "NONE" ]; then
            resolve_tmp_name=`echo $resolve_this_hostname | cut -f 1 -d "."`
            if [ "$resolve_tmp_name" = "$resolve_this_hostname" ]; then
                resolve_this_hostname="$resolve_this_hostname.$resolve_default_domain"

                $INFOTEXT "The default_domain parameter is set in the global configuration\n" \
                          "and added to the unqualified hostname. As a result the\n" \
                          "execd on this host would return the following hostname: >%s<\n" \
                          $resolve_this_hostname
            fi
       fi

       resolve_upper_this_hostname=`echo $resolve_this_hostname | tr "[a-z]" "[A-Z]"`
       for i in $resolve_admin_hosts; do
           resolve_upper_admin_hostname=`echo $i | tr "[a-z]" "[A-Z]"`
           if [ "$resolve_upper_admin_hostname" = "$resolve_upper_this_hostname" ]; then
              $INFOTEXT "This host can be resolved correctly.\n"
              done=true
              break
           fi
       done

       if [ $done = false ]; then
           $INFOTEXT "This host is unknown on the qmaster host.\n\n" \
                     "Please make sure that you added this host as administrative host!\n" \
                     "If you did not, please add this host now with the command\n\n" \
                     "   # qconf -ah HOSTNAME\n\n" \
                     "on your qmaster host.\n"
           if [ $loop_counter != 0 ]; then
               $INFOTEXT "If this host is already added as administrative host on your qmaster host\n" \
                         "there may be a hostname resolving problem on this machine.\n\n" \
                         "Please check your >/etc/hosts< file and >/etc/nsswitch.conf< file.\n\n" \
                         "Hostname resolving problems will cause the problem that the\n" \
                         "execution host will not be accepted by qmaster. Qmaster will\n" \
                         "receive no load report values and show a load value\n" \
                         "(>load_avg<) of 99.99 for this host.\n"
               if [ $autoinst = true ]; then
                   exit 1
               fi
           fi

           $INFOTEXT -auto $autoinst -ask "y" "n" -def "y" -n "Check again (y/n) [y] >> "
           if [ $? = 0 ]; then
              done=false
           else
              done=true
           fi
       else
           $INFOTEXT -wait -auto $autoinst -n "Hit <RETURN> to continue >> "
           $CLEAR
           return
       fi
       loop_counter=`expr $loop_counter + 1`
   done
}

#-------------------------------------------------------------------------
# AskIfDefaultOkAndSetVariables
#
AskIfDefaultOkAndSetVariables()
{
   if [ "`eval echo '$'$QSYST_ROOT`" = "" ]; then
      eval $QSYST_ROOT=`pwd | sed 's/\/tmp_mnt//'`
      export $QSYST_ROOT
   fi
   QSYST_ROOT_VAL=`eval echo '$'$QSYST_ROOT`

   QMDIR=$QSYST_ROOT_VAL/$QSYST_CELL_VAL/spool/qmaster

   SetCellDependentVariables

   $INFOTEXT -u "\nConfirm Grid Engine default installation settings"

   $INFOTEXT "\nThe following default settings can be used for an accelerated\n" \
             "installation procedure:\n\n" \
             "      \$SGE_ROOT          = %s" $QSYST_ROOT_VAL
   if [ "$SGE_QMASTER_PORT" != "" ]; then
      $INFOTEXT "      \$SGE_QMASTER_PORT  = %s" $SGE_QMASTER_PORT
   else
      $INFOTEXT "      service            = %s" $QSYST_SERVICE
   fi

   $INFOTEXT "      \$SGE_EXECD_PORT    = %s" $SGE_EXECD_PORT

   if [ $ADMINUSER = default ]; then
      $INFOTEXT "      admin user account = root"
   else
      $INFOTEXT "      admin user account = %s" $ADMINUSER
   fi

   if [ "$QSYST_CELL_VAL" != "default" ]; then
      $INFOTEXT "      cell name          = %s" $QSYST_CELL_VAL
   fi

   $INFOTEXT -auto $autoinst -ask "y" "n" -def "y" -n \
             "\nDo you want to use these configuration parameters (y/n) [y] >> "
   if [ $? = 0 ]; then
      return 0
   else
      return 1
   fi
}

#---------------------------------------------------
# SetFilePerm
# set file permissions to 644 and dirs. to 755 and change owner to admin
# user
#
SetFilePerm()
{
   f="$1"
   $INFOTEXT "Verifying and setting file permissions in >%s<" "$f"
   chmod -R go+r $f
   find $f -type d -exec chmod 755 {} \;
   find $f -type f -perm -100 -exec chmod go+x {} \;

   if [ $ADMINUSER != default ]; then
        chown -R $ADMINUSER $f
   fi
}

#-------------------------------------------------------------------------
# Makedir: make directory, chown/chgrp/chmod it. Exit if failure
#
Makedir()
{
   file=$1
   if [ ! -d $file ]; then
       $INFOTEXT "creating directory: %s" "$file"
       ExecuteAsAdmin $MKDIR -p $1
    fi

   ExecuteAsAdmin $CHMOD $DIRPERM $file
}

#-------------------------------------------------------------------------
# SetPerm: set permissions
#
SetPerm()
{
   file=$1
   ExecuteAsAdmin $CHMOD $FILEPERM $file
}

#-------------------------------------------------------------------------
# Make directories needed by qmaster
#
MakeDirsMaster()
{
   $INFOTEXT -u "\nMaking directories"
   Makedir $QSYST_CELL_VAL
   Makedir $COMMONDIR
   Makedir $QMDIR
   Makedir $QMDIR/job_scripts

   $INFOTEXT -wait -auto $autoinst -n "Hit <RETURN> to continue >> "
   $CLEAR
}

#-------------------------------------------------------------------------
# Initialize the spooling database (or directory structure)
#
InitSpoolingDatabase()
{
   $INFOTEXT -u "\nInitializing spooling database"
   ExecuteAsAdmin $SPOOLINIT $SPOOLING_LIB "$SPOOLING_ARGS" init

   $INFOTEXT -wait -auto $autoinst -n "Hit <RETURN> to continue >> "
   $CLEAR
}

#-------------------------------------------------------------------------
# PrintLocalConf:  print execution host local SGE/SGEEE configuration
#
PrintLocalConf()
{

   arg=$1
   if [ $arg = 1 ]; then
      $ECHO "# Version: pre6.0"
      $ECHO "#"
      $ECHO "# DO NOT MODIFY THIS FILE MANUALLY!"
      $ECHO "#"
      $ECHO "conf_version           0"
   fi
   $ECHO "mailer                 $MAILER"
   $ECHO "xterm                  $XTERM"
   $ECHO "qlogin_daemon          $QLOGIN_DAEMON"
   $ECHO "rlogin_daemon          $RLOGIN_DAEMON"
}

#-------------------------------------------------------------------------
# PrintHostGroup:  print an empty hostgroup
#
PrintHostGroup()
{
   $ECHO "group_name  $1"
   $ECHO "hostlist    NONE"
}

AddBootstrap()
{
   $INFOTEXT -u "\nDumping bootstrapping information"

   TruncCreateAndMakeWriteable $COMMONDIR/bootstrap
   PrintBootstrap > $COMMONDIR/bootstrap
   SetPerm $COMMONDIR/bootstrap
}

#-------------------------------------------------------------------------
# PrintBootstrap: print SGE/SGEEE bootstrapping information
#
PrintBootstrap()
{
   $ECHO "# Version: pre6.0"
   $ECHO "#"
   if [ $ADMINUSER != default ]; then
      $ECHO "admin_user             $ADMINUSER"
   else
      $ECHO "admin_user             none"
   fi
   $ECHO "default_domain         $CFG_DEFAULT_DOMAIN"
   $ECHO "ignore_fqdn            $IGNORE_FQDN_DEFAULT"
   $ECHO "spooling_method        $SPOOLING_METHOD"
   $ECHO "spooling_lib           $SPOOLING_LIB"
   $ECHO "spooling_params        $SPOOLING_ARGS"
   $ECHO "binary_path            $QSYST_ROOT_VAL/bin"
   $ECHO "qmaster_spool_dir      $QMDIR"
   $ECHO "product_mode           $PRODUCT_MODE"
}

#-------------------------------------------------------------------------
# PrintConf: print SGE/SGEEE default configuration
#
PrintConf()
{
   $ECHO "# Version: pre6.0"
   $ECHO "#"
   $ECHO "# DO NOT MODIFY THIS FILE MANUALLY!"
   $ECHO "#"
   $ECHO "conf_version           0"
   $ECHO "execd_spool_dir        $CFG_EXE_SPOOL"
   $ECHO "mailer                 $MAILER"
   $ECHO "xterm                  $XTERM"
   $ECHO "load_sensor            none"
   $ECHO "prolog                 none"
   $ECHO "epilog                 none"
   $ECHO "shell_start_mode       posix_compliant"
   $ECHO "login_shells           sh,ksh,csh,tcsh"
   $ECHO "min_uid                0"
   $ECHO "min_gid                0"
   $ECHO "user_lists             none"
   $ECHO "xuser_lists            none"
   if [ $inst = sgeee ]; then
      $ECHO "projects               none"
      $ECHO "xprojects              none"
      $ECHO "enforce_project        false"
      $ECHO "enforce_user           false"
   fi
   $ECHO "load_report_time       00:00:40"
   $ECHO "max_unheard            00:05:00"
   $ECHO "reschedule_unknown     00:00:00"
   $ECHO "loglevel               log_warning"
   $ECHO "administrator_mail     $CFG_MAIL_ADDR"
   if [ $afs = true ]; then
      $ECHO "set_token_cmd          /path_to_token_cmd/set_token_cmd"
      $ECHO "pag_cmd                /usr/afsws/bin/pagsh"
      $ECHO "token_extend_time      24:0:0"
   else
      $ECHO "set_token_cmd          none"
      $ECHO "pag_cmd                none"
      $ECHO "token_extend_time      none"
   fi
   $ECHO "shepherd_cmd           none"
   $ECHO "qmaster_params         none"
   $ECHO "execd_params           none"
   $ECHO "reporting_params       accounting=true reporting=false flush_time=00:00:15 joblog=false sharelog=00:00:00"
   $ECHO "finished_jobs          100"
   $ECHO "gid_range              $CFG_GID_RANGE"
   $ECHO "qlogin_command         $QLOGIN_COMMAND"
   $ECHO "qlogin_daemon          $QLOGIN_DAEMON"
   $ECHO "rlogin_daemon          $RLOGIN_DAEMON"
   $ECHO "max_aj_instances       2000"
   $ECHO "max_aj_tasks           75000"
   $ECHO "max_u_jobs             0"
   $ECHO "max_jobs               0"
}

#-------------------------------------------------------------------------
# GetGidRange
#
GetGidRange()
{
   done=false
   while [ $done = false ]; do
      $CLEAR
      $INFOTEXT -u "\nGrid Engine group id range"
      $INFOTEXT "\nWhen jobs are started under the control of Grid Engine an additional group id\n" \
                "is set on platforms which do not support jobs. This is done to provide maximum\n" \
                "control for Grid Engine jobs.\n\n" \
                "This additional UNIX group id range must be unused group id's in your system.\n" \
                "Each job will be assigned a unique id during the time it is running.\n" \
                "Therefore you need to provide a range of id's which will be assigned\n" \
                "dynamically for jobs.\n\n" \
                "The range must be big enough to provide enough numbers for the maximum number\n" \
                "of Grid Engine jobs running at a single moment on a single host. E.g. a range\n" \
                "like >20000-20100< means, that Grid Engine will use the group ids from\n" \
                "20000-20100 and provides a range for 100 Grid Engine jobs at the same time\n" \
                "on a single host.\n\n" \
                "You can change at any time the group id range in your cluster configuration.\n"

      $INFOTEXT -n "Please enter a range >> "

      CFG_GID_RANGE=`Enter ""`

      if [ "$CFG_GID_RANGE" != "" ]; then
         $INFOTEXT -wait -auto $autoinst -n "\nUsing >%s< as gid range. Hit <RETURN> to continue >> " \
                   "$CFG_GID_RANGE"
         $CLEAR
         done=true
      fi
   done
}

#-------------------------------------------------------------------------
# GetDefaultDomain
#
GetDefaultDomain()
{
   done=false
   while [ $done = false ]; do
      $CLEAR
      $INFOTEXT -u "\nDefault domain for hostnames"

      $INFOTEXT "\nSometimes the primary hostname of machines returns the short hostname\n" \
                  "without a domain suffix like >foo.com<.\n\n" \
                  "This can cause problems with getting load values of your execution hosts.\n" \
                  "If you are using DNS or you are using domains in your >/etc/hosts< file or\n" \
                  "your NIS configuration it is usually safe to define a default domain\n" \
                  "because it is only used if your execution hosts return the short hostname\n" \
                  "as their primary name.\n\n" \
                  "If your execution hosts reside in more than one domain, the default domain\n" \
                  "parameter must be set on all execution hosts individually.\n"

      $INFOTEXT -auto $autoinst -ask "y" "n" -def "y" -n \
                "Do you want to configure a default domain (y/n) [y] >> "
      if [ $? = 0 ]; then
         $INFOTEXT -n "\nPlease enter your default domain >> "
         CFG_DEFAULT_DOMAIN=`Enter ""`
         if [ "$CFG_DEFAULT_DOMAIN" != "" ]; then
            $INFOTEXT -wait -auto $autoinst -n "\nUsing >%s< as default domain. Hit <RETURN> to continue >> " \
                      $CFG_DEFAULT_DOMAIN
            $CLEAR
            done=true
         fi
      else
         CFG_DEFAULT_DOMAIN=none
         done=true
      fi
   done
}

#-------------------------------------------------------------------------
# GetConfiguration: get some parameters for global configuration
#
GetConfiguration()
{

   GetGidRange

   if [ $fast = true ]; then
      CFG_EXE_SPOOL=$QSYST_ROOT_VAL/$QSYST_CELL_VAL/spool
      CFG_MAIL_ADDR=none
      return 0
   fi

   done=false
   while [ $done = false ]; do
      $CLEAR
      $INFOTEXT -u "\nGrid Engine cluster configuration"
      $INFOTEXT "\nPlease give the basic configuration parameters of your Grid Engine\n" \
                "installation:\n\n   <execd_spool_dir>\n\n"

      if [ $ADMINUSER != default ]; then
            $INFOTEXT "The pathname of the spool directory of the execution hosts. User >%s<\n" \
                      "must have the right to create this directory and to write into it.\n" "$ADMINUSER"
      elif [ $euid = 0 ]; then
            $INFOTEXT "The pathname of the spool directory of the execution hosts. User >root<\n" \
                      "must have the right to create this directory and to write into it.\n"
      else
            $INFOTEXT "The pathname of the spool directory of the execution hosts. You\n" \
                      "must have the right to create this directory and to write into it.\n"
      fi

      $INFOTEXT -n "Default: [%s] >> " $QSYST_ROOT_VAL/$QSYST_CELL_VAL/spool

      CFG_EXE_SPOOL=`Enter $QSYST_ROOT_VAL/$QSYST_CELL_VAL/spool`

      $CLEAR
      $INFOTEXT -u "\nGrid Engine cluster configuration (continued)"
      $INFOTEXT -n "\n<administrator_mail>\n\n" \
                   "The email address of the administrator to whom problem reports are sent.\n\n" \
                   "It's is recommended to configure this parameter. You may use >none<\n" \
                   "if you do not wish to receive administrator mail.\n\n" \
                   "Please enter an email address in the form >user@foo.com<.\n\n" \
                   "Default: [none] >> "

      CFG_MAIL_ADDR=`Enter none`

      $CLEAR

      $INFOTEXT "\nThe following parameters for the cluster configuration were configured:\n\n" \
                "   execd_spool_dir        %s\n" \
                "   administrator_mail     %s\n" $CFG_EXE_SPOOL $CFG_MAIL_ADDR

      $INFOTEXT -auto $autoinst -ask "y" "n" -def "n" -n \
                "Do you want to change the configuration parameters (y/n) [n] >> "
      if [ $? = 1 ]; then
         done=true
      fi
   done
}

#-------------------------------------------------------------------------
# AddConfiguration
#
AddConfiguration()
{
   useold=false
#
# JG: TODO: a maintenance command could dump the configuration to file
#           we display it and decide whether to overwrite it.
#           To Change: spoolinit has to check whether the database already
#           exists and not overwrite it.
#
#   if [ -f $COMMONDIR/configuration ]; then
#      $INFOTEXT -u "\nCreating global cluster configuration"
#      $INFOTEXT "\nA global cluster configuration file already exists.\n"
#      $INFOTEXT -wait -auto $autoinst -n "Hit <RETURN> to display the configuration >> "
#
#      cat $COMMONDIR/configuration |grep -v conf_version |more
#
#      QMDIR_IN_CFG=`grep qmaster_spool_dir $COMMONDIR/configuration | awk '{print $2}'`
#      if [ "$QMDIR_IN_CFG" != $QMDIR ]; then
#         $CLEAR
#         $INFOTEXT -u "\nERROR - new qmaster spool directory"
#         $INFOTEXT "\nThe qmaster spool directory in your existing configuration is set to\n\n" \
#                   "   %s\n\n" \
#                   "and differs from your previous selection during this installation where you\n" \
#                   "set the qmaster spool directory to\n\n" \
#                   "   %s\n\n" \
#                   "Please either copy your old qmaster spool directory to the new directory and\n" \
#                   "edit the existing cluster configuration file to reflect this change and\n" \
#                   "restart the installation or delete the current cluster configuration file.\n" \
#                   "$QMDIR_IN_CFG" "$QMDIR"
#         $INFOTEXT -wait -auto $autoinst -n "Hit <RETURN> to cancel the installation >> "
#         exit 1
#      else
#         $INFOTEXT -auto $autoinst -ask "y" "n" -def "y" -n \
#                   "Do you want to create a new configuration (y/n) [y] >> "
#         if [ $? = 1 ]; then
#            $INFOTEXT -wait -auto $autoinst -n "Using existing configuration. Hit <RETURN> to continue >> "
#            useold=true
#         fi
#      fi
#   fi

   if [ $useold = false ]; then
      GetConfiguration
      #TruncCreateAndMakeWriteable $COMMONDIR/configuration
      #PrintConf >> $COMMONDIR/configuration
      #SetPerm $COMMONDIR/configuration
      TMPC=/tmp/configuration
      rm -f $TMPC
      PrintConf > $TMPC
      ExecuteAsAdmin $SPOOLDEFAULTS configuration $TMPC
      rm -f $TMPC
   fi
}

#-------------------------------------------------------------------------
# SetProductMode
#
SetProductMode()
{
   if [ $inst = sge ]; then
      PRODUCT_PREFIX=sge
   else
      PRODUCT_PREFIX=sgeee
   fi

   if [ $resport = true ]; then
      RESPORT_PREFIX=-reserved_port
   else
      RESPORT_PREFIX=""
   fi

   if [ $afs = true ]; then
      AFS_PREFIX=-afs
   else
      AFS_PREFIX=""
   fi

   if [ $csp = true ]; then
      SEC_COUNT=`strings $V5BIN/sge_qmaster | grep sec_init | wc -l`
      if [ 5 -gt $SEC_COUNT ]; then
         $INFOTEXT "\n>sge_qmaster< binary is not compiled with >-secure< option!\n"
         $INFOTEXT -wait -auto $autoinst -n "Hit <RETURN> to cancel the installation >> "
         exit 1
      else
         CSP_PREFIX=-csp
      fi  
   else
      CSP_PREFIX=""
   fi

   PRODUCT_MODE="${PRODUCT_PREFIX}${RESPORT_PREFIX}${AFS_PREFIX}${CSP_PREFIX}"
}

#-------------------------------------------------------------------------
# AddLocalConfiguration_With_Qconf
#
AddLocalConfiguration_With_Qconf()
{

   $CLEAR
   $INFOTEXT -u "\nCreating local configuration"

   TMPL=/tmp/${HOST}
   rm -f $TMPL
   if [ -f $TMPL ]; then
      $INFOTEXT "\nCan't create local configuration. Can't delete file >%s<" "$TMPL"
   else
      $INFOTEXT "\nCreating local configuration for host >%s<" $HOST
      PrintLocalConf 0 > /tmp/$HOST
      Execute $V5BIN/qconf -Aconf /tmp/$HOST
      rm -f /tmp/$HOST
      $INFOTEXT "Local configuration for host >%s< created." $HOST
   fi
   $INFOTEXT -wait -auto $autoinst -n "\nHit <RETURN> to continue >> "
}

#-------------------------------------------------------------------------
# AddLocalConfiguration
#
AddLocalConfiguration()
{
   useold=false

   $CLEAR
   $INFOTEXT -u "\nCreating local configuration"
   # JG: TODO: see comment regarding existing global configuration
#   if [ -f $LCONFDIR/$HOST ]; then
#      $INFOTEXT "\nA local configuration for this host already exists.\n"
#
#      $INFOTEXT -wait -auto $autoinst -n "Hit <RETURN> to display configuration >> "
#
#      cat $LCONFDIR/$HOST |grep -v conf_version |more
#
#      $INFOTEXT -auto $autoinst -ask "y" "n" -def "n" -n \
#                "\nDo you want to create a new configuration (y/n) [n] >> "
#      if [ $? = 1 ]; then
#         $INFOTEXT -wait -auto $autoinst -n "Keeping existing configuration. Hit <RETURN> to continue >> "
#         useold=true
#      else
#         $INFOTEXT -wait -auto $autoinst -n "Creating new local configuration. Hit <RETURN> to continue >> "
#      fi
#      $CLEAR
#   fi

   if [ $useold = false ]; then
#      TruncCreateAndMakeWriteable $LCONFDIR/$HOST
#      PrintLocalConf 1 >> $LCONFDIR/$HOST
#      SetPerm $LCONFDIR/$HOST
      TMPH=/tmp/$HOST
      rm -f $TMPH
      PrintLocalConf 1 > $TMPH
      ExecuteAsAdmin $SPOOLDEFAULTS local_conf $TMPH $HOST
      rm -f $TMPH
   fi
}

#-------------------------------------------------------------------------
# AddActQmaster: create act_qmaster file
#
AddActQmaster()
{
   $INFOTEXT "Creating >act_qmaster< file"

   TruncCreateAndMakeWriteable $COMMONDIR/act_qmaster
   $ECHO $HOST >> $COMMONDIR/act_qmaster
   SetPerm $COMMONDIR/act_qmaster
}

#-------------------------------------------------------------------------
# AddDefaultComplexes
#
AddDefaultComplexes()
{
   $INFOTEXT "Adding default complex attributes"
#   for c in arch h_rt mem_free num_proc  s_rt swap_total calendar h_stack mem_total qname s_stack swap_used cpu h_vmem mem_used rerun s_vmem tmpdir h_core hostname min_cpu_interval s_core seq_no virtual_free h_cpu load_avg np_load_avg s_cpu slots virtual_total h_data load_long np_load_long s_data swap_free virtual_used h_fsize load_medium np_load_medium s_fsize swap_rate h_rss load_short np_load_short s_rss swap_rsvd; do
#      if [ -f $QMDIR/centry/$c -a -s $QMDIR/centry/$c ]; then
#         $INFOTEXT -auto $autoinst -ask "y" "n" -def "y" -n \
#                   "Complex attribute >%s< already exists - should Complex attribute be preserved (y/n) [y] >> " $c
#         if [ $? = 1 ]; then
#            $INFOTEXT "Overwriting existing complex attribute>%s<" $c
#            ExecuteAsAdmin cp util/resources/centry/$c $QMDIR/centry
#         fi
#      else
#         ExecuteAsAdmin cp util/resources/centry/$c $QMDIR/centry
#      fi
#   done
#   ExecuteAsAdmin chmod $FILEPERM $QMDIR/centry/*
   ExecuteAsAdmin $SPOOLDEFAULTS complexes $QSYST_ROOT_VAL/util/resources/centry

}

#-------------------------------------------------------------------------
# AddDefaultDepartement
#
AddDefaultDepartement()
{
   if [ $inst = sgeee ]; then
      #$INFOTEXT "Adding SGEEE >defaultdepartment< userset"
      #ExecuteAsAdmin $CP util/resources/usersets/defaultdepartment $QMDIR/usersets
      #ExecuteAsAdmin $CHMOD $FILEPERM $QMDIR/usersets/defaultdepartment

      #$INFOTEXT "Adding SGEEE >deadlineusers< userset"
      #ExecuteAsAdmin $CP util/resources/usersets/deadlineusers $QMDIR/usersets
      #ExecuteAsAdmin $CHMOD 644 $QMDIR/usersets/deadlineusers

      $INFOTEXT "Adding SGEEE default usersets"
      ExecuteAsAdmin $SPOOLDEFAULTS usersets $QSYST_ROOT_VAL/util/resources/usersets
   fi
}

#-------------------------------------------------------------------------
# AddCommonFiles
#    Copy files from util directory to common dir
#
AddCommonFiles()
{
   for f in sge_aliases qtask sge_request; do
      if [ $f = sge_aliases ]; then
         $INFOTEXT "Adding >%s< path aliases file" $f
      elif [ $f = qtask ]; then
         $INFOTEXT "Adding >%s< qtcsh sample default request file" $f
      else
         $INFOTEXT "Adding >%s< default submit options file" $f
      fi
      ExecuteAsAdmin cp util/$f $COMMONDIR
      ExecuteAsAdmin chmod $FILEPERM $COMMONDIR/$f
   done

   unset f
}

#-------------------------------------------------------------------------
# AddPEFiles
#    Copy files from PE template directory to qmaster spool dir
#
AddPEFiles()
{
   $INFOTEXT "Adding default parallel environments (PE)"
#   for c in make; do
#      if [ -f $QMDIR/pe/$c -a -s $QMDIR/pe/$c ]; then
#         $INFOTEXT -auto $autoinst -ask "y" "n" -def "y" -n \
#                   "PE >%s< already exists - should PE be preserved (y/n) [y] >> " $c
#         if [ $? = 1 ]; then
#            $INFOTEXT "Overwriting existing PE >%s<" $c
#            ExecuteAsAdmin cp util/resources/pe/$c $QMDIR/pe
#         fi
#      else
#         ExecuteAsAdmin cp util/resources/pe/$c $QMDIR/pe
#      fi
#   done
#   ExecuteAsAdmin chmod $FILEPERM $QMDIR/pe/*
   ExecuteAsAdmin $SPOOLDEFAULTS pes $QSYST_ROOT_VAL/util/resources/pe
}
#-------------------------------------------------------------------------
# AddDefaultManager
#
AddDefaultManager()
{
   ExecuteAsAdmin $SPOOLDEFAULTS managers $*
#  TruncCreateAndMakeWriteable $QMDIR/managers
#  $ECHO $1 >> $QMDIR/managers
#  SetPerm $QMDIR/managers
}

# AddDefaultOperator
#
AddDefaultOperator()
{
   ExecuteAsAdmin $SPOOLDEFAULTS operators $*
}


#-------------------------------------------------------------------------
# ProcessQsystRoot: read SGE/SGEEE root directory and set $QSYST_ROOT
#                    check if $QSYST_ROOT matches current directory
#
ProcessQsystRoot()
{
   $CLEAR
   $INFOTEXT -u "\nChecking \$SGE_ROOT directory"
   $ECHO
   done=false
   while [ $done = false ]; do
      if [ "`eval echo '$'$QSYST_ROOT`" = "" ]; then
         eval $QSYST_ROOT=`pwd | sed 's/\/tmp_mnt//'`
         export $QSYST_ROOT
         QSYST_ROOT_VAL=`eval echo '$'$QSYST_ROOT`

         $INFOTEXT -n "The Grid Engine root directory (your current directory) is:\n\n" \
                      "   \$SGE_ROOT = %s\n\n" \
                      "If this directory is not correct (e.g. it may contain an automounter\n" \
                      "prefix) enter the correct path to this directory or hit <RETURN>\n" \
                      "to use default [%s] >> " $QSYST_ROOT_VAL $QSYST_ROOT_VAL

         eval $QSYST_ROOT=`Enter $QSYST_ROOT_VAL`
         $ECHO
      fi

      QSYST_ROOT_VAL=`eval echo '$'$QSYST_ROOT`

      # do not check for correct QSYST_ROOT in case of -nostrict
      if [ "$strict" = true ]; then
         # create a file in QSYST_ROOT
         if [ $ADMINUSER != default ]; then
            $V5UTILBIN/adminrun $ADMINUSER $TOUCH $QSYST_ROOT_VAL/tst$$ 2> /dev/null > /dev/null
         else
            touch $QSYST_ROOT_VAL/tst$$ 2> /dev/null > /dev/null
         fi
         ret=$?
         # check if we have write permission
         if [ $ret != 0 ]; then
            $CLEAR
            $INFOTEXT "Can't create a temporary file in the directory\n\n   %s\n\n" \
                      "This may be a permission problem (e.g. no read/write permission\n" \
                      "on a NFS mounted filesystem).\n" \
                      "Please check your permissions. You may cancel the installation now\n" \
                      "and restart it or continue and try again.\n" $QSYST_ROOT_VAL
            unset $QSYST_ROOT
            $INFOTEXT -wait -auto $autoinst -n "Hit <RETURN> to continue >> "
            $CLEAR
         elif [ ! -f tst$$ ]; then
            # check if QSYST_ROOT points to current directory
            $INFOTEXT "Your \$SGE_ROOT environment variable\n\n   \$SGE_ROOT = %s\n\n" \
                        "doesn't match the current directory.\n" $QSYST_ROOT_VAL
            ExecuteAsAdmin $RM -f $QSYST_ROOT_VAL/tst$$
            unset $QSYST_ROOT
         else
            ExecuteAsAdmin $RM -f $QSYST_ROOT_VAL/tst$$
            done=true
         fi
      else
         done=true
      fi
   done

   $INFOTEXT "Your \$SGE_ROOT directory: %s\n" $QSYST_ROOT_VAL
   $INFOTEXT -wait -auto $autoinst -n "Hit <RETURN> to continue >> "
   $CLEAR
}

#-------------------------------------------------------------------------
# GiveHints: give some useful hints at the end of the installation
#
GiveHints()
{

   if [ $autoinst = true ]; then
      return
   fi

   done=false
   while [ $done = false ]; do
      $CLEAR
      $INFOTEXT -u "\nUsing Grid Engine"
      $INFOTEXT "\nYou should now enter the command:\n\n" \
                "   source %s\n\n" \
                "if you are a csh/tcsh user or\n\n" \
                "   # . %s\n\n" \
                "if you are a sh/ksh user.\n\n" \
                "This will set or expand the following environment variables:\n\n" \
                "   - \$SGE_ROOT    (always necessary)\n" \
                "   - \$SGE_CELL    (if you are using a cell other than >default<)\n" \
                "   - \$SGE_QMASTER_PORT   (if you haven't added the service >%s<)\n" \
                "   - \$SGE_EXECD_PORT\n" \
                "   - \$PATH/\$path (to find the Grid Engine binaries)\n" \
                "   - \$MANPATH     (to access the manual pages)\n" \
                $QSYST_ROOT_VAL/$QSYST_CELL_VAL/common/settings.csh \
                $QSYST_ROOT_VAL/$QSYST_CELL_VAL/common/settings.sh  \
                $QSYST_SERVICE

      $INFOTEXT -wait -auto $autoinst -n "Hit <RETURN> to see where Grid Engine logs messages >> "
      $CLEAR

      $INFOTEXT -u "\nGrid Engine messages"
      $INFOTEXT "\nGrid Engine messages can be found at:\n\n" \
                "   /tmp/qmaster_messages (during qmaster startup)\n" \
                "   /tmp/execd_messages   (during execution daemon startup)\n\n" \
                "After startup the daemons log thier messages in their spool directories.\n\n" \
                "   Qmaster:     %s\n" \
                "   Exec daemon: <execd_spool_dir>/<hostname>/messages\n" $QMDIR/messages

      $INFOTEXT -auto $autoinst -ask "y" "n" -def "n" -n \
                "Do you want to see previous screen about using Grid Engine again (y/n) [n] >> "
      if [ $? = 0 ]; then
         :
      else
         done=true
      fi
   done

   if [ $WHICH = qmaster ]; then
      $CLEAR
      $INFOTEXT -u "\nYour Grid Engine qmaster installation is now completed"
      $INFOTEXT "\nPlease now login to all hosts where you want to run an execution daemon\n" \
                  "and start the execution host installation procedure.\n\n" \
                  "If you want to run an execution daemon on this host, please do not forget\n" \
                  "to make the execution host installation in this host as well.\n\n" \
                  "All execution hosts must be administrative hosts during the installation.\n" \
                  "All hosts which you added to the list of administrative hosts during this\n" \
                  "installation procedure can now be installed.\n\n" \
                  "You may verify your administrative hosts with the command\n\n" \
                  "   # qconf -sh\n\n" \
                  "and you may add new administrative hosts with the command\n\n" \
                  "   # qconf -ah <hostname>\n"
      exit 0
   else
      $INFOTEXT "Your execution daemon installation is now completed."
   fi
}

#-------------------------------------------------------------------------
# CheckWhoInstallsQsyst
#
CheckWhoInstallsQsyst()
{
   euid=`$V5UTILBIN/uidgid -euid`
   if [ $euid != 0 ]; then
      $CLEAR
      $INFOTEXT -u "\nGrid Engine - test installation"
      $INFOTEXT "\nYou are installing not as user >root<!\n\n" \
                  "This will allow you to run Grid Engine only under your user id for testing\n" \
                  "a limited functionality of Grid Engine.\n"
      
      $INFOTEXT -wait -auto $autoinst -n "Hit <RETURN> if this is ok or stop the installation with Ctrl-C >> "
      $CLEAR
      return 0
   fi

   # from here only root
   this_dir_user=`$V5UTILBIN/filestat -owner . 2> /dev/null`
   ret=$?
   if [ $ret != 0 ]; then
      $INFOTEXT "\nCan't resolve user name from current directory.\n" \
                "Installation failed. Exit.\n"
      exit 1           
   fi

   if [ $this_dir_user != root ]; then
      $CLEAR
      $INFOTEXT -u "\nGrid Engine admin user account"

      $INFOTEXT "\nThe current directory\n\n" \
                "   %s\n\n" \
                "is owned by user\n\n" \
                "   %s\n\n" \
                "If user >root< does not have write permissions in this directory on *all*\n" \
                "of the machines where Grid Engine will be installed (NFS partitions not\n" \
                "exported for user >root< with read/write permissions) it is recommended to\n" \
                "install Grid Engine that all spool files will be created under the user id\n" \
                "of user >%s<.\n\n" \
                "IMPORTANT NOTE: The daemons still have to be started by user >root<.\n" \
                `pwd` $this_dir_user $this_dir_user

      $INFOTEXT -auto $autoinst -ask "y" "n" -def "y" -n \
                "Do you want to install Grid Engine as admin user >%s< (y/n) [y] >> " $this_dir_user
      if [ $? = 0 ]; then
         $INFOTEXT "Installing Grid Engine as admin user >%s<" "$this_dir_user"
         ADMINUSER=$this_dir_user
         $INFOTEXT -wait -auto $autoinst -n "Hit <RETURN> to continue >> "
         $CLEAR
         return
      else
         $CLEAR
      fi
   fi

   $INFOTEXT -u "\nChoosing Grid Engine admin user account"

   $INFOTEXT "\nYou may install Grid Engine that all files are created with the user id of an\n" \
             "unprivileged user.\n\n" \
             "This will make it possible to install and run Grid Engine in directories\n" \
             "where user >root< has no permissions to create and write files and directories.\n\n" \
             "   - Grid Engine still has to be started by user >root<\n\n" \
             "   - this directory should be owned by the Grid Engine administrator\n"

   $INFOTEXT -auto $autoinst -ask "y" "n" -def "y" -n \
             "Do you want to install Grid Engine\n" \
             "under an user id other than >root< (y/n) [y] >> "

   if [ $? = 0 ]; then
      done=false
      while [ $done = false ]; do
         $CLEAR
         $INFOTEXT -u "\nChoosing a Grid Engine admin user name"
         $INFOTEXT -n "\nPlease enter the user name (or >root<) >> "
         INP=`Enter ""`
         $V5UTILBIN/checkuser -check "$INP"
         if [ $? != 0 ]; then
            $INFOTEXT "User >%s< does not exist - please correct the username" $INP
            $INFOTEXT -wait -auto $autoinst -n "Hit <RETURN> to continue >> "
            $CLEAR
         else
            $INFOTEXT "\nInstalling Grid Engine as user >%s<\n" $INP
            ADMINUSER=$INP
            if [ $ADMINUSER = root ]; then
               ADMINUSER=default
            fi
            $INFOTEXT -wait -auto $autoinst -n "Hit <RETURN> to continue >> "
            $CLEAR
            done=true
         fi
      done
   else
      $INFOTEXT "\nInstalling Grid Engine as user >root<\n"
      ADMINUSER=default
      $INFOTEXT -wait -auto $autoinst -n "Hit <RETURN> to continue >> "
      $CLEAR
   fi
}

#-------------------------------------------------------------------------
# CheckForCommdPort
#
CheckForCommdPort()
{
   host_type=$1
   if [ $resport = true ]; then
      qmaster_port_max=1023
   else
      qmaster_port_max=65500
   fi

   $V5UTILBIN/getservbyname $QSYST_SERVICE  >/dev/null 2>&1
   ret=$?

   if [ "$SGE_QMASTER_PORT" != "" -a "$SGE_EXECD_PORT" != "" ]; then
      $INFOTEXT -u "\nGrid Engine TCP/IP communication service"
      if [ $SGE_QMASTER_PORT -ge 1 -a $SGE_QMASTER_PORT -le $qmaster_port_max -a $SGE_EXECD_PORT -ge 1 -a $SGE_EXECD_PORT -le $execd_port_max ]; then
         $INFOTEXT "\nUsing the environment variable\n\n" \
                   "   \$SGE_QMASTER_PORT=%s\n\n" \
                     "as port for communication with >sge_qmaster<.\n\n" $SGE_QMASTER_PORT
         $INFOTEXT "\nUsing the environment variable\n\n" \
                   "   \$SGE_EXECD_PORT=%s\n\n" \
                     "as port for communication with >sge_execd<.\n\n" $SGE_EXECD_PORT
         if [ $ret = 0 ]; then
            $INFOTEXT "This overrides the preset TCP/IP service >%s<.\n" $QSYST_SERVICE
         fi
         $INFOTEXT -wait -auto $autoinst -n "Hit <RETURN> to continue >> "
         $CLEAR
         return
      else
         $INFOTEXT "\nThe environment variable\n\n" \
                   "   \$SGE_QMASTER_PORT=%s\nor\n    \$SGE_EXECD_PORT=%s\n\n" \
                   "has an invalid value (it must be in range 1..%s).\n\n" \
                   "Please set the environment variable(s) and restart\n" \
                   "the installation or configure the service >%s<." $SGE_QMASTER_PORT $SGE_EXECD_PORT $qmaster_port_max $QSYST_SERVICE
      fi
   fi

   $INFOTEXT -u "\nGrid Engine TCP/IP service >%s<" $QSYST_SERVICE
   if [ $ret != 0 ]; then
      $INFOTEXT "\nThere is no service >%s< available in your >/etc/services< file\n" \
                "or in your NIS/NIS+ database.\n\n" \
                "You may add this service now to your services database or choose a port number.\n" \
                "It is recommended to add the service now. If you are using NIS/NIS+ you should\n" \
                "add the service at your NIS/NIS+ server and not to the local >/etc/services<\n" \
                "file.\n\n" \
                "Please add an entry in the form\n\n" \
                "   %s <port_number>/tcp\n\n" \
                "to your services database and make sure to use an unused port number.\n" $QSYST_SERVICE $QSYST_SERVICE

      if [ "$host_type" = "exec" ]; then

         $INFOTEXT "Make sure to use the same port number as on the qmaster machine\n"
      fi
      $INFOTEXT -wait -auto $autoinst -n "Please add the service now or continue to enter a port number >> "

      # Check if $QSYST_SERVICE service is available now
      service_available=false
      done=false
      while [ $done = false ]; do
         $V5UTILBIN/getservbyname $QSYST_SERVICE 2>/dev/null
         if [ $? != 0 ]; then
            $CLEAR
            $INFOTEXT -u "\nNo TCP/IP service >%s< yet" $QSYST_SERVICE
            $INFOTEXT "\nThere is still no service for >%s< available.\n\n" \
                      "If you have just added the service it may take a while until the service\n" \
                      "propagates in your network. If this is true we can again check for\n" \
                      "the service >%s<. If you don't want to add this service or if\n" \
                      "you want to install Grid Engine just for testing purposes you can enter\n" \
                      "a port number.\n" $QSYST_SERVICE $QSYST_SERVICE

            $INFOTEXT -auto $autoinst -ask "y" "n" -def "y" -n \
                      "Check again (if not you need to enter a port number later) (y/n) [y] >> "
            if [ $? = 0 ]; then
               :
            else
               $INFOTEXT -n "Please enter an unused port number >> "
               INP=`Enter ""`
               chars=`echo $INP | wc -c`
               chars=`expr $chars - 1`
               digits=`expr $INP : "[0-9][0-9]*"`
               if [ "$chars" != "$digits" ]; then
                  $INFOTEXT "\nInvalid input. Must be a number."
               elif [ $INP -le 1 -o $INP -ge $qmaster_port_max ]; then
                  $INFOTEXT "\nInvalid port number. Must be in range [1..%s]." $qmaster_port_max
               elif [ $INP -le 1024 -a $euid != 0 ]; then
                  $INFOTEXT "\nYou are not user >root<. You need to use a port above 1024."
               else
                  ser=`awk '{ print $2 }' /etc/services | grep "^${INP}/tcp"`
                  if [ "$ser" = "$INP/tcp" ]; then
                     $INFOTEXT "\nFound service with port number >%s< in >/etc/services<. Choose again." "$INP"
                     done=false
                  else
                     done=true
                  fi
                  execd_inp=`expr ${INP} + 1` 
                  ser=`awk '{ print $2 }' /etc/services | grep "^${execd_inp}/tcp"`
                  if [ "$ser" = "$execd_inp/tcp" ]; then
                     $INFOTEXT "\nNeed an additional port for exec daemons (SGE_EXECD_PORT = SGE_QMASTER_PORT + 1)" 
                     $INFOTEXT "\nFound service with port number >%s< in >/etc/services<. Choose again." "$execd_inp"
                     done=false
                  else
                     done=true
                  fi
               fi
               if [ $done = false ]; then
                  $INFOTEXT -wait -auto $autoinst -n "Hit <RETURN> to continue >> "
               fi
            fi
         else
            done=true
            service_available=true
         fi
      done

      if [ $service_available = false ]; then
         SGE_QMASTER_PORT=$INP
         export SGE_QMASTER_PORT
         SGE_EXECD_PORT=`expr ${SGE_QMASTER_PORT} + 1`
         export SGE_EXECD_PORT
         $INFOTEXT "\nUsing port >%s<. No service >%s< available.\n" $SGE_QMASTER_PORT $QSYST_SERVICE
         $INFOTEXT "\nUsing port >%s< for execution daemons.\n" $SGE_EXECD_PORT
         $INFOTEXT -wait -auto $autoinst -n "Hit <RETURN> to continue >> "
         $CLEAR
      else
         unset SGE_QMASTER_PORT
         unset SGE_EXECD_PORT
         $INFOTEXT "\nService >%s< is now available.\n" $QSYST_SERVICE
         $INFOTEXT -wait -auto $autoinst -n "Hit <RETURN> to continue >> "
         $CLEAR
      fi
   else
      $INFOTEXT "\nUsing the service\n\n" \
                "   %s\n\n" \
                "for communication with Grid Engine.\n" $QSYST_SERVICE
      $INFOTEXT -wait -auto $autoinst -n "Hit <RETURN> to continue >> "
      $CLEAR
   fi
}
#-------------------------------------------------------------------------
# GetCell
#
GetCell()
{
   if [ $fast = true ]; then
      return
   fi

   $CLEAR
   $INFOTEXT -u "\nGrid Engine cells"
   $INFOTEXT -n "\nGrid Engine supports multiple cells.\n\n" \
                "If you are not planning to run multiple Grid Engine clusters or if you don't\n" \
                "know yet what is a Grid Engine cell it is safe to keep the default cell name\n\n" \
                "   default\n\n" \
                "If you want to install multiple cells you can enter a cell name now.\n\n" \
                "The environment variable\n\n" \
                "   \$SGE_CELL=<your_cell_name>\n\n" \
                "will be set for all further Grid Engine commands.\n\n" \
                "Enter cell name or hit <RETURN> to use default cell >default< >> "
   INP=`Enter default`
   eval $QSYST_CELL=$INP
   QSYST_CELL_VAL=`eval echo '$'$QSYST_CELL`

   $INFOTEXT -wait -auto $autoinst -n "\nUsing cell >%s<. Hit <RETURN> to continue >> " $QSYST_CELL_VAL
   $CLEAR
}

#-------------------------------------------------------------------------
# GetQmasterSpoolDir()
#
GetQmasterSpoolDir()
{
   euid=$1

   done=false
   while [ $done = false ]; do
      $CLEAR
      $INFOTEXT -u "\nGrid Engine qmaster spool directory"
      $INFOTEXT "\nThe qmaster spool directory is the place where the qmaster daemon stores\n" \
                "the configuration and the state of the queuing system.\n\n"

      if [ $euid = 0 ]; then
         if [ $ADMINUSER = default ]; then
            $INFOTEXT "User >root< on this host must have read/write accessto the qmaster\n" \
                      "spool directory.\n"
         else
            $INFOTEXT "The admin user >%s< must have read/write access\n" \
                      "to the qmaster spool directory.\n" $ADMINUSER
         fi
      else
         $INFOTEXT "Your account on this host must have read/write access\n" \
                   "to the qmaster spool directory.\n"
      fi

      $INFOTEXT -n "If you will install shadow master hosts or if you want to be able to start\n" \
                   "the qmaster daemon on other hosts (see the corresponding sectionin the\n" \
                   "Grid Engine Installation and Administration Manual for details) the account\n" \
                   "on the shadow master hosts also needs read/write access to this directory.\n\n" \
                   "Enter spool directory or hit <RETURN> to use default\n" \
                   "[%s] >> " \
                   $QSYST_ROOT_VAL/$QSYST_CELL_VAL/spool/qmaster

      QMDIR=`Enter $QSYST_ROOT_VAL/$QSYST_CELL_VAL/spool/qmaster`

      $INFOTEXT "\nThe following directory has been selected as qmaster spool directory:\n\n" \
                "   %s\n" $QMDIR

      $INFOTEXT -auto $autoinst -ask "y" "n" -def "n" -n \
                "Do you want to select another qmaster spool directory (y/n) [n] >> "

      if [ $? = 1 ]; then
         done=true
      fi
   done
}

#-------------------------------------------------------------------------
# CheckQmasterInstallation
#
CheckQmasterInstallation()
{
   $CLEAR
   $INFOTEXT -u "\nGrid Engine cells"
   $INFOTEXT -n "\nPlease enter cell name which you used for the qmaster\n" \
                "installation or press <RETURN> to use default cell >default< >> "
   INP=`Enter ""`
   if [ "$INP" = "" ]; then
      eval $QSYST_CELL=default
   else
      eval $QSYST_CELL=$INP
   fi

   QSYST_CELL_VAL=`eval echo '$'$QSYST_CELL`

   SetCellDependentVariables

   if [ ! -f $COMMONDIR/act_qmaster -o ! -f $COMMONDIR/bootstrap ]; then
      $INFOTEXT "\nObviously there was no qmaster installation yet!\nCall >install_qmaster<\n" \
                  "on the machine which shall run the Grid Engine qmaster\n"
      exit 1
   else
      $INFOTEXT "\nUsing cell: >%s<\n" $QSYST_CELL_VAL
   fi

   $INFOTEXT -wait -auto $autoinst -n "Hit <RETURN> to continue >> "
   $CLEAR

   user=`grep admin_user $COMMONDIR/bootstrap | awk '{ print $2 }'`

   if [ "$user" != "" ]; then
      if [ `echo "$user" |tr "A-Z" "a-z"` = "none" ]; then
         user=default
      fi
   fi

   if [ "$ADMINUSER" != "$user" ]; then
      if [ "$user" = default ]; then
         $INFOTEXT "The admin user >%s< is different than the default user >root<\n" \
                   "in the boostrap file.\n" $ADMINUSER
      else
         $INFOTEXT "The admin user >%s< doesn't match the admin username >%s<\n" \
                   "in the boostrap file.\n" $ADMINUSER $user
      fi
      $INFOTEXT "Installation failed. Exit."
      exit 1
   fi
}

#-------------------------------------------------------------------------
# AddQsystStartUpScript: Add startup script to rc files if root installs
#
AddQsystStartUpScript()
{
   euid=$1
   create=$2

   $CLEAR
   $INFOTEXT -u "\nGrid Engine startup script"
   $ECHO
   TMP_V5_STARTUP_FILE=/tmp/rcsge.$$
   STARTUP_FILE_NAME=rcsge
   S95NAME=S95rcsge

   if [ -f $TMP_V5_STARTUP_FILE ]; then
      Execute rm $TMP_V5_STARTUP_FILE
   fi
   if [ -f ${TMP_V5_STARTUP_FILE}.0 ]; then
      Execute rm ${TMP_V5_STARTUP_FILE}.0
   fi
   if [ -f ${TMP_V5_STARTUP_FILE}.1 ]; then
      Execute rm ${TMP_V5_STARTUP_FILE}.1
   fi

   V5_STARTUP_FILE=$QSYST_ROOT_VAL/$COMMONDIR/$STARTUP_FILE_NAME

   if [ $create = true ]; then

      Execute sed -e "s%GENROOT%${QSYST_ROOT_VAL}%g" \
                  -e "s%GENCELL%${QSYST_CELL_VAL}%g" \
                  -e "/#+-#+-#+-#-/,/#-#-#-#-#-#/d" \
                  util/startup_template > ${TMP_V5_STARTUP_FILE}.0

      if [ "$SGE_QMASTER_PORT" != "" -a "$SGE_EXECD_PORT" != "" ]; then
         Execute sed -e "s/=GENSGE_QMASTER_PORT/=$SGE_QMASTER_PORT/" \
                     -e "s/=GENSGE_EXECD_PORT/=$SGE_EXECD_PORT/"     \
                     ${TMP_V5_STARTUP_FILE}.0 > $TMP_V5_STARTUP_FILE
      else
         Execute sed -e "/GENSGE_QMASTER_PORT/d" \
                     -e "/GENSGE_EXECD_PORT/d"   \
                     ${TMP_V5_STARTUP_FILE}.0 > $TMP_V5_STARTUP_FILE
      fi

      ExecuteAsAdmin $CP $TMP_V5_STARTUP_FILE $V5_STARTUP_FILE
      ExecuteAsAdmin $CHMOD a+x $V5_STARTUP_FILE

      rm -f $TMP_V5_STARTUP_FILE ${TMP_V5_STARTUP_FILE}.0 ${TMP_V5_STARTUP_FILE}.1

      if [ $euid = 0 -a $ADMINUSER != default -a $WHICH = "qmaster" ]; then
         AddDefaultManager root $ADMINUSER
         AddDefaultOperator $ADMINUSER
      elif [ $euid != 0 ]; then
         AddDefaultManager $USER
         AddDefaultOperator $USER
      fi

      $INFOTEXT "Your Grid Engine cluster wide startup script is installed as:\n\n" \
                "   %s<\n\n" $V5_STARTUP_FILE
      $INFOTEXT -wait -auto $autoinst -n "Hit <RETURN> to continue >> "
   fi

   $CLEAR

   if [ $euid != 0 ]; then
      return 0
   fi

   $INFOTEXT -u "\nGrid Engine startup script"

   # --- from here only if root installs ---
   $INFOTEXT -auto $autoinst -ask "y" "n" -def "y" -n \
             "\nWe can install the startup script that\n" \
             "Grid Engine is started at machine boot (y/n) [y] >> "

   if [ $? = 1 ]; then
      $CLEAR
      return
   fi

   # If we have System V we need to put the startup script to $RC_PREFIX/init.d
   # and make a link in $RC_PREFIX/rc2.d to $RC_PREFIX/init.d
   if [ "$RC_FILE" = "sysv_rc" ]; then
      $INFOTEXT "Installing startup script %s" "$RC_PREFIX/$RC_DIR/$S95NAME"
      Execute rm -f $RC_PREFIX/$RC_DIR/$S95NAME
      Execute cp $V5_STARTUP_FILE $RC_PREFIX/init.d/$STARTUP_FILE_NAME
      Execute chmod a+x $RC_PREFIX/init.d/$STARTUP_FILE_NAME
      Execute ln -s $RC_PREFIX/init.d/$STARTUP_FILE_NAME $RC_PREFIX/$RC_DIR/$S95NAME

      # runlevel management in Linux is different -
      # each runlevel contains full set of links
      # RedHat uses runlevel 5 and SUSE runlevel 3 for xdm
      # RedHat uses runlevel 3 for full networked mode
      # Suse uses runlevel 2 for full networked mode
      # we already installed the script in level 3
      if [ $ARCH = linux -o $ARCH = glinux -o $ARCH = alinux -o $ARCH = slinux ]; then
         runlevel=`grep "^id:.:initdefault:"  /etc/inittab | cut -f2 -d:`
         if [ "$runlevel" = 2 -o  "$runlevel" = 5 ]; then
            $INFOTEXT "Installing startup script also in %s" "$RC_PREFIX/rc${runlevel}.d/$S95NAME"
            Execute rm -f $RC_PREFIX/rc${runlevel}.d/$S95NAME
            Execute ln -s $RC_PREFIX/init.d/$STARTUP_FILE_NAME $RC_PREFIX/rc${runlevel}.d/$S95NAME
         fi
      fi
   elif [ "$RC_FILE" = "insserv-linux" ]; then
      echo  cp $V5_STARTUP_FILE $RC_PREFIX/$STARTUP_FILE_NAME
      echo /sbin/insserv $RC_PREFIX/$STARTUP_FILE_NAME
      Execute cp $V5_STARTUP_FILE $RC_PREFIX/$STARTUP_FILE_NAME
      /sbin/insserv $RC_PREFIX/$STARTUP_FILE_NAME
   elif [ "$RC_FILE" = "freebsd" ]; then
      echo  cp $V5_STARTUP_FILE $RC_PREFIX/sge${RC_SUFFIX}
      Execute cp $V5_STARTUP_FILE $RC_PREFIX/sge${RC_SUFFIX}
   else
      # if this is not System V we simple add the call to the
      # startup script to RC_FILE

      # Start-up script already installed?
      #------------------------------------
      grep $STARTUP_FILE_NAME $RC_FILE > /dev/null 2>&1
      status=$?
      if [ $status != 0 ]; then
         $INFOTEXT "Adding application startup to %s" $RC_FILE
         # Add the procedure
         #------------------
         $ECHO "" >> $RC_FILE
         $ECHO "" >> $RC_FILE
         $ECHO "# Grid Engine start up" >> $RC_FILE
         $ECHO "#-$LINE---------" >> $RC_FILE
         $ECHO $V5_STARTUP_FILE >> $RC_FILE
      else
         $INFOTEXT "Found a call of %s in %s. Replacing with new call.\n" \
                   "Your old file %s is saved as %s" $STARTUP_FILE_NAME $RC_FILE $RC_FILE $RC_FILE.org.1

         mv $RC_FILE.org.3 $RC_FILE.org.4    2>/dev/null
         mv $RC_FILE.org.2 $RC_FILE.org.3    2>/dev/null
         mv $RC_FILE.org.1 $RC_FILE.org.2    2>/dev/null

         # save original file modes of RC_FILE
         uid=`$V5UTILBIN/filestat -uid $RC_FILE`
         gid=`$V5UTILBIN/filestat -gid $RC_FILE`
         perm=`$V5UTILBIN/filestat -mode $RC_FILE`

         Execute cp $RC_FILE $RC_FILE.org.1

         savedfile=`basename $RC_FILE`

         sed -e "s%.*$STARTUP_FILE_NAME.*%$V5_STARTUP_FILE%" \
                 $RC_FILE > /tmp/$savedfile.1

         Execute cp /tmp/$savedfile.1 $RC_FILE
         Execute chown $uid $RC_FILE
         Execute chgrp $gid $RC_FILE
         Execute chmod $perm $RC_FILE
         Execute rm -f /tmp/$savedfile.1
      fi
   fi

   $INFOTEXT -wait -auto $autoinst -n "\nHit <RETURN> to continue >> "
   $CLEAR
}

#-------------------------------------------------------------------------
# AddHostsFromFile: Get a list of hosts and add them as
# admin and submit hosts
#
AddHostsFromFile()
{
   file=$1
   done=false
   while [ $done = false ]; do
      $CLEAR
      $INFOTEXT -u "\nAdding admin and submit hosts from file"
      $INFOTEXT -n "\nPlease enter the file name which contains the host list: "
      file=`Enter none`
      if [ "$file" = "none" -o ! -f "$file" ]; then
         $INFOTEXT "\nYou entered an invalid file name or the file does not exist."
         $INFOTEXT -auto $autoinst -ask "y" "n" -def "y" -n \
                   "Do you want to enter a new file name (y/n) [y] >> "
         if [ $? = 1 ]; then
            return 1
         fi
      else
         for h in `cat $file`; do
            $V5BIN/qconf -ah $h
            $V5BIN/qconf -as $h
         done
         done=true
      fi
   done
}

#-------------------------------------------------------------------------
# AddHostsFromTerminal
#    Get a list of hosts and add the mas admin and submit hosts
#
AddHostsFromTerminal()
{
   stop=false
   while [ $stop = false ]; do
      $CLEAR
      $INFOTEXT -u "\nAdding admin and submit hosts"
      $INFOTEXT "\nPlease enter a blank seperated list of hosts.\n\n" \
                "Stop by entering <RETURN>. You may repeat this step until you are\n" \
                "entering an empty list. You will see messages from Grid Engine\n" \
                "when the hosts are added.\n"

      $INFOTEXT -n "Host(s): "

      hlist=`Enter ""`
      for h in $hlist; do
         $V5BIN/qconf -ah $h
         $V5BIN/qconf -as $h
      done
      if [ "$hlist" = "" ]; then
         stop=true
      else
         $INFOTEXT -wait -auto $autoinst -n "Hit <RETURN> to continue >> "
      fi
  done
}

#-------------------------------------------------------------------------
# AddHosts
#
AddHosts()
{
   $INFOTEXT -u "\nAdding Grid Engine hosts"
   $INFOTEXT "\nPlease now add the list of hosts, where you will later install your execution\n" \
             "daemons. These hosts will be also added as valid submit hosts.\n\n" \
             "Please enter a blank separated list of your execution hosts. You may\n" \
             "press <RETURN> if the line is getting too long. Once you are finished\n" \
             "simply press <RETURN> without entering a name.\n\n" \
             "You also may prepare a file with the hostnames of the machines where you plan\n" \
             "to install Grid Engine. This may be convenient if you are installing Grid\n" \
             "Engine on many hosts.\n\n"

   $INFOTEXT -auto $autoinst -ask "y" "n" -def "n" -n \
             "Do you want to use a file which contains the list of hosts (y/n) [n] >> "
   ret=$?
   if [ $ret = 0 ]; then
      AddHostsFromFile
      ret=$?
   fi

   if [ $ret = 1 ]; then
      AddHostsFromTerminal
   fi

   $INFOTEXT -wait -auto $autoinst -n "Finished adding hosts. Hit <RETURN> to continue >> "
   $CLEAR

   $INFOTEXT -u "\nCreating the default <all.q> queue and <allhosts> hostgroup"
   TMPL=/tmp/hostqueue$$
   TMPL2=${TMPL}.q
   rm -f $TMPL $TMPL2
   if [ -f $TMPL -o -f $TMPL2 ]; then
      $INFOTEXT "\nCan't delete template files >%s< or >%s<" "$TMPL" "$TMPL2"
   else
      PrintHostGroup @allhosts > $TMPL
      Execute $V5BIN/qconf -Ahgrp $TMPL
      Execute $V5BIN/qconf -sq > $TMPL
      Execute sed -e "/qname/s/template/all.q/" \
                  -e "/hostlist/s/NONE/@allhosts/" \
                  -e "/pe_list/s/NONE/make/" $TMPL > $TMPL2
      Execute $V5BIN/qconf -Aq $TMPL2
      rm -f $TMPL $TMPL2        
   fi

   $INFOTEXT -wait -auto $autoinst -n "\nHit <RETURN> to continue >> "
   $CLEAR
}

#-------------------------------------------------------------------------
# AddQueue
#
AddQueue()
{
   if [ $addqueue = false ]; then
      return
   fi

   exechost=`$V5UTILBIN/gethostname -name | cut -f1 -d.`

   slots=`$V5UTILBIN/loadcheck -loadval num_proc 2>/dev/null | sed "s/num_proc *//"`

   $INFOTEXT -u "\nAdding a queue for this host"
   $INFOTEXT "\nWe can now add a queue instance for this host:\n\n" \
             "   - it is added to the >allhosts< hostgroup\n" \
             "   - the queue provides %s slot(s) for jobs in all queues\n" \
             "     referencing the >allhosts< hostgroup\n\n" \
             "You do not need to add this host now, but before running jobs on this host\n" \
             "it must be added to at least one queue.\n" $slots

   $INFOTEXT -auto $autoinst -ask "y" "n" -def "y" -n \
             "Do you want to add a default queue instance for this host (y/n) [y] >> "

   if [ $? = 0 ]; then
      $V5BIN/qconf -aattr hostgroup hostlist $exechost @allhosts
      $V5BIN/qconf -aattr queue slots "[$exechost=$slots]" all.q
      $INFOTEXT -wait -auto $autoinst -n "\nHit <RETURN> to continue >> "
      $CLEAR
   fi
}

#-------------------------------------------------------------------------
# CreateSettingsFile: Create resource files for csh/sh
#
CreateSettingsFile()
{
   $INFOTEXT "Creating settings files for >.profile/.cshrc<"

   if [ -f $QSYST_ROOT_VAL/$COMMONDIR/settings.sh ]; then
      ExecuteAsAdmin $RM $QSYST_ROOT_VAL/$COMMONDIR/settings.sh
   fi

   if [ -f $QSYST_ROOT_VAL/$COMMONDIR/settings.csh ]; then
      ExecuteAsAdmin $RM $QSYST_ROOT_VAL/$COMMONDIR/settings.csh
   fi

   ExecuteAsAdmin util/create_settings.sh $QSYST_ROOT_VAL/$COMMONDIR

   SetPerm $QSYST_ROOT_VAL/$COMMONDIR/settings.sh
   SetPerm $QSYST_ROOT_VAL/$COMMONDIR/settings.csh
}

#--------------------------------------------------------------------------
# SetCellDependentVariables
#
SetCellDependentVariables()
{
   COMMONDIR=$QSYST_CELL_VAL/common
   LCONFDIR=$QSYST_CELL_VAL/common/local_conf
   CASHAREDDIR=$COMMONDIR/sgeCA
}

#--------------------------------------------------------------------------
#
WelcomeTheUser()
{
   if [ $autoinst = true ]; then
      return
   fi

   if [ $inst = sgeee ]; then
      $INFOTEXT -u "\nWelcome to the Grid Engine Enterprise Edition installation"
   else 
      $INFOTEXT -u "\nWelcome to the Grid Engine installation"
   fi

   $INFOTEXT -u "\nGrid Engine qmaster host installation"
   $INFOTEXT "\nBefore you continue with the installation please read these hints:\n\n" \
             "   - Your terminal window should have a size of at least\n" \
             "     80x24 characters\n\n" \
             "   - The INTR character is often bound to the key Ctrl-C.\n" \
             "     The term >Ctrl-C< is used during the installation if you\n" \
             "     have the possibility to abort the installation\n\n" \
             "The qmaster installation procedure will take approximately 5-10 minutes.\n"
   $INFOTEXT -wait -auto $autoinst -n "Hit <RETURN> to continue >> "
   $CLEAR
}

#--------------------------------------------------------------------------
# WelcomeTheUserExecHost
#
WelcomeTheUserExecHost()
{
   if [ $autoinst = true ]; then
      return
   fi
 
   $INFOTEXT -u "\nWelcome to the Grid Engine execution host installation"
   $INFOTEXT "\nIf you haven't installed the Grid Engine qmaster host yet, you must execute\n" \
             "this step (with >install_qmaster<) prior the execution host installation.\n\n" \
             "For a sucessfull installation you need a running Grid Engine qmaster. It is\n" \
             "also neccesary that this host is an administrative host.\n\n" \
             "You can verify your current list of administrative hosts with\n" \
             "the command:\n\n" \
             "   # qconf -sh\n\n" \
             "You can add an administrative host with the command:\n\n" \
             "   # qconf -ah <hostname>\n\n" \
             "The execution host installation will take approximately 5 minutes.\n"

   $INFOTEXT -wait -auto $autoinst -n "Hit <RETURN> to continue >> "
   $CLEAR
}

#--------------------------------------------------------------------------
# WelcomeTheUserSubmit
#
WelcomeTheUserSubmit()
{
   $INFOTEXT -u "\nGrid Engine submit host installation"
   $INFOTEXT "\nAdding a submit host to the Grid Engine cluster is done with the command:\n\n" \
             "   # qconf -as <hostname>\n\n" \
               "This command must be entered from a machine which is an administration host.\n" \
               "The qmaster host by default is an administration host."
}

#--------------------------------------------------------------------------
# StartQmaster
#
StartQmaster()
{
   $INFOTEXT -u "\nGrid Engine qmaster and scheduler startup"
   $INFOTEXT "\nStarting qmaster and scheduler daemon. Please wait ..."
   $V5_STARTUP_FILE -qmaster
   $INFOTEXT -wait -auto $autoinst -n "Hit <RETURN> to continue >> "
   $CLEAR
}

#--------------------------------------------------------------------------
# StartExecd
#
StartExecd()
{
   $INFOTEXT -u "\nGrid Engine execution daemon startup"
   $INFOTEXT "\nStarting execution daemon daemon. Please wait ..."
   $V5_STARTUP_FILE -execd
   $INFOTEXT -wait -auto $autoinst -n "\nHit <RETURN> to continue >> "
   $CLEAR
}

#--------------------------------------------------------------------------
# CheckBinaries
#
CheckBinaries()
{

BINFILES="sge_coshepherd \
          sge_execd sge_qmaster  \
          sge_schedd sge_shadowd \
          sge_shepherd qacct qalter qconf qdel qhold \
          qhost qlogin qmake qmod qmon qresub qrls qrsh qselect qsh qstat qsub qtcsh"

UTILFILES="adminrun checkprog checkuser filestat gethostbyaddr gethostbyname \
           gethostname getservbyname loadcheck now qrsh_starter rlogin rsh rshd \
           testsuidroot uidgid infotext"

THIRD_PARTY_FILES=openssl

   missing=false
   for f in $BINFILES; do
      if [ \! -f $V5BIN/$f ]; then
         missing=true
         $INFOTEXT "missing program >%s< in directory >%s<" $f $V5BIN
      fi
   done

   for f in $THIRD_PARTY_FILES; do
      if [ $f = openssl -a $csp = true ]; then
         if [ ! -f $V5UTILBIN/$f ]; then
           missing=true
           $INFOTEXT "missing program >%s< in directory >%s<" $f $V5BIN
         fi
      fi
   done

   for f in $UTILFILES; do
      if [ ! -f $V5UTILBIN/$f ]; then
         missing=true
         $INFOTEXT "missing program >%s< in directory >%s<" $f $V5UTILBIN
      fi
   done

   if [ $missing = true ]; then
      $INFOTEXT "\nMissing Grid Engine binaries!\n\n" \
      "A complete installation needs the following binaries in >%s<:\n\n" \
      "qacct           qlogin          qrsh            sge_shepherd\n" \
      "qalter          qmake           qselect         sge_coshepherd  \n" \
      "qconf           qmod            qsh             sge_execd\n" \
      "qdel            qmon            qstat           sge_qmaster\n" \
      "qhold           qresub          qsub            sge_schedd\n" \
      "qhost           qrls            qtcsh           sge_shadowd\n\n" \
      "The binaries in >%s< are:\n\n" \
      "adminrun       gethostbyaddr  loadcheck      rlogin         uidgid\n" \
      "checkprog      gethostbyname  now            rsh            infotext\n" \
      "checkuser      gethostname    openssl        rshd\n" \
      "filestat       getservbyname  qrsh_starter   testsuidroot\n\n" \
      "Installation failed. Exit.\n" $V5BIN $V5UTILBIN
      exit 1
   fi
}

#--------------------------------------------------------------------------
# SetPermissions
#    - set permission for regular files to 644
#    - set permission for executables and directories to 755
#
SetPermissions()
{
   $CLEAR
   $INFOTEXT -u "\nVerifying and setting file permissions"
   $ECHO

   euid=`$V5UTILBIN/uidgid -euid`

   if [ $euid != 0 ]; then
      $INFOTEXT "You are not installing as user >root<\n"
      $INFOTEXT "Can't set the file owner/group and permissions\n"
      $INFOTEXT -wait -auto $autoinst -n "Hit <RETURN> to continue >> "
      $CLEAR
      return 0
   else
      $INFOTEXT -auto $autoinst -ask "y" "n" -def "y" -n \
                "Did you install this version with >pkgadd< or did you already\n" \
                "verify and set the file permissions of your distribution (y/n) [y] >> "
      if [ $? = 0 ]; then
         $INFOTEXT -wait -auto $autoinst -n "We do not verify file permissions. Hit <RETURN> to continue >> "
         $CLEAR
         return 0
      fi
   fi

   rm -f ./tst$$ 2> /dev/null > /dev/null
   touch ./tst$$ 2> /dev/null > /dev/null
   ret=$?
   rm -f ./tst$$ 2> /dev/null > /dev/null
   if [ $ret != 0 ]; then
      $INFOTEXT -u "\nVerifying and setting file permissions (continued)"

      $INFOTEXT "\nWe can't set file permissions on this machine, because user root\n" \
                  "has not the necessary privileges to change file permissions\n" \
                  "on this file system.\n" \
                  "Probably this file system is an NFS mount where user root is\n" \
                  "mapped to user >nobody<.\n" \
                  "Please login now at your file server and set the file permissions and\n" \
                  "ownership of the entire distribution with the command:\n" \
                  "   # \$SGE_ROOT/util/setfileperm.sh <adminuser> <admingroup> \$SGE_ROOT\n\n" \
                  "where <adminuser> and <admingroup> are the Unix user/group names under which\n" \
                  "the files should be installed and created.\n\n"

      $INFOTEXT -wait -auto $autoinst -n "Please hit <RETURN> to continue once you set your file permissions >> "
      $CLEAR
      return 0
   elif [ $fast = false ]; then
      $CLEAR
      $INFOTEXT -u "\nVerifying and setting file permissions"
      $INFOTEXT "\nWe may now verify and set the file permissions of your Grid Engine\n" \
                "distribution.\n\n" \
                 "This may be useful since due to unpacking and copying of your distribution\n" \
                 "your files may be unaccessible to other users.\n\n" \
                 "We will set the permissions of directories and binaries to\n\n" \
                 "   755 - that means executable are accessible for the world\n\n" \
                 "and for ordinary files to\n\n" \
                 "   644 - that means readable for the world\n\n"

      $INFOTEXT -auto $autoinst -ask "y" "n" -def "y" -n \
               "Do you want to verify and set your file permissions (y/n) [y] >> "
      ret=$?
   else
      ret=0
   fi

   if [ $ret = 0 ]; then

      if [ $resport = true ]; then
         resportarg=-resport
      else
         resportarg="-noresport"
      fi

      if [ $ADMINUSER = default ]; then
         fileowner=root
      else
         fileowner=$ADMINUSER
      fi

      filegid=`$V5UTILBIN/uidgid -gid`

      $CLEAR

      util/setfileperm.sh -auto $resportarg $fileowner $filegid $SGE_ROOT

      $INFOTEXT -wait -auto $autoinst -n "Hit <RETURN> to continue >> "
   else
      $INFOTEXT -wait -auto $autoinst -n "We will not verify your file permissions. Hit <RETURN> to continue >>"
   fi
   $CLEAR
}

#--------------------------------------------------------------------------
# InitCA Create CA and initialize it for deamons and users
#
InitCA()
{

   if [ $csp = false ]; then
      return
   fi

   # Initialize CA, make directories and get DN info
   #
   util/sgeCA/sge_ca -init -days 365

   if [ $? != 0 ]; then
      CAErrUsage
   fi
   $INFOTEXT -wait -auto $autoinst -n "Hit <RETURN> to continue >> "
   $CLEAR
}


#--------------------------------------------------------------------------
# CheckCSP check that there are no old certs/keys
#
CheckCSP()
{

   if [ $csp = false ]; then
      return
   fi

   if [ "$SGE_QMASTER_PORT" != "" ]; then
      CA_PORT=port$SGE_QMASTER_PORT
   else
      CA_PORT=$QSYST_SERVICE
   fi

   $V5UTILBIN/adminrun $ADMINUSER test -f $HOME/.sge/$CA_PORT/$SGE_CELL
   if [ ! $? ]; then
      $INFOTEXT -e "Please remove the old CSP security directory \$HOME/.sge/\$CA_PORT/\$SGE_CELL. Exit."
      exit 1
   fi
}


#--------------------------------------------------------------------------
# SetSpoolingOptions sets / queries options for the spooling framework
#
SetSpoolingOptions()
{
   $INFOTEXT -u "\nSelect spooling method"
   SPOOLING_METHOD=`ExecuteAsAdmin $SPOOLINIT method`
   $ECHO $SPOOLING_METHOD
   case $SPOOLING_METHOD in 
      classic)
         SPOOLING_LIB=none
         SPOOLING_ARGS="$QSYST_ROOT_VAL/$COMMONDIR;$QMDIR"
         ;;
      berkeleydb)
         SPOOLING_LIB=none
         SPOOLING_SERVER=none
         SPOOLING_DIR="$QMDIR/spooldb"
         params_ok=0
         while [ $params_ok -eq 0 ]; do
            SpoolingQueryChange
            SpoolingCheckParams
            params_ok=$?
         done

         if [ $SPOOLING_SERVER = "none" ]; then
            Makedir $SPOOLING_DIR
            SPOOLING_ARGS="$SPOOLING_DIR"
         else
            SPOOLING_ARGS="$SPOOLING_SERVER:`basename $SPOOLING_DIR`"
         fi
         
         ;;
      *)
         $INFOTEXT -e "\nUnknown spooling method. Exit."
         exit 1
         ;;
   esac
}

SpoolingQueryChange()
{
   $INFOTEXT -u "\nBerkeley Database spooling parameters"
   $INFOTEXT "\nWe can use local spooling, which will go to a local filesystem" \
             "\nor use a RPC Client/Server mechanism. In this case, qmaster will" \
             "\ncontact a RPC server running on a separate server machine." \
             "\nIf you want to use the SGE shadowd, you have to use the " \
             "\nRPC Client/Server mechanism.\n"
   $INFOTEXT "\nEnter database server (none for local spooling)\n" \
             "or hit <RETURN> to use default [%s] >> " $SPOOLING_SERVER
             SPOOLING_SERVER=`Enter $SPOOLING_SERVER`

   $INFOTEXT "\nEnter the database directory\n" \
             "or hit <RETURN> to use default [%s] >> " $SPOOLING_DIR
             SPOOLING_DIR=`Enter $SPOOLING_DIR`
}

SpoolingCheckParams()
{
   # if we use local spooling, check if the database directory is on local fs
   if [ $SPOOLING_SERVER = "none" ]; then
      CheckLocalFilesystem $SPOOLING_DIR
      ret=$?
      if [ $ret -eq 0 ]; then
      $INFOTEXT -e "\nThe database directory >%s<\n" \
                   "is not on a local filesystem.\nPlease choose a local filesystem or configure the RPC Client/Server mechanism" $SPOOLING_DIR
         return 0
      fi
   else 
      # TODO: we should check if the hostname can be resolved
      # create a script to start the rpc server
      CreateRPCServerScript
      $INFOTEXT "Please startup the rc script >%s< on the RPC server machine\n" $COMMONDIR/rcrpc
      $INFOTEXT -wait -auto $autoinst -n "Hit <RETURN> to continue >> "
   fi

   return 1
}

CreateRPCServerScript()
{
   RPCSCRIPT=$COMMONDIR/rcrpc
   Execute sed -e "s%GENROOT%${QSYST_ROOT_VAL}%g" \
               -e "s%GENCELL%${QSYST_CELL_VAL}%g" \
               -e "s%SPOOLING_DIR%${SPOOLING_DIR}%g" \
               -e "/#+-#+-#+-#-/,/#-#-#-#-#-#/d" \
               util/rpc_startup_template > ${RPCSCRIPT}
   Execute $CHMOD a+x $RPCSCRIPT

}

CheckLocalFilesystem()
{  
   FS=`dirname $1`
   case $ARCH in
      solaris*)
         df -l $FS >/dev/null 2>&1
         if [ $? -eq 0 ]; then
            return 1
         else
            return 0
         fi
         ;;
       *linux)
          df -l $FS >/dev/null 2>&1
          if [ $? -eq 0 ]; then
             return 1
          else
             return 0
          fi
          ;;
      *)
         $INFOTEXT "\nDon't know how to test for local filesystem on this architecture!"
         $INFOTEXT -wait -n "\nPlease make sure that the directory $FS is on a local filesystem!\nHit <RETURN> to continue >> "
         return 1
         ;;
   esac

   return 0
}

#--------------------------------------------------------------------------
# THE MAIN PROCEDURE
#--------------------------------------------------------------------------

#-----------------------------------
# FIND ARCH + ARCH SPECIFIC DEFAULTS
#

myname=`basename $0`

cmdline=$*
for arg in $*; do
   if [ "$arg" = -sgeee ]; then
      myname=inst_sgeee
   fi
done

set - $cmdline

if [ $myname = inst_sge ]; then
   inst=sge
   QSYST=SGE
   QSYST_NAME=SGE
   LINE=---
   BLANKS="  "
elif [ $myname = inst_sgeee ]; then
   inst=sgeee
   QSYST=SGEEE
   QSYST_NAME=SGEEE
   LINE=-----
   BLANKS=""
else
   echo  "unknown name of this script: $0"
   echo  "must be either >inst_sge<, >inst_sgeee<"
   echo  "may be the >basename< command is not in your \$PATH"
   echo
   exit 1
fi

QSYST_ROOT=SGE_ROOT
QSYST_CELL=SGE_CELL
QSYST_MASTER_NAME=sge_qmaster
QSYST_EXECD_NAME=sge_execd
QSYST_SCHEDD_NAME=sge_schedd
QSYST_SHEPHERD_NAME=sge_shepherd
QSYST_SHADOWD_NAME=sge_shadowd
QSYST_SERVICE=sge_qmaster

if [ ! -f util/arch_variables ]; then
   echo "missing shell script \"util/arch_variables\""
   exit 1
fi

. ./util/arch_variables

if [ ! -f util/arch ]; then
   $ECHO "missing shell script \"util/arch\""
   exit 1
fi

shlib_path_name=`util/arch -lib`
old_value=`eval echo '$'$shlib_path_name`
if [ x$old_value = x ]; then
   eval $shlib_path_name=lib/$ARCH
else
   eval $shlib_path_name=$old_value:lib/$ARCH
fi
export $shlib_path_name

umask 022

unset GRD_DEBUG_LEVEL
unset COD_DEBUG_LEVEL
unset SGE_DEBUG_LEVEL

unset CODINE_ROOT 
unset GRD_ROOT

V5BIN=bin/$ARCH
V5UTILBIN=utilbin/$ARCH
QSYST_CELL_VAL=`eval echo '$'$QSYST_CELL`
if [ "$QSYST_CELL_VAL" = "" ]; then
   eval $QSYST_CELL=default
   QSYST_CELL_VAL=default
else
   QSYST_CELL_VAL=`eval echo '$'$QSYST_CELL`
fi
export $QSYST_CELL

ADMINUSER=default
MYUID=`$V5UTILBIN/uidgid -uid`
MYGID=`$V5UTILBIN/uidgid -gid`
DIRPERM=755
FILEPERM=644


#---------------------------------------
# setup INFOTEXT begin
#---------------------------------------

# set column break for automatic line break 
SGE_INFOTEXT_MAX_COLUMN=5000; export SGE_INFOTEXT_MAX_COLUMN


# export locale directory 
if [ "$SGE_ROOT" = "" ]; then 
   TMP_SGE_ROOT=`pwd | sed 's/\/tmp_mnt//'`
   GRIDLOCALEDIR="$TMP_SGE_ROOT/locale"
   export GRIDLOCALEDIR
fi

# set infotext binary path
INFOTXT_DUMMY=$V5UTILBIN/infotext
INFOTEXT=$INFOTXT_DUMMY
if [ ! -f $INFOTXT_DUMMY ]; then
   $ECHO "can't find \"$INFOTXT_DUMMY\""
   $ECHO "Installation failed."
   exit 1
fi

#---------------------------------------
# setup INFOTEXT end
#---------------------------------------

#---------------------------------------
# setup SPOOLDEFAULTS and SPOOLINIT start
#---------------------------------------
# set spooldefaults binary path
SPOOLDEFAULTS=$V5UTILBIN/spooldefaults
if [ ! -f $SPOOLDEFAULTS ]; then
   $ECHO "can't find \"$SPOOLDEFAULTS\""
   $ECHO "Installation failed."
   exit 1
fi

SPOOLINIT=$V5UTILBIN/spoolinit
if [ ! -f $SPOOLINIT ]; then
   $ECHO "can't find \"$SPOOLINIT\""
   $ECHO "Installation failed."
   exit 1
fi

#---------------------------------------
# setup SPOOLDEFAULTS and SPOOLINIT end
#---------------------------------------

HOST=`$V5UTILBIN/gethostname -name`
if [ "$HOST" = "" ]; then
   $INFOTEXT -e "can't get hostname of this machine. Installation failed."
   exit 1
fi


#-----------------------------
# commandline argument parsing
#
WHICH="undef"
strict=true
fast=false
autoinst=false
addqueue=true
resport=false
afs=false
csp=false

ARGC=$#
while [ $ARGC != 0 ]; do
   case $1 in
   -m)
      WHICH="qmaster"
      ;;
   -x)
      WHICH="execd"
      ;;
   -s)
      WHICH="submit"
      ;;
   -afs)
      afs=true
      ;;
   -nostrict)
      strict=false
      ;;
   -resport)
      resport=true
      ;;
   -fast)
      fast=true
      ;;
   -auto)
      if [ $WHICH = execd ]; then
         autoinst=true
         CLEAR=:
      fi
      ;;
   -noqueue)
      addqueue=false
      ;;
   -csp)
      csp=true
      ;;
   *)
      $ECHO "" >&2
      $INFOTEXT -e "Error: Unknown option %s" $1
      ErrUsage $0
      ;;
   esac
   shift
   ARGC=`expr $ARGC - 1`
done

if [ "$WHICH" = "undef" ]; then
   ErrUsage $0
fi

# exit if there are missing binaries
#
CheckBinaries

$CLEAR

case $WHICH in
qmaster)
   autoinst=false
   WelcomeTheUser
   PreCheckForFastInstall qmaster
   ret=$?

   if [ $ret = 0 ]; then
      AskIfDefaultOkAndSetVariables
      ret=$?
   fi

   if [ $ret != 0 ]; then
      CheckWhoInstallsQsyst
      ProcessQsystRoot
      CheckForCommdPort qmaster
      GetCell
      GetQmasterSpoolDir $euid
      SetCellDependentVariables
   fi

   SetPermissions
   MakeDirsMaster
   SelectHostNameResolving
   SetProductMode
   SetSpoolingOptions
   AddBootstrap
   InitSpoolingDatabase
   AddConfiguration
   AddLocalConfiguration
   AddActQmaster
   AddDefaultComplexes
   AddPEFiles
   AddDefaultDepartement
   AddCommonFiles
   CreateSettingsFile
   $INFOTEXT -wait -auto $autoinst -n "\nHit <RETURN> to continue >> "
   $CLEAR
   InitCA
   AddQsystStartUpScript $euid true
   StartQmaster
   AddHosts
   GiveHints
   ;;
execd)
   WelcomeTheUserExecHost
   PreCheckForFastInstall execd
   ret=$?
   if [ $ret = 0 ]; then
      AskIfDefaultOkAndSetVariables
      ret=$?
   fi

   if [ $ret != 0 ]; then
      CheckWhoInstallsQsyst
      ProcessQsystRoot
      CheckQmasterInstallation
      CheckForCommdPort exec
   fi
   CheckCellDirectory
   CheckCSP
   if [ "$QMDIR" = "" ];then
      # set qmaster dir
      QMDIR=$QSYST_ROOT_VAL/$QSYST_CELL_VAL/spool/qmaster
   fi
   CheckHostNameResolving
   AddLocalConfiguration_With_Qconf
   AddQsystStartUpScript $euid false
   StartExecd
   AddQueue
   GiveHints
   ;;
submit)
   WelcomeTheUserSubmit
   ;;
esac

exit 0
