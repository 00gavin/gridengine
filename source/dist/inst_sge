#!/bin/sh
#
# SGE/SGEEE installation script
#
#___INFO__MARK_BEGIN__
##########################################################################
#
#  The Contents of this file are made available subject to the terms of
#  the Sun Industry Standards Source License Version 1.2
#
#  Sun Microsystems Inc., March, 2001
#
#
#  Sun Industry Standards Source License Version 1.2
#  =================================================
#  The contents of this file are subject to the Sun Industry Standards
#  Source License Version 1.2 (the "License"); You may not use this file
#  except in compliance with the License. You may obtain a copy of the
#  License at http://gridengine.sunsource.net/Gridengine_SISSL_license.html
#
#  Software provided under this License is provided on an "AS IS" basis,
#  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
#  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
#  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
#  See the License for the specific provisions governing your rights and
#  obligations concerning the Software.
#
#  The Initial Developer of the Original Code is: Sun Microsystems, Inc.
#
#  Copyright: 2001 by Sun Microsystems, Inc.
#
#  All Rights Reserved.
#
##########################################################################
#___INFO__MARK_END__
#
# set -x

# Reset PATH to a safe value
#
PATH=/bin:/usr/bin:/usr/bsd

# Easy way to prevent clearing of screen
#
CLEAR=clear
#CLEAR=:

# set to false if you don't want this script uses the i18n functions
#
SGE_I18N=true

#-------------------------------------------------------------------------
# USEFUL LOCAL SHELL PROCEDURES

#-------------------------------------------------------------------------
# ErrUsage: print usage string, exit
#
ErrUsage()
{
   myname=`basename $0`
   $ECHO "" >&2
   $INFOTEXT -n "Usage: "
   $ECHO       " $myname -m|-x|-s [-nostrict] [-fast] [-auto] [-noqueue] [-csp] [-resport] [-afs]" >&2
   $ECHO       "     -m        \c" >&2
   $INFOTEXT "install qmaster host"
   $ECHO       "     -x        \c" >&2
   $INFOTEXT "install execution host or queueing system transfer host"
   $ECHO       "     -s        \c" >&2
   $INFOTEXT "how to install submit host"
   $ECHO       "     -fast     \c" >&2
   $INFOTEXT "install system with default options"
   $ECHO       "     -nostrict \c" >&2
   $INFOTEXT "do not check %s for write permissions" \$$QSYST_ROOT
   $ECHO       "     -auto     \c" >&2
   $INFOTEXT "auto answer all questions with default, do not wait at prompt"
   $ECHO     "     -csp      \c" >&2
   $INFOTEXT "install system with security framework protocol functionality"
   $ECHO     "     -afs      \c" >&2
   $INFOTEXT "install system with AFS functionality"
   $ECHO       "     -resport  \c" >&2
   $INFOTEXT "install system with reserved port security"
   $ECHO "" >&2

   exit 1
}

#-------------------------------------------------------------------------
# PreCheckForFastInstall: return 0 if all conditions for an accelerated
# installation procedure are met
#
PreCheckForFastInstall()
{

   if [ $resport = true ]; then
      commd_port_max=1023
   else
      commd_port_max=65500
   fi

   # must be first check - sets variable $euid
   euid=`$V5UTILBIN/uidgid -euid`

   if [ $fast = false ]; then
      return 1
   fi

   if [ $euid != 0 ]; then
      return 1
   fi

   $V5UTILBIN/getservbyname $QSYST_SERVICE  >/dev/null 2>&1
   ret=$?

   if [ $ret = 1 -a "$COMMD_PORT" = "" ]; then
      return 1
   fi

   if [ "$COMMD_PORT" != "" ]; then
      if [ "$COMMD_PORT" -le 1 -o $COMMD_PORT -ge $commd_port_max ]; then
         return 1
      fi
   fi


   this_dir_user=`$V5UTILBIN/filestat -owner .`

   if [ $this_dir_user = root ]; then
      touch ./tst$$ 2> /dev/null > /dev/null
      ret=$?
      rm -f ./tst$$
      if [ $ret != 0 ]; then
         return 1
      fi
   else
      ADMINUSER=$this_dir_user
      ExecuteAsAdmin $TOUCH ./tst$$ 2> /dev/null > /dev/null
      ret=$?
      ExecuteAsAdmin $RM -f ./tst$$
      if [ $ret != 0 ]; then
         return 1
      fi
   fi

   return 0
}

#-------------------------------------------------------------------------
# Ask the installer for the host name resolving method
# (IGNORE_FQND=true/false)
#
SelectHostNameResolving()
{
   $CLEAR
   $INFOTEXT -u "\nSelect default hostname resolving method"
   $INFOTEXT "\nAre all hosts of your cluster in one DNS domain? If this is" \
               "the case the host names\n" \
               ">%s< and >%s<\n" \
               "would be treated as eqal, because the DNS domain name >foo.com<" \
               "is ignored when comparing host names.\n" hostA hostA.foo.com

#   Translate 4 "Are all the hosts of your cluster in a single DNS domain"
#   YesNo "\n$transout" y
   $INFOTEXT -auto $autoinst -ask "y" "n" -def "y" -n "Are all the hosts of your cluster" \
               "in a single DNS domain (y/n) [y] >> " 
   if [ $? = 0 ]; then
      IGNORE_FQDN_DEFAULT=true
      $INFOTEXT "Ignoring domainname when comparing hostnames."
   else
      IGNORE_FQDN_DEFAULT=false
      $INFOTEXT "The domainname is not ignored when comparing hostnames."
   fi
   $ECHO
   WaitClear clear
}

#-------------------------------------------------------------------------
# Check whether the qmaster is installed and the file systems is shared
#
CheckCellDirectory()
{
   $CLEAR
   check_cell_error=0
   error_text=0
   if [ ! -d $COMMONDIR ]; then
      error_text=1
      check_cell_error=1
   fi

   if [ ! -f $COMMONDIR/configuration ]; then
      if [ $check_cell_error = 0 ]; then
         error_text=2
      fi
      check_cell_error=1
   fi

   if [ ! -f $COMMONDIR/act_qmaster ]; then
      if [ $check_cell_error = 0 ]; then
         error_text=3
      fi
      check_cell_error=1
   fi

   if [ $check_cell_error != 0 ]; then
      $INFOTEXT -u "\nChecking cell directory"
      $INFOTEXT "\nCannot find required files. The following error was returned:\n"

      if [ $error_text = 1 ]; then
         $INFOTEXT ">common directory not found: %s<\n" $COMMONDIR
      fi

      if [ $error_text = 2 ]; then
         $INFOTEXT ">configuration file not found: %s<\n" $COMMONDIR/configuration
      fi

      if [ $error_text = 3 ]; then
         $INFOTEXT ">%s file not found: %s<\n" act_qmaster $COMMONDIR/act_qmaster
      fi

      $INFOTEXT "Please make sure that you have installed the qmaster host before" \
                       "installing an execd host.\n"

      $INFOTEXT "The installation procedure will only work if you use a shared" \
                       "directory (e.g. shared with NFS) for your installation.\n"
   
      $INFOTEXT "The installation of the execution daemon will abort now.\n"

      $INFOTEXT -auto $autoinst -wait -n "Hit <RETURN> to cancel the installation >>"
      exit 1
   fi
}


#-------------------------------------------------------------------------
# Check the host names and put out warning message on probably wrong
# hostname resolving
#
CheckHostNameResolving()
{

   resolve_get_configuration=`ExecuteAsAdmin $V5BIN/qconf -sconf global | grep "^ignore_fqdn" `
   resolve_qmaster_params=`echo $resolve_get_configuration | egrep -i "true|1"`
   if [ "x$resolve_qmaster_params" = "x" ]; then
      $ECHO ""
      set IGNORE_FQDN_DEFAULT=false
   else
#     don't need this check when IGNORE_FQDN=true in qmaster_params
      set IGNORE_FQDN_DEFAULT=true
      return
   fi

   done=false
   loop_counter=0
   while [ $done = false ]; do
       done=false
       $CLEAR
       $INFOTEXT -u "\nChecking host name resolving"
       resolve_admin_hosts=`ExecuteAsAdmin $V5BIN/qconf -sh`
       resolve_this_hostname=`ExecuteAsAdmin $V5UTILBIN/gethostname -aname`
       resolve_default_domain=`ExecuteAsAdmin $V5BIN/qconf -sconf global | grep "^default_domain" | awk '{print $2}'`

       if [ "$resolve_default_domain" = "" ]; then
           resolve_default_domain="none"
       fi
       $INFOTEXT "\nThis host has the local hostname >%s<.\n" $resolve_this_hostname

       resolve_default_domain_upper=`echo $resolve_default_domain | tr "[a-z]" "[A-Z]"`
       if [ "$resolve_default_domain_upper" != "NONE" ]; then
            resolve_tmp_name=`echo $resolve_this_hostname | cut -f 1 -d "."`
            if [ "$resolve_tmp_name" = "$resolve_this_hostname" ]; then
                resolve_this_hostname="$resolve_this_hostname.$resolve_default_domain"

                $INFOTEXT "The default_domain parameter is set in the global" \
                            "configuration and added to the unqualified hostname." \
                            "As a result the execd on this host would return the" \
                            "following hostname: >%s<\n" $resolve_this_hostname
            fi
       fi
       resolve_upper_this_hostname=`echo $resolve_this_hostname | tr "[a-z]" "[A-Z]"`
       for i in $resolve_admin_hosts; do
           resolve_upper_admin_hostname=`echo $i | tr "[a-z]" "[A-Z]"`
           if [ "$resolve_upper_admin_hostname" = "$resolve_upper_this_hostname" ]; then
              $INFOTEXT "This host is resolved correctly.\n"
              done=true
              break
           fi
       done
       if [ $done = false ]; then
           $INFOTEXT "This host is unknown on the qmaster host.\n"
           
           $INFOTEXT -D "-" "Please make sure that you added this host" \
                       "as administrative host! If you did not, add this host" \
                       "with the command >%s< on your qmaster host.\n" "qconf -ah HOSTNAME"
           if [ $loop_counter != 0 ]; then
               $INFOTEXT -D "-" "If this host is already added as" \
                       "administrative host on your qmaster host, there may be a" \
                       "hostname resolving problem on this machine.\n"
               $INFOTEXT -D "-" "Please check your /etc/hosts file and" \
                       "nsswitch configuration file!\n"

               $INFOTEXT "Hostname resolving problems will cause the" \
                       "problem that the execution host will not be accepted" \
                       "by qmaster.\nThe qmaster will get no load report values" \
                       "and show a load value (%s) of %s for this host.\n" load_avg 99.99 
               if [ $autoinst = true ]; then
                   exit 1
               fi
           fi

           $INFOTEXT -auto $autoinst -ask "y" "n" -def "y" -n "Check again (y/n) [y] >> "
           if [ $? = 0 ]; then
              done=false
           else
              done=true
           fi
       else
           WaitClear clear
           return
       fi
       loop_counter=`expr $loop_counter + 1`
   done
}

#-------------------------------------------------------------------------
# AskIfDefaultOkAndSetVariables
#
AskIfDefaultOkAndSetVariables()
{
   eval $QSYST_ROOT=`pwd | sed 's/\/tmp_mnt//'`
   export $QSYST_ROOT
   QSYST_ROOT_VAL=`eval echo '$'$QSYST_ROOT`

   QMDIR=$QSYST_ROOT_VAL/$QSYST_CELL_VAL/spool/qmaster

   SetCellDependentVariables

   $INFOTEXT -u "\nConfirm %s default installation settings" "$QSYST"

   $INFOTEXT "\nThe following default settings can be used for an" \
               "accelerated installation procedure:\n"
   $ECHO ""
   $ECHO "      \$$QSYST_ROOT          = $QSYST_ROOT_VAL"

   if [ "$COMMD_PORT" != "" ]; then
      $ECHO "      \$COMMD_PORT        = $COMMD_PORT"
   else
      $ECHO "      service            = $QSYST_SERVICE"
   fi

   if [ $ADMINUSER = default ]; then
      $ECHO "      admin user account = root"
   else
      $ECHO "      admin user account = $ADMINUSER"
   fi

   if [ "$QSYST_CELL_VAL" != "default" ]; then
      $ECHO "      cell name          = $QSYST_CELL_VAL"
   fi
   $ECHO

   $INFOTEXT -auto $autoinst -ask "y" "n" -def "y" -n "Do you want to use these" \
               "configuration parameters (y/n) [y] >> "
   if [ $? = 0 ]; then
      return 0;
   else
      return 1;
   fi
}

#---------------------------------------------------
# SetFilePerm
# set file permissions to 644 and dirs. to 755 and change owner to admin
# user
#
SetFilePerm()
{
   f="$1"
   $INFOTEXT "Verifying and setting file permissions in >%s<" "$f"
   chmod -R go+r $f
   find $f -type d -exec chmod 755 {} \;
   find $f -type f -perm -100 -exec chmod go+x {} \;

   if [ $ADMINUSER != default ]; then
        chown -R $ADMINUSER $f
   fi
}

#-------------------------------------------------------------------------
# Makedir: make directory, chown/chgrp/chmod it. Exit if failure
#
Makedir()
{
   file=$1
   if [ ! -d $file ]; then
       $INFOTEXT "making %s" "$file"
       ExecuteAsAdmin $MKDIR -p $1
    fi

   ExecuteAsAdmin $CHMOD $DIRPERM $file
}

#-------------------------------------------------------------------------
# SetPerm: set permissions
#
SetPerm()
{
   file=$1
   ExecuteAsAdmin $CHMOD $FILEPERM $file
}

#-------------------------------------------------------------------------
# Make directories needed by qmaster
#
MakeDirsMaster()
{
   $INFOTEXT -u "\nMaking directories"
   Makedir $QSYST_CELL_VAL
   Makedir $COMMONDIR
   Makedir $HISTDIR
   Makedir $LCONFDIR
   Makedir $QMDIR
   Makedir $QMDIR/admin_hosts
   Makedir $QMDIR/ckpt
   Makedir $QMDIR/complexes
   Makedir $QMDIR/exec_hosts
   Makedir $QMDIR/job_scripts
   Makedir $QMDIR/jobs
   Makedir $QMDIR/pe
   Makedir $QMDIR/queues
   Makedir $QMDIR/submit_hosts
   Makedir $QMDIR/usersets

   WaitClear clear
}

#-------------------------------------------------------------------------
# PrintLocalConf:  print execution host local SGE/SGEEE configuration
#
PrintLocalConf()
{
   arg=$1
   if [ $arg = 1 ]; then
      $ECHO "conf_version           0"
   fi
   $ECHO "mailer                 $MAILER"
   $ECHO "xterm                  $XTERM"
   $ECHO "qlogin_daemon          $QLOGIN_DAEMON"
   $ECHO "rlogin_daemon          $RLOGIN_DAEMON"
}

#-------------------------------------------------------------------------
# PrintConf: print SGE/SGEEE default configuration
#
PrintConf()
{
   $ECHO "conf_version           0"
   $ECHO "qmaster_spool_dir      $QMDIR"
   $ECHO "execd_spool_dir        $CFG_EXE_SPOOL"
   $ECHO "binary_path            $QSYST_ROOT_VAL/bin"
   $ECHO "mailer                 $MAILER"
   $ECHO "xterm                  $XTERM"
   $ECHO "load_sensor            none"
   $ECHO "prolog                 none"
   $ECHO "epilog                 none"
   $ECHO "shell_start_mode       posix_compliant"
   $ECHO "login_shells           sh,ksh,csh,tcsh"
   $ECHO "min_uid                0"
   $ECHO "min_gid                0"
   $ECHO "user_lists             none"
   $ECHO "xuser_lists            none"
   if [ $inst = sgeee ]; then
      $ECHO "projects               none"
      $ECHO "xprojects              none"
      $ECHO "enforce_project        false"
      $ECHO "enforce_user           false"
   fi
   $ECHO "load_report_time       00:00:40"
   $ECHO "stat_log_time          48:00:00"
   $ECHO "max_unheard            00:05:00"
   $ECHO "reschedule_unknown     00:00:00"
   $ECHO "loglevel               log_warning"
   $ECHO "administrator_mail     $CFG_MAIL_ADDR"
   if [ $afs = true ]; then
      $ECHO "set_token_cmd          /path_to_token_cmd/set_token_cmd"
      $ECHO "pag_cmd                /usr/afsws/bin/pagsh"
      $ECHO "token_extend_time      24:0:0"
   else
      $ECHO "set_token_cmd          none"
      $ECHO "pag_cmd                none"
      $ECHO "token_extend_time      none"
   fi
   $ECHO "shepherd_cmd           none"
   $ECHO "qmaster_params         none"
   $ECHO "schedd_params          none"
   $ECHO "execd_params           none"
   $ECHO "finished_jobs          100"
   $ECHO "gid_range              $CFG_GID_RANGE"
   if [ $ADMINUSER != default ]; then
      $ECHO "admin_user             $ADMINUSER"
   else
      $ECHO "admin_user             none"
   fi
   $ECHO "qlogin_command         $QLOGIN_COMMAND"
   $ECHO "qlogin_daemon          $QLOGIN_DAEMON"
   $ECHO "rlogin_daemon          $RLOGIN_DAEMON"
   $ECHO "default_domain         $CFG_DEFAULT_DOMAIN"
   $ECHO "ignore_fqdn            $IGNORE_FQDN_DEFAULT"
   $ECHO "max_aj_instances       2000"
   $ECHO "max_aj_tasks           75000"
   $ECHO "max_u_jobs             0"
}

#-------------------------------------------------------------------------
# GetGidRange
#
GetGidRange()
{
   done=false
   while [ $done = false ]; do
      $CLEAR
      $INFOTEXT -u "\n%s group id range" "$QSYST"
      $INFOTEXT "\nWhen jobs are started under the control of %s an additional group id is set" \
                  "on platforms which do not support jobs. This is done to provide maximum control" \
                  "for %s jobs.\n" $QSYST $QSYST
      $INFOTEXT "This additional UNIX group id range must be unused group id's in your system." \
                  "Each job will be assigned a unique id during the time it is running." \
                  "Therefore you need to provide a range of id's which will be assigned" \
                  "dynamically for jobs.\n"
      $INFOTEXT "The range must be big enough to provide enough numbers for the maximum number" \
                  "of %s jobs running at a single moment on a single host. E.g. a range like" \
                  ">20000-20100< means, that %s will use the group ids from 20000-20100" \
                  "and provides a range for 100 %s jobs at the same time on a single host.\n" \
                  $QSYST $QSYST $QSYST
      $INFOTEXT "You can change at any time the group id range in your cluster configuration.\n"

      Translate 2 "Please enter a range: "

      CFG_GID_RANGE=`Enter ""`

      if [ "$CFG_GID_RANGE" != "" ]; then
         $INFOTEXT "Using >%s< as gid range." "$CFG_GID_RANGE"
         $ECHO
         WaitClear clear
         done=true
      fi
   done
}

#-------------------------------------------------------------------------
# GetDefaultDomain
#
GetDefaultDomain()
{
   done=false
   while [ $done = false ]; do
      $CLEAR
      $INFOTEXT -u "\nDefault domain for hostnames"

      $INFOTEXT "\nSometimes the primary hostname of machines returns the short hostname" \
                  "without a domain suffix like >%s<.\n" \
                  "This can cause problems with getting load values of your execution hosts.\n" \
                  "If you are using DNS or you are using domains in your >%s< file or" \
                  "your NIS configuration it is usually safe to define a default domain" \
                  "because it is only used if your execution hosts return the short hostname" \
                  "as their primary name.\n" \
                  "If your execution hosts reside in more than one domain, the default domain" \
                  "parameter must be set on all execution hosts individually.\n" company.com /etc/hosts

      Translate 4 "Do you want to configure a default domain"
      YesNo "$transout" y
      if [ $? = 0 ]; then
         Translate 2 "\nPlease enter your default domain: "
         CFG_DEFAULT_DOMAIN=`Enter ""`
         if [ "$CFG_DEFAULT_DOMAIN" != "" ]; then
            $ECHO
            $INFOTEXT "Using >%s< as default domain" $CFG_DEFAULT_DOMAIN
            WaitClear clear
         fi
      else
         CFG_DEFAULT_DOMAIN=none
      fi
      done=true
   done
}

#-------------------------------------------------------------------------
# GetConfiguration: get some parameters for global configuration
#
GetConfiguration()
{

   GetGidRange

   if [ $fast = false -a "$IGNORE_FQDN_DEFAULT" = false ]; then
      GetDefaultDomain
   else
      CFG_DEFAULT_DOMAIN=none
   fi

   if [ $fast = true ]; then
      CFG_EXE_SPOOL=$QSYST_ROOT_VAL/$QSYST_CELL_VAL/spool
      CFG_MAIL_ADDR=none
      return 0
   fi

   done=false
   while [ $done = false ]; do
      $CLEAR
      $INFOTEXT -u "\n%s cluster configuration" "$QSYST"
      $INFOTEXT "\nPlease give the basic configuration parameters of" \
                  "your %s installation:\n%s\n"  "$QSYST" "<execd_spool_dir>"

      if [ $ADMINUSER != default ]; then
            $INFOTEXT "The pathname of the spool directory of the execution hosts. User >%s<" \
                        "must have the right to create this directory and to write into it.\n" "$ADMINUSER"
      elif [ $euid = 0 ]; then
            $INFOTEXT "The pathname of the spool directory of the execution hosts. The user root" \
                        "must have the right to create this directory and to write into it.\n" 
      else
            $INFOTEXT "The pathname of the spool directory of the execution hosts. You" \
                        "must have the right to create this directory and to write into it.\n"
      fi

      $INFOTEXT -n "Default: (%s) >> " $QSYST_ROOT_VAL/$QSYST_CELL_VAL/spool

      CFG_EXE_SPOOL=`Enter $QSYST_ROOT_VAL/$QSYST_CELL_VAL/spool`

      $CLEAR
      $INFOTEXT -u "\n%s cluster configuration" "$QSYST"
      $INFOTEXT "\nPlease give the basic configuration parameters of" \
                  "your %s installation:\n%s\n"  "$QSYST" "<administrator_mail>"
      $INFOTEXT "The email address of the administrator to whom problem reports are sent.\n"
      $INFOTEXT "It's is recommended to configure this parameter. You may use >none<" \
                  "if you do not wish to receive administrator mail.\n"
      $INFOTEXT "Please enter an email address in the form:\n>%s<\n" "user@foo.com" 
      $INFOTEXT -n "Default: (%s) >> " none

      CFG_MAIL_ADDR=`Enter none`

      $CLEAR

      $INFOTEXT "\nThe following parameters for the cluster configuration were configured:\n"
      $ECHO "   execd_spool_dir        $CFG_EXE_SPOOL"
      $ECHO "   administrator_mail     $CFG_MAIL_ADDR"
      $ECHO ""

      Translate 4 "Do you want to change the configuration parameters"
      YesNo "$transout" n
      if [ $? = 1 ]; then
         done=true
      fi
   done
}

#-------------------------------------------------------------------------
# AddConfiguration
#
AddConfiguration()
{
   useold=false

   if [ -f $COMMONDIR/configuration ]; then
      $INFOTEXT -u "\nCreating global cluster configuration"
      $INFOTEXT "\nA global cluster configuration file already exists."
      Translate 4 "Press <RETURN> to display the configuration >>"
      WaitClear noclear "\n$transout \c"

      cat $COMMONDIR/configuration |grep -v conf_version |more

      QMDIR_IN_CFG=`grep qmaster_spool_dir $COMMONDIR/configuration | awk '{print $2}'`
      if [ "$QMDIR_IN_CFG" != $QMDIR ]; then
         $CLEAR
         $INFOTEXT -u "\nERROR - new qmaster spool directory"
         $INFOTEXT "\nThe qmaster spool directory in your existing configuration is set to\n%s\n" \
                     "and differs from your previous selection during this installation where you"  \
                     "set the qmaster spool directory to\n%s.\n" "$QMDIR_IN_CFG" "$QMDIR"
         $INFOTEXT "Please either copy your old qmaster spool directory to the new directory and" \
                     "edit the existing cluster configuration file to reflect this change and"      \
                     "restart the installation or delete the current cluster configuration file.\n"

         Translate 4 "Hit <RETURN> to cancel the installation >>"
         WaitClear noclear "$transout \c"
         exit 1
      else
         Translate 4 "Do you want to create a new configuration"
         YesNo "$transout" y
         if [ $? = 1 ]; then
            Translate 4 "Using existing configuration. Hit <RETURN> to continue >>"
            WaitClear noclear "$transout \c"
            useold=true
         fi
      fi
   fi

   if [ $useold = false ]; then
      GetConfiguration
      TruncCreateAndMakeWriteable $COMMONDIR/configuration
      PrintConf >> $COMMONDIR/configuration
      SetPerm $COMMONDIR/configuration
   fi

   TruncCreateAndMakeWriteable $COMMONDIR/product_mode
   if [ $inst = sge ]; then
      PRODUCT_PREFIX=sge
   else
      PRODUCT_PREFIX=sgeee
   fi

   if [ $resport = true ]; then
      RESPORT_PREFIX=-reserved_port
   else
      RESPORT_PREFIX=""
   fi

   if [ $afs = true ]; then
      AFS_PREFIX=-afs
   else
      AFS_PREFIX=""
   fi

   if [ $csp = true ]; then
      X509_COUNT=`strings $V5BIN/sge_qmaster | grep X509 | wc -l`
      if [ 50 -gt $X509_COUNT ]; then
         $INFOTEXT "\nsge_qmaster binary is not compiled with -secure option!\n"
         Translate 4 "Hit <RETURN> to cancel the installation >>"
         WaitClear noclear "$transout \c"
         exit 1
      else
         CSP_PREFIX=-csp
      fi  
   else
      CSP_PREFIX=""
   fi

   $ECHO ${PRODUCT_PREFIX}${RESPORT_PREFIX}${AFS_PREFIX}${CSP_PREFIX} >> $COMMONDIR/product_mode
   SetPerm $COMMONDIR/product_mode
}

#-------------------------------------------------------------------------
# AddLocalConfiguration_With_Qconf
#
AddLocalConfiguration_With_Qconf()
{
   TMPL=/tmp/${HOST}
   rm -f $TMPL
   if [ -f $TMPL ]; then
      $INFOTEXT "Sorry - can't create local configuration. Can't delete file >%s<" "$TMPL"
   else
      $INFOTEXT "Creating local configuration for host >%s<" $HOST
      PrintLocalConf 0 > /tmp/$HOST
      Execute $V5BIN/qconf -Aconf /tmp/$HOST
      rm -f /tmp/$HOST
      $INFOTEXT "Local configuration for host >%s< created." $HOST
   fi
   WaitClear clear
}

#-------------------------------------------------------------------------
# AddLocalConfiguration
#
AddLocalConfiguration()
{
   useold=false

   $INFOTEXT "\nCreating local configuration"
   if [ -f $LCONFDIR/$HOST ]; then
      $ECHO
      $INFOTEXT "A local configuration for this host already exists."

      Translate 4 "Press <RETURN> to display the configuration >>"
      WaitClear noclear "\n$transout \c"

      cat $LCONFDIR/$HOST |grep -v conf_version |more

      Translate 4 "Do you want to overrride this configuration with a default config"
      YesNo "\n$transout" n
      if [ $? = 1 ]; then
         Translate 4 "Keeping existing configuration"
         useold=true
      else
         Translate 4 "Creating new local configuration for this host"

      fi
      WaitClear noclear "\n$transout >> \c"
      $CLEAR
   fi

   if [ $useold = false ]; then
      TruncCreateAndMakeWriteable $LCONFDIR/$HOST
      PrintLocalConf 1 >> $LCONFDIR/$HOST
      SetPerm $LCONFDIR/$HOST
   fi
}

#-------------------------------------------------------------------------
# AddActQmaster: create act_qmaster file
#
AddActQmaster()
{
   $INFOTEXT "Creating >act_qmaster< file"

   TruncCreateAndMakeWriteable $COMMONDIR/act_qmaster
   $ECHO $HOST >> $COMMONDIR/act_qmaster
   SetPerm $COMMONDIR/act_qmaster
}

#-------------------------------------------------------------------------
# AddDefaultComplexes
#
AddDefaultComplexes()
{
   $INFOTEXT "Adding default complexes >host< and >queue<"
   for c in host queue; do
      if [ -f $QMDIR/complexes/$c -a -s $QMDIR/complexes/$c ]; then
         Translate 4 "Complex >%s< already exists - should complex be preserved" $c
         YesNo "$transout" y
         if [ $? = 1 ]; then
            $INFOTEXT "Overwriting existing complex >%s<" $c
            ExecuteAsAdmin cp util/resources/complexes/$c $QMDIR/complexes
         fi
      else
         ExecuteAsAdmin cp util/resources/complexes/$c $QMDIR/complexes
      fi
   done
   ExecuteAsAdmin chmod $FILEPERM $QMDIR/complexes/*
}

#-------------------------------------------------------------------------
# AddDefaultDepartement
#
AddDefaultDepartement()
{
   if [ $inst = sgeee ]; then
      $INFOTEXT "Adding SGEEE >defaultdepartment< userset"
      ExecuteAsAdmin $CP util/resources/usersets/defaultdepartment $QMDIR/usersets
      ExecuteAsAdmin $CHMOD $FILEPERM $QMDIR/usersets/defaultdepartment

      $INFOTEXT "Adding SGEEE >deadlineusers< userset"
      ExecuteAsAdmin $CP util/resources/usersets/deadlineusers $QMDIR/usersets
      ExecuteAsAdmin $CHMOD 644 $QMDIR/usersets/deadlineusers

   fi
}

#-------------------------------------------------------------------------
# AddCommonFiles
#    Copy files from util directory to common dir
#
AddCommonFiles()
{
   for f in sge_aliases qtask sge_request; do
      if [ $f = sge_aliases ]; then
         $INFOTEXT "Adding >%s< path aliases file" $f
      elif [ $f = qtask ]; then
         $INFOTEXT "Adding >%s< qtcsh sample default request file" $f
      else
         $INFOTEXT "Adding >%s< default submit options file" $f
      fi
      ExecuteAsAdmin cp util/$f $COMMONDIR
      ExecuteAsAdmin chmod $FILEPERM $COMMONDIR/$f
   done

   unset f
}

#-------------------------------------------------------------------------
# AddPEFiles
#    Copy files from PE template directory to qmaster spool dir
#
AddPEFiles()
{

   $INFOTEXT "Adding default PE environment for >%s<" qmake
   for c in make; do
      if [ -f $QMDIR/pe/$c -a -s $QMDIR/pe/$c ]; then
         Translate 4 "PE >%s< already exists - should PE be preserved" $c
         YesNo "$transout" y
         if [ $? = 1 ]; then
            $INFOTEXT "Overwriting existing PE >%s<" $c
            ExecuteAsAdmin cp util/resources/pe/$c $QMDIR/pe
         fi
      else
         ExecuteAsAdmin cp util/resources/pe/$c $QMDIR/pe
      fi
   done
   ExecuteAsAdmin chmod $FILEPERM $QMDIR/pe/*
}

#-------------------------------------------------------------------------
# AddDefaultManager
#
AddDefaultManager()
{
  TruncCreateAndMakeWriteable $QMDIR/managers
  $ECHO $1 >> $QMDIR/managers
  SetPerm $QMDIR/managers
}


#-------------------------------------------------------------------------
# ProcessQsystRoot: read SGE/SGEEE root directory and set $QSYST_ROOT
#                    check if $QSYST_ROOT matches current directory
#
ProcessQsystRoot()
{
   $CLEAR
   $INFOTEXT -u "\nChecking %s directory" $QSYST_ROOT
   $ECHO
   done=false
   while [ $done = false ]; do
      if [ "`eval echo '$'$QSYST_ROOT`" = "" ]; then
         eval $QSYST_ROOT=`pwd | sed 's/\/tmp_mnt//'`
         export $QSYST_ROOT
         QSYST_ROOT_VAL=`eval echo '$'$QSYST_ROOT`

         $INFOTEXT -n "The %s root directory (your current directory) is:\n%s\n"             \
                     "If this directory is not correct (e.g. it may contain an automounter" \
                     "prefix) enter the correct path to this directory or hit <RETURN>"     \
                     "to use default\n    \"%s\" >> " \
                     "$QSYST" "\$$QSYST_ROOT = $QSYST_ROOT_VAL" $QSYST_ROOT_VAL

         eval $QSYST_ROOT=`Enter $QSYST_ROOT_VAL`
         $ECHO
      fi

      QSYST_ROOT_VAL=`eval echo '$'$QSYST_ROOT`

      # do not check for correct QSYST_ROOT in case of -nostrict
      if [ "$strict" = true ]; then
         # create a file in QSYST_ROOT
         if [ $ADMINUSER != default ]; then
            $V5UTILBIN/adminrun $ADMINUSER $TOUCH $QSYST_ROOT_VAL/tst$$ 2> /dev/null > /dev/null
         else
            touch $QSYST_ROOT_VAL/tst$$ 2> /dev/null > /dev/null
         fi
         ret=$?
         # check if we have write permission
         if [ $ret != 0 ]; then
            $CLEAR
            $INFOTEXT "Can't create a temporary file in the directory\n>%s<\n" \
                        "This may be a permission problem (e.g. no read/write permission" \
                        "on a NFS mounted filesystem).\n" \
                        "Please check your permissions. You may cancel the installation now" \
                        "and restart it or continue and try again.\n" "$QSYST_ROOT_VAL"
            $ECHO ""
            unset $QSYST_ROOT
            WaitClear clear
         elif [ ! -f tst$$ ]; then
            # check if QSYST_ROOT points to current directory
            $INFOTEXT "Your %s environment variable\n>%s<\n" \
                        "doesn't match the current directory.\n" \
                        "\$$QSYST_ROOT" "$QSYST_ROOT_VAL"
            ExecuteAsAdmin $RM -f $QSYST_ROOT_VAL/tst$$
            unset $QSYST_ROOT
         else
            ExecuteAsAdmin $RM -f $QSYST_ROOT_VAL/tst$$
            done=true
         fi
      else
         done=true
      fi
   done

   $INFOTEXT "Your %s root directory:\n%s\n" $QSYST $QSYST_ROOT_VAL
   WaitClear clear
}

#-------------------------------------------------------------------------
# GiveHints: give some useful hints at the end of the installation
#
GiveHints()
{

   if [ $autoinst = true ]; then
      return
   fi

   done=false
   while [ $done = false ]; do
      $CLEAR
      $INFOTEXT -u "\nUsing %s" "$QSYST"
      $INFOTEXT "\nYou should now enter the command:\n%s\n" \
                  "if you are a %s user or\n%s\n" \
                  "if you are a %s user.\n" \
                  "% source $QSYST_ROOT_VAL/$QSYST_CELL_VAL/common/settings.csh" \
                  "csh/tcsh" \
                  "# . $QSYST_ROOT_VAL/$QSYST_CELL_VAL/common/settings.sh" \
                  "sh/ksh"

      
      $INFOTEXT "This will set or expand the following environment variables:\n"
      $INFOTEXT -S 3 -D "-" "%s (always necessary)" \$$QSYST_ROOT
      $INFOTEXT -S 3 -D "-" "%s (always necessary)" \$$QSYST_ROOT
      $INFOTEXT -S 3 -D "-" "%s (if you are using a cell other than >default<)" \$$QSYST_CELL
      $INFOTEXT -S 3 -D "-" "%s (if you haven't added the service %s)" \$COMMD_PORT "$QSYST_SERVICE"
      $INFOTEXT -S 3 -D "-" "%s (to find the %s binaries)" "\$PATH/\$path" "$QSYST"
      $INFOTEXT -S 3 -D "-" "%s (to access the %s manual pages)" \$MANPATH "$QSYST"

      $ECHO ""
      Translate 4 "Press <RETURN> to see where %s logs messages >>" $QSYST
      WaitClear clear "$transout \c"

      $INFOTEXT -u "\n%s messages" "$QSYST"
      $INFOTEXT "\nMessages from %s can be found at:\n" "$QSYST"
      $INFOTEXT -D "-" -S 3 "%s (during %s qmaster startup)" /tmp/qmaster_messages $QSYST
      $INFOTEXT -D "-" -S 3 "%s (during %s exec daemon startup)" /tmp/execd_messages $QSYST
      $INFOTEXT "\nAfter the startup the daemons log their messages in their spool directories.\n"

      $INFOTEXT "%s qmaster:\n%s\n" "$QSYST" "$QMDIR/messages"
      $INFOTEXT "%s execution daemon:\n%s\n" "$QSYST" "<execd_spool_dir>/<hostname>/messages"

      Translate 4 "Do you want to see previous screen about using %s again" $QSYST
      YesNo "\n\n$transout" n
      if [ $? = 0 ]; then
         :
      else
         done=true
      fi
   done

   $CLEAR

   if [ $WHICH = qmaster ]; then
      $INFOTEXT -u "\nYour %s qmaster installation is now completed" "$QSYST"
      $INFOTEXT "\nPlease now login to all hosts where you want to run an execution daemon" \
                  "and start the execution host installation procedure.\n" \
                  "If you want to run an execution daemon on this host, please do not forget" \
                  "to make the execution host installation in this host as well.\n" \
                  "All execution hosts must be administrative hosts during the installation." \
                  "All hosts which you added to the list of administrative hosts during this" \
                  "installation procedure can now be installed.\n" \
                  "You may verify your administrative hosts with the command\n%s\n" \
                  "and you may add new administrative hosts with the command\n%s\n" \
                  "qconf -sh" "qconf -ah <hostname>"
      exit 0
   else
      $INFOTEXT -u "\nYour %s execution daemon installation is now completed." "$QSYST"
   fi
}

#-------------------------------------------------------------------------
# CheckWhoInstallsQsyst
#
CheckWhoInstallsQsyst()
{
   euid=`$V5UTILBIN/uidgid -euid`
   if [ $euid != 0 ]; then
      $CLEAR
      $INFOTEXT -u "\n%s - test installation" "$QSYST"
      $INFOTEXT "\nYou are installing %s not as user >root<!\n" \
                  "This will allow you to run %s only under your user id for testing" \
                  "a limited functionality of %s.\n" "$QSYST" "$QSYST" "$QSYST"
      
      Translate 4 "Hit <RETURN> if this is ok or stop the installation with Ctrl-C >>"
      WaitClear clear "$transout \c"
      return 0
   fi

   # from here only root
   this_dir_user=`$V5UTILBIN/filestat -owner .`

   if [ $this_dir_user != root ]; then
      $CLEAR
      $INFOTEXT "\n%s admin user account" "$QSYST"

      $INFOTEXT "\nThe current directory is\n%s\nis owned by user\n%s\n" `pwd` $this_dir_user
      $INFOTEXT "If user >root< does not have write permissions in this directory on *all*" \
                  "of the machines where %s will be installed (NFS partitions not exported"   \
                  "for user >root< with read/write permissions) it is recommended to install" \
                  "%s that all spool files will be created under the user id" \
                  "of user >%s<.\n\nIMPORTANT NOTE: The daemons still have to be started" \
                  "by user >%s<" "$QSYST" "$QSYST" $this_dir_user "root"

      Translate 4 "Do you want to install %s as admin user >%s<" $QSYST $this_dir_user
      YesNo "\n$transout" y
      if [ $? = 0 ]; then
         $ECHO ""
         $INFOTEXT "Installing application as admin user >%s<" "$this_dir_user"
         ADMINUSER=$this_dir_user
         WaitClear clear
         return
      else
         $CLEAR
      fi
   fi


   $INFOTEXT -u "\nChoosing %s admin user account" "$QSYST"
   $INFOTEXT "\nYou may install %s that all files are created with the user id of an" \
               "unprivileged user.\n" \
               "This will make it possible to install and run %s in directories" \
               "where user >%s< has no permissions to create and write files and directories.\n" \
               $QSYST $QSYST "root"

   $INFOTEXT -D "-" -S 3 "%s still has to be started by user >%s<" "$QSYST" root
   $INFOTEXT -D "-" -S 3 "This directory and all distribution files already should be owned" \
                           "by the %s administrator" "$QSYST"
   $ECHO ""
   Translate 4 "Do you want to install %s under an user id other than >%s<" "$QSYST" root
   YesNo "$transout" y

   if [ $? = 0 ]; then
      done=false
      while [ $done = false ]; do
         $CLEAR
         $INFOTEXT -u "\nChoosing a %s admin user name" "$QSYST"
         $ECHO ""
         Translate 2 "Please enter the user name (or >%s<) >> " root
         INP=`Enter ""`
         $V5UTILBIN/checkuser -check "$INP"
         if [ $? != 0 ]; then
            $INFOTEXT "The user %s does not exist - please correct the username" $INP
            WaitClear clear
         else
            $ECHO
            $INFOTEXT "Installing %s as user >%s<" $QSYST $INP
            $ECHO
            ADMINUSER=$INP
            if [ $ADMINUSER = root ]; then
               ADMINUSER=default
            fi
            WaitClear clear
            done=true
         fi
      done
   else
      $ECHO 
      $INFOTEXT "Installing %s as user %s" "$QSYST" root
      $ECHO
      ADMINUSER=default
      WaitClear clear
   fi
}

#-------------------------------------------------------------------------
# CheckForCommdPort
#
CheckForCommdPort()
{
   host_type=$1
   if [ $resport = true ]; then
      commd_port_max=1023
   else
      commd_port_max=65500
   fi

   $V5UTILBIN/getservbyname $QSYST_SERVICE  >/dev/null 2>&1
   ret=$?

   if [ "$COMMD_PORT" != "" ]; then
      $INFOTEXT -u "\n%s TCP/IP communication service" "$QSYST"

      if [ $COMMD_PORT -ge 1 -a $COMMD_PORT -le $commd_port_max ]; then
         $INFOTEXT "\nUsing the environment variable\n%s\n" \
                     "as port for communication with >%s<.\n" \
                     "\$COMMD_PORT=$COMMD_PORT" "$QSYST_COMMD_NAME"
         if [ $ret = 0 ]; then
            $INFOTEXT "This overrides the preset TCP/IP service >%s<.\n" "$QSYST_SERVICE"
         fi
         WaitClear clear
         return
      else
         $INFOTEXT "\nThe environment variable\n%s\nhas an invalid value" \
                     "(it must be in range 1..%s).\n" "\$COMMD_PORT=$COMMD_PORT" \
                     "$commd_port_max"
         Translate 4 "Please set %s and restart\nthe installation or configure the service >%s<" \$COMMD_PORT $QSYST_SERVICE
         WaitClear noclear "$transout >> \c"
         exit 1
      fi
   fi

   if [ $ret != 0 ]; then
      $INFOTEXT -u "\n%s TCP/IP service >%s<" "$QSYST" "$QSYST_SERVICE"
      $INFOTEXT "\nThere is no service >%s< available in your >/etc/services< file " \
                  "or in your NIS/NIS+ database.\n" "$QSYST_SERVICE"
      $INFOTEXT -D "-" -S 3 "You may add this service now to your services database"
      $INFOTEXT -D "-" -S 3 "or choose a port number\n"
      $INFOTEXT "It is recommended to add the service now. If you are using NIS/NIS+ you" \
                  "should add the service at your NIS/NIS+ server and not to the local"     \
                  ">/etc/services< file.\n"
      $INFOTEXT "Please add an entry in the form\n%s\n" \
                  "to your services database and make sure to use an unused port number.\n" \
                  "$QSYST_SERVICE port_number/tcp"

      if [ "$host_type" = "exec" ]; then

         $INFOTEXT "Make sure to use the same port number as on the qmaster machine\n"
      fi
      Translate 4 "Please add the service now or continue to enter a port number >>"
      WaitClear noclear "$transout \c"

      # Check if $QSYST_SERVICE service is available now
      service_available=false
      done=false
      while [ $done = false ]; do
         $V5UTILBIN/getservbyname $QSYST_SERVICE 2>/dev/null
         if [ $? != 0 ]; then
            $CLEAR
            $INFOTEXT -u "\nNo TCP/IP service >%s< yet" "$QSYST_SERVICE"
            $INFOTEXT "\nThere is still no service for >%s< available.\n" "$QSYST_SERVICE"
            $INFOTEXT "If you have just added the service it may take a while until the service" \
                        "propagates in your network. If this is true we can again check for" \
                        "the service >%s<. If you don't want to add this service or if" \
                        "you want to install >%s< just for testing purposes you can enter" \
                        "a port number.\n" "$QSYST_SERVICE" "$QSYST"

            Translate 4 "Check again (press >Y<) or enter port number now (y/number) [Y] >>"
            $ECHO "$transout \c"
            INP=`Enter Y`
            if [ $INP = y -o $INP = Y ]; then
               :
            else
               chars=`echo $INP | wc -c`
               chars=`expr $chars - 1`
               digits=`expr $INP : "[0-9][0-9]*"`
               if [ "$chars" != "$digits" ]; then
                  $INFOTEXT "\nInvalid input. Must be a number."
               elif [ $INP -le 1 -o $INP -ge $commd_port_max ]; then
                  $INFOTEXT "\nInvalid port number. Must be in range [1..$commd_port_max]."
               elif [ $INP -le 1024 -a $euid != 0 ]; then
                  $INFOTEXT "\nYou are not user >root<. Use a port above 1024."
               else
                  ser=`awk '{ print $2 }' /etc/services | grep "^${INP}/tcp"`
                  if [ "$ser" = "$INP/tcp" ]; then
                     $INFOTEXT "\nFound service with port number >%s< in >/etc/services<. Choose again." "$INP"
                  else
                     done=true
                  fi
               fi
               if [ $done = false ]; then
                  WaitClear noclear
               fi
            fi
         else
            done=true
            service_available=true
         fi
      done

      if [ $service_available = false ]; then
         COMMD_PORT=$INP
         export COMMD_PORT
         $INFOTEXT "\nUsing port >%s<." "$COMMD_PORT"
         $INFOTEXT "No service >%s< available.\n" "$QSYST_SERVICE"
         WaitClear clear
      else
         unset COMMD_PORT
         $INFOTEXT "\nService >%s< is now available." "$QSYST_SERVICE"
         WaitClear clear
      fi
   else
      $INFOTEXT "\nUsing the service\n%s\nfor communication with >%s<.\n" \
                  "$QSYST_SERVICE" "$QSYST"
      WaitClear clear
   fi
}

#-------------------------------------------------------------------------
# GetCell
#
GetCell()
{
   if [ $fast = true ]; then
      return
   fi

   $CLEAR
   $INFOTEXT -u "\n%s cells" "$QSYST"
   $INFOTEXT "\n%s supports multiple cells.\nIf you are not planning to run" \
               "multiple %s clusters or if you don't know yet what is a %s cell" \
               "it is safe to keep the default cell name\n>%s<\n" \
               "$QSYST" "$QSYST" "$QSYST" "default"
   $INFOTEXT "If you want to run multiple cells you can enter a cell name now."

   $INFOTEXT "The environment variable\n%s\n" \
               "will be set for all further %s commands.\n" \
               "$QSYST_CELL=<your_cell_name>" "$QSYST"

   Translate 4 "Enter cell name or hit <RETURN> to use default cell >%s<" default
   $ECHO "$transout >> \c"
   INP=`Enter ""`
   if [ "$INP" = "" ]; then
      eval $QSYST_CELL=default
   else
      eval $QSYST_CELL=$INP
   fi

   QSYST_CELL_VAL=`eval echo '$'$QSYST_CELL`

   $INFOTEXT "\nUsing default cell: >%s<" $QSYST_CELL_VAL

   WaitClear clear
}

#-------------------------------------------------------------------------
# GetQmasterSpoolDir()
#
GetQmasterSpoolDir()
{
   euid=$1

   done=false
   while [ $done = false ]; do
      $CLEAR
      $INFOTEXT -u "\n%s qmaster spool directory" "$QSYST"
      $INFOTEXT "\nThe qmaster spool directory is the place where the %s qmaster" \
                  "daemon stores the configuration and the state of the queuing system.\n" \
                  "$QSYST"

      if [ $euid = 0 ]; then
         if [ $ADMINUSER = default ]; then
            $INFOTEXT "The >%s< user on this host must have read/write access" \
                        "to the qmaster spool directory.\n" root
         else
            $INFOTEXT "The admin user >%s< must have read/write access" \
                        "to the qmaster spool directory.\n" $ADMINUSER
         fi
      else
         $INFOTEXT "Your account on this host must have read/write access " \
                     "to the qmaster spool directory.\n"
      fi

      $INFOTEXT "If you will install shadow master hosts or if you want to be able to" \
                  "start the qmaster daemon on other hosts (see the corresponding section" \
                  "in the %s Installation and Administration Manual for details) the account" \
                  "on the shadow master hosts also needs read/write access to this directory.\n" \
                  "$QSYST"

      $INFOTEXT "Enter spool directory or hit <RETURN> to use default"

      $ECHO "   \"$QSYST_ROOT_VAL/$QSYST_CELL_VAL/spool/qmaster\" >> \c"

      QMDIR=`Enter $QSYST_ROOT_VAL/$QSYST_CELL_VAL/spool/qmaster`

      $INFOTEXT "\nThe following directory has been selected as qmaster" \
                  "spool directory:\n%s\n" "$QMDIR"

      Translate 4 "Do you want to select another qmaster spool directory"
      YesNo "$transout" n

      if [ $? = 1 ]; then
         done=true
      fi
   done
}

#-------------------------------------------------------------------------
# CheckQmasterInstallation
#
CheckQmasterInstallation()
{
   $CLEAR
   $INFOTEXT -u "\n%s cells"  "$QSYST"
   $INFOTEXT -n "\nPlease enter cell name which you used for %s qmaster" \
               "installation or press <RETURN> to use default cell >default< >> " "$QSYST"
   INP=`Enter ""`
   if [ "$INP" = "" ]; then
      eval $QSYST_CELL=default
   else
      eval $QSYST_CELL=$INP
   fi

   QSYST_CELL_VAL=`eval echo '$'$QSYST_CELL`

   SetCellDependentVariables

   if [ ! -f $COMMONDIR/act_qmaster -o ! -f $COMMONDIR/configuration ]; then
      $INFOTEXT "\nObviously there was no %s qmaster installation!\nCall >%s -m<\n" \
                  "on the machine which shall run the %s qmaster\n" "$QSYST" "$myname" "$QSYST"
      exit 1
   else
      $INFOTEXT "Using default cell: >%s<\n" $QSYST_CELL_VAL
   fi

   WaitClear clear

   user=`grep admin_user $COMMONDIR/configuration | awk '{ print $2 }'`

   if [ "$user" != "" ]; then
      if [ `echo "$user" |tr "A-Z" "a-z"` = "none" ]; then
         user=default
      fi
   fi

   if [ "$ADMINUSER" != "$user" ]; then
      if [ "$user" = default ]; then
         $INFOTEXT "The admin user >%s< is different than the default >%s<" \
                     "in the global cluster configuration.\n" "$user" default
      else
         $INFOTEXT "The admin user >%s< doesn't match the admin username >%s<" \
                     "in the global cluster configuration.\n" "$user" $ADMINUSER
      fi
      $INFOTEXT "Installation failed. Exit."
      exit 1
   fi
}

#-------------------------------------------------------------------------
# AddQsystStartUpScript: Add startup script to rc files if root installs
#
AddQsystStartUpScript()
{
   euid=$1
   create=$2

   $CLEAR
   $INFOTEXT -u "\n%s startup script" "$QSYST"
   $ECHO
   TMP_V5_STARTUP_FILE=/tmp/rcsge.$$
   STARTUP_FILE_NAME=rcsge
   S95NAME=S95rcsge

   if [ -f $TMP_V5_STARTUP_FILE ]; then
      Execute rm $TMP_V5_STARTUP_FILE
   fi
   if [ -f ${TMP_V5_STARTUP_FILE}.0 ]; then
      Execute rm ${TMP_V5_STARTUP_FILE}.0
   fi
   if [ -f ${TMP_V5_STARTUP_FILE}.1 ]; then
      Execute rm ${TMP_V5_STARTUP_FILE}.1
   fi

   V5_STARTUP_FILE=$QSYST_ROOT_VAL/$COMMONDIR/$STARTUP_FILE_NAME

   if [ $create = true ]; then

      Execute sed -e "s%GENROOT%${QSYST_ROOT_VAL}%g" \
                  -e "s%GENCELL%${QSYST_CELL_VAL}%g" \
                  -e "/#+-#+-#+-#-/,/#-#-#-#-#-#/d" \
                  util/startup_template > ${TMP_V5_STARTUP_FILE}.0

      if [ "$COMMD_PORT" != "" ]; then
         Execute sed -e "s/=GENCOMMD_PORT/=$COMMD_PORT/" \
                     ${TMP_V5_STARTUP_FILE}.0 > $TMP_V5_STARTUP_FILE
      else
         Execute sed -e "/GENCOMMD_PORT/d" \
                     ${TMP_V5_STARTUP_FILE}.0 > $TMP_V5_STARTUP_FILE
      fi

      ExecuteAsAdmin $CP $TMP_V5_STARTUP_FILE $V5_STARTUP_FILE
      ExecuteAsAdmin $CHMOD a+x $V5_STARTUP_FILE

      rm -f $TMP_V5_STARTUP_FILE ${TMP_V5_STARTUP_FILE}.0 ${TMP_V5_STARTUP_FILE}.1

      if [ $euid = 0 -a $ADMINUSER != default -a $WHICH = "qmaster" ]; then
         AddDefaultManager $ADMINUSER
      elif [ $euid != 0 ]; then
         AddDefaultManager $USER
      fi

      $INFOTEXT "\nYour system wide %s startup script is installed as:\n>%s<\n" \
                  "$QSYST" "$V5_STARTUP_FILE"
      WaitClear clear
   else
      $CLEAR
   fi

   if [ $euid != 0 ]; then
      return 0
   fi

   # --- from here only if root installs ---
   Translate 4 "We can install the startup script that %s is started at machine boot" $QSYST
   YesNo "\n$transout" y

   if [ $? = 1 ]; then
      $CLEAR
      return
   fi

   echo

   # If we have System V we need to put the startup script to $RC_PREFIX/init.d
   # and make a link in $RC_PREFIX/rc2.d to $RC_PREFIX/init.d
   if [ "$RC_FILE" = "sysv_rc" ]; then
      $INFOTEXT "Installing startup script %s" "$RC_PREFIX/$RC_DIR/$S95NAME"
      Execute rm -f $RC_PREFIX/$RC_DIR/$S95NAME
      Execute cp $V5_STARTUP_FILE $RC_PREFIX/init.d/$STARTUP_FILE_NAME
      Execute chmod a+x $RC_PREFIX/init.d/$STARTUP_FILE_NAME
      Execute ln -s $RC_PREFIX/init.d/$STARTUP_FILE_NAME $RC_PREFIX/$RC_DIR/$S95NAME

      # runlevel management in Linux is different -
      # each runlevel contains full set of links
      # RedHat uses runlevel 5 and SUSE runlevel 3 for xdm
      # RedHat uses runlevel 3 for full networked mode
      # Suse uses runlevel 2 for full networked mode
      # we already installed the script in level 3
      if [ $ARCH = linux -o $ARCH = glinux -o $ARCH = alinux -o $ARCH = slinux ]; then
         runlevel=`grep "^id:.:initdefault:"  /etc/inittab | cut -f2 -d:`
         if [ "$runlevel" = 2 -o  "$runlevel" = 5 ]; then
            $INFOTEXT "Installing startup script also in %s" "$RC_PREFIX/rc${runlevel}.d/$S95NAME"
            Execute rm -f $RC_PREFIX/rc${runlevel}.d/$S95NAME
            Execute ln -s $RC_PREFIX/init.d/$STARTUP_FILE_NAME $RC_PREFIX/rc${runlevel}.d/$S95NAME
         fi
      fi
   elif [ "$RC_FILE" = "insserv-linux" ]; then
      echo  cp $V5_STARTUP_FILE $RC_PREFIX/$STARTUP_FILE_NAME
      echo /sbin/insserv $RC_PREFIX/$STARTUP_FILE_NAME
      Execute cp $V5_STARTUP_FILE $RC_PREFIX/$STARTUP_FILE_NAME
      /sbin/insserv $RC_PREFIX/$STARTUP_FILE_NAME
   else
      # if this is not System V we simple add the call to the
      # startup script to RC_FILE

      # Start-up script already installed?
      #------------------------------------
      grep $STARTUP_FILE_NAME $RC_FILE > /dev/null 2>&1
      status=$?
      if [ $status != 0 ]; then
         $INFOTEXT "Adding application startup to %s" $RC_FILE
         # Add the procedure
         #------------------
         $ECHO "" >> $RC_FILE
         $ECHO "" >> $RC_FILE
         $ECHO "# $QSYST start up" >> $RC_FILE
         $ECHO "#-$LINE---------" >> $RC_FILE
         $ECHO $V5_STARTUP_FILE >> $RC_FILE
      else
         $INFOTEXT "Found a call of %s in $s. Replacing with new call.\n" \
                     "Your old %s is saved as %s" $STARTUP_FILE_NAME $RC_FILE $RC_FILE $RC_FILE.org.1

         mv $RC_FILE.org.3 $RC_FILE.org.4    2>/dev/null
         mv $RC_FILE.org.2 $RC_FILE.org.3    2>/dev/null
         mv $RC_FILE.org.1 $RC_FILE.org.2    2>/dev/null

         # save original file modes of RC_FILE
         uid=`$V5UTILBIN/filestat -uid $RC_FILE`
         gid=`$V5UTILBIN/filestat -gid $RC_FILE`
         perm=`$V5UTILBIN/filestat -mode $RC_FILE`

         Execute cp $RC_FILE $RC_FILE.org.1

         savedfile=`basename $RC_FILE`

         sed -e "s%.*$STARTUP_FILE_NAME.*%$V5_STARTUP_FILE%" \
                 $RC_FILE > /tmp/$savedfile.1

         Execute cp /tmp/$savedfile.1 $RC_FILE
         Execute chown $uid $RC_FILE
         Execute chgrp $gid $RC_FILE
         Execute chmod $perm $RC_FILE
         Execute rm -f /tmp/$savedfile.1
      fi
   fi

   WaitClear clear
}

#-------------------------------------------------------------------------
# AddHostsFromFile: Get a list of hosts and add them as
# admin and submit hosts
#
AddHostsFromFile()
{
   file=$1
   done=false
   while [ $done = false ]; do
      $CLEAR
      $INFOTEXT -u "\nAdding admin and submit hosts from file"
      $INFOTEXT -n "\nPlease enter the file name which contains the host list: "
      file=`Enter none`
      if [ "$file" = "none" -o ! -f "$file" ]; then
         $INFOTEXT "\nYou entered an invalid file name or the file does not exist."
         Translate 4 "Do you want to enter a new file name"
         YesNo "\n$transout " y
         if [ $? = 1 ]; then
            return 1
         fi
      else
         for h in `cat $file`; do
            $V5BIN/qconf -ah $h
            $V5BIN/qconf -as $h
         done
         done=true
      fi
   done
}

#-------------------------------------------------------------------------
# AddHostsFromTerminal
#    Get a list of hosts and add the mas admin and submit hosts
#
AddHostsFromTerminal()
{
   stop=false
   while [ $stop = false ]; do
      $CLEAR
      $INFOTEXT -u "\nAdding admin and submit hosts"
      $INFOTEXT "\nPlease enter a blank seperated list of hosts. " \
                  "Stop by entering <RETURN>. You may repeat this step until" \
                  "you are entering an empty list. You will see" \
                  "messages from %s when the hosts are added.\n" "$QSYST"


      $INFOTEXT -n "Host(s): "

      hlist=`Enter ""`
      for h in $hlist; do
         $V5BIN/qconf -ah $h
         $V5BIN/qconf -as $h
      done
      if [ "$hlist" = "" ]; then
         stop=true
      else
         WaitClear noclear
      fi
  done
}

#-------------------------------------------------------------------------
# AddHosts
#
AddHosts()
{
   $INFOTEXT -u "\nAdding %s hosts" "$QSYST"
   $INFOTEXT "\nPlease now add the list of hosts, where you will later install your execution" \
               "daemons. These hosts will be also added as valid submit hosts.\n" \
               "Please enter a blank separated list of your execution hosts. You may" \
               "press <RETURN> if the line is getting too long. Once you are finished" \
               "simply press <RETURN> without entering a name.\n" \
               "You also may prepare a file with the hostnames of the machines where you plan" \
               "to install %s. This may be convenient if you are installing %s on many hosts.\n" \
               "$QSYST" "$QSYST"

   Translate 4 "Do you want to use a file which contains the list of hosts"
   YesNo "$transout" n
   ret=$?
   if [ $ret = 0 ]; then
      AddHostsFromFile
      ret=$?
   fi

   if [ $ret = 1 ]; then
      AddHostsFromTerminal
   fi

   Translate 4 "Finished adding hosts. Hit <RETURN> to continue >>"
   WaitClear clear "\n$transout \c"
}

#-------------------------------------------------------------------------
# AddQueue
#
AddQueue()
{
   if [ $addqueue = false ]; then
      return
   fi

   exechost=`$V5UTILBIN/gethostname -name | cut -f1 -d.`

#   This does not work on solaris64 when running in locale en_FW.MBE
#   because the tr -s " " doesn't work correctly :
#
#   slots=`$V5UTILBIN/loadcheck -loadval num_proc | tr -s " " | cut -f2 -d" "`
#
#  So let's do this:
#
   slots=`$V5UTILBIN/loadcheck -loadval num_proc | sed "s/num_proc *//"`

   $INFOTEXT -u "\nAdding a default %s queue for this host" "$QSYST"
   $INFOTEXT "\nWe can now add a sample queue for this host with following attributes:\n" 
   $INFOTEXT -D "-" -S 3 "the queue has the name >%s.q<" "${exechost}"
   $INFOTEXT -D "-" -S 3 "the queue provides %s slot(s) for jobs" "$slots"
   $INFOTEXT -D "-" -S 3 "the queue provides access for any user with an account on this machine"
   $INFOTEXT -D "-" -S 3 "the queue has no resource limits"
   $INFOTEXT "\nYou do not need to add a queue now, but before running jobs on this host" \
               "need to add a queue with >qconf< or the GUI >qmon<.\n"

   Translate 4 "Do you want to add a default queue for this host"
   YesNo "$transout" y

   if [ $? = 0 ]; then
      TMPL=/tmp/queue_template.$$
      rm -f $TMPL ${TMPL}.q
      $V5BIN/qconf -sq > $TMPL
      Execute sed -e "/qname/s/template/${exechost}.q/" \
                  -e "/hostname/s/unknown/$exechost/" \
                  -e "/slots/s/1/$slots/" $TMPL > ${TMPL}.q
      $V5BIN/qconf -Aq ${TMPL}.q
      WaitClear clear
      rm -f $TMPL ${TMPL}.q
   fi
}

#-------------------------------------------------------------------------
# CreateSettingsFile: Create resource files for csh/sh
#
CreateSettingsFile()
{
   $INFOTEXT "Creating settings files for >%s<" ".profile/.cshrc"

   if [ -f $QSYST_ROOT_VAL/$COMMONDIR/settings.sh ]; then
      ExecuteAsAdmin $RM $QSYST_ROOT_VAL/$COMMONDIR/settings.sh
   fi

   if [ -f $QSYST_ROOT_VAL/$COMMONDIR/settings.csh ]; then
      ExecuteAsAdmin $RM $QSYST_ROOT_VAL/$COMMONDIR/settings.csh
   fi

   ExecuteAsAdmin util/create_settings.sh $QSYST_ROOT_VAL/$COMMONDIR

   SetPerm $QSYST_ROOT_VAL/$COMMONDIR/settings.sh
   SetPerm $QSYST_ROOT_VAL/$COMMONDIR/settings.csh
}

#--------------------------------------------------------------------------
# SetCellDependentVariables
#
SetCellDependentVariables()
{
   COMMONDIR=$QSYST_CELL_VAL/common
   LCONFDIR=$QSYST_CELL_VAL/common/local_conf
   CASHAREDDIR=$COMMONDIR/sgeCA
   HISTDIR=$COMMONDIR/history
}

#--------------------------------------------------------------------------
#
WelcomeTheUser()
{
   if [ $autoinst = true ]; then
      return
   fi

   $INFOTEXT -u "\nWelcome to the %s installation" $QSYST
   $INFOTEXT -u "\n%s qmaster host installation" $QSYST
   $INFOTEXT "\nBefore you continue with the installation please read these hints:\n"
   $INFOTEXT -D "-" -S 3 "Your terminal window should have a size of at least 80x24 characters.\n"
   $INFOTEXT -D "-" -S 3 "The INTR character is often bound to the key Ctrl-C. The term" \
                           "Ctrl-C is used during the installation if you have the" \
                           "possibility to abort the installation.\n"
   $INFOTEXT "The qmaster installation procedure will take approximately 5-10 minutes.\n"
   WaitClear clear
}

#--------------------------------------------------------------------------
# WelcomeTheUserExecHost
#
WelcomeTheUserExecHost()
{
   if [ $autoinst = true ]; then
      return
   fi
 
   $INFOTEXT -u "\nWelcome to the %s installation" "$QSYST"
   $INFOTEXT -u "\n%s execution host installation" "$QSYST"
   $INFOTEXT "\nIf you haven't installed the %s qmaster host yet, you must execute" \
               "this step (with >%s<) prior the execution host installation.\n"       \
               "For a sucessfull installation you need a running %s qmaster. It is"   \
               "also neccesary that this host is an administrative host.\n"           \
               "$QSYST" "install_qmaster" "$QSYST"

   
   $INFOTEXT "You can verify your current list of administrative hosts with" \
               "the command:\n%s\n" "% qconf -sh"
   $INFOTEXT "You can add an administrative host with the command:\n%s\n"    \
               "% qconf -ah <hostname>"
   $INFOTEXT "The execution host installation will take approximately 5 minutes."
   $ECHO ""

   WaitClear clear
}

#--------------------------------------------------------------------------
# WelcomeTheUserSubmit
#
WelcomeTheUserSubmit()
{
   $INFOTEXT -u "\n%s submit host installation" "$QSYST"
   $INFOTEXT "\nAdding a submit host to the %s cluster is done with the command:\n%s\n" \
               "This command must be entered from a machine which is an administration host." \
               "The %s qmaster machine is by default an administration host." \
               "$QSYST" "% qconf -as hostname" "$QSYST"
}

#--------------------------------------------------------------------------
# StartQmaster
#
StartQmaster()
{
   $INFOTEXT -u "\n%s qmaster and scheduler startup" "$QSYST"
   $INFOTEXT "\nStarting %s qmaster and scheduler daemon. Please wait ..." "$QSYST"
   $V5_STARTUP_FILE -qmaster
   WaitClear clear
}

#--------------------------------------------------------------------------
# StartExecd
#
StartExecd()
{
   $INFOTEXT -u "\n%s execution daemon startup" "$QSYST"
   $INFOTEXT "\nStarting %s execution daemon daemon. Please wait ..." "$QSYST"
   $V5_STARTUP_FILE -execd
   WaitClear clear
}

#--------------------------------------------------------------------------
# CheckBinaries
#
CheckBinaries()
{

BINFILES="sge_commd sge_coshepherd \
          sge_execd sge_qmaster  \
          sge_schedd sge_shadowd \
          sge_shepherd sgecommdcntl qacct qalter qconf qdel qhold \
          qhost qlogin qmake qmod qmon qresub qrls qrsh qselect qsh qstat qsub qtcsh"

UTILFILES="adminrun checkprog checkuser filestat gethostbyaddr gethostbyname \
           gethostname getservbyname loadcheck now qrsh_starter rlogin rsh rshd \
           testsuidroot uidgid infotext"

THIRD_PARTY_FILES=openssl

   missing=false
   for f in $BINFILES; do
      if [ \! -f $V5BIN/$f ]; then
         missing=true
         $INFOTEXT "missing program %s in directory %s" $f $V5BIN
      fi
   done

   for f in $THIRD_PARTY_FILES; do
      if [ $f = openssl -a $csp = true ]; then
         if [ ! -f $V5UTILBIN/$f ]; then
           missing=true
           $INFOTEXT "missing program %s in directory %s" $f $V5BIN
         fi
      fi
   done

   for f in $UTILFILES; do
      if [ ! -f $V5UTILBIN/$f ]; then
         missing=true
         $INFOTEXT "missing program %s in directory %s" $f $V5UTILBIN
      fi
   done

   if [ $missing = true ]; then
      $INFOTEXT "\nMissing %s binaries!\n" $QSYST

      $INFOTEXT "A complete installation needs the following binaries in >%s<:" $V5BIN
      $ECHO ""
      $ECHO "qacct           qlogin          qrsh            sge_commd       sge_shepherd"
      $ECHO "qalter          qmake           qselect         sge_coshepherd  sgecommdcntl"
      $ECHO "qconf           qmod            qsh             sge_execd"
      $ECHO "qdel            qmon            qstat           sge_qmaster"
      $ECHO "qhold           qresub          qsub            sge_schedd"
      $ECHO "qhost           qrls            qtcsh           sge_shadowd"
      $ECHO ""
      $INFOTEXT "The binaries in >%s< are:" $V5UTILBIN
      $ECHO ""
      $ECHO "adminrun       gethostbyaddr  loadcheck      rlogin         uidgid"
      $ECHO "checkprog      gethostbyname  now            rsh            infotext"
      $ECHO "checkuser      gethostname    openssl        rshd"
      $ECHO "filestat       getservbyname  qrsh_starter   testsuidroot"
      $ECHO ""
      $INFOTEXT "Installation failed. Exit."
      exit 1
   fi
}

#--------------------------------------------------------------------------
# SetPermissions
#    - set permission for regular files to 644
#    - set permission for executables and directories to 755
#
SetPermissions()
{
   $CLEAR
   $INFOTEXT -u "\nVerifying and setting file permissions"
   $ECHO

   euid=`$V5UTILBIN/uidgid -euid`

   if [ $euid != 0 ]; then
      $INFOTEXT "You are not installing as user %s\n" root
      $INFOTEXT "Can't set the file owner/group and permissions\n"
      WaitClear clear
      return 0
   else
      Translate 0 "Did you install this version with >pkgadd< or did you already"
      Translate 4 "verify and set the file permissions of your distribution"
      YesNo "$transout" y
      if [ $? = 0 ]; then
         Translate 4 "We do not verify file permissions. Hit <RETURN> to continue >>"
         WaitClear clear "\n$transout \c"
         return 0
      fi
   fi

   rm -f ./tst$$ 2> /dev/null > /dev/null
   touch ./tst$$ 2> /dev/null > /dev/null
   ret=$?
   rm -f ./tst$$ 2> /dev/null > /dev/null
   if [ $ret != 0 ]; then
      $INFOTEXT -u "\nVerifying and setting file permissions (continued)"

      $INFOTEXT "\nWe can't set file permissions on this machine, because user root"    \
                  "has not the necessary privileges to change file permissions"           \
                  "on this file system.\n"                                                \
                  "Probably this file system is an NFS mount where user root is"          \
                  "mapped to user >nobody<.\n"                                            \
                  "Please login now at your file server and set the file permissions and" \
                  "ownership of the entire distribution with the command:\n%s %s\n"       \
                  "where %s and %s are the Unix user/group names under which"             \
                  "the files should be installed and created.\n"                            \
                  "% \$$QSYST_ROOT/util/setfileperm.sh <adminuser> <admingroup>"          \
                  "\$SGE_ROOT" "<adminuser>" "<admingroup>"

      Translate 4 "Please hit <RETURN> to continue once you set your file permissions >>"
      WaitClear clear "$transout \c"
      return 0
   elif [ $fast = false ]; then
      $CLEAR
      $INFOTEXT -u "\nVerifying and setting file permissions"
      $INFOTEXT "\nWe may now verify and set the file permissions of your %s distribution.\n" \
                  "This may be useful since due to unpacking and copying of your"  \
                  "distribution your files may be unaccessible to other users.\n"  \
                  "We will set the permissions of directories and binaries to\n\n"   \
                  "755 - that means executable are accessible for the world\n\n"   \
                  "and for ordinary files to\n\n"                                  \
                  "644 - that means readable for the world\n\n" "$QSYST"

      Translate 4 "Do you want to verify and set your file permissions"
      YesNo "\n$transout" y
      ret=$?
   else
      ret=0
   fi

   if [ $ret = 0 ]; then

      if [ $resport = true ]; then
         resportarg=-resport
      else
         resportarg="-noresport"
      fi

      if [ $ADMINUSER = default ]; then
         fileowner=root
      else
         fileowner=$ADMINUSER
      fi

      filegid=`$V5UTILBIN/uidgid -gid`

      $CLEAR

      util/setfileperm.sh -auto $resportarg $fileowner $filegid $SGE_ROOT

      WaitClear clear
   else
      Translate 4 "We will not verify your file permissions. Hit <RETURN> to continue >>"
      WaitClear clear "\n$transout \c"
   fi
}

#--------------------------------------------------------------------------
# InitCA Create CA and initialize it for deamons and users
#
InitCA()
{

   if [ $csp = false ]; then
      return
   fi

   # Initialize CA, make directories and get DN info
   #
   util/sgeCA/sge_ca -init

   WaitClear clear
}


#--------------------------------------------------------------------------
# CheckCSP check that there are no old certs/keys
#
CheckCSP()
{

   if [ $csp = false ]; then
      return
   fi

   if [ "$COMMD_PORT" != "" ]; then
      CA_PORT=port$COMMD_PORT
   else
      CA_PORT=sge_commd
   fi

   $V5UTILBIN/adminrun $ADMINUSER test -f $HOME/.sge/$CA_PORT/$SGE_CELL
   if [ ! $? ]; then
      $INFOTEXT -e "Please remove the old CSP security directory $HOME/.sge/$CA_PORT/$SGE_CELL. Exit."
      exit 1
   fi
}


#--------------------------------------------------------------------------
# THE MAIN PROCEDURE
#--------------------------------------------------------------------------

#-----------------------------------
# FIND ARCH + ARCH SPECIFIC DEFAULTS
#

myname=`basename $0`

cmdline=$*
for arg in $*; do
   if [ "$arg" = -sgeee ]; then
      myname=inst_sgeee
   fi
done

set - $cmdline

if [ $myname = inst_sge ]; then
   inst=sge
   QSYST=SGE
   QSYST_NAME=SGE
   LINE=---
   BLANKS="  "
elif [ $myname = inst_sgeee ]; then
   inst=sgeee
   QSYST=SGEEE
   QSYST_NAME=SGEEE
   LINE=-----
   BLANKS=""
else
   echo  "unknown name of this script: $0"
   echo  "must be either >inst_sge<, >inst_sgeee<"
   echo  "may be the >basename< command is not in your \$PATH"
   echo
   exit 1
fi

QSYST_ROOT=SGE_ROOT
QSYST_CELL=SGE_CELL
QSYST_MASTER_NAME=sge_qmaster
QSYST_EXECD_NAME=sge_execd
QSYST_SCHEDD_NAME=sge_schedd
QSYST_SHEPHERD_NAME=sge_shepherd
QSYST_SHADOWD_NAME=sge_shadowd
QSYST_COMMD_NAME=sge_commd
QSYST_COMMDCNTL_NAME=sgecommdcntl
QSYST_SERVICE=sge_commd

if [ ! -f util/arch_variables ]; then
   echo "missing shell script \"util/arch_variables\""
   exit 1
fi

. ./util/arch_variables

if [ ! -f util/arch ]; then
   $ECHO "missing shell script \"util/arch\""
   exit 1
fi

#----------------------------------------------------
# setup i18n

if [ "$GETTEXT" != "" -a "SGE_I18N" = true ]; then
   unset TEXTDOMAINDIR TEXTDOMAIN
   TEXTDOMAINDIR="`/bin/pwd`/locale"
   TEXTDOMAIN=gridengine
   translation=1
else
   translation=0
   unset LANG LC_ALL LC_COLLATE LC_CTYPE LC_MESSAGES LC_MONETARY
   unset LC_NUMERIC LC_TIME LANGUAGE
fi

# end of internationalization setup
#----------------------------------------------------

umask 022

unset GRD_DEBUG_LEVEL
unset COD_DEBUG_LEVEL
unset SGE_DEBUG_LEVEL

unset CODINE_ROOT 
unset GRD_ROOT

V5BIN=bin/$ARCH
V5UTILBIN=utilbin/$ARCH
QSYST_CELL_VAL=`eval echo '$'$QSYST_CELL`
if [ "$QSYST_CELL_VAL" = "" ]; then
   eval $QSYST_CELL=default
   QSYST_CELL_VAL=default
else
   QSYST_CELL_VAL=`eval echo '$'$QSYST_CELL`
fi
export $QSYST_CELL

ADMINUSER=default
MYUID=`$V5UTILBIN/uidgid -uid`
MYGID=`$V5UTILBIN/uidgid -gid`
DIRPERM=755
FILEPERM=644


#-----------------------------
# setup INFOTEXT
#-----------------------------
INFOTEXT=$V5UTILBIN/infotext
if [ ! -f $INFOTEXT ]; then
   $ECHO "can't find \"$INFOTEXT\""
   $ECHO "Installation failed."
   exit 1
fi


HOST=`$V5UTILBIN/gethostname -name`
if [ "$HOST" = "" ]; then
   $INFOTEXT -e "can't determine your hostname. Installation failed."
   exit 1
fi


#-----------------------------
# commandline argument parsing
#
WHICH="undef"
strict=true
fast=false
autoinst=false
addqueue=true
resport=false
afs=false
csp=false

ARGC=$#
while [ $ARGC != 0 ]; do
   case $1 in
   -m)
      WHICH="qmaster"
      ;;
   -x)
      WHICH="execd"
      ;;
   -s)
      WHICH="submit"
      ;;
   -afs)
      afs=true
      ;;
   -nostrict)
      strict=false
      ;;
   -resport)
      resport=true
      ;;
   -fast)
      fast=true
      ;;
   -auto)
      if [ $WHICH = execd ]; then
         autoinst=true
         CLEAR=:
      fi
      ;;
   -noqueue)
      addqueue=false
      ;;
   -csp)
      csp=true
      ;;
   *)
      $ECHO "" >&2
      $INFOTEXT -e "Error: Unknown option %s" $1
      ErrUsage $0
      ;;
   esac
   shift
   ARGC=`expr $ARGC - 1`
done

if [ "$WHICH" = "undef" ]; then
   ErrUsage $0
fi

# exit if there are missing binaries
#
CheckBinaries

$CLEAR

case $WHICH in
qmaster)
   autoinst=false
   WelcomeTheUser
   PreCheckForFastInstall qmaster
   ret=$?

   if [ $ret = 0 ]; then
      AskIfDefaultOkAndSetVariables
      ret=$?
   fi

   if [ $ret != 0 ]; then
      CheckWhoInstallsQsyst
      ProcessQsystRoot
      CheckForCommdPort qmaster
      GetCell
      GetQmasterSpoolDir $euid
      SetCellDependentVariables
   fi

   SetPermissions
   MakeDirsMaster
   SelectHostNameResolving
   AddConfiguration
   $CLEAR
   AddLocalConfiguration
   AddActQmaster
   AddDefaultComplexes
   AddPEFiles
   AddDefaultDepartement
   AddCommonFiles
   CreateSettingsFile
   WaitClear clear
   InitCA
   AddQsystStartUpScript $euid true
   StartQmaster
   AddHosts
   GiveHints
   ;;
execd)
   WelcomeTheUserExecHost
   PreCheckForFastInstall execd
   ret=$?
   if [ $ret = 0 ]; then
      AskIfDefaultOkAndSetVariables
      ret=$?
   fi

   if [ $ret != 0 ]; then
      CheckWhoInstallsQsyst
      ProcessQsystRoot
      CheckQmasterInstallation
      CheckForCommdPort exec
   fi
   CheckCellDirectory
   CheckCSP
   CheckHostNameResolving
   AddLocalConfiguration_With_Qconf
   AddQsystStartUpScript $euid false
   StartExecd
   AddQueue
   GiveHints
   ;;
submit)
   WelcomeTheUserSubmit
   ;;
esac

exit 0
