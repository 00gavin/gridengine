<HTML>
<HEAD>
<!-- Created by texi2html 1.56k from eventclient.texi on 9 April 2002 -->

<TITLE>Autodocs for Grid Engine Event Client Interface</TITLE>
</HEAD>
<BODY>
<H1>Grid Engine Event Client Interface</H1>
<H2>Documentation taken from source code</H2>
<H2>Edition 1.0 for Version pre6.0 (Maintrunk)</H2>
<H2>@today</H2>
<ADDRESS>The Grid Engine Team</ADDRESS>
<P>
<P><HR><P>
<H1>Table of Contents</H1>
<UL>
<LI><A NAME="TOC1" HREF="eventclient.html#SEC1">Eventclient</A>
<UL>
<LI><A NAME="TOC2" HREF="eventclient.html#SEC2">--EV_Type</A>
<LI><A NAME="TOC3" HREF="eventclient.html#SEC3">--Event_Client_Interface</A>
<LI><A NAME="TOC4" HREF="eventclient.html#SEC4">-Busy-state</A>
<LI><A NAME="TOC5" HREF="eventclient.html#SEC5">-Events</A>
<LI><A NAME="TOC6" HREF="eventclient.html#SEC6">-Flushing</A>
<LI><A NAME="TOC7" HREF="eventclient.html#SEC7">-ID-numbers</A>
<LI><A NAME="TOC8" HREF="eventclient.html#SEC8">-Subscription</A>
<LI><A NAME="TOC9" HREF="eventclient.html#SEC9">Client</A>
<UL>
<LI><A NAME="TOC10" HREF="eventclient.html#SEC10">--Event_Client</A>
<LI><A NAME="TOC11" HREF="eventclient.html#SEC11">-Event_Client_Global_Variables</A>
<LI><A NAME="TOC12" HREF="eventclient.html#SEC12">ck_event_number</A>
<LI><A NAME="TOC13" HREF="eventclient.html#SEC13">ec_commit</A>
<LI><A NAME="TOC14" HREF="eventclient.html#SEC14">ec_config_changed</A>
<LI><A NAME="TOC15" HREF="eventclient.html#SEC15">ec_deregister</A>
<LI><A NAME="TOC16" HREF="eventclient.html#SEC16">ec_get</A>
<LI><A NAME="TOC17" HREF="eventclient.html#SEC17">ec_get_busy</A>
<LI><A NAME="TOC18" HREF="eventclient.html#SEC18">ec_get_busy_handling</A>
<LI><A NAME="TOC19" HREF="eventclient.html#SEC19">ec_get_clientdata</A>
<LI><A NAME="TOC20" HREF="eventclient.html#SEC20">ec_get_edtime</A>
<LI><A NAME="TOC21" HREF="eventclient.html#SEC21">ec_get_flush</A>
<LI><A NAME="TOC22" HREF="eventclient.html#SEC22">ec_mark4registration</A>
<LI><A NAME="TOC23" HREF="eventclient.html#SEC23">ec_need_new_registration</A>
<LI><A NAME="TOC24" HREF="eventclient.html#SEC24">ec_prepare_registration</A>
<LI><A NAME="TOC25" HREF="eventclient.html#SEC25">ec_register</A>
<LI><A NAME="TOC26" HREF="eventclient.html#SEC26">ec_set_busy</A>
<LI><A NAME="TOC27" HREF="eventclient.html#SEC27">ec_set_busy_handling</A>
<LI><A NAME="TOC28" HREF="eventclient.html#SEC28">ec_set_clientdata</A>
<LI><A NAME="TOC29" HREF="eventclient.html#SEC29">ec_set_edtime</A>
<LI><A NAME="TOC30" HREF="eventclient.html#SEC30">ec_set_flush</A>
<LI><A NAME="TOC31" HREF="eventclient.html#SEC31">ec_subscribe</A>
<LI><A NAME="TOC32" HREF="eventclient.html#SEC32">ec_subscribe_all</A>
<LI><A NAME="TOC33" HREF="eventclient.html#SEC33">ec_subscribe_flush</A>
<LI><A NAME="TOC34" HREF="eventclient.html#SEC34">ec_unset_flush</A>
<LI><A NAME="TOC35" HREF="eventclient.html#SEC35">ec_unsubscribe</A>
<LI><A NAME="TOC36" HREF="eventclient.html#SEC36">ec_unsubscribe_all</A>
<LI><A NAME="TOC37" HREF="eventclient.html#SEC37">get_event_list</A>
</UL>
<LI><A NAME="TOC38" HREF="eventclient.html#SEC38">Server</A>
<UL>
<LI><A NAME="TOC39" HREF="eventclient.html#SEC39">--Event_Client_Server</A>
<LI><A NAME="TOC40" HREF="eventclient.html#SEC40">-Event_Client_Server_Defines</A>
<LI><A NAME="TOC41" HREF="eventclient.html#SEC41">-Event_Client_Server_Global_Variables</A>
<LI><A NAME="TOC42" HREF="eventclient.html#SEC42">check_send_new_subscribed_list</A>
<LI><A NAME="TOC43" HREF="eventclient.html#SEC43">ck_4_deliver_events</A>
<LI><A NAME="TOC44" HREF="eventclient.html#SEC44">reinit_event_client</A>
<LI><A NAME="TOC45" HREF="eventclient.html#SEC45">set_event_client_busy</A>
<LI><A NAME="TOC46" HREF="eventclient.html#SEC46">sge_ack_event</A>
<LI><A NAME="TOC47" HREF="eventclient.html#SEC47">sge_add_event</A>
<LI><A NAME="TOC48" HREF="eventclient.html#SEC48">sge_add_event_client</A>
<LI><A NAME="TOC49" HREF="eventclient.html#SEC49">sge_add_list_event</A>
<LI><A NAME="TOC50" HREF="eventclient.html#SEC50">sge_event_client_exit</A>
<LI><A NAME="TOC51" HREF="eventclient.html#SEC51">sge_eventclient_subscribed</A>
<LI><A NAME="TOC52" HREF="eventclient.html#SEC52">sge_flush_events</A>
<LI><A NAME="TOC53" HREF="eventclient.html#SEC53">sge_gdi_kill_eventclient</A>
<LI><A NAME="TOC54" HREF="eventclient.html#SEC54">sge_gdi_tsm</A>
<LI><A NAME="TOC55" HREF="eventclient.html#SEC55">sge_get_next_event_number</A>
<LI><A NAME="TOC56" HREF="eventclient.html#SEC56">sge_locate_event_client</A>
<LI><A NAME="TOC57" HREF="eventclient.html#SEC57">sge_mod_event_client</A>
<LI><A NAME="TOC58" HREF="eventclient.html#SEC58">sge_next_flush</A>
<LI><A NAME="TOC59" HREF="eventclient.html#SEC59">sge_total_update_event</A>
<LI><A NAME="TOC60" HREF="eventclient.html#SEC60">total_update</A>
</UL>
<LI><A NAME="TOC61" HREF="eventclient.html#SEC61">event_text</A>
</UL>
<LI><A NAME="TOC62" HREF="eventclient.html#SEC62">Function Index</A>
</UL>
<P><HR><P>

<P>
Copyright (C) The Grid Engine Team




<H1><A NAME="SEC1" HREF="eventclient.html#TOC1">Eventclient</A></H1>



<H2><A NAME="SEC2" HREF="eventclient.html#TOC2">--EV_Type</A></H2>

<P>
<A NAME="IDX1"></A>


<DL COMPACT>

<DT><B>NAME</B>
<DD>

<PRE>
EV_Type -- event client object
</PRE>


<DT><B>ELEMENTS</B>
<DD>

<PRE>
SGE_ULONG(EV_id)
   event client id (see Eventclient/-ID-numbers)

SGE_STRING(EV_name)
   event client name (any string characterizing the client)

SGE_HOST(EV_host)
   host on which the event client resides

SGE_STRING(EV_commproc)
   addressing information

SGE_ULONG(EV_commid)
   unique id of the event client in commd

SGE_ULONG(EV_uid)
   user id under which the event client is running

SGE_ULONG(EV_d_time)
   event delivery time (interval used by qmaster to deliver events)

SGE_STRING(EV_subscription)
   information about subscription and flushing
   (see Eventclient/-Subscription and Eventclient/-Flushing)

SGE_ULONG(EV_busy_handling)
   information about handling of busy states
   (see Eventclient/-Busy-state)

SGE_ULONG(EV_last_heard_from)
   time when qmaster heard from the event client for the last time

SGE_ULONG(EV_last_send_time)
   time of the last delivery of events

SGE_ULONG(EV_next_send_time)
   next time scheduled for the delivery of events

SGE_ULONG(EV_next_number)
   next sequential number for events (each event gets a unique number)

SGE_ULONG(EV_busy)
   is the event client busy? (0 = false, 1 = true)
   no events will be delivered to a busy client

SGE_LIST(EV_events)
   list of events - they will be spooled until the event client
   acknowledges receipt

SGE_ULONG(EV_clientdata)
   a 32bit ulong for use by the event client or special handling
   for certain event clients
</PRE>


<DT><B>FUNCTION</B>
<DD>

<PRE>
An event client creates and initializes such an object and passes
it to qmaster for registration.
Qmaster will fill some of the fields (e.g. the EV_id) and send
the object back to the event client on successful registration.
Whenever the event client wants to change some configuration
parameters, it changes the object and sends it to qmaster
with a modification request.

Qmaster uses the object internally to track sequential numbers,
delivery times, timeouts etc.
</PRE>


<DT><B>SEE ALSO</B>
<DD>

<UL>
<LI>

section <A HREF="eventclient.html#SEC3">--Event_Client_Interface</A>.
<LI>

section <A HREF="eventclient.html#SEC7">-ID-numbers</A>.
<LI>

section <A HREF="eventclient.html#SEC8">-Subscription</A>.
<LI>

section <A HREF="eventclient.html#SEC6">-Flushing</A>.
<LI>

section <A HREF="eventclient.html#SEC4">-Busy-state</A>.
</UL>

</DL>



<H2><A NAME="SEC3" HREF="eventclient.html#TOC3">--Event_Client_Interface</A></H2>

<P>
<A NAME="IDX2"></A>


<DL COMPACT>

<DT><B>NAME</B>
<DD>

<PRE>
Evenclient -- The Grid Engine Event Client Interface
</PRE>


<DT><B>FUNCTION</B>
<DD>

<PRE>
The Grid Engine Event Client Interface provides a means to connect
to the Grid Engine qmaster and receive information about objects
(actual object properties and changes).
It provides a subscribe/unsubscribe mechanism allowing fine grained
selection of objects per object types (e.g. jobs, queues, hosts)
and event types (e.g. add, modify, delete).
Flushing triggered by individual events can be set.
Policies can be set how to handle busy event clients.
It should have much less impact on qmaster performance than polling
the same data in regular intervals.
</PRE>


<DT><B>NOTES</B>
<DD>

<PRE>
The current implementation is a generalized form of the event client
interface that already existed in Codine/GRD.
</PRE>


<DT><B>SEE ALSO</B>
<DD>

<UL>
<LI>

section <A HREF="eventclient.html#SEC2">--EV_Type</A>.
<LI>

section <A HREF="eventclient.html#SEC8">-Subscription</A>.
<LI>

section <A HREF="eventclient.html#SEC6">-Flushing</A>.
<LI>

section <A HREF="eventclient.html#SEC4">-Busy-state</A>.
<LI>

section <A HREF="eventclient.html#SEC10">--Event_Client</A>.
<LI>

section <A HREF="eventclient.html#SEC39">--Event_Client_Server</A>.
</UL>

</DL>



<H2><A NAME="SEC4" HREF="eventclient.html#TOC4">-Busy-state</A></H2>

<P>
<A NAME="IDX3"></A>


<DL COMPACT>

<DT><B>NAME</B>
<DD>

<PRE>
Busy-state -- Handling of busy event clients
</PRE>


<DT><B>FUNCTION</B>
<DD>

<PRE>
An event client may have time periods where it is busy doing some
processing and can not accept new events.

In this case, qmaster should not send out new events but spool them,
as otherwise timeouts would occur waiting for acknowledges.

Therefore an event client can set a policy that describes how busy
states are set and unset.

Which policy to use is set with the ev_set_busy_handling() function
call. The policy can be changed dynamically at runtime.

The following policies are implemented at present:
   EV_BUSY_NO_HANDLING    - busy state is not handled automatically
                            by the event client interface
   EV_BUSY_UNTIL_ACK      - when delivering events qmaster will set
                            the eventclient to busy and will unset
                            the busy state when the event client
                            acknowledges receipt of the events.
   EV_BUSY_UNTIL_RELEASED - when delivering events qmaster will set
                            the eventclient to busy.
                            It will stay in the busy state until it
                            is explicitly released by the client
                            (calling ec_set_busy(0))
</PRE>


<DT><B>SEE ALSO</B>
<DD>

<UL>
<LI>

section <A HREF="eventclient.html#SEC27">ec_set_busy_handling</A>.
<LI>

section <A HREF="eventclient.html#SEC26">ec_set_busy</A>.
</UL>

</DL>



<H2><A NAME="SEC5" HREF="eventclient.html#TOC5">-Events</A></H2>

<P>
<A NAME="IDX4"></A>


<DL COMPACT>

<DT><B>NAME</B>
<DD>

<PRE>
Events -- events available from qmaster
</PRE>


<DT><B>FUNCTION</B>
<DD>

<PRE>
The following events can be raised in qmaster and be subscribed
by an event client:

   sgeE_ALL_EVENTS

   sgeE_ADMINHOST_LIST              send admin host list at registration
   sgeE_ADMINHOST_ADD               event add admin host
   sgeE_ADMINHOST_DEL               event delete admin host
   sgeE_ADMINHOST_MOD               event modify admin host

   sgeE_CALENDAR_LIST               send calendar list at registration
   sgeE_CALENDAR_ADD                event add calendar
   sgeE_CALENDAR_DEL                event delete calendar
   sgeE_CALENDAR_MOD                event modify calendar

   sgeE_CKPT_LIST                   send ckpt list at registration
   sgeE_CKPT_ADD                    event add ckpt
   sgeE_CKPT_DEL                    event delete ckpt
   sgeE_CKPT_MOD                    event modify ckpt

   sgeE_COMPLEX_LIST                send complex list at registration
   sgeE_COMPLEX_ADD                 event add complex
   sgeE_COMPLEX_DEL                 event delete complex
   sgeE_COMPLEX_MOD                 event modify complex

   sgeE_CONFIG_LIST                 send config list at registration
   sgeE_CONFIG_ADD                  event add config
   sgeE_CONFIG_DEL                  event delete config
   sgeE_CONFIG_MOD                  event modify config

   sgeE_EXECHOST_LIST               send exec host list at registration
   sgeE_EXECHOST_ADD                event add exec host
   sgeE_EXECHOST_DEL                event delete exec host
   sgeE_EXECHOST_MOD                event modify exec host

   sgeE_GLOBAL_CONFIG               global config changed, replace by sgeE_CONFIG_MOD

   sgeE_JATASK_DEL                  event delete array job task
   sgeE_JATASK_MOD                  event modify array job task

   sgeE_JOB_LIST                    send job list at registration
   sgeE_JOB_ADD                     event job add (new job)
   sgeE_JOB_DEL                     event job delete
   sgeE_JOB_MOD                     event job modify
   sgeE_JOB_MOD_SCHED_PRIORITY      event job modify priority
   sgeE_JOB_USAGE                   event job online usage
   sgeE_JOB_FINAL_USAGE             event job final usage report after job end

   sgeE_JOB_SCHEDD_INFO_LIST        send job schedd info list at registration
   sgeE_JOB_SCHEDD_INFO_ADD         event jobs schedd info added
   sgeE_JOB_SCHEDD_INFO_DEL         event jobs schedd info deleted
   sgeE_JOB_SCHEDD_INFO_MOD         event jobs schedd info modified

   sgeE_MANAGER_LIST                send manager list at registration
   sgeE_MANAGER_ADD                 event add manager
   sgeE_MANAGER_DEL                 event delete manager
   sgeE_MANAGER_MOD                 event modify manager

   sgeE_OPERATOR_LIST               send operator list at registration
   sgeE_OPERATOR_ADD                event add operator
   sgeE_OPERATOR_DEL                event delete operator
   sgeE_OPERATOR_MOD                event modify operator

   sgeE_NEW_SHARETREE               replace possibly existing share tree

   sgeE_PE_LIST                     send pe list at registration
   sgeE_PE_ADD                      event pe add
   sgeE_PE_DEL                      event pe delete
   sgeE_PE_MOD                      event pe modify

   sgeE_PROJECT_LIST                send project list at registration
   sgeE_PROJECT_ADD                 event project add
   sgeE_PROJECT_DEL                 event project delete
   sgeE_PROJECT_MOD                 event project modify

   sgeE_QMASTER_GOES_DOWN           qmaster notifies all event clients, before
                                    it exits

   sgeE_QUEUE_LIST                  send queue list at registration
   sgeE_QUEUE_ADD                   event queue add
   sgeE_QUEUE_DEL                   event queue delete
   sgeE_QUEUE_MOD                   event queue modify
   sgeE_QUEUE_SUSPEND_ON_SUB        queue is suspended by subordinate mechanism
   sgeE_QUEUE_UNSUSPEND_ON_SUB      queue is unsuspended by subordinate mechanism

   sgeE_SCHED_CONF                  replace existing (sge) scheduler configuration

   sgeE_SCHEDDMONITOR               trigger scheduling run

   sgeE_SHUTDOWN                    request shutdown of an event client

   sgeE_SUBMITHOST_LIST             send submit host list at registration
   sgeE_SUBMITHOST_ADD              event add submit host
   sgeE_SUBMITHOST_DEL              event delete submit host
   sgeE_SUBMITHOST_MOD              event modify submit host

   sgeE_USER_LIST                   send user list at registration
   sgeE_USER_ADD                    event user add
   sgeE_USER_DEL                    event user delete
   sgeE_USER_MOD                    event user modify

   sgeE_USERSET_LIST                send userset list at registration
   sgeE_USERSET_ADD                 event userset add
   sgeE_USERSET_DEL                 event userset delete
   sgeE_USERSET_MOD                 event userset modify

If user mapping is enabled (compile time option), the following
additional events can be subscribed:

   sgeE_USERMAPPING_ENTRY_LIST      send list of user mappings
   sgeE_USERMAPPING_ENTRY_ADD       a new user mapping was added
   sgeE_USERMAPPING_ENTRY_DEL       a user mapping was deleted
   sgeE_USERMAPPING_ENTRY_MOD       a user mapping entry was changed

   sgeE_HOST_GROUP_LIST             send list of host groups
   sgeE_HOST_GROUP_ADD              a host group was added
   sgeE_HOST_GROUP_DEL              a host group was deleted
   sgeE_HOST_GROUP_MOD              a host group was changed
</PRE>


<DT><B>NOTES</B>
<DD>

<PRE>
This list of events will increase as further event situations
are identified and interfaced.
</PRE>


<DT><B>SEE ALSO</B>
<DD>

<UL>
<LI>

section <A HREF="eventclient.html#SEC8">-Subscription</A>.
</UL>

</DL>



<H2><A NAME="SEC6" HREF="eventclient.html#TOC6">-Flushing</A></H2>

<P>
<A NAME="IDX5"></A>


<DL COMPACT>

<DT><B>NAME</B>
<DD>

<PRE>
Flushing -- Configuration of event flushing
</PRE>


<DT><B>FUNCTION</B>
<DD>

<PRE>
In the standard configuration, qmaster will deliver events
in certain intervals to event clients.
These intervals can be configured using the ec_set_edtime()
function call.

In certain cases, an event client will want to be immediately
notified, if certain events occur. A scheduler for example
could be notified immediately, if resources in a cluster become
available to allow instant refilling of the cluster.

The event client interface allows to configure flushing
for each individual event id.

Flushing can either be switched off (default) for an event, or
a delivery time can be configured.
If a delivery time is configured, events for the event client
will be delivered by qmaster at latest after this delivery time.
A delivery time of 0 means instant delivery.

Flushing can be changed dynamically at runtime through the
ec_set_flush/ec_unset_flush functions.
</PRE>


<DT><B>SEE ALSO</B>
<DD>

<UL>
<LI>

section <A HREF="eventclient.html#SEC29">ec_set_edtime</A>.
<LI>

section <A HREF="eventclient.html#SEC30">ec_set_flush</A>.
<LI>

section <A HREF="eventclient.html#SEC34">ec_unset_flush</A>.
<LI>

section <A HREF="eventclient.html#SEC33">ec_subscribe_flush</A>.
</UL>

</DL>



<H2><A NAME="SEC7" HREF="eventclient.html#TOC7">-ID-numbers</A></H2>

<P>
<A NAME="IDX6"></A>


<DL COMPACT>

<DT><B>NAME</B>
<DD>

<PRE>
ID-numbers -- id numbers for registration
</PRE>


<DT><B>SYNOPSIS</B>
<DD>

<PRE>
#include &#60;sge_eventL.h&#62;
</PRE>


<DT><B>FUNCTION</B>
<DD>

<PRE>
Each event client registered at qmaster has a unique client id.
The request for registering at qmaster contains either a concrete
id the client wants to occupy, or it asks the qmaster to assign
an id.
The client sets the id to use at registration with the
ec_prepare_registration function call.

The following id's can be used:
   EV_ID_ANY    - qmaster will assign a unique id
   EV_ID_SCHEDD - register at qmaster as scheduler
</PRE>


<DT><B>NOTES</B>
<DD>

<PRE>
As long as an event client does not expect any special handling
within qmaster, it should let qmaster assign an id.

If a client expects special handling, a new id in the range
[2;10] has to be created and the special handling has to be
implemented in qmaster (probably in sge_m_event.c).
</PRE>


<DT><B>SEE ALSO</B>
<DD>

<UL>
<LI>

section <A HREF="eventclient.html#SEC24">ec_prepare_registration</A>.
<LI>

section <A HREF="eventclient.html#SEC48">sge_add_event_client</A>.
</UL>

</DL>



<H2><A NAME="SEC8" HREF="eventclient.html#TOC8">-Subscription</A></H2>

<P>
<A NAME="IDX7"></A>


<DL COMPACT>

<DT><B>NAME</B>
<DD>

<PRE>
Subscription -- Subscription interface for event clients
</PRE>


<DT><B>FUNCTION</B>
<DD>

<PRE>
An event client is notified, if certain event conditions are
raised in qmaster.

Which events an event client is interested in can be set through
the subscription interface.

Events have a unique event identification that classifies them,
e.g. "a job has been submitted" or "a queue has been disabled".

Delivery of events can be switched on/off for each event id
individually.

Subscription can be changed dynamically at runtime through the
ec_subscribe/ec_unsubscribe functions.
</PRE>


<DT><B>SEE ALSO</B>
<DD>

<UL>
<LI>

section <A HREF="eventclient.html#SEC5">-Events</A>.
<LI>

section <A HREF="eventclient.html#SEC31">ec_subscribe</A>.
<LI>

section <A HREF="eventclient.html#SEC32">ec_subscribe_all</A>.
<LI>

section <A HREF="eventclient.html#SEC35">ec_unsubscribe</A>.
<LI>

section <A HREF="eventclient.html#SEC36">ec_unsubscribe_all</A>.
<LI>

section <A HREF="eventclient.html#SEC33">ec_subscribe_flush</A>.
</UL>

</DL>



<H2><A NAME="SEC9" HREF="eventclient.html#TOC9">Client</A></H2>



<H3><A NAME="SEC10" HREF="eventclient.html#TOC10">--Event_Client</A></H3>

<P>
<A NAME="IDX8"></A>


<DL COMPACT>

<DT><B>NAME</B>
<DD>

<PRE>
Event Client Interface -- Client Functionality
</PRE>


<DT><B>FUNCTION</B>
<DD>

<PRE>
The client side of the event client interface provides functions
to register and deregister (before registering, you have to call
ec_prepare_registration to set an id and client name).

The subscribe / unsubscribe mechanism allows to select the data
(object types and events) an event client shall be sent.

It is possible to set the interval in which qmaster will send
new events to an event client.
</PRE>


<DT><B>EXAMPLE</B>
<DD>

<PRE>
clients/qevent/qevent.c can serve as a simple example.
The scheduler (daemons/schedd/sge_schedd.c) is also implemented
as event client and uses all mechanisms of the event client
interface.
</PRE>


<DT><B>SEE ALSO</B>
<DD>

<UL>
<LI>

section <A HREF="eventclient.html#SEC3">--Event_Client_Interface</A>.
<LI>

section <A HREF="eventclient.html#SEC24">ec_prepare_registration</A>.
<LI>

section <A HREF="eventclient.html#SEC25">ec_register</A>.
<LI>

section <A HREF="eventclient.html#SEC15">ec_deregister</A>.
<LI>

section <A HREF="eventclient.html#SEC31">ec_subscribe</A>.
<LI>

section <A HREF="eventclient.html#SEC32">ec_subscribe_all</A>.
<LI>

section <A HREF="eventclient.html#SEC35">ec_unsubscribe</A>.
<LI>

section <A HREF="eventclient.html#SEC36">ec_unsubscribe_all</A>.
<LI>

section <A HREF="eventclient.html#SEC21">ec_get_flush</A>.
<LI>

section <A HREF="eventclient.html#SEC30">ec_set_flush</A>.
<LI>

section <A HREF="eventclient.html#SEC34">ec_unset_flush</A>.
<LI>

section <A HREF="eventclient.html#SEC33">ec_subscribe_flush</A>.
<LI>

section <A HREF="eventclient.html#SEC29">ec_set_edtime</A>.
<LI>

section <A HREF="eventclient.html#SEC20">ec_get_edtime</A>.
<LI>

section <A HREF="eventclient.html#SEC27">ec_set_busy_handling</A>.
<LI>

section <A HREF="eventclient.html#SEC18">ec_get_busy_handling</A>.
<LI>

section <A HREF="eventclient.html#SEC28">ec_set_clientdata</A>.
<LI>

section <A HREF="eventclient.html#SEC19">ec_get_clientdata</A>.
<LI>

section <A HREF="eventclient.html#SEC13">ec_commit</A>.
<LI>

section <A HREF="eventclient.html#SEC16">ec_get</A>.
<LI>

section <A HREF="eventclient.html#SEC22">ec_mark4registration</A>.
<LI>

section <A HREF="eventclient.html#SEC23">ec_need_new_registration</A>.
</UL>

</DL>


<H3><A NAME="SEC11" HREF="eventclient.html#TOC11">-Event_Client_Global_Variables</A></H3>

<P>
<A NAME="IDX9"></A>


<DL COMPACT>

<DT><B>NAME</B>
<DD>

<PRE>
Global_Variables -- global variables in the client
</PRE>


<DT><B>SYNOPSIS</B>
<DD>

<PRE>
static int config_changed = 0;
static int need_register  = 1;
static lListElem *ec      = NULL;
static u_long32 ec_reg_id = 0;
</PRE>


<DT><B>FUNCTION</B>
<DD>

<PRE>
config_changed - the configuration changed (subscription or event interval)
need_register  - the client is not registered at the server
ec             - event client object holding configuration data
ec_reg_id      - the id used to register at the qmaster
</PRE>


<DT><B>NOTES</B>
<DD>

<PRE>
These global variables should be part of the event client object.
The only remaining global variable would be a list of event client objects,
allowing one client to connect to multiple event client servers.
</PRE>


</DL>


<H3><A NAME="SEC12" HREF="eventclient.html#TOC12">ck_event_number</A></H3>

<P>
<A NAME="IDX10"></A>


<DL COMPACT>

<DT><B>NAME</B>
<DD>

<PRE>
ck_event_number() -- test event numbers
</PRE>


<DT><B>SYNOPSIS</B>
<DD>

<PRE>
#include "sge_c_event.h"

static u_long32 ck_event_number(lList *lp, u_long32 *waiting_for,
                                u_long32 *wrong_number)
</PRE>


<DT><B>FUNCTION</B>
<DD>

<PRE>
Tests list of events if it contains right numbered events.

Events with numbers lower than expected get trashed.

In cases the master has added no new events to the event list
and the acknowledge we sent was lost also a list with events lower
than "waiting_for" is correct.
But the number of the last event must be at least "waiting_for"-1.

On success *waiting_for will contain the next number we wait for.

On failure *waiting_for gets not changed and if wrong_number is not
NULL *wrong_number contains the wrong number we got.
</PRE>


<DT><B>INPUTS</B>
<DD>

<PRE>
lList *lp              - event list to check
u_long32 *waiting_for  - next number to wait for
u_long32 *wrong_number - event number that causes a failure
</PRE>


<DT><B>RESULT</B>
<DD>

<PRE>
static u_long32 - 0 on success, else -1
</PRE>


</DL>


<H3><A NAME="SEC13" HREF="eventclient.html#TOC13">ec_commit</A></H3>

<P>
<A NAME="IDX11"></A>


<DL COMPACT>

<DT><B>NAME</B>
<DD>

<PRE>
ec_commit() -- commit configuration changes
</PRE>


<DT><B>SYNOPSIS</B>
<DD>

<PRE>
#include "sge_c_event.h"

int ec_commit(void)
</PRE>


<DT><B>FUNCTION</B>
<DD>

<PRE>
Configuration changes (subscription and/or event delivery time) will be
sent to the event server.
The function should be called after (multiple) configuration changes
have been made.
If it is not explicitly called by the event client program, the next
call of ec_get will commit configuration changes before looking for new
events.
</PRE>


<DT><B>RESULT</B>
<DD>

<PRE>
int - 1 on success, else 0
</PRE>


<DT><B>SEE ALSO</B>
<DD>

<UL>
<LI>

section <A HREF="eventclient.html#SEC14">ec_config_changed</A>.
<LI>

section <A HREF="eventclient.html#SEC16">ec_get</A>.
</UL>

</DL>


<H3><A NAME="SEC14" HREF="eventclient.html#TOC14">ec_config_changed</A></H3>

<P>
<A NAME="IDX12"></A>


<DL COMPACT>

<DT><B>NAME</B>
<DD>

<PRE>
ec_config_changed() -- tell system the config has changed
</PRE>


<DT><B>SYNOPSIS</B>
<DD>

<PRE>
#include "sge_c_event.h"

static void ec_config_changed(void)
</PRE>


<DT><B>FUNCTION</B>
<DD>

<PRE>
Checkes whether the configuration has changes.
Configuration changes can either be changes in the subscription
or change of the event delivery interval.
</PRE>


<DT><B>SEE ALSO</B>
<DD>

<UL>
<LI>

section <A HREF="eventclient.html#SEC31">ec_subscribe</A>.
<LI>

section <A HREF="eventclient.html#SEC32">ec_subscribe_all</A>.
<LI>

section <A HREF="eventclient.html#SEC35">ec_unsubscribe</A>.
<LI>

section <A HREF="eventclient.html#SEC36">ec_unsubscribe_all</A>.
<LI>

section <A HREF="eventclient.html#SEC29">ec_set_edtime</A>.
</UL>

</DL>


<H3><A NAME="SEC15" HREF="eventclient.html#TOC15">ec_deregister</A></H3>

<P>
<A NAME="IDX13"></A>


<DL COMPACT>

<DT><B>NAME</B>
<DD>

<PRE>
ec_deregister() -- deregister from the event server
</PRE>


<DT><B>SYNOPSIS</B>
<DD>

<PRE>
#include "sge_c_event.h"

int ec_deregister(void)
</PRE>


<DT><B>FUNCTION</B>
<DD>

<PRE>
Deregister from the event server (usually the qmaster).
This function should be called when an event client exits.

If an event client does not deregister, qmaster will spool events for this
client until it times out (it did not acknowledge events sent by qmaster).
After the timeout, it will be deleted.
</PRE>


<DT><B>RESULT</B>
<DD>

<PRE>
int - 1, if the deregistration succeeded, else 0
</PRE>


<DT><B>SEE ALSO</B>
<DD>

<UL>
<LI>

section <A HREF="eventclient.html#SEC25">ec_register</A>.
</UL>

</DL>


<H3><A NAME="SEC16" HREF="eventclient.html#TOC16">ec_get</A></H3>

<P>
<A NAME="IDX14"></A>


<DL COMPACT>

<DT><B>NAME</B>
<DD>

<PRE>
ec_get() -- look for new events
</PRE>


<DT><B>SYNOPSIS</B>
<DD>

<PRE>
#include "sge_c_event.h"

int ec_get(lList **event_list)
</PRE>


<DT><B>FUNCTION</B>
<DD>

<PRE>
ec_get looks for new events.
If new events have arrived, they are passed back to the caller in the
parameter event_list.

If the event client is not yet registered at the event server,
the registration will be done before looking for events.

If the configuration changed since the last call of ec_get and has
not been committed, ec_commit will be called before looking for
events.
</PRE>


<DT><B>INPUTS</B>
<DD>

<PRE>
lList **event_list - pointer to an event list to hold arriving events
</PRE>


<DT><B>RESULT</B>
<DD>

<PRE>
int - 0, if events or an empty event list was received, or
         if no data was received within a certain time period
     &#60;0 (commlib error code), if an error occured
</PRE>


<DT><B>NOTES</B>
<DD>

<PRE>
The event_list has to be freed by the calling function.
</PRE>


<DT><B>SEE ALSO</B>
<DD>

<UL>
<LI>

section <A HREF="eventclient.html#SEC25">ec_register</A>.
<LI>

section <A HREF="eventclient.html#SEC13">ec_commit</A>.
</UL>

</DL>


<H3><A NAME="SEC17" HREF="eventclient.html#TOC17">ec_get_busy</A></H3>

<P>
<A NAME="IDX15"></A>


<DL COMPACT>

<DT><B>NAME</B>
<DD>

<PRE>
ec_get_busy() -- get the busy state
</PRE>


<DT><B>SYNOPSIS</B>
<DD>

<PRE>
int ec_get_busy(void)
</PRE>


<DT><B>FUNCTION</B>
<DD>

<PRE>
Reads the busy state of the event client.
</PRE>


<DT><B>RESULT</B>
<DD>

<PRE>
int - 1: the client is busy, 0: the client is idle
</PRE>


<DT><B>NOTES</B>
<DD>

<PRE>
The function only returns the local busy state in the event client itself.
If this state changes, it will be reported to qmaster with the next
communication, but not back from qmaster to the client.
</PRE>


<DT><B>SEE ALSO</B>
<DD>

<UL>
<LI>

section <A HREF="eventclient.html#SEC4">-Busy-state</A>.
<LI>

section <A HREF="eventclient.html#SEC27">ec_set_busy_handling</A>.
<LI>

section <A HREF="eventclient.html#SEC26">ec_set_busy</A>.
</UL>

</DL>


<H3><A NAME="SEC18" HREF="eventclient.html#TOC18">ec_get_busy_handling</A></H3>

<P>
<A NAME="IDX16"></A>


<DL COMPACT>

<DT><B>NAME</B>
<DD>

<PRE>
ec_get_busy_handling() -- get configured busy handling policy
</PRE>


<DT><B>SYNOPSIS</B>
<DD>

<PRE>
#include "sge_c_event.h"

ev_busy_handling ec_get_busy_handling(void)
</PRE>


<DT><B>FUNCTION</B>
<DD>

<PRE>
Returns the policy currently configured.
</PRE>


<DT><B>RESULT</B>
<DD>

<PRE>
ev_busy_handling - the current policy
</PRE>


<DT><B>SEE ALSO</B>
<DD>

<UL>
<LI>

section <A HREF="eventclient.html#SEC29">ec_set_edtime</A>.
<LI>

section <A HREF="eventclient.html#SEC4">-Busy-state</A>.
</UL>

</DL>


<H3><A NAME="SEC19" HREF="eventclient.html#TOC19">ec_get_clientdata</A></H3>

<P>
<A NAME="IDX17"></A>


<DL COMPACT>

<DT><B>NAME</B>
<DD>

<PRE>
ec_get_clientdata() -- get the clientdata value
</PRE>


<DT><B>SYNOPSIS</B>
<DD>

<PRE>
#include "sge_c_event.h"

u_long32 ec_get_clientdata()
</PRE>


<DT><B>FUNCTION</B>
<DD>

<PRE>
Get the current value of the clientdata for the event client.
</PRE>


<DT><B>RESULT</B>
<DD>

<PRE>
u_long32 - current value
</PRE>


<DT><B>SEE ALSO</B>
<DD>

<UL>
<LI>

section <A HREF="eventclient.html#SEC19">ec_get_clientdata</A>.
<LI>

See <TT>`Eventclient/EV_Type'</TT>
</UL>

</DL>


<H3><A NAME="SEC20" HREF="eventclient.html#TOC20">ec_get_edtime</A></H3>

<P>
<A NAME="IDX18"></A>


<DL COMPACT>

<DT><B>NAME</B>
<DD>

<PRE>
ec_get_edtime() -- get the current event delivery interval
</PRE>


<DT><B>SYNOPSIS</B>
<DD>

<PRE>
#include "sge_c_event.h"

int ec_get_edtime(void)
</PRE>


<DT><B>FUNCTION</B>
<DD>

<PRE>
Get the interval qmaster will use to send events to the client.
</PRE>


<DT><B>RESULT</B>
<DD>

<PRE>
int - the interval in seconds
</PRE>


<DT><B>SEE ALSO</B>
<DD>

<UL>
<LI>

section <A HREF="eventclient.html#SEC29">ec_set_edtime</A>.
</UL>

</DL>


<H3><A NAME="SEC21" HREF="eventclient.html#TOC21">ec_get_flush</A></H3>

<P>
<A NAME="IDX19"></A>


<DL COMPACT>

<DT><B>NAME</B>
<DD>

<PRE>
ec_get_flush() -- get flushing information for an event
</PRE>


<DT><B>SYNOPSIS</B>
<DD>

<PRE>
#include "sge_c_event.h"

int ec_get_flush(ev_event event)
</PRE>


<DT><B>FUNCTION</B>
<DD>

<PRE>
An event client can request flushing of events from qmaster for any
number of the events subscribed.
This function returns the flushing information for an individual event.
</PRE>


<DT><B>INPUTS</B>
<DD>

<PRE>
ev_event event - the event id to query
</PRE>


<DT><B>RESULT</B>
<DD>

<PRE>
int - EV_NO_FLUSH(-1) or the number of seconds used for flushing
</PRE>


<DT><B>SEE ALSO</B>
<DD>

<UL>
<LI>

section <A HREF="eventclient.html#SEC6">-Flushing</A>.
<LI>

section <A HREF="eventclient.html#SEC30">ec_set_flush</A>.
</UL>

</DL>


<H3><A NAME="SEC22" HREF="eventclient.html#TOC22">ec_mark4registration</A></H3>

<P>
<A NAME="IDX20"></A>


<DL COMPACT>

<DT><B>NAME</B>
<DD>

<PRE>
ec_mark4registration() -- new registration is required
</PRE>


<DT><B>SYNOPSIS</B>
<DD>

<PRE>
#include "sge_c_event.h"

void ec_mark4registration(void)
</PRE>


<DT><B>FUNCTION</B>
<DD>

<PRE>
Tells the event client mechanism, that the connection to the server
is broken and it has to reregister.
</PRE>


<DT><B>NOTES</B>
<DD>

<PRE>
Should be no external interface. The event client mechanism should itself
detect such situations and react accordingly.
</PRE>


<DT><B>SEE ALSO</B>
<DD>

<UL>
<LI>

section <A HREF="eventclient.html#SEC23">ec_need_new_registration</A>.
</UL>

</DL>


<H3><A NAME="SEC23" HREF="eventclient.html#TOC23">ec_need_new_registration</A></H3>

<P>
<A NAME="IDX21"></A>


<DL COMPACT>

<DT><B>NAME</B>
<DD>

<PRE>
ec_need_new_registration() -- is a reregistration neccessary?
</PRE>


<DT><B>SYNOPSIS</B>
<DD>

<PRE>
#include "sge_c_event.h"

int ec_need_new_registration(void)
</PRE>


<DT><B>FUNCTION</B>
<DD>

<PRE>
Function to check, if a new registration at the server is neccessary.
</PRE>


<DT><B>RESULT</B>
<DD>

<PRE>
int - 1, if the client has to (re)register, else 0
</PRE>


</DL>


<H3><A NAME="SEC24" HREF="eventclient.html#TOC24">ec_prepare_registration</A></H3>

<P>
<A NAME="IDX22"></A>


<DL COMPACT>

<DT><B>NAME</B>
<DD>

<PRE>
ec_prepare_registration() -- prepare registration at server
</PRE>


<DT><B>SYNOPSIS</B>
<DD>

<PRE>
#include "sge_c_event.h"

int ec_prepare_registration(ev_registration_id id, const char *name)
</PRE>


<DT><B>FUNCTION</B>
<DD>

<PRE>
Initializes necessary data structures and sets the data needed for
registration at an event server.
The events sgeE_QMASTER_GOES_DOWN and sgeE_SHUTDOWN are subscribed.

For valid id's see Eventclient/-ID-numbers.

The name is informational data that will be included in messages
(errors, warnings, infos) and will be shown in the command line tool
qconf -sec.
</PRE>


<DT><B>INPUTS</B>
<DD>

<PRE>
ev_registration_id id  - id used to register
const char *name       - name of the event client
</PRE>


<DT><B>RESULT</B>
<DD>

<PRE>
int - 1,if the function succeeded, else 0
</PRE>


<DT><B>SEE ALSO</B>
<DD>

<UL>
<LI>

section <A HREF="eventclient.html#SEC2">--EV_Type</A>.
<LI>

section <A HREF="eventclient.html#SEC7">-ID-numbers</A>.
<LI>

section <A HREF="eventclient.html#SEC8">-Subscription</A>.
<LI>

See <TT>`qconf'</TT>
<LI>

See <TT>`manpage'</TT>
<LI>

See <TT>`list'</TT>
<LI>

See <TT>`of'</TT>
<LI>

See <TT>`events'</TT>
</UL>

</DL>


<H3><A NAME="SEC25" HREF="eventclient.html#TOC25">ec_register</A></H3>

<P>
<A NAME="IDX23"></A>


<DL COMPACT>

<DT><B>NAME</B>
<DD>

<PRE>
ec_register() -- register at the event server
</PRE>


<DT><B>SYNOPSIS</B>
<DD>

<PRE>
#include "sge_c_event.h"

int ec_register(void)
</PRE>


<DT><B>FUNCTION</B>
<DD>

<PRE>
Registers the event client at the event server (usually the qmaster).
This function can be called explicitly in the event client at startup
or when the connection to qmaster is down.

It will be called implicitly by ec_get, whenever it detects the neccessity
to (re)register the client.
</PRE>


<DT><B>RESULT</B>
<DD>

<PRE>
int - 1, if the registration succeeded, else 0
</PRE>


<DT><B>SEE ALSO</B>
<DD>

<UL>
<LI>

section <A HREF="eventclient.html#SEC15">ec_deregister</A>.
<LI>

section <A HREF="eventclient.html#SEC16">ec_get</A>.
</UL>

</DL>


<H3><A NAME="SEC26" HREF="eventclient.html#TOC26">ec_set_busy</A></H3>

<P>
<A NAME="IDX24"></A>


<DL COMPACT>

<DT><B>NAME</B>
<DD>

<PRE>
ec_set_busy() -- set the busy state
</PRE>


<DT><B>SYNOPSIS</B>
<DD>

<PRE>
int ec_set_busy(int busy)
</PRE>


<DT><B>FUNCTION</B>
<DD>

<PRE>
Sets the busy state of the client. This has to be done if the busy policy
has been set to EV_BUSY_UNTIL_RELEASED.
An event client can set or unset the busy state at any time.
While it is marked busy at the qmaster, qmaster will not deliver events to
this client.
The changed busy state will be communicated to qmaster with the next
call to ec_commit (implicitly called by the next ec_get).
</PRE>


<DT><B>INPUTS</B>
<DD>

<PRE>
int busy - 1 = event client busy, 0 = event client idle
</PRE>


<DT><B>RESULT</B>
<DD>

<PRE>
int - 1 = success, 0 = failed
</PRE>


<DT><B>SEE ALSO</B>
<DD>

<UL>
<LI>

section <A HREF="eventclient.html#SEC4">-Busy-state</A>.
<LI>

section <A HREF="eventclient.html#SEC27">ec_set_busy_handling</A>.
<LI>

section <A HREF="eventclient.html#SEC17">ec_get_busy</A>.
</UL>

</DL>


<H3><A NAME="SEC27" HREF="eventclient.html#TOC27">ec_set_busy_handling</A></H3>

<P>
<A NAME="IDX25"></A>


<DL COMPACT>

<DT><B>NAME</B>
<DD>

<PRE>
ec_set_edtime() -- set the event client busy handling
</PRE>


<DT><B>SYNOPSIS</B>
<DD>

<PRE>
#include "sge_c_event.h"

int ec_set_busy_handling(ev_busy_handling handling)
</PRE>


<DT><B>FUNCTION</B>
<DD>

<PRE>
The event client interface has a mechanism to handle situations in which
an event client is busy and will not accept any new events.
The policy to use can be configured using this function.
For valid policies see ...
This parameter can be changed during runtime and will take effect
after a call to ec_commit or ec_get.
</PRE>


<DT><B>INPUTS</B>
<DD>

<PRE>
ev_busy_handling handling - the policy to use
</PRE>


<DT><B>RESULT</B>
<DD>

<PRE>
int - 1, if the value was changed, else 0
</PRE>


<DT><B>SEE ALSO</B>
<DD>

<UL>
<LI>

section <A HREF="eventclient.html#SEC18">ec_get_busy_handling</A>.
<LI>

section <A HREF="eventclient.html#SEC4">-Busy-state</A>.
<LI>

section <A HREF="eventclient.html#SEC13">ec_commit</A>.
<LI>

section <A HREF="eventclient.html#SEC16">ec_get</A>.
</UL>

</DL>


<H3><A NAME="SEC28" HREF="eventclient.html#TOC28">ec_set_clientdata</A></H3>

<P>
<A NAME="IDX26"></A>


<DL COMPACT>

<DT><B>NAME</B>
<DD>

<PRE>
ec_set_clientdata() -- set the clientdata value
</PRE>


<DT><B>SYNOPSIS</B>
<DD>

<PRE>
#include "sge_c_event.h"

void ec_set_clientdata(u_long32 data)
</PRE>


<DT><B>FUNCTION</B>
<DD>

<PRE>
An event client (the event client object) has a field EV_clientdata.
It is of datatype u_long32 and can be used by the event client for
any purpose.

The sge scheduler uses it to store the last order from scheduler processed
by qmaster.
</PRE>


<DT><B>INPUTS</B>
<DD>

<PRE>
u_long32 data - the clientdata to set
</PRE>


<DT><B>SEE ALSO</B>
<DD>

<UL>
<LI>

section <A HREF="eventclient.html#SEC19">ec_get_clientdata</A>.
<LI>

section <A HREF="eventclient.html#SEC2">--EV_Type</A>.
<LI>

See <TT>`documentation'</TT>
<LI>

See <TT>`of'</TT>
<LI>

See <TT>`scheduler'</TT>
<LI>

See <TT>`-'</TT>
<LI>

See <TT>`qmaster'</TT>
<LI>

See <TT>`mechanisms'</TT>
</UL>

</DL>


<H3><A NAME="SEC29" HREF="eventclient.html#TOC29">ec_set_edtime</A></H3>

<P>
<A NAME="IDX27"></A>


<DL COMPACT>

<DT><B>NAME</B>
<DD>

<PRE>
ec_set_edtime() -- set the event delivery interval
</PRE>


<DT><B>SYNOPSIS</B>
<DD>

<PRE>
#include "sge_c_event.h"

int ec_set_edtime(int interval)
</PRE>


<DT><B>FUNCTION</B>
<DD>

<PRE>
Set the interval qmaster will use to send events to the client.
Any number &#62; 0 is a valid interval in seconds.
</PRE>


<DT><B>INPUTS</B>
<DD>

<PRE>
int interval - interval [s]
</PRE>


<DT><B>RESULT</B>
<DD>

<PRE>
int - 1, if the value was changed, else 0
</PRE>


<DT><B>NOTES</B>
<DD>

<PRE>
The maximum interval should be limited. A too big interval makes
qmaster spool lots of events and consume a lot of memory.
</PRE>


<DT><B>SEE ALSO</B>
<DD>

<UL>
<LI>

section <A HREF="eventclient.html#SEC20">ec_get_edtime</A>.
</UL>

</DL>


<H3><A NAME="SEC30" HREF="eventclient.html#TOC30">ec_set_flush</A></H3>

<P>
<A NAME="IDX28"></A>


<DL COMPACT>

<DT><B>NAME</B>
<DD>

<PRE>
ec_set_flush() -- set flushing information for an event
</PRE>


<DT><B>SYNOPSIS</B>
<DD>

<PRE>
#include "sge_c_event.h"

int ec_set_flush(ev_event event, int flush)
</PRE>


<DT><B>FUNCTION</B>
<DD>

<PRE>
An event client can request flushing of events from qmaster for any
number of the events subscribed.
This function sets the flushing information for an individual event.
</PRE>


<DT><B>INPUTS</B>
<DD>

<PRE>
ev_event event - id of the event to configure
int flush      - the number of seconds between creation of
                 the event and flushing of the messages.
</PRE>


<DT><B>RESULT</B>
<DD>

<PRE>
int - 1 on success, else 0
</PRE>


<DT><B>SEE ALSO</B>
<DD>

<UL>
<LI>

section <A HREF="eventclient.html#SEC6">-Flushing</A>.
<LI>

section <A HREF="eventclient.html#SEC21">ec_get_flush</A>.
<LI>

section <A HREF="eventclient.html#SEC34">ec_unset_flush</A>.
<LI>

section <A HREF="eventclient.html#SEC33">ec_subscribe_flush</A>.
</UL>

</DL>


<H3><A NAME="SEC31" HREF="eventclient.html#TOC31">ec_subscribe</A></H3>

<P>
<A NAME="IDX29"></A>


<DL COMPACT>

<DT><B>NAME</B>
<DD>

<PRE>
ec_subscribe() -- Subscribe an event
</PRE>


<DT><B>SYNOPSIS</B>
<DD>

<PRE>
#include "sge_c_event.h"

int ec_subscribe(ev_event event)
</PRE>


<DT><B>FUNCTION</B>
<DD>

<PRE>
Subscribe a certain event.
See Eventclient/-Events for a list of all events.
The subscription will be in effect after calling ec_commit or ec_get.
It is possible / sensible to subscribe all events wanted and then call
ec_commit.
</PRE>


<DT><B>INPUTS</B>
<DD>

<PRE>
ev_event event - the event number
</PRE>


<DT><B>RESULT</B>
<DD>

<PRE>
int - 1 on success, else 0
</PRE>


<DT><B>SEE ALSO</B>
<DD>

<UL>
<LI>

section <A HREF="eventclient.html#SEC5">-Events</A>.
<LI>

section <A HREF="eventclient.html#SEC32">ec_subscribe_all</A>.
<LI>

section <A HREF="eventclient.html#SEC35">ec_unsubscribe</A>.
<LI>

section <A HREF="eventclient.html#SEC36">ec_unsubscribe_all</A>.
<LI>

section <A HREF="eventclient.html#SEC13">ec_commit</A>.
<LI>

section <A HREF="eventclient.html#SEC16">ec_get</A>.
</UL>

</DL>


<H3><A NAME="SEC32" HREF="eventclient.html#TOC32">ec_subscribe_all</A></H3>

<P>
<A NAME="IDX30"></A>


<DL COMPACT>

<DT><B>NAME</B>
<DD>

<PRE>
ec_subscribe_all() -- subscribe all events
</PRE>


<DT><B>SYNOPSIS</B>
<DD>

<PRE>
#include "sge_c_event.h"

int ec_subscribe_all(void)
</PRE>


<DT><B>FUNCTION</B>
<DD>

<PRE>
Subscribe all possible event.
The subscription will be in effect after calling ec_commit or ec_get.
</PRE>


<DT><B>RESULT</B>
<DD>

<PRE>
int - 1 on success, else 0
</PRE>


<DT><B>NOTES</B>
<DD>

<PRE>
Subscribing all events can cause a lot of traffic and may decrease performance
of qmaster.
Only subscribe all events, if you really need them.
</PRE>


<DT><B>SEE ALSO</B>
<DD>

<UL>
<LI>

section <A HREF="eventclient.html#SEC31">ec_subscribe</A>.
<LI>

section <A HREF="eventclient.html#SEC35">ec_unsubscribe</A>.
<LI>

section <A HREF="eventclient.html#SEC36">ec_unsubscribe_all</A>.
<LI>

section <A HREF="eventclient.html#SEC13">ec_commit</A>.
<LI>

section <A HREF="eventclient.html#SEC16">ec_get</A>.
</UL>

</DL>


<H3><A NAME="SEC33" HREF="eventclient.html#TOC33">ec_subscribe_flush</A></H3>

<P>
<A NAME="IDX31"></A>


<DL COMPACT>

<DT><B>NAME</B>
<DD>

<PRE>
ec_subscribe_flush() -- subscribe an event and set flushing
</PRE>


<DT><B>SYNOPSIS</B>
<DD>

<PRE>
#include "sge_c_event.h"

int ec_subscribe_flush(ev_event event, int flush)
</PRE>


<DT><B>FUNCTION</B>
<DD>

<PRE>
Subscribes and event and configures flushing for this event.
</PRE>


<DT><B>INPUTS</B>
<DD>

<PRE>
ev_event event - id of the event to subscribe and flush
int flush      - number of seconds between event creation
                 and flushing of events
</PRE>


<DT><B>RESULT</B>
<DD>

<PRE>
int - 1 on success, else 0
</PRE>


<DT><B>SEE ALSO</B>
<DD>

<UL>
<LI>

section <A HREF="eventclient.html#SEC8">-Subscription</A>.
<LI>

section <A HREF="eventclient.html#SEC6">-Flushing</A>.
<LI>

section <A HREF="eventclient.html#SEC31">ec_subscribe</A>.
<LI>

section <A HREF="eventclient.html#SEC30">ec_set_flush</A>.
</UL>

</DL>


<H3><A NAME="SEC34" HREF="eventclient.html#TOC34">ec_unset_flush</A></H3>

<P>
<A NAME="IDX32"></A>


<DL COMPACT>

<DT><B>NAME</B>
<DD>

<PRE>
ec_unset_flush() -- unset flushing information
</PRE>


<DT><B>SYNOPSIS</B>
<DD>

<PRE>
#include "sge_c_event.h"

int ec_unset_flush(ev_event event)
</PRE>


<DT><B>FUNCTION</B>
<DD>

<PRE>
Switch of flushing of an individual event.
</PRE>


<DT><B>INPUTS</B>
<DD>

<PRE>
ev_event event - if of the event to configure
</PRE>


<DT><B>RESULT</B>
<DD>

<PRE>
int - 1 on success, else 0
</PRE>


<DT><B>SEE ALSO</B>
<DD>

<UL>
<LI>

section <A HREF="eventclient.html#SEC6">-Flushing</A>.
<LI>

section <A HREF="eventclient.html#SEC30">ec_set_flush</A>.
<LI>

section <A HREF="eventclient.html#SEC21">ec_get_flush</A>.
<LI>

section <A HREF="eventclient.html#SEC33">ec_subscribe_flush</A>.
</UL>

</DL>


<H3><A NAME="SEC35" HREF="eventclient.html#TOC35">ec_unsubscribe</A></H3>

<P>
<A NAME="IDX33"></A>


<DL COMPACT>

<DT><B>NAME</B>
<DD>

<PRE>
ec_unsubscribe() -- unsubscribe an event
</PRE>


<DT><B>SYNOPSIS</B>
<DD>

<PRE>
#include "sge_c_event.h"

int ec_unsubscribe(ev_event event)
</PRE>


<DT><B>FUNCTION</B>
<DD>

<PRE>
Unsubscribe a certain event.
See ... for a list of all events.
The change will be in effect after calling ec_commit or ec_get.
It is possible / sensible to unsubscribe all events
no longer needed and then call ec_commit.
</PRE>


<DT><B>INPUTS</B>
<DD>

<PRE>
ev_event event - the event to unsubscribe
</PRE>


<DT><B>RESULT</B>
<DD>

<PRE>
int - 1 on success, else 0
</PRE>


<DT><B>NOTES</B>
<DD>

<PRE>
The events sgeE_QMASTER_GOES_DOWN and sgeE_SHUTDOWN cannot
be unsubscribed. ec_unsubscribe will output an error message if
you try to unsubscribe sgeE_QMASTER_GOES_DOWN or sgeE_SHUTDOWN
and return 0.
</PRE>


<DT><B>SEE ALSO</B>
<DD>

<UL>
<LI>

section <A HREF="eventclient.html#SEC5">-Events</A>.
<LI>

section <A HREF="eventclient.html#SEC31">ec_subscribe</A>.
<LI>

section <A HREF="eventclient.html#SEC32">ec_subscribe_all</A>.
<LI>

section <A HREF="eventclient.html#SEC36">ec_unsubscribe_all</A>.
<LI>

section <A HREF="eventclient.html#SEC13">ec_commit</A>.
<LI>

section <A HREF="eventclient.html#SEC16">ec_get</A>.
</UL>

</DL>


<H3><A NAME="SEC36" HREF="eventclient.html#TOC36">ec_unsubscribe_all</A></H3>

<P>
<A NAME="IDX34"></A>


<DL COMPACT>

<DT><B>NAME</B>
<DD>

<PRE>
ec_unsubscribe_all() -- unsubscribe all events
</PRE>


<DT><B>SYNOPSIS</B>
<DD>

<PRE>
#include "sge_c_event.h"

int ec_unsubscribe_all(void)
</PRE>


<DT><B>FUNCTION</B>
<DD>

<PRE>
Unsubscribe all possible event.
The change will be in effect after calling ec_commit or ec_get.
</PRE>


<DT><B>RESULT</B>
<DD>

<PRE>
int - 1 on success, else 0
</PRE>


<DT><B>NOTES</B>
<DD>

<PRE>
The events sgeE_QMASTER_GOES_DOWN and sgeE_SHUTDOWN will not be
unsubscribed.
</PRE>


<DT><B>SEE ALSO</B>
<DD>

<UL>
<LI>

section <A HREF="eventclient.html#SEC31">ec_subscribe</A>.
<LI>

section <A HREF="eventclient.html#SEC32">ec_subscribe_all</A>.
<LI>

section <A HREF="eventclient.html#SEC35">ec_unsubscribe</A>.
<LI>

section <A HREF="eventclient.html#SEC13">ec_commit</A>.
<LI>

section <A HREF="eventclient.html#SEC16">ec_get</A>.
</UL>

</DL>


<H3><A NAME="SEC37" HREF="eventclient.html#TOC37">get_event_list</A></H3>

<P>
<A NAME="IDX35"></A>


<DL COMPACT>

<DT><B>NAME</B>
<DD>

<PRE>
get_event_list() -- get event list via gdi call
</PRE>


<DT><B>SYNOPSIS</B>
<DD>

<PRE>
static int get_event_list(int sync, lList **report_list)
</PRE>


<DT><B>FUNCTION</B>
<DD>

<PRE>
Tries to retrieve the event list.
Returns the incoming data and the commlib status/error code.
This function is used by ec_get.
</PRE>


<DT><B>INPUTS</B>
<DD>

<PRE>
int sync            - synchronous transfer
lList **report_list - pointer to returned list
</PRE>


<DT><B>RESULT</B>
<DD>

<PRE>
static int - commlib status/error code
</PRE>


<DT><B>SEE ALSO</B>
<DD>

<UL>
<LI>

section <A HREF="eventclient.html#SEC16">ec_get</A>.
</UL>

</DL>



<H2><A NAME="SEC38" HREF="eventclient.html#TOC38">Server</A></H2>



<H3><A NAME="SEC39" HREF="eventclient.html#TOC39">--Event_Client_Server</A></H3>

<P>
<A NAME="IDX36"></A>


<DL COMPACT>

<DT><B>NAME</B>
<DD>

<PRE>
Event Client Interface -- Server Functionality
</PRE>


<DT><B>FUNCTION</B>
<DD>

<PRE>
The server module of the event client interface is used to integrate
the capability to server event clients into server daemons.

It is used in the Grid Engine qmaster but should be capable to handle
any event client server integration.
</PRE>


<DT><B>SEE ALSO</B>
<DD>

<UL>
<LI>

section <A HREF="eventclient.html#SEC3">--Event_Client_Interface</A>.
<LI>

section <A HREF="eventclient.html#SEC44">reinit_event_client</A>.
<LI>

section <A HREF="eventclient.html#SEC48">sge_add_event_client</A>.
<LI>

section <A HREF="eventclient.html#SEC57">sge_mod_event_client</A>.
<LI>

section <A HREF="eventclient.html#SEC50">sge_event_client_exit</A>.
<LI>

section <A HREF="eventclient.html#SEC53">sge_gdi_kill_eventclient</A>.
<LI>

section <A HREF="eventclient.html#SEC51">sge_eventclient_subscribed</A>.
<LI>

section <A HREF="eventclient.html#SEC46">sge_ack_event</A>.
<LI>

section <A HREF="eventclient.html#SEC43">ck_4_deliver_events</A>.
<LI>

section <A HREF="eventclient.html#SEC52">sge_flush_events</A>.
<LI>

section <A HREF="eventclient.html#SEC58">sge_next_flush</A>.
<LI>

section <A HREF="eventclient.html#SEC49">sge_add_list_event</A>.
<LI>

section <A HREF="eventclient.html#SEC47">sge_add_event</A>.
<LI>

section <A HREF="eventclient.html#SEC55">sge_get_next_event_number</A>.
<LI>

section <A HREF="eventclient.html#SEC54">sge_gdi_tsm</A>.
<LI>

section <A HREF="eventclient.html#SEC56">sge_locate_event_client</A>.
<LI>

section <A HREF="eventclient.html#SEC45">set_event_client_busy</A>.
</UL>

</DL>


<H3><A NAME="SEC40" HREF="eventclient.html#TOC40">-Event_Client_Server_Defines</A></H3>

<P>
<A NAME="IDX37"></A>


<DL COMPACT>

<DT><B>NAME</B>
<DD>

<PRE>
Defines -- Constants used in the module
</PRE>


<DT><B>SYNOPSIS</B>
<DD>

<PRE>
#define FLUSH_INTERVAL 15
#define EVENT_ACK_MIN_TIMEOUT 600
#define EVENT_ACK_MAX_TIMEOUT 1200
</PRE>


<DT><B>FUNCTION</B>
<DD>

<PRE>
FLUSH_INTERVAL is the default event delivery interval, if the client
would not set a correct interval.

EVENT_ACK_MIN/MAX_TIMEOUT is the minimum/maximum timeout value for an event
client sending the acknowledge for the delivery of events.
The real timeout value depends on the event delivery interval for the
event client (10 * event delivery interval).
</PRE>


</DL>


<H3><A NAME="SEC41" HREF="eventclient.html#TOC41">-Event_Client_Server_Global_Variables</A></H3>

<P>
<A NAME="IDX38"></A>


<DL COMPACT>

<DT><B>NAME</B>
<DD>

<PRE>
-Global_Variables() -- global Variables
</PRE>


<DT><B>SYNOPSIS</B>
<DD>

<PRE>
extern lList *Master_Adminhost_List;
extern lList *Master_Calendar_List;
extern lList *Master_Ckpt_List;
extern lList *Master_Complex_List;
extern lList *Master_Config_List;
extern lList *Master_Exechost_List;
extern lList *Master_Job_List;
extern lList *Master_Job_Schedd_Info_List;
extern lList *Master_Manager_List;
extern lList *Master_Operator_List;
extern lList *Master_Pe_List;
extern lList *Master_Project_List;
extern lList *Master_Queue_List;
extern lList *Master_Sched_Config_List;
extern lList *Master_Sharetree_List;
extern lList *Master_Submithost_List;
extern lList *Master_User_List;
extern lList *Master_Userset_List;

lList *EV_Clients = NULL;
</PRE>


<DT><B>FUNCTION</B>
<DD>

<PRE>
The extern lList's reference all object lists that can be used
in a Grid Engine event client interface.

EV_Clients is a list of all event clients to the event server.
</PRE>


</DL>


<H3><A NAME="SEC42" HREF="eventclient.html#TOC42">check_send_new_subscribed_list</A></H3>

<P>
<A NAME="IDX39"></A>


<DL COMPACT>

<DT><B>NAME</B>
<DD>

<PRE>
check_send_new_subscribed_list() -- check suscription for new list events
</PRE>


<DT><B>SYNOPSIS</B>
<DD>

<PRE>
static void check_send_new_subscribed_list(const char *old_subscription,
                                           const char *new_subscription,
                                           lListElem *event_client,
                                           ev_event event)
</PRE>


<DT><B>FUNCTION</B>
<DD>

<PRE>
Checks, if sgeE*_LIST events have been added to the subscription of a
certain event client. If yes, send these lists to the event client.
</PRE>


<DT><B>INPUTS</B>
<DD>

<PRE>
const char *old_subscription - former subscription
const char *new_subscription - new subscription
lListElem *event_client      - the event client object
ev_event event               - the event to check
</PRE>


<DT><B>SEE ALSO</B>
<DD>

<UL>
<LI>

section <A HREF="eventclient.html#SEC59">sge_total_update_event</A>.
</UL>

</DL>


<H3><A NAME="SEC43" HREF="eventclient.html#TOC43">ck_4_deliver_events</A></H3>

<P>
<A NAME="IDX40"></A>


<DL COMPACT>

<DT><B>NAME</B>
<DD>

<PRE>
ck_4_deliver_events() -- deliver events if necessary
</PRE>


<DT><B>SYNOPSIS</B>
<DD>

<PRE>
#include "sge_m_event.h"

void ck_4_deliver_events(u_long32 now)
</PRE>


<DT><B>FUNCTION</B>
<DD>

<PRE>
Checks delivery time of each event client - if it has been reached, deliver
all events for that client.

In addition, timed out event clients are removed. An event client times out,
if it doesn't acknowledge events within 10 * EV_ed_time
(respecting EVENT_ACK_MIN_TIMEOUT and EVENT_ACK_MAX_TIMEOUT).
</PRE>


<DT><B>INPUTS</B>
<DD>

<PRE>
u_long32 now - actual timestamp
</PRE>


<DT><B>SEE ALSO</B>
<DD>

<UL>
<LI>

section <A HREF="eventclient.html#SEC41">-Event_Client_Server_Global_Variables</A>.
<LI>

section <A HREF="eventclient.html#SEC46">sge_ack_event</A>.
</UL>

</DL>


<H3><A NAME="SEC44" HREF="eventclient.html#TOC44">reinit_event_client</A></H3>

<P>
<A NAME="IDX41"></A>


<DL COMPACT>

<DT><B>NAME</B>
<DD>

<PRE>
reinit_event_client() -- do a total update for the scheduler
</PRE>


<DT><B>SYNOPSIS</B>
<DD>

<PRE>
#include "sge_m_event.h"

int reinit_event_client(ev_registration_id id)
</PRE>


<DT><B>FUNCTION</B>
<DD>

<PRE>
Does a total update (send all lists) to the event client specified by id
and outputs an error message.
</PRE>


<DT><B>INPUTS</B>
<DD>

<PRE>
ev_registration_id id - the id of the event client to reinitialize.
</PRE>


<DT><B>RESULT</B>
<DD>

<PRE>
int - 0 if reinitialization failed, e.g. because the event client does
      not exits, else 0
</PRE>


<DT><B>SEE ALSO</B>
<DD>

<UL>
<LI>

section <A HREF="eventclient.html#SEC60">total_update</A>.
</UL>

</DL>


<H3><A NAME="SEC45" HREF="eventclient.html#TOC45">set_event_client_busy</A></H3>

<P>
<A NAME="IDX42"></A>


<DL COMPACT>

<DT><B>NAME</B>
<DD>

<PRE>
set_event_client_busy() -- set the busy state of event clients
</PRE>


<DT><B>SYNOPSIS</B>
<DD>

<PRE>
#include "sge_m_event.h"

void set_event_client_busy(lListElem *event_client, int busy)
</PRE>


<DT><B>FUNCTION</B>
<DD>

<PRE>
Sets the busy state of one or all event clients.
</PRE>


<DT><B>INPUTS</B>
<DD>

<PRE>
lListElem *event_client - the event client to modify - NULL to modify all
int busy                - busy state - 0 = not busy, 1 = busy
</PRE>


<DT><B>NOTES</B>
<DD>

<PRE>
The busy state should better be a boolean if it this datatype was available
in the cull library.
</PRE>


</DL>


<H3><A NAME="SEC46" HREF="eventclient.html#TOC46">sge_ack_event</A></H3>

<P>
<A NAME="IDX43"></A>


<DL COMPACT>

<DT><B>NAME</B>
<DD>

<PRE>
sge_ack_event() -- process acknowledge to event delivery
</PRE>


<DT><B>SYNOPSIS</B>
<DD>

<PRE>
#include "sge_m_event.h"

int sge_ack_event(lListElem *event_client, ev_event event_number)
</PRE>


<DT><B>FUNCTION</B>
<DD>

<PRE>
After the server sent events to an event client, it has to acknowledge
their receipt.
Acknowledged events are deleted from the list of events to deliver, otherwise
they will be resent after the next event delivery interval.
If the handling of a busy state of the event client is enabled and set to
EV_BUSY_UNTIL_ACK, the event client will be set to "not busy".
</PRE>


<DT><B>INPUTS</B>
<DD>

<PRE>
lListElem *event_client - event client sending acknowledge
ev_event event_number   - serial number of the last event to acknowledge
</PRE>


<DT><B>RESULT</B>
<DD>

<PRE>
int - always 0
</PRE>


<DT><B>NOTES</B>
<DD>

<PRE>
Returncode makes no sense anymore. Either improve error handling or
make function return void.
</PRE>


<DT><B>SEE ALSO</B>
<DD>

<UL>
<LI>

section <A HREF="eventclient.html#SEC55">sge_get_next_event_number</A>.
</UL>

</DL>


<H3><A NAME="SEC47" HREF="eventclient.html#TOC47">sge_add_event</A></H3>

<P>
<A NAME="IDX44"></A>


<DL COMPACT>

<DT><B>NAME</B>
<DD>

<PRE>
sge_add_event() -- add an object as event
</PRE>


<DT><B>SYNOPSIS</B>
<DD>

<PRE>
#include "sge_m_event.h"

void sge_add_event(lListElem *event_client, ev_event type, u_long32
intkey, u_long32 intkey2, const char *strkey, lListElem *element)
</PRE>


<DT><B>FUNCTION</B>
<DD>

<PRE>
Adds an object to the list of events to deliver. Called, if an event occurs to
that object, e.g. it was added to Grid Engine, modified or deleted.

Internally, a list with that single object is created and passed to
sge_add_list_event().
</PRE>


<DT><B>INPUTS</B>
<DD>

<PRE>
lListElem *event_client - the event client to receive the event, if NULL,
                          all event clients will receive the event
ev_event type           - the event id
u_long32 intkey         - additional data
u_long32 intkey2        - additional data
const char *strkey      - additional data
lListElem *element      - the object to deliver as event
</PRE>


<DT><B>NOTES</B>
<DD>

<PRE>
Do we need the additional data fields?
</PRE>


<DT><B>SEE ALSO</B>
<DD>

<UL>
<LI>

section <A HREF="eventclient.html#SEC49">sge_add_list_event</A>.
</UL>

</DL>


<H3><A NAME="SEC48" HREF="eventclient.html#TOC48">sge_add_event_client</A></H3>

<P>
<A NAME="IDX45"></A>


<DL COMPACT>

<DT><B>NAME</B>
<DD>

<PRE>
sge_add_event_client() -- register a new event client
</PRE>


<DT><B>SYNOPSIS</B>
<DD>

<PRE>
#include "sge_m_event.h"

int sge_add_event_client(lListElem *clio, lList **alpp, lList **eclpp,
char *ruser, char *rhost)
</PRE>


<DT><B>FUNCTION</B>
<DD>

<PRE>
Registeres a new event client.
If it requested a dynamic id, a new id is created and assigned.
If it is a special client (with fixed id) and an event client
with this id already exists, the old instance is deleted and the
new one registered.
If the registration succees, the event client is sent all data
(sgeE*_LIST events) according to its subscription.
</PRE>


<DT><B>INPUTS</B>
<DD>

<PRE>
lListElem *clio - the event client object used as registration data
lList **alpp    - answer list pointer for answer to event client
lList **eclpp   - list pointer to return new event client object
char *ruser     - user that tries to register an event client
char *rhost     - host on which the event client runs
</PRE>


<DT><B>RESULT</B>
<DD>

<PRE>
int - AN_status value. STATUS_OK on success, else error code
</PRE>


<DT><B>SEE ALSO</B>
<DD>

<UL>
<LI>

section <A HREF="eventclient.html#SEC57">sge_mod_event_client</A>.
<LI>

section <A HREF="eventclient.html#SEC53">sge_gdi_kill_eventclient</A>.
<LI>

section <A HREF="eventclient.html#SEC60">total_update</A>.
</UL>

</DL>


<H3><A NAME="SEC49" HREF="eventclient.html#TOC49">sge_add_list_event</A></H3>

<P>
<A NAME="IDX46"></A>


<DL COMPACT>

<DT><B>NAME</B>
<DD>

<PRE>
sge_add_list_event() -- add a list as event
</PRE>


<DT><B>SYNOPSIS</B>
<DD>

<PRE>
#include "sge_m_event.h"

void sge_add_list_event(lListElem *event_client, ev_event type, u_long32
intkey, u_long32 intkey2, const char *strkey, lList *list)
</PRE>


<DT><B>FUNCTION</B>
<DD>

<PRE>
Adds a list of objects to the list of events to deliver, e.g. the sgeE*_LIST
events.
</PRE>


<DT><B>INPUTS</B>
<DD>

<PRE>
lListElem *event_client - the event client to receive the event, if NULL,
                          all event clients will receive the event
ev_event type           - the event id
u_long32 intkey         - additional data
u_long32 intkey2        - additional data
const char *strkey      - additional data
lList *list             - the list to deliver as event
</PRE>


<DT><B>NOTES</B>
<DD>

<PRE>
Do we need the additional data fields?
</PRE>


<DT><B>SEE ALSO</B>
<DD>

<UL>
<LI>

section <A HREF="eventclient.html#SEC47">sge_add_event</A>.
</UL>

</DL>


<H3><A NAME="SEC50" HREF="eventclient.html#TOC50">sge_event_client_exit</A></H3>

<P>
<A NAME="IDX47"></A>


<DL COMPACT>

<DT><B>NAME</B>
<DD>

<PRE>
sge_event_client_exit() -- event client deregisters
</PRE>


<DT><B>SYNOPSIS</B>
<DD>

<PRE>
#include "sge_m_event.h"

void sge_event_client_exit(const char *host, const char *commproc,
                           sge_pack_buffer *pb)
</PRE>


<DT><B>FUNCTION</B>
<DD>

<PRE>
Deregistration of an event client.
The event client tells qmaster that it wants to deregister - usually before
it exits.
The event client is removed from the list of all event clients.
</PRE>


<DT><B>INPUTS</B>
<DD>

<PRE>
const char *host     - host that sent the exit message
const char *commproc - commproc of the sender
sge_pack_buffer *pb  - packbuffer containing information about event client
</PRE>


</DL>


<H3><A NAME="SEC51" HREF="eventclient.html#TOC51">sge_eventclient_subscribed</A></H3>

<P>
<A NAME="IDX48"></A>


<DL COMPACT>

<DT><B>NAME</B>
<DD>

<PRE>
sge_eventclient_subscribed() -- has event client subscribed a certain event?
</PRE>


<DT><B>SYNOPSIS</B>
<DD>

<PRE>
#include "sge_m_event.h"

int sge_eventclient_subscribed(const lListElem *event_client, ev_event event)
</PRE>


<DT><B>FUNCTION</B>
<DD>

<PRE>
Checks if the given event client has a certain event subscribed.
</PRE>


<DT><B>INPUTS</B>
<DD>

<PRE>
const lListElem *event_client - event client to check
ev_event event                - event to check
</PRE>


<DT><B>RESULT</B>
<DD>

<PRE>
int - 0 = not subscribed, 1 = subscribed
</PRE>


</DL>


<H3><A NAME="SEC52" HREF="eventclient.html#TOC52">sge_flush_events</A></H3>

<P>
<A NAME="IDX49"></A>


<DL COMPACT>

<DT><B>NAME</B>
<DD>

<PRE>
sge_flush_events() -- set the flushing time for events
</PRE>


<DT><B>SYNOPSIS</B>
<DD>

<PRE>
#include "sge_m_event.h"

void sge_flush_events(lListElem *event_client, int interval)
</PRE>


<DT><B>FUNCTION</B>
<DD>

<PRE>
Sets the timestamp for the next flush of events for all or a specific
event client.
When events will be next sent to an event client is stored in its
event client object in the variable EV_next_send_time.
</PRE>


<DT><B>INPUTS</B>
<DD>

<PRE>
lListElem *event_client - the event client for which to define flushing,
                          or NULL (flush all event clients)
int interval            - time in seconds until next flush
</PRE>


<DT><B>SEE ALSO</B>
<DD>

<UL>
<LI>

section <A HREF="eventclient.html#SEC43">ck_4_deliver_events</A>.
</UL>

</DL>


<H3><A NAME="SEC53" HREF="eventclient.html#TOC53">sge_gdi_kill_eventclient</A></H3>

<P>
<A NAME="IDX50"></A>


<DL COMPACT>

<DT><B>NAME</B>
<DD>

<PRE>
sge_gdi_kill_eventclient() -- kill an event client
</PRE>


<DT><B>SYNOPSIS</B>
<DD>

<PRE>
#include "sge_m_event.h"

void sge_gdi_kill_eventclient(const char *host, sge_gdi_request *request,
sge_gdi_request *answer)
</PRE>


<DT><B>FUNCTION</B>
<DD>

<PRE>
Kills one or all dynamic event clients.
If a certain event client id is contained in the request, an event client
with that id is killed.
If the requested id is EC_ID_ANY (0), all event clients with dynamic ids
are killed.
Killing an event client is done by sending it the special event
sgeE_SHUTDOWN and flushing immediately.
</PRE>


<DT><B>INPUTS</B>
<DD>

<PRE>
const char *host         - host that sent the kill request
sge_gdi_request *request - request containing the event client id
sge_gdi_request *answer  - answer structure to return an answer to the
                           client issuing the kill command (usually qconf)
</PRE>


<DT><B>SEE ALSO</B>
<DD>

<UL>
<LI>

See <TT>`qconf'</TT>
<LI>

See <TT>`-kec'</TT>
</UL>

</DL>


<H3><A NAME="SEC54" HREF="eventclient.html#TOC54">sge_gdi_tsm</A></H3>

<P>
<A NAME="IDX51"></A>


<DL COMPACT>

<DT><B>NAME</B>
<DD>

<PRE>
sge_gdi_tsm() -- trigger scheduling
</PRE>


<DT><B>SYNOPSIS</B>
<DD>

<PRE>
#include "sge_m_event.h"

void sge_gdi_tsm(char *host, sge_gdi_request *request, sge_gdi_request
*answer)
</PRE>


<DT><B>FUNCTION</B>
<DD>

<PRE>
Triggers a scheduling run for the scheduler as special event client.
</PRE>


<DT><B>INPUTS</B>
<DD>

<PRE>
char *host               - host that triggered scheduling
sge_gdi_request *request - request structure
sge_gdi_request *answer  - answer structure to return to client
</PRE>


<DT><B>NOTES</B>
<DD>

<PRE>
This function should not be part of the core event client interface.
Or it should be possible to trigger any event client.
</PRE>


<DT><B>SEE ALSO</B>
<DD>

<UL>
<LI>

See <TT>`qconf'</TT>
<LI>

See <TT>`-tsm'</TT>
</UL>

</DL>


<H3><A NAME="SEC55" HREF="eventclient.html#TOC55">sge_get_next_event_number</A></H3>

<P>
<A NAME="IDX52"></A>


<DL COMPACT>

<DT><B>NAME</B>
<DD>

<PRE>
sge_get_next_event_number() -- next event number for an event client
</PRE>


<DT><B>SYNOPSIS</B>
<DD>

<PRE>
#include "sge_m_event.h"

u_long32 sge_get_next_event_number(u_long32 client_id)
</PRE>


<DT><B>FUNCTION</B>
<DD>

<PRE>
Retrieves the next serial event number for an event client.
</PRE>


<DT><B>INPUTS</B>
<DD>

<PRE>
u_long32 client_id - id of the event client
</PRE>


<DT><B>RESULT</B>
<DD>

<PRE>
u_long32 - serial number for next event to deliver
</PRE>


</DL>


<H3><A NAME="SEC56" HREF="eventclient.html#TOC56">sge_locate_event_client</A></H3>

<P>
<A NAME="IDX53"></A>


<DL COMPACT>

<DT><B>NAME</B>
<DD>

<PRE>
sge_locate_event_client() -- search for the scheduler
</PRE>


<DT><B>SYNOPSIS</B>
<DD>

<PRE>
#include "sge_m_event.h"

lListElem* sge_locate_event_client(ev_registration_id id)
</PRE>


<DT><B>FUNCTION</B>
<DD>

<PRE>
Searches the event client list for an event client with the
specified id.
Returns a pointer to the event client object or
NULL, if no such event client is registered.
</PRE>


<DT><B>INPUTS</B>
<DD>

<PRE>
ev_registration_id id - id of the event client to search
</PRE>


<DT><B>RESULT</B>
<DD>

<PRE>
lListElem* - event client object or NULL.
</PRE>


</DL>


<H3><A NAME="SEC57" HREF="eventclient.html#TOC57">sge_mod_event_client</A></H3>

<P>
<A NAME="IDX54"></A>


<DL COMPACT>

<DT><B>NAME</B>
<DD>

<PRE>
sge_mod_event_client() -- modify event client
</PRE>


<DT><B>SYNOPSIS</B>
<DD>

<PRE>
#include "sge_m_event.h"

int sge_mod_event_client(lListElem *clio, lList **alpp, lList **eclpp,
char *ruser, char *rhost)
</PRE>


<DT><B>FUNCTION</B>
<DD>

<PRE>
An event client object is modified.
It is possible to modify the event delivery time and
the subscription.
If the subscription is changed, and new sgeE*_LIST events are subscribed,
these lists are sent to the event client.
</PRE>


<DT><B>INPUTS</B>
<DD>

<PRE>
lListElem *clio - object containing the data to change
lList **alpp    - answer list pointer
lList **eclpp   - list pointer to return changed object
char *ruser     - user that triggered the modify action
char *rhost     - host that triggered the modify action
</PRE>


<DT><B>RESULT</B>
<DD>

<PRE>
int - AN_status code. STATUS_OK on success, else error code
</PRE>


<DT><B>SEE ALSO</B>
<DD>

<UL>
<LI>

section <A HREF="eventclient.html#SEC42">check_send_new_subscribed_list</A>.
</UL>

</DL>


<H3><A NAME="SEC58" HREF="eventclient.html#TOC58">sge_next_flush</A></H3>

<P>
<A NAME="IDX55"></A>


<DL COMPACT>

<DT><B>NAME</B>
<DD>

<PRE>
sge_next_flush() -- when will be the next flush of events?
</PRE>


<DT><B>SYNOPSIS</B>
<DD>

<PRE>
#include "sge_m_event.h"

int sge_next_flush(int now)
</PRE>


<DT><B>FUNCTION</B>
<DD>

<PRE>
Returns the timestamp of the next required flush to any event client
(the minimum of EV_next_send_time for all event clients).
</PRE>


<DT><B>INPUTS</B>
<DD>

<PRE>
int now - actual timestamp
</PRE>


<DT><B>RESULT</B>
<DD>

<PRE>
int - the timestamp of the next flush or
      0, if no event client is connected and up.
</PRE>


</DL>


<H3><A NAME="SEC59" HREF="eventclient.html#TOC59">sge_total_update_event</A></H3>

<P>
<A NAME="IDX56"></A>


<DL COMPACT>

<DT><B>NAME</B>
<DD>

<PRE>
sge_total_update_event() -- create a total update event
</PRE>


<DT><B>SYNOPSIS</B>
<DD>

<PRE>
static void sge_total_update_event(lListElem *event_client, ev_event type)
</PRE>


<DT><B>FUNCTION</B>
<DD>

<PRE>
Creates an event delivering a certain list of objects for an event client.
</PRE>


<DT><B>INPUTS</B>
<DD>

<PRE>
lListElem *event_client - event client to receive the list
ev_event type           - event describing the list to update
</PRE>


</DL>


<H3><A NAME="SEC60" HREF="eventclient.html#TOC60">total_update</A></H3>

<P>
<A NAME="IDX57"></A>


<DL COMPACT>

<DT><B>NAME</B>
<DD>

<PRE>
total_update() -- send all data to eventclient
</PRE>


<DT><B>SYNOPSIS</B>
<DD>

<PRE>
static void total_update(lListElem *event_client)
</PRE>


<DT><B>FUNCTION</B>
<DD>

<PRE>
Sends all complete lists it subscribed to an eventclient.
If the event client receives a complete list instead of single events,
it should completely update it's database.
</PRE>


<DT><B>INPUTS</B>
<DD>

<PRE>
lListElem *event_client - the event client to update
</PRE>


</DL>



<H2><A NAME="SEC61" HREF="eventclient.html#TOC61">event_text</A></H2>

<P>
<A NAME="IDX58"></A>


<DL COMPACT>

<DT><B>NAME</B>
<DD>

<PRE>
event_text() -- deliver event description
</PRE>


<DT><B>SYNOPSIS</B>
<DD>

<PRE>
const char* event_text(const lListElem *event)
</PRE>


<DT><B>FUNCTION</B>
<DD>

<PRE>
Deliveres a short description of an event object.
</PRE>


<DT><B>INPUTS</B>
<DD>

<PRE>
const lListElem *event - the event to describe
</PRE>


<DT><B>RESULT</B>
<DD>

<PRE>
const char* - pointer to the descriptive string.
</PRE>


<DT><B>NOTES</B>
<DD>

<PRE>
The result points to a static buffer. Subsequent calls to event_text
will overwrite previous results.
</PRE>


</DL>


<H1><A NAME="SEC62" HREF="eventclient.html#TOC62">Function Index</A></H1>
<P>
Jump to:
<A HREF="#findex_-">-</A>
-
<A HREF="#findex_c">c</A>
-
<A HREF="#findex_e">e</A>
-
<A HREF="#findex_g">g</A>
-
<A HREF="#findex_r">r</A>
-
<A HREF="#findex_s">s</A>
-
<A HREF="#findex_t">t</A>
<P>
<H2><A NAME="findex_-">-</A></H2>
<DIR>
<LI><A HREF="eventclient.html#IDX1">--EV_Type</A>
<LI><A HREF="eventclient.html#IDX8">--Event_Client</A>
<LI><A HREF="eventclient.html#IDX2">--Event_Client_Interface</A>
<LI><A HREF="eventclient.html#IDX36">--Event_Client_Server</A>
<LI><A HREF="eventclient.html#IDX3">-Busy-state</A>
<LI><A HREF="eventclient.html#IDX9">-Event_Client_Global_Variables</A>
<LI><A HREF="eventclient.html#IDX37">-Event_Client_Server_Defines</A>
<LI><A HREF="eventclient.html#IDX38">-Event_Client_Server_Global_Variables</A>
<LI><A HREF="eventclient.html#IDX4">-Events</A>
<LI><A HREF="eventclient.html#IDX5">-Flushing</A>
<LI><A HREF="eventclient.html#IDX6">-ID-numbers</A>
<LI><A HREF="eventclient.html#IDX7">-Subscription</A>
</DIR>
<H2><A NAME="findex_c">c</A></H2>
<DIR>
<LI><A HREF="eventclient.html#IDX39">check_send_new_subscribed_list</A>
<LI><A HREF="eventclient.html#IDX40">ck_4_deliver_events</A>
<LI><A HREF="eventclient.html#IDX10">ck_event_number</A>
</DIR>
<H2><A NAME="findex_e">e</A></H2>
<DIR>
<LI><A HREF="eventclient.html#IDX11">ec_commit</A>
<LI><A HREF="eventclient.html#IDX12">ec_config_changed</A>
<LI><A HREF="eventclient.html#IDX13">ec_deregister</A>
<LI><A HREF="eventclient.html#IDX14">ec_get</A>
<LI><A HREF="eventclient.html#IDX15">ec_get_busy</A>
<LI><A HREF="eventclient.html#IDX16">ec_get_busy_handling</A>
<LI><A HREF="eventclient.html#IDX17">ec_get_clientdata</A>
<LI><A HREF="eventclient.html#IDX18">ec_get_edtime</A>
<LI><A HREF="eventclient.html#IDX19">ec_get_flush</A>
<LI><A HREF="eventclient.html#IDX20">ec_mark4registration</A>
<LI><A HREF="eventclient.html#IDX21">ec_need_new_registration</A>
<LI><A HREF="eventclient.html#IDX22">ec_prepare_registration</A>
<LI><A HREF="eventclient.html#IDX23">ec_register</A>
<LI><A HREF="eventclient.html#IDX24">ec_set_busy</A>
<LI><A HREF="eventclient.html#IDX25">ec_set_busy_handling</A>
<LI><A HREF="eventclient.html#IDX26">ec_set_clientdata</A>
<LI><A HREF="eventclient.html#IDX27">ec_set_edtime</A>
<LI><A HREF="eventclient.html#IDX28">ec_set_flush</A>
<LI><A HREF="eventclient.html#IDX29">ec_subscribe</A>
<LI><A HREF="eventclient.html#IDX30">ec_subscribe_all</A>
<LI><A HREF="eventclient.html#IDX31">ec_subscribe_flush</A>
<LI><A HREF="eventclient.html#IDX32">ec_unset_flush</A>
<LI><A HREF="eventclient.html#IDX33">ec_unsubscribe</A>
<LI><A HREF="eventclient.html#IDX34">ec_unsubscribe_all</A>
<LI><A HREF="eventclient.html#IDX58">event_text</A>
</DIR>
<H2><A NAME="findex_g">g</A></H2>
<DIR>
<LI><A HREF="eventclient.html#IDX35">get_event_list</A>
</DIR>
<H2><A NAME="findex_r">r</A></H2>
<DIR>
<LI><A HREF="eventclient.html#IDX41">reinit_event_client</A>
</DIR>
<H2><A NAME="findex_s">s</A></H2>
<DIR>
<LI><A HREF="eventclient.html#IDX42">set_event_client_busy</A>
<LI><A HREF="eventclient.html#IDX43">sge_ack_event</A>
<LI><A HREF="eventclient.html#IDX44">sge_add_event</A>
<LI><A HREF="eventclient.html#IDX45">sge_add_event_client</A>
<LI><A HREF="eventclient.html#IDX46">sge_add_list_event</A>
<LI><A HREF="eventclient.html#IDX47">sge_event_client_exit</A>
<LI><A HREF="eventclient.html#IDX48">sge_eventclient_subscribed</A>
<LI><A HREF="eventclient.html#IDX49">sge_flush_events</A>
<LI><A HREF="eventclient.html#IDX50">sge_gdi_kill_eventclient</A>
<LI><A HREF="eventclient.html#IDX51">sge_gdi_tsm</A>
<LI><A HREF="eventclient.html#IDX52">sge_get_next_event_number</A>
<LI><A HREF="eventclient.html#IDX53">sge_locate_event_client</A>
<LI><A HREF="eventclient.html#IDX54">sge_mod_event_client</A>
<LI><A HREF="eventclient.html#IDX55">sge_next_flush</A>
<LI><A HREF="eventclient.html#IDX56">sge_total_update_event</A>
</DIR>
<H2><A NAME="findex_t">t</A></H2>
<DIR>
<LI><A HREF="eventclient.html#IDX57">total_update</A>
</DIR>


<P><HR><P>
This document was generated on 9 April 2002 using
<A HREF="http://wwwinfo.cern.ch/dis/texi2html/">texi2html</A>&nbsp;1.56k.
</BODY>
</HTML>
