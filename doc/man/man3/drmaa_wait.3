'\" t
.\"___INFO__MARK_BEGIN__
.\"
.\" Copyright: 2001 by Sun Microsystems, Inc.
.\"
.\"___INFO__MARK_END__
.\" $RCSfile: drmaa_wait.3,v $     Last Update: $Date: 2003/07/28 16:13:41 $     Revision: $Revision: 1.1 $
.\"
.\"
.\" Some handy macro definitions [from Tom Christensen's man(1) manual page].
.\"
.de M    \" man page reference
\\fI\\$1\\fR\\|(\\$2)\\$3
..
.TH drmaa_wait 3 "$Date: 2003/07/28 16:13:41 $" "xxRELxx" "xxQS_NAMExx DRMAA"
.\"
.\"
.\"
.SH NAME
drmaa_synchronize, drmaa_wait, drmaa_wifexited, drmaa_wexitstatus, drmaa_wifsignaled, drmaa_wtermsig, drmaa_wcoredump,
drmaa_wifaborted \- Waiting for jobs to finish
.PP
.\"
.\"
.\"
.SH SYNOPSIS
.B #include """drmaa.h"""
.PP
\fBint drmaa_synchronize(const char *job_ids[], signed long timeout, int dispose, char *error_diagnosis, size_t error_diag_len);\fB
.PP
.nf
\fBint drmaa_wait(const char *job_id, char *job_id_out, size_t job_id_out_len, int *stat, signed long timeout, drmaa_attr_values_t **rusage, char *error_diagnosis, size_t error_diagnois_len);\fB
.PP
.nf
\fBint drmaa_wifaborted(int *aborted, int stat, char *error_diagnosis, size_t error_diag_len);\fB
.PP
.nf
\fBint drmaa_wifexited(int *exited, int stat, char *error_diagnosis, size_t error_diag_len);\fB
.PP
.nf
\fBint drmaa_wifsignaled(int *signaled, int stat, char *error_diagnosis, size_t error_diag_len);\fB
.PP
.nf
\fBint drmaa_wcoredump(int *core_dumped, int stat, char *error_diagnosis, size_t error_diag_len);\fB
.PP
.nf
\fBint drmaa_wexitstatus(int *exit_status, int stat, char *error_diagnosis, size_t error_diag_len);\fB
.PP
.nf
\fBint drmaa_wtermsig(char *signal, size_t signal_len, int stat, char *error_diagnosis, size_t error_diag_len);\fB
.PP
.nf
.\"
.\"
.\"
.SH DESCRIPTION
The drmaa_synchronize() function delays its caller until all jobs specified in \fIjob_ids\fP 
failed or finished execution. If \fIjob_ids\fP contains `DRMAA_JOB_IDS_SESSION_ALL', then this 
function waits for all jobs submitted during this DRMAA session. The \fIjob_ids\fP pointer array
must be \fINULL\fP terminated.  
.PP
To prevent blocking indefinitely in this call, the caller could use \fItimeout\fP specifying 
after how many seconds to time out in this call. The special value DRMAA_TIMEOUT_WAIT_FOREVER can be to wait 
indefinitely for a result. The special value DRMAA_TIMEOUT_NO_WAIT can be specified to return immediately. 
If the call exits before \fItimeout\fP, all the jobs have been waited on or there was an interrupt. 
If the invocation exits on \fItimeout\fP, the return code is DRMAA_ERRNO_EXIT_TIMEOUT. 
.PP
The \fIdispose\fP parameter specifies how to treat reaping information. 
If `0' is passed to this paramter job finish information will still be available when 
.M drmaa_wait 3
is used. When `1' was passed 
.M drmaa_wait 3
will not know this job anymore.
.\" 
.\" 
.\" 
.SS "drmaa_wait()"
The drmaa_wait() function delays its caller until a job failed or finished execution.
This routine is modeled on the 
.M wait4 3 
routine. 
If the special string `DRMAA_JOB_IDS_SESSION_ANY' is passed as \fIjob_id\fP, this routine 
will wait for any job from the session. Otherwise the \fIjobi_id\fP must be the job identifier
of a job or array job task that was submitted during the session.
.PP
The \fItimeout\fP value is used to specify the desired behavior when a result is not 
immediately available. The special value DRMAA_TIMEOUT_WAIT_FOREVER can be specified to wait indefinitely for 
a result. The value DRMAA_TIMEOUT_NO_WAIT may be specified to return immediately if no result is available. 
Alternatively, a number of seconds can be specified to indicate how long to wait for a 
result to become available. If the call exits before \fItimeout\fP, either the job has 
been waited on successfully or there was an interrupt. If the invocation exits on 
\fItimeout\fP, the return code is DRMAA_ERRNO_EXIT_TIMEOUT.
.PP
The routine reaps jobs on a successful call, so any subsequent calls to 
.M drmaa_wait 3 
will fail returning an error DRMAA_ERRNO_INVALID_JOB meaning that the job has been already reaped. 
This error is the same as if the job was unknown. Failing due to an elapsed timeout has an effect 
that it is possible to issue 
.M drmaa_wait 3
multiple times for the same \fIjob_id\fP. 
.PP
If \fIjob_id_out\fP is not a null pointer, then on return from a successful 
.M drmaa_wait 3
call, up to \fIjob_id_out_len\fP characters from the job id of the failed 
or finished job are returned.
.PP
If \fIstat\fP is not a null pointer, then on return from a successful 
.M drmaa_wait 3
call, the status of the job is stored in the interger pointed to by \fIstat\fP.
\fIstat\fP indicates whether job failed or finished and other information. The 
information encoded in the integer value can be accessed via 
.M drmaa_wifaborted 3
.M drmaa_wifexited 3
.M drmaa_wifsignaled 3
.M drmaa_wcoredump 3
.M drmaa_wexitstatus 3
.M drmaa_wtermsig 3 .
.PP
If \fIrusage\fP is not a null pointer, then on return from a successful
.M drmaa_wait 3
call, a summary of the  resources used by the terminated job is returned in form of a
DRMAA  values  string  vector. The entries in the DRMAA values string vector can be
extracted using
.M drmaa_get_next_attr_value 3 . 
Each string returned by
.M drmaa_get_next_attr_value 3
complies with the format <name>=<value>. The string 
portions <name> and <value> specify name and amount of the resource consumed by 
the job. The \fIrusage\fP output parameter is not yet implemented.
.PP
.\"
.\" 
.\" 
.SS "drmaa_wifaborted()"
The drmaa_wifaborted() function evaluates in the interger pointed to by \fIaborted\fP
a non-zero value, if \fIstat\fP was returned by for a job that ended before entering the 
running state.
.PP
.\"
.\" 
.\" 
.SS "drmaa_wifexited()"
The drmaa_wifexited() function evaluates in the integer pointed to by \fIexited\fP a 
non-zero value, if \fIstat\fP was returned for a job that terminated normally. A 
zero value can also indicate that altough the job has terminated normally an exit 
status is not available or that it is not known whether the job terminated normally. 
In both cases 
.M drmaa_wexitstatus 3
will not provide exit status information. A non-zero value returned in \fIexited\fP 
indicates more detailed diagnosis can be provided by means of 
.M drmaa_wifsignaled 3 , 
.M drmaa_wtermsig 3 
and 
.M drmaa_wcoredump 3 .
.PP
.\"
.\"
.\"
.SS "drmaa_wifsignaled()"
The drmaa_wifsignaled() function evaluates in the integer pointed to by \fIsignaled\fP 
a non-zero value, if \fIstat\fP was returned for a job that terminated due to the receipt of a 
signal. A zero value can also indicate that altough the job has terminated due to the receipt of 
a signal the signal is not available or that it is not known whether the job terminated due to 
the receipt of a signal. In both cases 
.M drmaa_wtermsig 3
will not provide signal information.
.PP
.\"
.\"
.\"
.SS "drmaa_wcoredump()"
If
.M drmaa_wifsignaled 3 
returned non-zero in the \fIsignaled\fP parameter, the drmaa_wcoredump() function evaluates in the 
integer pointed to by \fIcore_dumped\fP a non-zero value, if a core image of the terminated 
job was created. 
.PP
.\"
.\"
.\"
.SS "drmaa_wexitstatus()"
If 
.M drmaa_wifexited 3
returned non-zero in the \fIexited\fP parameter, the drmaa_wexitstatus() function evaluates in the
integer pointed to by \fIexit_code\fP the exit code that the job passed to 
.M exit 2 
or the value that the child process returned from main.
.PP
.\"
.\"
.\"
.SS "drmaa_wtermsig()"
If 
.M drmaa_wifsignaled 3
returned non-zero in the \fIsignaled\fP parameter, the drmaa_wtermsig() function evaluates 
into \fIsignal\fP up to \fIsignal_len\fP characters of a string representation of the signal 
that caused the termination of the job. For signals declared by POSIX.1, the symbolic names 
are returned (e.g., SIGABRT, SIGALRM). For signals not declared by POSIX, any other string 
may be returned.
.PP
.\"
.\"
.\"
.SH "RETURN VALUES"
Upon successful completion, drmaa_run_job(), drmaa_run_bulk_jobs(), and drmaa_get_next_job_id()
return DRMAA_ERRNO_SUCCESS. Other values indicate an error.
Up to \fIerror_diag_len\fP characters of error related diagnosis 
information is then provided in the buffer \fIerror_diagnosis\fP.
.PP
.\"
.\"
.\"
.SH "ERRORS"
The drmaa_synchronize(), drmaa_wait(), drmaa_wifexited(), drmaa_wexitstatus(), 
drmaa_wifsignaled(), drmaa_wtermsig(), drmaa_wcoredump(), and drmaa_wifaborted()
will fail if:
.\" 
.SS "DRMAA_ERRNO_INTERNAL_ERROR"
Unexpected or internal DRMAA error like memory allocation, system call failure, etc.
.\" 
.SS "DRMAA_ERRNO_DRM_COMMUNICATION_FAILURE"
Could not contact DRM system for this request.
.\" 
.SS "DRMAA_ERRNO_AUTH_FAILURE"
The specified request is not processed successfully due to authorization failure.
.\" 
.SS "DRMAA_ERRNO_INVALID_ARGUMENT"
The input value for an argument is invalid.
.\" 
.SS "DRMAA_ERRNO_NO_ACTIVE_SESSION"
Failed because there is no active session.
.\" 
.SS "DRMAA_ERRNO_NO_MEMORY"
Failed allocating memory.
.\" 
.PP
The drmaa_synchronize() and drmaa_wait() functions will fail if:
.SS "DRMAA_ERRNO_EXIT_TIMEOUT"
Time-out condition.
.\" 
.SS "DRMAA_ERRNO_INVALID_JOB"
The job specified by the does not exist.
.\" 
.PP
The drmaa_wait() will fail if:
.SS "DRMAA_ERRNO_NO_RUSAGE"
This error code is returned by drmaa_wait() when a job 
has finished but no rusage and stat data could be provided.
.PP
.\" 
.\" 
.\" 
.SH "SEE ALSO"
.M drmaa_submit 3 .
