'\" t
.\"___INFO__MARK_BEGIN__
.\"
.\" Copyright: 2001 by Sun Microsystems, Inc.
.\"
.\"___INFO__MARK_END__
.\"
.\" $RCSfile: lListType.3,v $     Last Update: $Date: 2001/07/20 08:19:04 $     Revision: $Revision: 1.3 $
.\"
.\"
.\" Some handy macro definitions [from Tom Christensen's man(1) manual page].
.\"
.de SB      \" small and bold
.if !"\\$1"" \\s-2\\fB\&\\$1\\s0\\fR\\$2 \\$3 \\$4 \\$5
..
.\"
.de T    \" switch to typewriter font
.ft CW      \" probably want CW if you don't have TA font
..
.\"
.de TY      \" put $1 in typewriter font
.if t .T
.if n ``\c
\\$1\c
.if t .ft P
.if n \&''\c
\\$2
..
.\"
.de M    \" man page reference
\\fI\\$1\\fR\\|(\\$2)\\$3
..
.TH LIST_TYPE 3 "$Date: 2001/07/20 08:19:04 $" "xxRELxx" "xxQS_NAMExx List Library"
.\"
.SH NAME
lAddElemStr, lDelElemStr, lGetElemStr - list operations
.br
lAddSubStr, lDelSubStr, lGetSubStr - sub-list operations
.\"
.\"
.SH SYNOPSIS
.B #include """cull.h"""
.PP
.nf
\fBlListElem* lAddElemStr(\fP
.RS
\fBlList** lpp,\fP
\fBint nm,\fP
\fBchar *s,\fP
\fBlDescr *dp\fP
.RE
.fi
\fB);\fP
.PP
.\"
.nf
\fBint lDelElemStr(\fP
.RS
\fBlList** lpp,\fP
\fBint nm,\fP
\fBchar *s\fP
.RE
.fi
\fB);\fP
.PP
.\"
.nf
\fBlListElem *lGetElemStr(\fP
.RS
\fBlList* lp,\fP
\fBint nm,\fP
\fBchar *s\fP
.RE
.fi
\fB);\fP
.PP
.\"
.nf
\fBlListElem* lAddSubStr(\fP
.RS
\fBlListElem* ep,\fP
\fBint nm,\fP
\fBchar *s,\fP
B
\fBint snm,\fP
\fBlDescr *dp\fP
.RE
.fi
\fB);\fP
.PP
.\"
.nf
\fBint lDelSubStr(\fP
.RS
\fBlListElem* ep,\fP
\fBint nm,\fP
\fBchar *s,\fP
\fBint snm\fP
.RE
.fi
\fB);\fP
.PP
.\"
.nf
\fBlListElem *lGetSubStr(\fP
.RS
\fBlListElem* ep,\fP
\fBint nm,\fP
\fBchar *s,\fP
\fBint snm\fP
.RE
.fi
\fB);\fP
.PP
.\"
.nf
\fBlListElem *lDiffListStr(\fP
.RS
\fBint nm,\fP
\fBlList** lpp1,\fP
\fBlList** lpp1,\fP
.RE
.fi
\fB);\fP
.\"
.\"
.SH DESCRIPTION
.IP "\fBlListElem *lAddElemStr(lpp, nm, s, dp)\fP"
Appends an element to the list \fB*lpp\fP. The new element gets
the type \fBdp\fP (using
.M lCreateElem 3 ).
Field \fBnm\fP of the new elements 
gets the value \fBs\fP (using
.M lSetString 3 ).
No test are made to ensure
uniqueness of elements in the list. If \fB*lpp\fP is NULL a new
list head gets created
(using
.M lCreateList 3 ).
\fBlAddElemStr()\fP fails if the given list or descriptor
has no field \fBnm\fP.
.\"
.IP "\fBint lDelElemStr(lpp, nm, s)\fP"
Removes one element containing \fBs\fP at field \fBnm\fP in the list \fB*lpp\fP.
.I lGetElemStr
is used to find the element. It gets unchained and freed. 
If no more elements are in the list after unchaining the list head 
gets freed and NULL is written to \fB*lpp\fP.
.I lDelElemStr
fails if the 
given list has no field \fBnm\fP. 
.\"
.IP "\fBlListElem *lGetElemStr(lp, nm, s)\fP"
Searches the first element containing \fBs\fP at field \fBnm\fP in the list \fBlp\fP.
.M strcmp 3
s used to perform the compare.
.I lGetElemStr
returns the element.
.\"
.IP "\fBlListElem *lAddSubStr(ep, nm, s, snm, dp)\fP"
Uses
.I lAddElemStr
to append an element to the sub-list field \fBsnm\fP of
the element \fBep\fP. 
.\"
.IP "\fBint lDelSubStr(ep, nm, s, snm)\fP"
Uses
.I lDelElemStr
to remove an element from the sub-list field \fBsnm\fP of
the element \fBep\fP.
.\" 
.IP "\fBlListElem *lGetSubStr(ep, nm, s, snm)\fP"
Uses
.I lGetElemStr
to find an element in the sub-list field \fBsnm\fP of
the element \fBep\fP.
.\"
.IP "\fBint lDiffListStr(nm, lpp1, lpp2)\fP"
.I lDiffListStr
removes and frees elements in 
.I both 
lists with the same string key in field \fBnm\fP.
.\" 
.\"
.SH EXAMPLES
.PP
The first example shows the usage of list functions:
.nf

=======================================================================

#include "cull.h" 

f()
{  
.RS
lList *lp = NULL;
lListElem *ep;

/* add a queue element where QU_qname is "balin.q" to the list lp */
if (!(ep=lAddElemStr(&lp, QU_qname, "balin.q", QU_Type))) {
.RS
/* ... */   
.RE
}
lSetString(ep, QU_qhostname, "balin.mydomain");

/* get the element of lp where QU_qname is "balin.q" */
if (!(ep=lGetElemStr(lp, QU_qname, "balin.q"))) {
.RS
/* ... */
.RE
}

/* remove the element of lp where QU_qname is "balin.q" */
if (!lDelElemStr(&lp, QU_qname, "balin.q")) {
.RS
/* ... */
.RE
}

/* here lp will be NULL again */

return;
.RE
}  
.fi

=======================================================================

The second example shows the usage of sub-list functions:
.PP
.nf

=======================================================================

#include "cull.h" 

g(queue)
lListElem *queue;
{  
.RS
lListElem *ep;

/* add an owner element with OW_name "bill" to the */
/* sub-list QU_ownerlist of the element ep          */
ep = lAddSubStr(ep, OW_name, "bill", QU_ownerlist, OW_Type);
if ( !ep ) {
.RS
/* ... */   
.RE
}
lSetString(ep, OW_permissions, "everything");

/* get the element in the sub-list QU_ownerlist of  */
/* the element ep where OW_name is "bill"          */
if (!(ep=lGetSubStr(ep, OW_name, "bill", QU_ownerlist))) {
.RS
/* ... */
.RE
}
printf("Owner: %s\n", lGetString(ep, OW_name));

/* remove the element in the sub-list of element ep */
/* where OW_name is "bill"                         */
if (!lDelSubStr(ep, OW_name, "bill", QU_ownerlist)) {
.RS
/* ... */
.RE
}

return;
.RE
}  

=======================================================================

.fi
.\"
.\"
.SH "RETURN VALUES"
.I lAddElemStr
and
.I lAddSubStr
return a pointer to the added list element or NULL on error.
.I lDelElemStr
and
.I lDelSubStr
return 1 on success and 0 on error.
.I lGetElemStr
and
.I lGetSubStr
return a pointer to the found list element or NULL on error.
.I lDiffListStr
returns 0 on success and -1 on error.
.\"
.\"
.SH "SEE ALSO"
.M xxqs_name_sxx_intro 1 ,
.M list_intro 3 ,
.M lSetString 3 ,
.M lGetString 3 ,
.M lAppendElem 3 ,
.M lDechainElem 3 ,
.M lCreateElem 3 ,
.M lCreateList 3 .
.\"
.\"
.SH COPYRIGHT
See
.M xxqs_name_sxx_intro 1
for a full statement of rights and permissions.
